<?php

/**
 * This file is part of the package demosplan.
 *
 * (c) 2010-present DEMOS plan GmbH, for more information see the license file.
 *
 * All rights reserved
 */

namespace demosplan\DemosPlanCoreBundle\Command;


use Nette\PhpGenerator\PhpFile;
use ReflectionClass;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;
use Symfony\Component\Filesystem\Filesystem;


class GenerateEntityInterfaceCommand extends CoreCommand
{
    private const CORE_ENTITY_DIRECTORY = 'demosplan\\DemosPlanCoreBundle\\Entity';
    private const INTERFACE_NAMESPACE = 'DemosEurope\\DemosplanAddon\\Contracts\\Entities';
    protected static $defaultName = 'dplan:generate-entity-interface';
    public function __construct(ParameterBagInterface $parameterBag,
                                private readonly Filesystem $filesystem)
    {
        parent::__construct($parameterBag);

    }


    protected function configure(): void
    {
        $this
            ->setDescription('Generates interface for entity classes')
            ->setHelp('This command analyzes entity classes and generates corresponding interfaces')
            ->addArgument('entity', InputArgument::OPTIONAL, 'Entity name to generate interface for (optional)')
            ->addOption('output-dir', 'o', InputOption::VALUE_REQUIRED, 'Output directory for the generated interface', 'interface-repo/src/Contracts/Entities');
    }
    public function execute(InputInterface $input, OutputInterface $output): int
    {
        $output = new SymfonyStyle($input, $output);

        $entityName = $input->getArgument('entity');
        $outputDir = $input->getOption('output-dir');

        // Create output directory if it doesn't exist
        if (!$this->filesystem->exists($outputDir)) {
            $this->filesystem->mkdir($outputDir, 0755);
        }

        // Define paths
        $entityClass = self::CORE_ENTITY_DIRECTORY . '\\CustomFields\\' . $entityName;
        $interfacePath = $outputDir . '/' . $entityName . 'Interface.php';

        // Generate interface
        $interfaceContent = $this->generateInterfaceFromEntity($entityClass, $entityName);

        // Write interface file
        $this->filesystem->dumpFile($interfacePath, (string) $interfaceContent);

        $this->addInterfaceToEntity($entityClass, self::INTERFACE_NAMESPACE . '\\' . $entityName . 'Interface', $entityClass . '.php');

        $output->writeln("Generated interface for {$entityName}: {$interfacePath}");

        return Command::SUCCESS;
    }

    private function generateInterfaceFromEntity(string $entityClass, string $entityName): PhpFile
    {
        $newFile = new PhpFile();
        $newFile->setStrictTypes();
        $namespace = $newFile->addNamespace(self::INTERFACE_NAMESPACE);
        $interface = $namespace->addInterface($entityName . 'Interface');

        $interface->addComment('WARNING: THIS INTERFACE IS AUTOGENERATED.');
        $interface->addComment("MANUAL CHANGES WILL BE LOST ON RE-GENERATION.\n");




        // Use PHP reflection for analyzing the class
        $reflectionClass = new ReflectionClass($entityClass);



        foreach ($reflectionClass->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) {
            $newMethod = $interface->addMethod($method->getName());
            $newMethod->setPublic();

            foreach ($method->getParameters() as $parameter) {
                $paramType = $parameter->getType();
                $newParam = $newMethod->addParameter($parameter->getName());

                if ($paramType !== null) {
                    $newParam->setType((string) $paramType);
                }

                if ($parameter->isDefaultValueAvailable()) {
                    $newParam->setDefaultValue($parameter->getDefaultValue());
                }
            }

            $returnType = $method->getReturnType();
            if ($returnType !== null) {
                $returnTypeName = (string) $returnType;
                if (!str_starts_with($returnTypeName, 'demosplan\\DemosPlanCoreBundle')) {
                    $newMethod->setReturnType($returnTypeName);
                }
            }
        }

        return $newFile;
    }

    private function addInterfaceToEntity(string $entityClass, string $interfaceName, string $entityFilePath): void
    {
        // Convert namespace-style path to a valid file system path
        $entityFilePath = str_replace('\\', DIRECTORY_SEPARATOR, $entityFilePath);

        $reflectionClass = new ReflectionClass($entityClass);

        // Read the existing file content
        if (!file_exists($entityFilePath)) {
            throw new \RuntimeException("File not found: {$entityFilePath}");
        }

        $fileContent = file_get_contents($entityFilePath);

        // Extract the short name of the interface
        $interfaceShortName = basename(str_replace('\\', '/', $interfaceName));

        // Add the `use` statement after the namespace if it doesn't already exist
        if (!str_contains($fileContent, "use {$interfaceName};")) {
            // Find the namespace statement and insert the use statement after it
            $fileContent = preg_replace(
                '/(namespace\s+[^;]+;\s+)/s',
                "$1\nuse {$interfaceName};\n",
                $fileContent
            );
        }

        // Check if the interface is already implemented
        if (in_array($interfaceName, $reflectionClass->getInterfaceNames(), true)) {
            return; // Interface already implemented, no changes needed
        }

        // Add the interface to the class declaration
        $pattern = '/class\s+' . $reflectionClass->getShortName() . '\s*(extends\s+[^\s]+)?\s*/';
        $replacement = 'class ' . $reflectionClass->getShortName() . ' $1 implements ' . $interfaceShortName . ' ';
        $updatedContent = preg_replace($pattern, $replacement, $fileContent);

        // Write the updated content back to the file
        file_put_contents($entityFilePath, $updatedContent);
    }
}
