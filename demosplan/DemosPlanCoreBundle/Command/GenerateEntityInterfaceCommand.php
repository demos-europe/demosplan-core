<?php

/**
 * This file is part of the package demosplan.
 *
 * (c) 2010-present DEMOS plan GmbH, for more information see the license file.
 *
 * All rights reserved
 */

namespace demosplan\DemosPlanCoreBundle\Command;


use Nette\PhpGenerator\InterfaceType;
use Nette\PhpGenerator\Method;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\Traits\MethodsAware;
use ReflectionClass;
use ReflectionMethod;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\HttpFoundation\File\File;


class GenerateEntityInterfaceCommand extends CoreCommand
{
    private const CORE_ENTITY_DIRECTORY = 'demosplan\\DemosPlanCoreBundle\\Entity';
    private const INTERFACE_NAMESPACE = 'DemosEurope\\DemosplanAddon\\Contracts\\Entities';
    protected static $defaultName = 'dplan:generate-entity-interface';
    public function __construct(ParameterBagInterface $parameterBag,
                                private readonly Filesystem $filesystem)
    {
        parent::__construct($parameterBag);

    }


    protected function configure(): void
    {
        $this
            ->setDescription('Generates interface for entity classes')
            ->setHelp('This command analyzes entity classes and generates corresponding interfaces')
            ->addArgument('entity', InputArgument::OPTIONAL, 'Entity name to generate interface for (optional)')
            ->addOption('output-dir', 'o', InputOption::VALUE_REQUIRED, 'Output directory for the generated interface', 'interface-repo/src/Contracts/Entities')
            ->addOption('files', 'f', InputArgument::OPTIONAL, 'Comma-separated list of changed entity files to process');
    }
    public function execute(InputInterface $input, OutputInterface $output): int
    {
        $output = new SymfonyStyle($input, $output);

        $entityName = $input->getArgument('entity');
        $outputDir = $input->getOption('output-dir');
        $filesOption = $input->getOption('files');

        // Create output directory if it doesn't exist
        if (!$this->filesystem->exists($outputDir)) {
            $this->filesystem->mkdir($outputDir, 0755);
        }

        // Determine entities to process
        $entityClassPaths = [];

        if ($filesOption) {
            // Process provided list of changed files
            $output->title('Processing specified entity files');
            $entityClassPaths = explode(',', $filesOption);

            if (empty($entityClassPaths)) {
                $output->info('No valid entities found in the provided files');
                return Command::SUCCESS;
            }

            $output->info(sprintf('Found %d entities to process: %s', count($entityClassPaths), implode(', ', $entityClassPaths)));
        }

        foreach ($entityClassPaths as $entityClassPath) {
            // Define paths
            // Remove the file extension

            $className = pathinfo(basename($entityClassPath), PATHINFO_FILENAME);
            $entityClassPath = str_replace('/', '\\', $entityClassPath);
            $entityClassPath = str_replace('.php', '', $entityClassPath);

            $interfacePath = $outputDir . '/' . $entityName . 'Interface.php';

            $output->title('Entity Name' . $className);
            $output->title('Entity Class Path ' . $entityClassPath);
            $output->title('Interface Path ' . $interfacePath);

            // Generate interface
            $interfaceContent = $this->generateInterfaceFromEntity($entityClassPath, $className);

            // Write interface file
            $this->filesystem->dumpFile($interfacePath, (string) $interfaceContent);

            $this->addInterfaceToEntity($entityClassPath, self::INTERFACE_NAMESPACE . '\\' . $className . 'Interface', $entityClassPath . '.php');

            $output->writeln("Generated interface for {$className}: {$interfacePath}");

            return Command::SUCCESS;
        }

    }

    private function generateInterfaceFromEntity(string $entityClass, string $entityName): PhpFile
    {
        $newFile = new PhpFile();
        $newFile->setStrictTypes();
        $namespace = $newFile->addNamespace(self::INTERFACE_NAMESPACE);
        $interface = $namespace->addInterface($entityName . 'Interface');

        $interface->addComment('WARNING: THIS INTERFACE IS AUTOGENERATED.');
        $interface->addComment("MANUAL CHANGES WILL BE LOST ON RE-GENERATION.\n");




        // Use PHP reflection for analyzing the class
        $reflectionClass = new ReflectionClass($entityClass);
        $this->addPublicMethodsToInterface($reflectionClass, $interface);


        return $newFile;
    }

    private function addPublicMethodsToInterface(ReflectionClass $reflectionClass, InterfaceType $interface): void {
        foreach ($reflectionClass->getMethods(\ReflectionMethod::IS_PUBLIC) as $entityMethod) {
            $interfaceMethod = $interface->addMethod($entityMethod->getName());
            $interfaceMethod->setPublic();
            $this->addParametersToMethod($entityMethod, $interfaceMethod);

            $returnType = $entityMethod->getReturnType();
            if ($returnType !== null) {
                $returnTypeName = (string) $returnType;
                if (!str_starts_with($returnTypeName, 'demosplan\\DemosPlanCoreBundle')) {
                    $interfaceMethod->setReturnType($returnTypeName);
                }
            }
        }

    }

    private function addParametersToMethod(ReflectionMethod $entityMethod,  Method $interfaceMethod): void
    {
        foreach ($entityMethod->getParameters() as $parameter) {
            $paramType = $parameter->getType();
            $newParam = $interfaceMethod->addParameter($parameter->getName());

            if ($paramType !== null) {
                $newParam->setType((string) $paramType);
            }

            if ($parameter->isDefaultValueAvailable()) {
                $newParam->setDefaultValue($parameter->getDefaultValue());
            }
        }

    }

    private function addInterfaceToEntity(string $entityClass, string $interfaceName, string $entityFilePath): void
    {
        // Convert namespace-style path to a valid file system path
        $entityFilePath = str_replace('\\', DIRECTORY_SEPARATOR, $entityFilePath);

        $reflectionClass = new ReflectionClass($entityClass);

        // Read the existing file content
        if (!file_exists($entityFilePath)) {
            throw new \RuntimeException("File not found: {$entityFilePath}");
        }

        $fileContent = file_get_contents($entityFilePath);

        // Extract the short name of the interface
        $interfaceShortName = basename(str_replace('\\', '/', $interfaceName));

        // Add the `use` statement after the namespace if it doesn't already exist
        if (!str_contains($fileContent, "use {$interfaceName};")) {
            // Find the namespace statement and insert the use statement after it
            $fileContent = preg_replace(
                '/(namespace\s+[^;]+;\s+)/s',
                "$1\nuse {$interfaceName};\n",
                $fileContent
            );
        }

        // Check if the interface is already implemented
        if (in_array($interfaceName, $reflectionClass->getInterfaceNames(), true)) {
            return; // Interface already implemented, no changes needed
        }

        // Add the interface to the class declaration
        $pattern = '/class\s+' . $reflectionClass->getShortName() . '\s*(extends\s+[^\s]+)?\s*/';
        $replacement = 'class ' . $reflectionClass->getShortName() . ' $1 implements ' . $interfaceShortName . ' ';
        $updatedContent = preg_replace($pattern, $replacement, $fileContent);

        // Write the updated content back to the file
        file_put_contents($entityFilePath, $updatedContent);
    }
}
