var wG = Object.defineProperty;
var CG = (t, e, i) => e in t ? wG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var bG = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
var Ne = (t, e, i) => CG(t, typeof e != "symbol" ? e + "" : e, i);
import { defineComponent as je, createElementBlock as X, openBlock as G, normalizeClass as he, createCommentVNode as de, renderSlot as ge, ref as ue, onMounted as er, onUnmounted as Fs, createVNode as ee, inject as bo, watchEffect as vi, watch as ct, computed as O, toRef as sk, shallowRef as MG, provide as bd, isVNode as IG, Teleport as WM, Transition as Ws, createElementVNode as be, h as ju, nextTick as ji, resolveComponent as Os, createBlock as De, createSlots as ok, withCtx as Ye, createTextVNode as Ct, normalizeProps as ia, guardReactiveProps as ra, toDisplayString as Pe, Fragment as ht, renderList as xi, mergeProps as Tt, resolveDynamicComponent as Nr, withDirectives as $t, vShow as gi, withKeys as At, withModifiers as at, unref as j, getCurrentScope as $h, onScopeDispose as KM, toValue as zt, reactive as su, Comment as vG, Text as xG, toRaw as UC, getCurrentInstance as Uo, effectScope as QG, isRef as eg, normalizeStyle as eE, triggerRef as ll, mergeModels as li, useTemplateRef as cs, useModel as Hi, useAttrs as Sy, vModelDynamic as FG, vModelText as SG, useId as Pn, onBeforeUnmount as XM, useSlots as Ng, vModelCheckbox as DG, vModelSelect as TG, createApp as RG, onBeforeMount as _G, toHandlers as ZM, toHandlerKey as kG, TransitionGroup as YG, render as NG, markRaw as qM, isReactive as MQ, defineCustomElement as UG } from "vue";
var r1e = bG((la, ss) => {
  var ak = typeof global == "object" && global && global.Object === Object && global, LG = typeof self == "object" && self && self.Object === Object && self, YA = ak || LG || Function("return this")(), Hu = YA.Symbol, Ak = Object.prototype, zG = Ak.hasOwnProperty, PG = Ak.toString, Kd = Hu ? Hu.toStringTag : void 0;
  function OG(t) {
    var e = zG.call(t, Kd), i = t[Kd];
    try {
      t[Kd] = void 0;
      var r = !0;
    } catch {
    }
    var n = PG.call(t);
    return r && (e ? t[Kd] = i : delete t[Kd]), n;
  }
  var GG = Object.prototype, jG = GG.toString;
  function HG(t) {
    return jG.call(t);
  }
  var JG = "[object Null]", VG = "[object Undefined]", IQ = Hu ? Hu.toStringTag : void 0;
  function Ug(t) {
    return t == null ? t === void 0 ? VG : JG : IQ && IQ in Object(t) ? OG(t) : HG(t);
  }
  function $M(t) {
    return t != null && typeof t == "object";
  }
  var WG = Array.isArray, vQ = Hu ? Hu.prototype : void 0;
  vQ && vQ.toString;
  function lk(t) {
    var e = typeof t;
    return t != null && (e == "object" || e == "function");
  }
  var KG = "[object AsyncFunction]", XG = "[object Function]", ZG = "[object GeneratorFunction]", qG = "[object Proxy]";
  function ck(t) {
    if (!lk(t))
      return !1;
    var e = Ug(t);
    return e == XG || e == ZG || e == KG || e == qG;
  }
  var dw = YA["__core-js_shared__"], xQ = function() {
    var t = /[^.]+$/.exec(dw && dw.keys && dw.keys.IE_PROTO || "");
    return t ? "Symbol(src)_1." + t : "";
  }();
  function $G(t) {
    return !!xQ && xQ in t;
  }
  var ej = Function.prototype, tj = ej.toString;
  function Xl(t) {
    if (t != null) {
      try {
        return tj.call(t);
      } catch {
      }
      try {
        return t + "";
      } catch {
      }
    }
    return "";
  }
  var ij = /[\\^$.*+?()[\]{}|]/g, rj = /^\[object .+?Constructor\]$/, nj = Function.prototype, sj = Object.prototype, oj = nj.toString, aj = sj.hasOwnProperty, Aj = RegExp(
    "^" + oj.call(aj).replace(ij, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function lj(t) {
    if (!lk(t) || $G(t))
      return !1;
    var e = ck(t) ? Aj : rj;
    return e.test(Xl(t));
  }
  function cj(t, e) {
    return t == null ? void 0 : t[e];
  }
  function Lg(t, e) {
    var i = cj(t, e);
    return lj(i) ? i : void 0;
  }
  var LC = Lg(YA, "WeakMap"), uj = 9007199254740991;
  function uk(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= uj;
  }
  function dj(t) {
    return t != null && uk(t.length) && !ck(t);
  }
  var hj = Object.prototype;
  function dk(t) {
    var e = t && t.constructor, i = typeof e == "function" && e.prototype || hj;
    return t === i;
  }
  var gj = "[object Arguments]";
  function QQ(t) {
    return $M(t) && Ug(t) == gj;
  }
  var hk = Object.prototype, fj = hk.hasOwnProperty, pj = hk.propertyIsEnumerable, mj = QQ(/* @__PURE__ */ function() {
    return arguments;
  }()) ? QQ : function(t) {
    return $M(t) && fj.call(t, "callee") && !pj.call(t, "callee");
  };
  function Ej() {
    return !1;
  }
  var gk = typeof la == "object" && la && !la.nodeType && la, FQ = gk && typeof ss == "object" && ss && !ss.nodeType && ss, yj = FQ && FQ.exports === gk, SQ = yj ? YA.Buffer : void 0, Bj = SQ ? SQ.isBuffer : void 0, wj = Bj || Ej, Cj = "[object Arguments]", bj = "[object Array]", Mj = "[object Boolean]", Ij = "[object Date]", vj = "[object Error]", xj = "[object Function]", Qj = "[object Map]", Fj = "[object Number]", Sj = "[object Object]", Dj = "[object RegExp]", Tj = "[object Set]", Rj = "[object String]", _j = "[object WeakMap]", kj = "[object ArrayBuffer]", Yj = "[object DataView]", Nj = "[object Float32Array]", Uj = "[object Float64Array]", Lj = "[object Int8Array]", zj = "[object Int16Array]", Pj = "[object Int32Array]", Oj = "[object Uint8Array]", Gj = "[object Uint8ClampedArray]", jj = "[object Uint16Array]", Hj = "[object Uint32Array]", mi = {};
  mi[Nj] = mi[Uj] = mi[Lj] = mi[zj] = mi[Pj] = mi[Oj] = mi[Gj] = mi[jj] = mi[Hj] = !0;
  mi[Cj] = mi[bj] = mi[kj] = mi[Mj] = mi[Yj] = mi[Ij] = mi[vj] = mi[xj] = mi[Qj] = mi[Fj] = mi[Sj] = mi[Dj] = mi[Tj] = mi[Rj] = mi[_j] = !1;
  function Jj(t) {
    return $M(t) && uk(t.length) && !!mi[Ug(t)];
  }
  function Vj(t) {
    return function(e) {
      return t(e);
    };
  }
  var fk = typeof la == "object" && la && !la.nodeType && la, Th = fk && typeof ss == "object" && ss && !ss.nodeType && ss, Wj = Th && Th.exports === fk, hw = Wj && ak.process, DQ = function() {
    try {
      var t = Th && Th.require && Th.require("util").types;
      return t || hw && hw.binding && hw.binding("util");
    } catch {
    }
  }(), TQ = DQ && DQ.isTypedArray, Kj = TQ ? Vj(TQ) : Jj;
  function Xj(t, e) {
    return function(i) {
      return t(e(i));
    };
  }
  var Zj = Xj(Object.keys, Object), qj = Object.prototype, $j = qj.hasOwnProperty;
  function e3(t) {
    if (!dk(t))
      return Zj(t);
    var e = [];
    for (var i in Object(t))
      $j.call(t, i) && i != "constructor" && e.push(i);
    return e;
  }
  var zC = Lg(YA, "Map");
  function t3(t) {
    return t;
  }
  var PC = Lg(YA, "DataView"), OC = Lg(YA, "Promise"), GC = Lg(YA, "Set"), RQ = "[object Map]", i3 = "[object Object]", _Q = "[object Promise]", kQ = "[object Set]", YQ = "[object WeakMap]", NQ = "[object DataView]", r3 = Xl(PC), n3 = Xl(zC), s3 = Xl(OC), o3 = Xl(GC), a3 = Xl(LC), ol = Ug;
  (PC && ol(new PC(new ArrayBuffer(1))) != NQ || zC && ol(new zC()) != RQ || OC && ol(OC.resolve()) != _Q || GC && ol(new GC()) != kQ || LC && ol(new LC()) != YQ) && (ol = function(t) {
    var e = Ug(t), i = e == i3 ? t.constructor : void 0, r = i ? Xl(i) : "";
    if (r)
      switch (r) {
        case r3:
          return NQ;
        case n3:
          return RQ;
        case s3:
          return _Q;
        case o3:
          return kQ;
        case a3:
          return YQ;
      }
    return e;
  });
  var A3 = "[object Map]", l3 = "[object Set]", c3 = Object.prototype, u3 = c3.hasOwnProperty;
  function UQ(t) {
    if (t == null)
      return !0;
    if (dj(t) && (WG(t) || typeof t == "string" || typeof t.splice == "function" || wj(t) || Kj(t) || mj(t)))
      return !t.length;
    var e = ol(t);
    if (e == A3 || e == l3)
      return !t.size;
    if (dk(t))
      return !e3(t).length;
    for (var i in t)
      if (u3.call(t, i))
        return !1;
    return !0;
  }
  var d3 = 0;
  function h3(t) {
    var e = ++d3;
    return t3(t) + e;
  }
  var pk = /* @__PURE__ */ ((t) => (t[t.SATELLITE = 0] = "SATELLITE", t[t.STREETMAP = 1] = "STREETMAP", t))(pk || {}), qi = /* @__PURE__ */ ((t) => (t.VORHABEN = "vorhaben", t.COCKPIT = "cockpit", t))(qi || {}), Tr = /* @__PURE__ */ ((t) => (t.POINT = "Point", t.LINESTRING = "LineString", t.POLYGON = "Polygon", t.MULTIPOLYGON = "MultiPolygon", t))(Tr || {}), ai = /* @__PURE__ */ ((t) => (t.Draw = "draw", t.Base = "base", t.Cadastral = "cadastral", t))(ai || {}), eI = /* @__PURE__ */ ((t) => (t.CADASTRAL = "cadastral", t.NEIGHBOUR = "neighbour", t.READONLY = "read-only", t.STATUS = "status", t.SUPERIORAREAS = "superiorareas", t))(eI || {}), Kp = /* @__PURE__ */ ((t) => (t.NEIGBHBOURS = "NEIGHBOURS", t.CONVERSIONS = "KONVERSIONSFLAECHE", t.COMMERCIALS = "GEWERBLICHER_STANDORT", t.CADASTRALS = "FLURSTUECKE", t))(Kp || {});
  const g3 = {
    key: 0,
    class: "control-panel-extra"
  }, f3 = /* @__PURE__ */ je({
    __name: "ControlPanel",
    props: {
      position: {
        type: String,
        required: !0
      },
      invisible: { type: Boolean, default: !1 }
    },
    setup(t) {
      return (e, i) => (G(), X("div", {
        class: he(["control-panel d-print-none", [`control-panel-${t.position}`, { invisible: t.invisible }]])
      }, [
        e.$slots.extra ? (G(), X("div", g3, [
          ge(e.$slots, "extra", {}, void 0, !0)
        ])) : de("", !0),
        ge(e.$slots, "default", {}, void 0, !0)
      ], 2));
    }
  }), p3 = '.control-panel[data-v-e7193ff9]{position:absolute;z-index:10;display:flex}.control-panel[data-v-e7193ff9] .ol-control{box-shadow:0 .125rem .25rem #04071a13;height:fit-content}.control-panel[data-v-e7193ff9] .ol-control .draw-control-enabled{background-color:#99bae9;border-color:#99bae9}.control-panel[data-v-e7193ff9] .ol-control button{background-color:#fff;border:1px solid #fff;padding:.5rem;color:var(--diplan-body-color);min-width:2.4rem;min-height:2.4rem}.control-panel[data-v-e7193ff9] .ol-control button[disabled]{opacity:.66}.control-panel[data-v-e7193ff9] .ol-control button:hover:not([disabled]){background-color:#2964ba;border-color:#2964ba;color:#fff}.control-panel[data-v-e7193ff9] .ol-control button .ol-zoom-in{border-top-left-radius:5px!important;border-top-right-radius:5px!important}.control-panel[data-v-e7193ff9] .ol-control button :deep(.ol-zoom-out){border-bottom-left-radius:5px;border-bottom-right-radius:5px}@media print{.control-panel[data-v-e7193ff9] .ol-control button{display:none}}.control-panel-left[data-v-e7193ff9]{left:24px;top:50%;transform:translateY(-50%);flex-direction:column;max-height:80%}.control-panel-top-left[data-v-e7193ff9]{top:24px;left:24px;flex-direction:row-reverse}.control-panel-top[data-v-e7193ff9]{top:24px;left:50%;transform:translate(-50%);flex-direction:row;max-width:80%}.control-panel-top-right[data-v-e7193ff9]{top:24px;right:24px;flex-direction:row}.control-panel-top-right .control-panel-extra[data-v-e7193ff9] .ol-control{-webkit-clip-path:inset(-5px 0px -5px -5px);clip-path:inset(-5px 0px -5px 0px)}.control-panel-right[data-v-e7193ff9]{right:24px;top:40%;transform:translateY(-50%);flex-direction:column;max-height:80%}.control-panel-right[data-v-e7193ff9] .ol-control:nth-child(2) button:after,.control-panel-right[data-v-e7193ff9] .ol-control:nth-child(6) button:after,.control-panel-right[data-v-e7193ff9] .ol-control:nth-child(7) button:after,.control-panel-right[data-v-e7193ff9] .ol-control:nth-child(8) button:after{content:"";position:absolute;left:10%;bottom:0;height:1px;width:80%;border-bottom:1px solid #ccc}.control-panel-bottom-left[data-v-e7193ff9]{bottom:24px;left:24px;flex-direction:row-reverse;align-items:flex-end}.control-panel-bottom[data-v-e7193ff9]{bottom:24px;left:50%;transform:translate(-50%);flex-direction:row;max-width:80%}.control-panel-bottom-right[data-v-e7193ff9]{bottom:24px;right:24px;flex-direction:column}.control-panel-bottom-right[data-v-e7193ff9] .ol-control{display:flex;flex-direction:column;margin-bottom:1rem}.control-panel[data-v-e7193ff9] .ol-mouse-position{box-shadow:0 .125rem .25rem #04071a13;background-color:#ffffffa8;border-radius:0;width:200px;min-height:2.3rem;display:flex;align-items:center;justify-content:center}.control-panel[data-v-e7193ff9] .ol-full-screen button{font-size:0em}.control-panel[data-v-e7193ff9] .ol-full-screen button:before{font-size:1rem}', Zl = (t, e) => {
    const i = t.__vccOpts || t;
    for (const [r, n] of e)
      i[r] = n;
    return i;
  }, qA = /* @__PURE__ */ Zl(f3, [["styles", [p3]], ["__scopeId", "data-v-e7193ff9"]]);
  var Zr = "top", On = "bottom", Gn = "right", qr = "left", Dy = "auto", Md = [Zr, On, Gn, qr], Yl = "start", Ju = "end", mk = "clippingParents", tI = "viewport", Pc = "popper", Ek = "reference", jC = /* @__PURE__ */ Md.reduce(function(t, e) {
    return t.concat([e + "-" + Yl, e + "-" + Ju]);
  }, []), iI = /* @__PURE__ */ [].concat(Md, [Dy]).reduce(function(t, e) {
    return t.concat([e, e + "-" + Yl, e + "-" + Ju]);
  }, []), yk = "beforeRead", Bk = "read", wk = "afterRead", Ck = "beforeMain", bk = "main", Mk = "afterMain", Ik = "beforeWrite", vk = "write", xk = "afterWrite", Qk = [yk, Bk, wk, Ck, bk, Mk, Ik, vk, xk];
  function Lo(t) {
    return t ? (t.nodeName || "").toLowerCase() : null;
  }
  function jn(t) {
    if (t == null)
      return window;
    if (t.toString() !== "[object Window]") {
      var e = t.ownerDocument;
      return e && e.defaultView || window;
    }
    return t;
  }
  function Nl(t) {
    var e = jn(t).Element;
    return t instanceof e || t instanceof Element;
  }
  function os(t) {
    var e = jn(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement;
  }
  function rI(t) {
    if (typeof ShadowRoot > "u")
      return !1;
    var e = jn(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot;
  }
  function m3(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(i) {
      var r = e.styles[i] || {}, n = e.attributes[i] || {}, s = e.elements[i];
      !os(s) || !Lo(s) || (Object.assign(s.style, r), Object.keys(n).forEach(function(o) {
        var a = n[o];
        a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a);
      }));
    });
  }
  function E3(t) {
    var e = t.state, i = {
      popper: {
        position: e.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function() {
      Object.keys(e.elements).forEach(function(r) {
        var n = e.elements[r], s = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : i[r]), a = o.reduce(function(A, l) {
          return A[l] = "", A;
        }, {});
        !os(n) || !Lo(n) || (Object.assign(n.style, a), Object.keys(s).forEach(function(A) {
          n.removeAttribute(A);
        }));
      });
    };
  }
  const nI = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: m3,
    effect: E3,
    requires: ["computeStyles"]
  };
  function xo(t) {
    return t.split("-")[0];
  }
  var Ml = Math.max, tE = Math.min, Vu = Math.round;
  function HC() {
    var t = navigator.userAgentData;
    return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) {
      return e.brand + "/" + e.version;
    }).join(" ") : navigator.userAgent;
  }
  function Fk() {
    return !/^((?!chrome|android).)*safari/i.test(HC());
  }
  function Wu(t, e, i) {
    e === void 0 && (e = !1), i === void 0 && (i = !1);
    var r = t.getBoundingClientRect(), n = 1, s = 1;
    e && os(t) && (n = t.offsetWidth > 0 && Vu(r.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && Vu(r.height) / t.offsetHeight || 1);
    var o = Nl(t) ? jn(t) : window, a = o.visualViewport, A = !Fk() && i, l = (r.left + (A && a ? a.offsetLeft : 0)) / n, c = (r.top + (A && a ? a.offsetTop : 0)) / s, u = r.width / n, d = r.height / s;
    return {
      width: u,
      height: d,
      top: c,
      right: l + u,
      bottom: c + d,
      left: l,
      x: l,
      y: c
    };
  }
  function sI(t) {
    var e = Wu(t), i = t.offsetWidth, r = t.offsetHeight;
    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: i,
      height: r
    };
  }
  function Sk(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e))
      return !0;
    if (i && rI(i)) {
      var r = e;
      do {
        if (r && t.isSameNode(r))
          return !0;
        r = r.parentNode || r.host;
      } while (r);
    }
    return !1;
  }
  function Ma(t) {
    return jn(t).getComputedStyle(t);
  }
  function y3(t) {
    return ["table", "td", "th"].indexOf(Lo(t)) >= 0;
  }
  function NA(t) {
    return ((Nl(t) ? t.ownerDocument : (
      // $FlowFixMe[prop-missing]
      t.document
    )) || window.document).documentElement;
  }
  function Ty(t) {
    return Lo(t) === "html" ? t : (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      t.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      t.parentNode || // DOM Element detected
      (rI(t) ? t.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      NA(t)
    );
  }
  function LQ(t) {
    return !os(t) || // https://github.com/popperjs/popper-core/issues/837
    Ma(t).position === "fixed" ? null : t.offsetParent;
  }
  function B3(t) {
    var e = /firefox/i.test(HC()), i = /Trident/i.test(HC());
    if (i && os(t)) {
      var r = Ma(t);
      if (r.position === "fixed")
        return null;
    }
    var n = Ty(t);
    for (rI(n) && (n = n.host); os(n) && ["html", "body"].indexOf(Lo(n)) < 0; ) {
      var s = Ma(n);
      if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
        return n;
      n = n.parentNode;
    }
    return null;
  }
  function zg(t) {
    for (var e = jn(t), i = LQ(t); i && y3(i) && Ma(i).position === "static"; )
      i = LQ(i);
    return i && (Lo(i) === "html" || Lo(i) === "body" && Ma(i).position === "static") ? e : i || B3(t) || e;
  }
  function oI(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
  }
  function Rh(t, e, i) {
    return Ml(t, tE(e, i));
  }
  function w3(t, e, i) {
    var r = Rh(t, e, i);
    return r > i ? i : r;
  }
  function Dk() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }
  function Tk(t) {
    return Object.assign({}, Dk(), t);
  }
  function Rk(t, e) {
    return e.reduce(function(i, r) {
      return i[r] = t, i;
    }, {});
  }
  var C3 = function(e, i) {
    return e = typeof e == "function" ? e(Object.assign({}, i.rects, {
      placement: i.placement
    })) : e, Tk(typeof e != "number" ? e : Rk(e, Md));
  };
  function b3(t) {
    var e, i = t.state, r = t.name, n = t.options, s = i.elements.arrow, o = i.modifiersData.popperOffsets, a = xo(i.placement), A = oI(a), l = [qr, Gn].indexOf(a) >= 0, c = l ? "height" : "width";
    if (!(!s || !o)) {
      var u = C3(n.padding, i), d = sI(s), h = A === "y" ? Zr : qr, g = A === "y" ? On : Gn, f = i.rects.reference[c] + i.rects.reference[A] - o[A] - i.rects.popper[c], p = o[A] - i.rects.reference[A], m = zg(s), E = m ? A === "y" ? m.clientHeight || 0 : m.clientWidth || 0 : 0, y = f / 2 - p / 2, C = u[h], w = E - d[c] - u[g], M = E / 2 - d[c] / 2 + y, I = Rh(C, M, w), b = A;
      i.modifiersData[r] = (e = {}, e[b] = I, e.centerOffset = I - M, e);
    }
  }
  function M3(t) {
    var e = t.state, i = t.options, r = i.element, n = r === void 0 ? "[data-popper-arrow]" : r;
    n != null && (typeof n == "string" && (n = e.elements.popper.querySelector(n), !n) || Sk(e.elements.popper, n) && (e.elements.arrow = n));
  }
  const _k = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: b3,
    effect: M3,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function Ku(t) {
    return t.split("-")[1];
  }
  var I3 = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function v3(t, e) {
    var i = t.x, r = t.y, n = e.devicePixelRatio || 1;
    return {
      x: Vu(i * n) / n || 0,
      y: Vu(r * n) / n || 0
    };
  }
  function zQ(t) {
    var e, i = t.popper, r = t.popperRect, n = t.placement, s = t.variation, o = t.offsets, a = t.position, A = t.gpuAcceleration, l = t.adaptive, c = t.roundOffsets, u = t.isFixed, d = o.x, h = d === void 0 ? 0 : d, g = o.y, f = g === void 0 ? 0 : g, p = typeof c == "function" ? c({
      x: h,
      y: f
    }) : {
      x: h,
      y: f
    };
    h = p.x, f = p.y;
    var m = o.hasOwnProperty("x"), E = o.hasOwnProperty("y"), y = qr, C = Zr, w = window;
    if (l) {
      var M = zg(i), I = "clientHeight", b = "clientWidth";
      if (M === jn(i) && (M = NA(i), Ma(M).position !== "static" && a === "absolute" && (I = "scrollHeight", b = "scrollWidth")), M = M, n === Zr || (n === qr || n === Gn) && s === Ju) {
        C = On;
        var B = u && M === w && w.visualViewport ? w.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          M[I]
        );
        f -= B - r.height, f *= A ? 1 : -1;
      }
      if (n === qr || (n === Zr || n === On) && s === Ju) {
        y = Gn;
        var x = u && M === w && w.visualViewport ? w.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          M[b]
        );
        h -= x - r.width, h *= A ? 1 : -1;
      }
    }
    var Q = Object.assign({
      position: a
    }, l && I3), v = c === !0 ? v3({
      x: h,
      y: f
    }, jn(i)) : {
      x: h,
      y: f
    };
    if (h = v.x, f = v.y, A) {
      var T;
      return Object.assign({}, Q, (T = {}, T[C] = E ? "0" : "", T[y] = m ? "0" : "", T.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + f + "px)" : "translate3d(" + h + "px, " + f + "px, 0)", T));
    }
    return Object.assign({}, Q, (e = {}, e[C] = E ? f + "px" : "", e[y] = m ? h + "px" : "", e.transform = "", e));
  }
  function x3(t) {
    var e = t.state, i = t.options, r = i.gpuAcceleration, n = r === void 0 ? !0 : r, s = i.adaptive, o = s === void 0 ? !0 : s, a = i.roundOffsets, A = a === void 0 ? !0 : a, l = {
      placement: xo(e.placement),
      variation: Ku(e.placement),
      popper: e.elements.popper,
      popperRect: e.rects.popper,
      gpuAcceleration: n,
      isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, zQ(Object.assign({}, l, {
      offsets: e.modifiersData.popperOffsets,
      position: e.options.strategy,
      adaptive: o,
      roundOffsets: A
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, zQ(Object.assign({}, l, {
      offsets: e.modifiersData.arrow,
      position: "absolute",
      adaptive: !1,
      roundOffsets: A
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-placement": e.placement
    });
  }
  const aI = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: x3,
    data: {}
  };
  var Of = {
    passive: !0
  };
  function Q3(t) {
    var e = t.state, i = t.instance, r = t.options, n = r.scroll, s = n === void 0 ? !0 : n, o = r.resize, a = o === void 0 ? !0 : o, A = jn(e.elements.popper), l = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && l.forEach(function(c) {
      c.addEventListener("scroll", i.update, Of);
    }), a && A.addEventListener("resize", i.update, Of), function() {
      s && l.forEach(function(c) {
        c.removeEventListener("scroll", i.update, Of);
      }), a && A.removeEventListener("resize", i.update, Of);
    };
  }
  const AI = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {
    },
    effect: Q3,
    data: {}
  };
  var F3 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Xp(t) {
    return t.replace(/left|right|bottom|top/g, function(e) {
      return F3[e];
    });
  }
  var S3 = {
    start: "end",
    end: "start"
  };
  function PQ(t) {
    return t.replace(/start|end/g, function(e) {
      return S3[e];
    });
  }
  function lI(t) {
    var e = jn(t), i = e.pageXOffset, r = e.pageYOffset;
    return {
      scrollLeft: i,
      scrollTop: r
    };
  }
  function cI(t) {
    return Wu(NA(t)).left + lI(t).scrollLeft;
  }
  function D3(t, e) {
    var i = jn(t), r = NA(t), n = i.visualViewport, s = r.clientWidth, o = r.clientHeight, a = 0, A = 0;
    if (n) {
      s = n.width, o = n.height;
      var l = Fk();
      (l || !l && e === "fixed") && (a = n.offsetLeft, A = n.offsetTop);
    }
    return {
      width: s,
      height: o,
      x: a + cI(t),
      y: A
    };
  }
  function T3(t) {
    var e, i = NA(t), r = lI(t), n = (e = t.ownerDocument) == null ? void 0 : e.body, s = Ml(i.scrollWidth, i.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = Ml(i.scrollHeight, i.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -r.scrollLeft + cI(t), A = -r.scrollTop;
    return Ma(n || i).direction === "rtl" && (a += Ml(i.clientWidth, n ? n.clientWidth : 0) - s), {
      width: s,
      height: o,
      x: a,
      y: A
    };
  }
  function uI(t) {
    var e = Ma(t), i = e.overflow, r = e.overflowX, n = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + n + r);
  }
  function kk(t) {
    return ["html", "body", "#document"].indexOf(Lo(t)) >= 0 ? t.ownerDocument.body : os(t) && uI(t) ? t : kk(Ty(t));
  }
  function _h(t, e) {
    var i;
    e === void 0 && (e = []);
    var r = kk(t), n = r === ((i = t.ownerDocument) == null ? void 0 : i.body), s = jn(r), o = n ? [s].concat(s.visualViewport || [], uI(r) ? r : []) : r, a = e.concat(o);
    return n ? a : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      a.concat(_h(Ty(o)))
    );
  }
  function JC(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height
    });
  }
  function R3(t, e) {
    var i = Wu(t, !1, e === "fixed");
    return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i;
  }
  function OQ(t, e, i) {
    return e === tI ? JC(D3(t, i)) : Nl(e) ? R3(e, i) : JC(T3(NA(t)));
  }
  function _3(t) {
    var e = _h(Ty(t)), i = ["absolute", "fixed"].indexOf(Ma(t).position) >= 0, r = i && os(t) ? zg(t) : t;
    return Nl(r) ? e.filter(function(n) {
      return Nl(n) && Sk(n, r) && Lo(n) !== "body";
    }) : [];
  }
  function k3(t, e, i, r) {
    var n = e === "clippingParents" ? _3(t) : [].concat(e), s = [].concat(n, [i]), o = s[0], a = s.reduce(function(A, l) {
      var c = OQ(t, l, r);
      return A.top = Ml(c.top, A.top), A.right = tE(c.right, A.right), A.bottom = tE(c.bottom, A.bottom), A.left = Ml(c.left, A.left), A;
    }, OQ(t, o, r));
    return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
  }
  function Yk(t) {
    var e = t.reference, i = t.element, r = t.placement, n = r ? xo(r) : null, s = r ? Ku(r) : null, o = e.x + e.width / 2 - i.width / 2, a = e.y + e.height / 2 - i.height / 2, A;
    switch (n) {
      case Zr:
        A = {
          x: o,
          y: e.y - i.height
        };
        break;
      case On:
        A = {
          x: o,
          y: e.y + e.height
        };
        break;
      case Gn:
        A = {
          x: e.x + e.width,
          y: a
        };
        break;
      case qr:
        A = {
          x: e.x - i.width,
          y: a
        };
        break;
      default:
        A = {
          x: e.x,
          y: e.y
        };
    }
    var l = n ? oI(n) : null;
    if (l != null) {
      var c = l === "y" ? "height" : "width";
      switch (s) {
        case Yl:
          A[l] = A[l] - (e[c] / 2 - i[c] / 2);
          break;
        case Ju:
          A[l] = A[l] + (e[c] / 2 - i[c] / 2);
          break;
      }
    }
    return A;
  }
  function Xu(t, e) {
    e === void 0 && (e = {});
    var i = e, r = i.placement, n = r === void 0 ? t.placement : r, s = i.strategy, o = s === void 0 ? t.strategy : s, a = i.boundary, A = a === void 0 ? mk : a, l = i.rootBoundary, c = l === void 0 ? tI : l, u = i.elementContext, d = u === void 0 ? Pc : u, h = i.altBoundary, g = h === void 0 ? !1 : h, f = i.padding, p = f === void 0 ? 0 : f, m = Tk(typeof p != "number" ? p : Rk(p, Md)), E = d === Pc ? Ek : Pc, y = t.rects.popper, C = t.elements[g ? E : d], w = k3(Nl(C) ? C : C.contextElement || NA(t.elements.popper), A, c, o), M = Wu(t.elements.reference), I = Yk({
      reference: M,
      element: y,
      placement: n
    }), b = JC(Object.assign({}, y, I)), B = d === Pc ? b : M, x = {
      top: w.top - B.top + m.top,
      bottom: B.bottom - w.bottom + m.bottom,
      left: w.left - B.left + m.left,
      right: B.right - w.right + m.right
    }, Q = t.modifiersData.offset;
    if (d === Pc && Q) {
      var v = Q[n];
      Object.keys(x).forEach(function(T) {
        var S = [Gn, On].indexOf(T) >= 0 ? 1 : -1, D = [Zr, On].indexOf(T) >= 0 ? "y" : "x";
        x[T] += v[D] * S;
      });
    }
    return x;
  }
  function Y3(t, e) {
    e === void 0 && (e = {});
    var i = e, r = i.placement, n = i.boundary, s = i.rootBoundary, o = i.padding, a = i.flipVariations, A = i.allowedAutoPlacements, l = A === void 0 ? iI : A, c = Ku(r), u = c ? a ? jC : jC.filter(function(g) {
      return Ku(g) === c;
    }) : Md, d = u.filter(function(g) {
      return l.indexOf(g) >= 0;
    });
    d.length === 0 && (d = u);
    var h = d.reduce(function(g, f) {
      return g[f] = Xu(t, {
        placement: f,
        boundary: n,
        rootBoundary: s,
        padding: o
      })[xo(f)], g;
    }, {});
    return Object.keys(h).sort(function(g, f) {
      return h[g] - h[f];
    });
  }
  function N3(t) {
    if (xo(t) === Dy)
      return [];
    var e = Xp(t);
    return [PQ(t), e, PQ(e)];
  }
  function U3(t) {
    var e = t.state, i = t.options, r = t.name;
    if (!e.modifiersData[r]._skip) {
      for (var n = i.mainAxis, s = n === void 0 ? !0 : n, o = i.altAxis, a = o === void 0 ? !0 : o, A = i.fallbackPlacements, l = i.padding, c = i.boundary, u = i.rootBoundary, d = i.altBoundary, h = i.flipVariations, g = h === void 0 ? !0 : h, f = i.allowedAutoPlacements, p = e.options.placement, m = xo(p), E = m === p, y = A || (E || !g ? [Xp(p)] : N3(p)), C = [p].concat(y).reduce(function(V, Z) {
        return V.concat(xo(Z) === Dy ? Y3(e, {
          placement: Z,
          boundary: c,
          rootBoundary: u,
          padding: l,
          flipVariations: g,
          allowedAutoPlacements: f
        }) : Z);
      }, []), w = e.rects.reference, M = e.rects.popper, I = /* @__PURE__ */ new Map(), b = !0, B = C[0], x = 0; x < C.length; x++) {
        var Q = C[x], v = xo(Q), T = Ku(Q) === Yl, S = [Zr, On].indexOf(v) >= 0, D = S ? "width" : "height", F = Xu(e, {
          placement: Q,
          boundary: c,
          rootBoundary: u,
          altBoundary: d,
          padding: l
        }), R = S ? T ? Gn : qr : T ? On : Zr;
        w[D] > M[D] && (R = Xp(R));
        var Y = Xp(R), L = [];
        if (s && L.push(F[v] <= 0), a && L.push(F[R] <= 0, F[Y] <= 0), L.every(function(V) {
          return V;
        })) {
          B = Q, b = !1;
          break;
        }
        I.set(Q, L);
      }
      if (b)
        for (var N = g ? 3 : 1, H = function(Z) {
          var se = C.find(function(k) {
            var _ = I.get(k);
            if (_)
              return _.slice(0, Z).every(function(q) {
                return q;
              });
          });
          if (se)
            return B = se, "break";
        }, P = N; P > 0; P--) {
          var ie = H(P);
          if (ie === "break") break;
        }
      e.placement !== B && (e.modifiersData[r]._skip = !0, e.placement = B, e.reset = !0);
    }
  }
  const Nk = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: U3,
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };
  function GQ(t, e, i) {
    return i === void 0 && (i = {
      x: 0,
      y: 0
    }), {
      top: t.top - e.height - i.y,
      right: t.right - e.width + i.x,
      bottom: t.bottom - e.height + i.y,
      left: t.left - e.width - i.x
    };
  }
  function jQ(t) {
    return [Zr, Gn, On, qr].some(function(e) {
      return t[e] >= 0;
    });
  }
  function L3(t) {
    var e = t.state, i = t.name, r = e.rects.reference, n = e.rects.popper, s = e.modifiersData.preventOverflow, o = Xu(e, {
      elementContext: "reference"
    }), a = Xu(e, {
      altBoundary: !0
    }), A = GQ(o, r), l = GQ(a, n, s), c = jQ(A), u = jQ(l);
    e.modifiersData[i] = {
      referenceClippingOffsets: A,
      popperEscapeOffsets: l,
      isReferenceHidden: c,
      hasPopperEscaped: u
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
      "data-popper-reference-hidden": c,
      "data-popper-escaped": u
    });
  }
  const Uk = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: L3
  };
  function z3(t, e, i) {
    var r = xo(t), n = [qr, Zr].indexOf(r) >= 0 ? -1 : 1, s = typeof i == "function" ? i(Object.assign({}, e, {
      placement: t
    })) : i, o = s[0], a = s[1];
    return o = o || 0, a = (a || 0) * n, [qr, Gn].indexOf(r) >= 0 ? {
      x: a,
      y: o
    } : {
      x: o,
      y: a
    };
  }
  function P3(t) {
    var e = t.state, i = t.options, r = t.name, n = i.offset, s = n === void 0 ? [0, 0] : n, o = iI.reduce(function(c, u) {
      return c[u] = z3(u, e.rects, s), c;
    }, {}), a = o[e.placement], A = a.x, l = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += A, e.modifiersData.popperOffsets.y += l), e.modifiersData[r] = o;
  }
  const Lk = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: P3
  };
  function O3(t) {
    var e = t.state, i = t.name;
    e.modifiersData[i] = Yk({
      reference: e.rects.reference,
      element: e.rects.popper,
      placement: e.placement
    });
  }
  const dI = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: O3,
    data: {}
  };
  function G3(t) {
    return t === "x" ? "y" : "x";
  }
  function j3(t) {
    var e = t.state, i = t.options, r = t.name, n = i.mainAxis, s = n === void 0 ? !0 : n, o = i.altAxis, a = o === void 0 ? !1 : o, A = i.boundary, l = i.rootBoundary, c = i.altBoundary, u = i.padding, d = i.tether, h = d === void 0 ? !0 : d, g = i.tetherOffset, f = g === void 0 ? 0 : g, p = Xu(e, {
      boundary: A,
      rootBoundary: l,
      padding: u,
      altBoundary: c
    }), m = xo(e.placement), E = Ku(e.placement), y = !E, C = oI(m), w = G3(C), M = e.modifiersData.popperOffsets, I = e.rects.reference, b = e.rects.popper, B = typeof f == "function" ? f(Object.assign({}, e.rects, {
      placement: e.placement
    })) : f, x = typeof B == "number" ? {
      mainAxis: B,
      altAxis: B
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, B), Q = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, v = {
      x: 0,
      y: 0
    };
    if (M) {
      if (s) {
        var T, S = C === "y" ? Zr : qr, D = C === "y" ? On : Gn, F = C === "y" ? "height" : "width", R = M[C], Y = R + p[S], L = R - p[D], N = h ? -b[F] / 2 : 0, H = E === Yl ? I[F] : b[F], P = E === Yl ? -b[F] : -I[F], ie = e.elements.arrow, V = h && ie ? sI(ie) : {
          width: 0,
          height: 0
        }, Z = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Dk(), se = Z[S], k = Z[D], _ = Rh(0, I[F], V[F]), q = y ? I[F] / 2 - N - _ - se - x.mainAxis : H - _ - se - x.mainAxis, U = y ? -I[F] / 2 + N + _ + k + x.mainAxis : P + _ + k + x.mainAxis, J = e.elements.arrow && zg(e.elements.arrow), ae = J ? C === "y" ? J.clientTop || 0 : J.clientLeft || 0 : 0, $ = (T = Q == null ? void 0 : Q[C]) != null ? T : 0, Ce = R + q - $ - ae, Re = R + U - $, Oe = Rh(h ? tE(Y, Ce) : Y, R, h ? Ml(L, Re) : L);
        M[C] = Oe, v[C] = Oe - R;
      }
      if (a) {
        var K, Ae = C === "x" ? Zr : qr, ut = C === "x" ? On : Gn, Me = M[w], Fe = w === "y" ? "height" : "width", jt = Me + p[Ae], Rt = Me - p[ut], rt = [Zr, qr].indexOf(m) !== -1, Ke = (K = Q == null ? void 0 : Q[w]) != null ? K : 0, Qt = rt ? jt : Me - I[Fe] - b[Fe] - Ke + x.altAxis, Ht = rt ? Me + I[Fe] + b[Fe] - Ke - x.altAxis : Rt, lt = h && rt ? w3(Qt, Me, Ht) : Rh(h ? Qt : jt, Me, h ? Ht : Rt);
        M[w] = lt, v[w] = lt - Me;
      }
      e.modifiersData[r] = v;
    }
  }
  const zk = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: j3,
    requiresIfExists: ["offset"]
  };
  function H3(t) {
    return {
      scrollLeft: t.scrollLeft,
      scrollTop: t.scrollTop
    };
  }
  function J3(t) {
    return t === jn(t) || !os(t) ? lI(t) : H3(t);
  }
  function V3(t) {
    var e = t.getBoundingClientRect(), i = Vu(e.width) / t.offsetWidth || 1, r = Vu(e.height) / t.offsetHeight || 1;
    return i !== 1 || r !== 1;
  }
  function W3(t, e, i) {
    i === void 0 && (i = !1);
    var r = os(e), n = os(e) && V3(e), s = NA(e), o = Wu(t, n, i), a = {
      scrollLeft: 0,
      scrollTop: 0
    }, A = {
      x: 0,
      y: 0
    };
    return (r || !r && !i) && ((Lo(e) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    uI(s)) && (a = J3(e)), os(e) ? (A = Wu(e, !0), A.x += e.clientLeft, A.y += e.clientTop) : s && (A.x = cI(s))), {
      x: o.left + a.scrollLeft - A.x,
      y: o.top + a.scrollTop - A.y,
      width: o.width,
      height: o.height
    };
  }
  function K3(t) {
    var e = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), r = [];
    t.forEach(function(s) {
      e.set(s.name, s);
    });
    function n(s) {
      i.add(s.name);
      var o = [].concat(s.requires || [], s.requiresIfExists || []);
      o.forEach(function(a) {
        if (!i.has(a)) {
          var A = e.get(a);
          A && n(A);
        }
      }), r.push(s);
    }
    return t.forEach(function(s) {
      i.has(s.name) || n(s);
    }), r;
  }
  function X3(t) {
    var e = K3(t);
    return Qk.reduce(function(i, r) {
      return i.concat(e.filter(function(n) {
        return n.phase === r;
      }));
    }, []);
  }
  function Z3(t) {
    var e;
    return function() {
      return e || (e = new Promise(function(i) {
        Promise.resolve().then(function() {
          e = void 0, i(t());
        });
      })), e;
    };
  }
  function q3(t) {
    var e = t.reduce(function(i, r) {
      var n = i[r.name];
      return i[r.name] = n ? Object.assign({}, n, r, {
        options: Object.assign({}, n.options, r.options),
        data: Object.assign({}, n.data, r.data)
      }) : r, i;
    }, {});
    return Object.keys(e).map(function(i) {
      return e[i];
    });
  }
  var HQ = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function JQ() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
      e[i] = arguments[i];
    return !e.some(function(r) {
      return !(r && typeof r.getBoundingClientRect == "function");
    });
  }
  function Ry(t) {
    t === void 0 && (t = {});
    var e = t, i = e.defaultModifiers, r = i === void 0 ? [] : i, n = e.defaultOptions, s = n === void 0 ? HQ : n;
    return function(a, A, l) {
      l === void 0 && (l = s);
      var c = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, HQ, s),
        modifiersData: {},
        elements: {
          reference: a,
          popper: A
        },
        attributes: {},
        styles: {}
      }, u = [], d = !1, h = {
        state: c,
        setOptions: function(m) {
          var E = typeof m == "function" ? m(c.options) : m;
          f(), c.options = Object.assign({}, s, c.options, E), c.scrollParents = {
            reference: Nl(a) ? _h(a) : a.contextElement ? _h(a.contextElement) : [],
            popper: _h(A)
          };
          var y = X3(q3([].concat(r, c.options.modifiers)));
          return c.orderedModifiers = y.filter(function(C) {
            return C.enabled;
          }), g(), h.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function() {
          if (!d) {
            var m = c.elements, E = m.reference, y = m.popper;
            if (JQ(E, y)) {
              c.rects = {
                reference: W3(E, zg(y), c.options.strategy === "fixed"),
                popper: sI(y)
              }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(x) {
                return c.modifiersData[x.name] = Object.assign({}, x.data);
              });
              for (var C = 0; C < c.orderedModifiers.length; C++) {
                if (c.reset === !0) {
                  c.reset = !1, C = -1;
                  continue;
                }
                var w = c.orderedModifiers[C], M = w.fn, I = w.options, b = I === void 0 ? {} : I, B = w.name;
                typeof M == "function" && (c = M({
                  state: c,
                  options: b,
                  name: B,
                  instance: h
                }) || c);
              }
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: Z3(function() {
          return new Promise(function(p) {
            h.forceUpdate(), p(c);
          });
        }),
        destroy: function() {
          f(), d = !0;
        }
      };
      if (!JQ(a, A))
        return h;
      h.setOptions(l).then(function(p) {
        !d && l.onFirstUpdate && l.onFirstUpdate(p);
      });
      function g() {
        c.orderedModifiers.forEach(function(p) {
          var m = p.name, E = p.options, y = E === void 0 ? {} : E, C = p.effect;
          if (typeof C == "function") {
            var w = C({
              state: c,
              name: m,
              instance: h,
              options: y
            }), M = function() {
            };
            u.push(w || M);
          }
        });
      }
      function f() {
        u.forEach(function(p) {
          return p();
        }), u = [];
      }
      return h;
    };
  }
  var $3 = /* @__PURE__ */ Ry(), eH = [AI, dI, aI, nI], tH = /* @__PURE__ */ Ry({
    defaultModifiers: eH
  }), iH = [AI, dI, aI, nI, Lk, Nk, zk, _k, Uk], hI = /* @__PURE__ */ Ry({
    defaultModifiers: iH
  });
  const Pk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    afterMain: Mk,
    afterRead: wk,
    afterWrite: xk,
    applyStyles: nI,
    arrow: _k,
    auto: Dy,
    basePlacements: Md,
    beforeMain: Ck,
    beforeRead: yk,
    beforeWrite: Ik,
    bottom: On,
    clippingParents: mk,
    computeStyles: aI,
    createPopper: hI,
    createPopperBase: $3,
    createPopperLite: tH,
    detectOverflow: Xu,
    end: Ju,
    eventListeners: AI,
    flip: Nk,
    hide: Uk,
    left: qr,
    main: bk,
    modifierPhases: Qk,
    offset: Lk,
    placements: iI,
    popper: Pc,
    popperGenerator: Ry,
    popperOffsets: dI,
    preventOverflow: zk,
    read: Bk,
    reference: Ek,
    right: Gn,
    start: Yl,
    top: Zr,
    variationPlacements: jC,
    viewport: tI,
    write: vk
  }, Symbol.toStringTag, { value: "Module" }));
  /*!
    * Bootstrap v5.3.5 (https://getbootstrap.com/)
    * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    */
  const Ja = /* @__PURE__ */ new Map(), gw = {
    set(t, e, i) {
      Ja.has(t) || Ja.set(t, /* @__PURE__ */ new Map());
      const r = Ja.get(t);
      if (!r.has(e) && r.size !== 0) {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(r.keys())[0]}.`);
        return;
      }
      r.set(e, i);
    },
    get(t, e) {
      return Ja.has(t) && Ja.get(t).get(e) || null;
    },
    remove(t, e) {
      if (!Ja.has(t))
        return;
      const i = Ja.get(t);
      i.delete(e), i.size === 0 && Ja.delete(t);
    }
  }, rH = 1e6, nH = 1e3, VC = "transitionend", Ok = (t) => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, (e, i) => `#${CSS.escape(i)}`)), t), sH = (t) => t == null ? `${t}` : Object.prototype.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), oH = (t) => {
    do
      t += Math.floor(Math.random() * rH);
    while (document.getElementById(t));
    return t;
  }, aH = (t) => {
    if (!t)
      return 0;
    let {
      transitionDuration: e,
      transitionDelay: i
    } = window.getComputedStyle(t);
    const r = Number.parseFloat(e), n = Number.parseFloat(i);
    return !r && !n ? 0 : (e = e.split(",")[0], i = i.split(",")[0], (Number.parseFloat(e) + Number.parseFloat(i)) * nH);
  }, Gk = (t) => {
    t.dispatchEvent(new Event(VC));
  }, ca = (t) => !t || typeof t != "object" ? !1 : (typeof t.jquery < "u" && (t = t[0]), typeof t.nodeType < "u"), CA = (t) => ca(t) ? t.jquery ? t[0] : t : typeof t == "string" && t.length > 0 ? document.querySelector(Ok(t)) : null, Id = (t) => {
    if (!ca(t) || t.getClientRects().length === 0)
      return !1;
    const e = getComputedStyle(t).getPropertyValue("visibility") === "visible", i = t.closest("details:not([open])");
    if (!i)
      return e;
    if (i !== t) {
      const r = t.closest("summary");
      if (r && r.parentNode !== i || r === null)
        return !1;
    }
    return e;
  }, bA = (t) => !t || t.nodeType !== Node.ELEMENT_NODE || t.classList.contains("disabled") ? !0 : typeof t.disabled < "u" ? t.disabled : t.hasAttribute("disabled") && t.getAttribute("disabled") !== "false", jk = (t) => {
    if (!document.documentElement.attachShadow)
      return null;
    if (typeof t.getRootNode == "function") {
      const e = t.getRootNode();
      return e instanceof ShadowRoot ? e : null;
    }
    return t instanceof ShadowRoot ? t : t.parentNode ? jk(t.parentNode) : null;
  }, iE = () => {
  }, Pg = (t) => {
    t.offsetHeight;
  }, Hk = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, fw = [], AH = (t) => {
    document.readyState === "loading" ? (fw.length || document.addEventListener("DOMContentLoaded", () => {
      for (const e of fw)
        e();
    }), fw.push(t)) : t();
  }, us = () => document.documentElement.dir === "rtl", ms = (t) => {
    AH(() => {
      const e = Hk();
      if (e) {
        const i = t.NAME, r = e.fn[i];
        e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = r, t.jQueryInterface);
      }
    });
  }, mn = (t, e = [], i = t) => typeof t == "function" ? t.call(...e) : i, Jk = (t, e, i = !0) => {
    if (!i) {
      mn(t);
      return;
    }
    const n = aH(e) + 5;
    let s = !1;
    const o = ({
      target: a
    }) => {
      a === e && (s = !0, e.removeEventListener(VC, o), mn(t));
    };
    e.addEventListener(VC, o), setTimeout(() => {
      s || Gk(e);
    }, n);
  }, gI = (t, e, i, r) => {
    const n = t.length;
    let s = t.indexOf(e);
    return s === -1 ? !i && r ? t[n - 1] : t[0] : (s += i ? 1 : -1, r && (s = (s + n) % n), t[Math.max(0, Math.min(s, n - 1))]);
  }, lH = /[^.]*(?=\..*)\.|.*/, cH = /\..*/, uH = /::\d+$/, pw = {};
  let VQ = 1;
  const Vk = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  }, dH = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function Wk(t, e) {
    return e && `${e}::${VQ++}` || t.uidEvent || VQ++;
  }
  function Kk(t) {
    const e = Wk(t);
    return t.uidEvent = e, pw[e] = pw[e] || {}, pw[e];
  }
  function hH(t, e) {
    return function i(r) {
      return fI(r, {
        delegateTarget: t
      }), i.oneOff && Ee.off(t, r.type, e), e.apply(t, [r]);
    };
  }
  function gH(t, e, i) {
    return function r(n) {
      const s = t.querySelectorAll(e);
      for (let {
        target: o
      } = n; o && o !== this; o = o.parentNode)
        for (const a of s)
          if (a === o)
            return fI(n, {
              delegateTarget: o
            }), r.oneOff && Ee.off(t, n.type, e, i), i.apply(o, [n]);
    };
  }
  function Xk(t, e, i = null) {
    return Object.values(t).find((r) => r.callable === e && r.delegationSelector === i);
  }
  function Zk(t, e, i) {
    const r = typeof e == "string", n = r ? i : e || i;
    let s = qk(t);
    return dH.has(s) || (s = t), [r, n, s];
  }
  function WQ(t, e, i, r, n) {
    if (typeof e != "string" || !t)
      return;
    let [s, o, a] = Zk(e, i, r);
    e in Vk && (o = ((g) => function(f) {
      if (!f.relatedTarget || f.relatedTarget !== f.delegateTarget && !f.delegateTarget.contains(f.relatedTarget))
        return g.call(this, f);
    })(o));
    const A = Kk(t), l = A[a] || (A[a] = {}), c = Xk(l, o, s ? i : null);
    if (c) {
      c.oneOff = c.oneOff && n;
      return;
    }
    const u = Wk(o, e.replace(lH, "")), d = s ? gH(t, i, o) : hH(t, o);
    d.delegationSelector = s ? i : null, d.callable = o, d.oneOff = n, d.uidEvent = u, l[u] = d, t.addEventListener(a, d, s);
  }
  function WC(t, e, i, r, n) {
    const s = Xk(e[i], r, n);
    s && (t.removeEventListener(i, s, !!n), delete e[i][s.uidEvent]);
  }
  function fH(t, e, i, r) {
    const n = e[i] || {};
    for (const [s, o] of Object.entries(n))
      s.includes(r) && WC(t, e, i, o.callable, o.delegationSelector);
  }
  function qk(t) {
    return t = t.replace(cH, ""), Vk[t] || t;
  }
  const Ee = {
    on(t, e, i, r) {
      WQ(t, e, i, r, !1);
    },
    one(t, e, i, r) {
      WQ(t, e, i, r, !0);
    },
    off(t, e, i, r) {
      if (typeof e != "string" || !t)
        return;
      const [n, s, o] = Zk(e, i, r), a = o !== e, A = Kk(t), l = A[o] || {}, c = e.startsWith(".");
      if (typeof s < "u") {
        if (!Object.keys(l).length)
          return;
        WC(t, A, o, s, n ? i : null);
        return;
      }
      if (c)
        for (const u of Object.keys(A))
          fH(t, A, u, e.slice(1));
      for (const [u, d] of Object.entries(l)) {
        const h = u.replace(uH, "");
        (!a || e.includes(h)) && WC(t, A, o, d.callable, d.delegationSelector);
      }
    },
    trigger(t, e, i) {
      if (typeof e != "string" || !t)
        return null;
      const r = Hk(), n = qk(e), s = e !== n;
      let o = null, a = !0, A = !0, l = !1;
      s && r && (o = r.Event(e, i), r(t).trigger(o), a = !o.isPropagationStopped(), A = !o.isImmediatePropagationStopped(), l = o.isDefaultPrevented());
      const c = fI(new Event(e, {
        bubbles: a,
        cancelable: !0
      }), i);
      return l && c.preventDefault(), A && t.dispatchEvent(c), c.defaultPrevented && o && o.preventDefault(), c;
    }
  };
  function fI(t, e = {}) {
    for (const [i, r] of Object.entries(e))
      try {
        t[i] = r;
      } catch {
        Object.defineProperty(t, i, {
          configurable: !0,
          get() {
            return r;
          }
        });
      }
    return t;
  }
  function KQ(t) {
    if (t === "true")
      return !0;
    if (t === "false")
      return !1;
    if (t === Number(t).toString())
      return Number(t);
    if (t === "" || t === "null")
      return null;
    if (typeof t != "string")
      return t;
    try {
      return JSON.parse(decodeURIComponent(t));
    } catch {
      return t;
    }
  }
  function mw(t) {
    return t.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);
  }
  const ua = {
    setDataAttribute(t, e, i) {
      t.setAttribute(`data-bs-${mw(e)}`, i);
    },
    removeDataAttribute(t, e) {
      t.removeAttribute(`data-bs-${mw(e)}`);
    },
    getDataAttributes(t) {
      if (!t)
        return {};
      const e = {}, i = Object.keys(t.dataset).filter((r) => r.startsWith("bs") && !r.startsWith("bsConfig"));
      for (const r of i) {
        let n = r.replace(/^bs/, "");
        n = n.charAt(0).toLowerCase() + n.slice(1), e[n] = KQ(t.dataset[r]);
      }
      return e;
    },
    getDataAttribute(t, e) {
      return KQ(t.getAttribute(`data-bs-${mw(e)}`));
    }
  };
  class Og {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(e) {
      return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e;
    }
    _configAfterMerge(e) {
      return e;
    }
    _mergeConfigObj(e, i) {
      const r = ca(i) ? ua.getDataAttribute(i, "config") : {};
      return {
        ...this.constructor.Default,
        ...typeof r == "object" ? r : {},
        ...ca(i) ? ua.getDataAttributes(i) : {},
        ...typeof e == "object" ? e : {}
      };
    }
    _typeCheckConfig(e, i = this.constructor.DefaultType) {
      for (const [r, n] of Object.entries(i)) {
        const s = e[r], o = ca(s) ? "element" : sH(s);
        if (!new RegExp(n).test(o))
          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${r}" provided type "${o}" but expected type "${n}".`);
      }
    }
  }
  const pH = "5.3.5";
  class io extends Og {
    constructor(e, i) {
      super(), e = CA(e), e && (this._element = e, this._config = this._getConfig(i), gw.set(this._element, this.constructor.DATA_KEY, this));
    }
    // Public
    dispose() {
      gw.remove(this._element, this.constructor.DATA_KEY), Ee.off(this._element, this.constructor.EVENT_KEY);
      for (const e of Object.getOwnPropertyNames(this))
        this[e] = null;
    }
    _queueCallback(e, i, r = !0) {
      Jk(e, i, r);
    }
    _getConfig(e) {
      return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e;
    }
    // Static
    static getInstance(e) {
      return gw.get(CA(e), this.DATA_KEY);
    }
    static getOrCreateInstance(e, i = {}) {
      return this.getInstance(e) || new this(e, typeof i == "object" ? i : null);
    }
    static get VERSION() {
      return pH;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(e) {
      return `${e}${this.EVENT_KEY}`;
    }
  }
  const Ew = (t) => {
    let e = t.getAttribute("data-bs-target");
    if (!e || e === "#") {
      let i = t.getAttribute("href");
      if (!i || !i.includes("#") && !i.startsWith("."))
        return null;
      i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && i !== "#" ? i.trim() : null;
    }
    return e ? e.split(",").map((i) => Ok(i)).join(",") : null;
  }, et = {
    find(t, e = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(e, t));
    },
    findOne(t, e = document.documentElement) {
      return Element.prototype.querySelector.call(e, t);
    },
    children(t, e) {
      return [].concat(...t.children).filter((i) => i.matches(e));
    },
    parents(t, e) {
      const i = [];
      let r = t.parentNode.closest(e);
      for (; r; )
        i.push(r), r = r.parentNode.closest(e);
      return i;
    },
    prev(t, e) {
      let i = t.previousElementSibling;
      for (; i; ) {
        if (i.matches(e))
          return [i];
        i = i.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(t, e) {
      let i = t.nextElementSibling;
      for (; i; ) {
        if (i.matches(e))
          return [i];
        i = i.nextElementSibling;
      }
      return [];
    },
    focusableChildren(t) {
      const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((i) => `${i}:not([tabindex^="-"])`).join(",");
      return this.find(e, t).filter((i) => !bA(i) && Id(i));
    },
    getSelectorFromElement(t) {
      const e = Ew(t);
      return e && et.findOne(e) ? e : null;
    },
    getElementFromSelector(t) {
      const e = Ew(t);
      return e ? et.findOne(e) : null;
    },
    getMultipleElementsFromSelector(t) {
      const e = Ew(t);
      return e ? et.find(e) : [];
    }
  }, _y = (t, e = "hide") => {
    const i = `click.dismiss${t.EVENT_KEY}`, r = t.NAME;
    Ee.on(document, i, `[data-bs-dismiss="${r}"]`, function(n) {
      if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), bA(this))
        return;
      const s = et.getElementFromSelector(this) || this.closest(`.${r}`);
      t.getOrCreateInstance(s)[e]();
    });
  }, mH = "alert", EH = "bs.alert", $k = `.${EH}`, yH = `close${$k}`, BH = `closed${$k}`, wH = "fade", CH = "show";
  class Gg extends io {
    // Getters
    static get NAME() {
      return mH;
    }
    // Public
    close() {
      if (Ee.trigger(this._element, yH).defaultPrevented)
        return;
      this._element.classList.remove(CH);
      const i = this._element.classList.contains(wH);
      this._queueCallback(() => this._destroyElement(), this._element, i);
    }
    // Private
    _destroyElement() {
      this._element.remove(), Ee.trigger(this._element, BH), this.dispose();
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = Gg.getOrCreateInstance(this);
        if (typeof e == "string") {
          if (i[e] === void 0 || e.startsWith("_") || e === "constructor")
            throw new TypeError(`No method named "${e}"`);
          i[e](this);
        }
      });
    }
  }
  _y(Gg, "close");
  ms(Gg);
  const bH = "button", MH = "bs.button", IH = `.${MH}`, vH = ".data-api", xH = "active", XQ = '[data-bs-toggle="button"]', QH = `click${IH}${vH}`;
  class jg extends io {
    // Getters
    static get NAME() {
      return bH;
    }
    // Public
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle(xH));
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = jg.getOrCreateInstance(this);
        e === "toggle" && i[e]();
      });
    }
  }
  Ee.on(document, QH, XQ, (t) => {
    t.preventDefault();
    const e = t.target.closest(XQ);
    jg.getOrCreateInstance(e).toggle();
  });
  ms(jg);
  const FH = "swipe", vd = ".bs.swipe", SH = `touchstart${vd}`, DH = `touchmove${vd}`, TH = `touchend${vd}`, RH = `pointerdown${vd}`, _H = `pointerup${vd}`, kH = "touch", YH = "pen", NH = "pointer-event", UH = 40, LH = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  }, zH = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)"
  };
  class rE extends Og {
    constructor(e, i) {
      super(), this._element = e, !(!e || !rE.isSupported()) && (this._config = this._getConfig(i), this._deltaX = 0, this._supportPointerEvents = !!window.PointerEvent, this._initEvents());
    }
    // Getters
    static get Default() {
      return LH;
    }
    static get DefaultType() {
      return zH;
    }
    static get NAME() {
      return FH;
    }
    // Public
    dispose() {
      Ee.off(this._element, vd);
    }
    // Private
    _start(e) {
      if (!this._supportPointerEvents) {
        this._deltaX = e.touches[0].clientX;
        return;
      }
      this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX);
    }
    _end(e) {
      this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), mn(this._config.endCallback);
    }
    _move(e) {
      this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const e = Math.abs(this._deltaX);
      if (e <= UH)
        return;
      const i = e / this._deltaX;
      this._deltaX = 0, i && mn(i > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      this._supportPointerEvents ? (Ee.on(this._element, RH, (e) => this._start(e)), Ee.on(this._element, _H, (e) => this._end(e)), this._element.classList.add(NH)) : (Ee.on(this._element, SH, (e) => this._start(e)), Ee.on(this._element, DH, (e) => this._move(e)), Ee.on(this._element, TH, (e) => this._end(e)));
    }
    _eventIsPointerPenTouch(e) {
      return this._supportPointerEvents && (e.pointerType === YH || e.pointerType === kH);
    }
    // Static
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
  }
  const PH = "carousel", OH = "bs.carousel", UA = `.${OH}`, eY = ".data-api", GH = "ArrowLeft", jH = "ArrowRight", HH = 500, Xd = "next", mc = "prev", Oc = "left", Zp = "right", JH = `slide${UA}`, yw = `slid${UA}`, VH = `keydown${UA}`, WH = `mouseenter${UA}`, KH = `mouseleave${UA}`, XH = `dragstart${UA}`, ZH = `load${UA}${eY}`, qH = `click${UA}${eY}`, tY = "carousel", Gf = "active", $H = "slide", e8 = "carousel-item-end", t8 = "carousel-item-start", i8 = "carousel-item-next", r8 = "carousel-item-prev", iY = ".active", rY = ".carousel-item", n8 = iY + rY, s8 = ".carousel-item img", o8 = ".carousel-indicators", a8 = "[data-bs-slide], [data-bs-slide-to]", A8 = '[data-bs-ride="carousel"]', l8 = {
    [GH]: Zp,
    [jH]: Oc
  }, c8 = {
    interval: 5e3,
    keyboard: !0,
    pause: "hover",
    ride: !1,
    touch: !0,
    wrap: !0
  }, u8 = {
    interval: "(number|boolean)",
    // TODO:v6 remove boolean support
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean"
  };
  class xd extends io {
    constructor(e, i) {
      super(e, i), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = et.findOne(o8, this._element), this._addEventListeners(), this._config.ride === tY && this.cycle();
    }
    // Getters
    static get Default() {
      return c8;
    }
    static get DefaultType() {
      return u8;
    }
    static get NAME() {
      return PH;
    }
    // Public
    next() {
      this._slide(Xd);
    }
    nextWhenVisible() {
      !document.hidden && Id(this._element) && this.next();
    }
    prev() {
      this._slide(mc);
    }
    pause() {
      this._isSliding && Gk(this._element), this._clearInterval();
    }
    cycle() {
      this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      if (this._config.ride) {
        if (this._isSliding) {
          Ee.one(this._element, yw, () => this.cycle());
          return;
        }
        this.cycle();
      }
    }
    to(e) {
      const i = this._getItems();
      if (e > i.length - 1 || e < 0)
        return;
      if (this._isSliding) {
        Ee.one(this._element, yw, () => this.to(e));
        return;
      }
      const r = this._getItemIndex(this._getActive());
      if (r === e)
        return;
      const n = e > r ? Xd : mc;
      this._slide(n, i[e]);
    }
    dispose() {
      this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
    }
    // Private
    _configAfterMerge(e) {
      return e.defaultInterval = e.interval, e;
    }
    _addEventListeners() {
      this._config.keyboard && Ee.on(this._element, VH, (e) => this._keydown(e)), this._config.pause === "hover" && (Ee.on(this._element, WH, () => this.pause()), Ee.on(this._element, KH, () => this._maybeEnableCycle())), this._config.touch && rE.isSupported() && this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      for (const r of et.find(s8, this._element))
        Ee.on(r, XH, (n) => n.preventDefault());
      const i = {
        leftCallback: () => this._slide(this._directionToOrder(Oc)),
        rightCallback: () => this._slide(this._directionToOrder(Zp)),
        endCallback: () => {
          this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), HH + this._config.interval));
        }
      };
      this._swipeHelper = new rE(this._element, i);
    }
    _keydown(e) {
      if (/input|textarea/i.test(e.target.tagName))
        return;
      const i = l8[e.key];
      i && (e.preventDefault(), this._slide(this._directionToOrder(i)));
    }
    _getItemIndex(e) {
      return this._getItems().indexOf(e);
    }
    _setActiveIndicatorElement(e) {
      if (!this._indicatorsElement)
        return;
      const i = et.findOne(iY, this._indicatorsElement);
      i.classList.remove(Gf), i.removeAttribute("aria-current");
      const r = et.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement);
      r && (r.classList.add(Gf), r.setAttribute("aria-current", "true"));
    }
    _updateInterval() {
      const e = this._activeElement || this._getActive();
      if (!e)
        return;
      const i = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
      this._config.interval = i || this._config.defaultInterval;
    }
    _slide(e, i = null) {
      if (this._isSliding)
        return;
      const r = this._getActive(), n = e === Xd, s = i || gI(this._getItems(), r, n, this._config.wrap);
      if (s === r)
        return;
      const o = this._getItemIndex(s), a = (h) => Ee.trigger(this._element, h, {
        relatedTarget: s,
        direction: this._orderToDirection(e),
        from: this._getItemIndex(r),
        to: o
      });
      if (a(JH).defaultPrevented || !r || !s)
        return;
      const l = !!this._interval;
      this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
      const c = n ? t8 : e8, u = n ? i8 : r8;
      s.classList.add(u), Pg(s), r.classList.add(c), s.classList.add(c);
      const d = () => {
        s.classList.remove(c, u), s.classList.add(Gf), r.classList.remove(Gf, u, c), this._isSliding = !1, a(yw);
      };
      this._queueCallback(d, r, this._isAnimated()), l && this.cycle();
    }
    _isAnimated() {
      return this._element.classList.contains($H);
    }
    _getActive() {
      return et.findOne(n8, this._element);
    }
    _getItems() {
      return et.find(rY, this._element);
    }
    _clearInterval() {
      this._interval && (clearInterval(this._interval), this._interval = null);
    }
    _directionToOrder(e) {
      return us() ? e === Oc ? mc : Xd : e === Oc ? Xd : mc;
    }
    _orderToDirection(e) {
      return us() ? e === mc ? Oc : Zp : e === mc ? Zp : Oc;
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = xd.getOrCreateInstance(this, e);
        if (typeof e == "number") {
          i.to(e);
          return;
        }
        if (typeof e == "string") {
          if (i[e] === void 0 || e.startsWith("_") || e === "constructor")
            throw new TypeError(`No method named "${e}"`);
          i[e]();
        }
      });
    }
  }
  Ee.on(document, qH, a8, function(t) {
    const e = et.getElementFromSelector(this);
    if (!e || !e.classList.contains(tY))
      return;
    t.preventDefault();
    const i = xd.getOrCreateInstance(e), r = this.getAttribute("data-bs-slide-to");
    if (r) {
      i.to(r), i._maybeEnableCycle();
      return;
    }
    if (ua.getDataAttribute(this, "slide") === "next") {
      i.next(), i._maybeEnableCycle();
      return;
    }
    i.prev(), i._maybeEnableCycle();
  });
  Ee.on(window, ZH, () => {
    const t = et.find(A8);
    for (const e of t)
      xd.getOrCreateInstance(e);
  });
  ms(xd);
  const d8 = "collapse", h8 = "bs.collapse", Hg = `.${h8}`, g8 = ".data-api", f8 = `show${Hg}`, p8 = `shown${Hg}`, m8 = `hide${Hg}`, E8 = `hidden${Hg}`, y8 = `click${Hg}${g8}`, Bw = "show", ou = "collapse", jf = "collapsing", B8 = "collapsed", w8 = `:scope .${ou} .${ou}`, C8 = "collapse-horizontal", b8 = "width", M8 = "height", I8 = ".collapse.show, .collapse.collapsing", KC = '[data-bs-toggle="collapse"]', v8 = {
    parent: null,
    toggle: !0
  }, x8 = {
    parent: "(null|element)",
    toggle: "boolean"
  };
  class Zu extends io {
    constructor(e, i) {
      super(e, i), this._isTransitioning = !1, this._triggerArray = [];
      const r = et.find(KC);
      for (const n of r) {
        const s = et.getSelectorFromElement(n), o = et.find(s).filter((a) => a === this._element);
        s !== null && o.length && this._triggerArray.push(n);
      }
      this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
    }
    // Getters
    static get Default() {
      return v8;
    }
    static get DefaultType() {
      return x8;
    }
    static get NAME() {
      return d8;
    }
    // Public
    toggle() {
      this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (this._isTransitioning || this._isShown())
        return;
      let e = [];
      if (this._config.parent && (e = this._getFirstLevelChildren(I8).filter((a) => a !== this._element).map((a) => Zu.getOrCreateInstance(a, {
        toggle: !1
      }))), e.length && e[0]._isTransitioning || Ee.trigger(this._element, f8).defaultPrevented)
        return;
      for (const a of e)
        a.hide();
      const r = this._getDimension();
      this._element.classList.remove(ou), this._element.classList.add(jf), this._element.style[r] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
      const n = () => {
        this._isTransitioning = !1, this._element.classList.remove(jf), this._element.classList.add(ou, Bw), this._element.style[r] = "", Ee.trigger(this._element, p8);
      }, o = `scroll${r[0].toUpperCase() + r.slice(1)}`;
      this._queueCallback(n, this._element, !0), this._element.style[r] = `${this._element[o]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown() || Ee.trigger(this._element, m8).defaultPrevented)
        return;
      const i = this._getDimension();
      this._element.style[i] = `${this._element.getBoundingClientRect()[i]}px`, Pg(this._element), this._element.classList.add(jf), this._element.classList.remove(ou, Bw);
      for (const n of this._triggerArray) {
        const s = et.getElementFromSelector(n);
        s && !this._isShown(s) && this._addAriaAndCollapsedClass([n], !1);
      }
      this._isTransitioning = !0;
      const r = () => {
        this._isTransitioning = !1, this._element.classList.remove(jf), this._element.classList.add(ou), Ee.trigger(this._element, E8);
      };
      this._element.style[i] = "", this._queueCallback(r, this._element, !0);
    }
    _isShown(e = this._element) {
      return e.classList.contains(Bw);
    }
    // Private
    _configAfterMerge(e) {
      return e.toggle = !!e.toggle, e.parent = CA(e.parent), e;
    }
    _getDimension() {
      return this._element.classList.contains(C8) ? b8 : M8;
    }
    _initializeChildren() {
      if (!this._config.parent)
        return;
      const e = this._getFirstLevelChildren(KC);
      for (const i of e) {
        const r = et.getElementFromSelector(i);
        r && this._addAriaAndCollapsedClass([i], this._isShown(r));
      }
    }
    _getFirstLevelChildren(e) {
      const i = et.find(w8, this._config.parent);
      return et.find(e, this._config.parent).filter((r) => !i.includes(r));
    }
    _addAriaAndCollapsedClass(e, i) {
      if (e.length)
        for (const r of e)
          r.classList.toggle(B8, !i), r.setAttribute("aria-expanded", i);
    }
    // Static
    static jQueryInterface(e) {
      const i = {};
      return typeof e == "string" && /show|hide/.test(e) && (i.toggle = !1), this.each(function() {
        const r = Zu.getOrCreateInstance(this, i);
        if (typeof e == "string") {
          if (typeof r[e] > "u")
            throw new TypeError(`No method named "${e}"`);
          r[e]();
        }
      });
    }
  }
  Ee.on(document, y8, KC, function(t) {
    (t.target.tagName === "A" || t.delegateTarget && t.delegateTarget.tagName === "A") && t.preventDefault();
    for (const e of et.getMultipleElementsFromSelector(this))
      Zu.getOrCreateInstance(e, {
        toggle: !1
      }).toggle();
  });
  ms(Zu);
  const ZQ = "dropdown", Q8 = "bs.dropdown", ql = `.${Q8}`, pI = ".data-api", F8 = "Escape", qQ = "Tab", S8 = "ArrowUp", $Q = "ArrowDown", D8 = 2, T8 = `hide${ql}`, R8 = `hidden${ql}`, _8 = `show${ql}`, k8 = `shown${ql}`, nY = `click${ql}${pI}`, sY = `keydown${ql}${pI}`, Y8 = `keyup${ql}${pI}`, Gc = "show", N8 = "dropup", U8 = "dropend", L8 = "dropstart", z8 = "dropup-center", P8 = "dropdown-center", cl = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', O8 = `${cl}.${Gc}`, qp = ".dropdown-menu", G8 = ".navbar", j8 = ".navbar-nav", H8 = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", J8 = us() ? "top-end" : "top-start", V8 = us() ? "top-start" : "top-end", W8 = us() ? "bottom-end" : "bottom-start", K8 = us() ? "bottom-start" : "bottom-end", X8 = us() ? "left-start" : "right-start", Z8 = us() ? "right-start" : "left-start", q8 = "top", $8 = "bottom", e5 = {
    autoClose: !0,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle"
  }, t5 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
  };
  class Gs extends io {
    constructor(e, i) {
      super(e, i), this._popper = null, this._parent = this._element.parentNode, this._menu = et.next(this._element, qp)[0] || et.prev(this._element, qp)[0] || et.findOne(qp, this._parent), this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
      return e5;
    }
    static get DefaultType() {
      return t5;
    }
    static get NAME() {
      return ZQ;
    }
    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (bA(this._element) || this._isShown())
        return;
      const e = {
        relatedTarget: this._element
      };
      if (!Ee.trigger(this._element, _8, e).defaultPrevented) {
        if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(j8))
          for (const r of [].concat(...document.body.children))
            Ee.on(r, "mouseover", iE);
        this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Gc), this._element.classList.add(Gc), Ee.trigger(this._element, k8, e);
      }
    }
    hide() {
      if (bA(this._element) || !this._isShown())
        return;
      const e = {
        relatedTarget: this._element
      };
      this._completeHide(e);
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
    }
    // Private
    _completeHide(e) {
      if (!Ee.trigger(this._element, T8, e).defaultPrevented) {
        if ("ontouchstart" in document.documentElement)
          for (const r of [].concat(...document.body.children))
            Ee.off(r, "mouseover", iE);
        this._popper && this._popper.destroy(), this._menu.classList.remove(Gc), this._element.classList.remove(Gc), this._element.setAttribute("aria-expanded", "false"), ua.removeDataAttribute(this._menu, "popper"), Ee.trigger(this._element, R8, e);
      }
    }
    _getConfig(e) {
      if (e = super._getConfig(e), typeof e.reference == "object" && !ca(e.reference) && typeof e.reference.getBoundingClientRect != "function")
        throw new TypeError(`${ZQ.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      return e;
    }
    _createPopper() {
      if (typeof Pk > "u")
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
      let e = this._element;
      this._config.reference === "parent" ? e = this._parent : ca(this._config.reference) ? e = CA(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference);
      const i = this._getPopperConfig();
      this._popper = hI(e, this._menu, i);
    }
    _isShown() {
      return this._menu.classList.contains(Gc);
    }
    _getPlacement() {
      const e = this._parent;
      if (e.classList.contains(U8))
        return X8;
      if (e.classList.contains(L8))
        return Z8;
      if (e.classList.contains(z8))
        return q8;
      if (e.classList.contains(P8))
        return $8;
      const i = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      return e.classList.contains(N8) ? i ? V8 : J8 : i ? K8 : W8;
    }
    _detectNavbar() {
      return this._element.closest(G8) !== null;
    }
    _getOffset() {
      const {
        offset: e
      } = this._config;
      return typeof e == "string" ? e.split(",").map((i) => Number.parseInt(i, 10)) : typeof e == "function" ? (i) => e(i, this._element) : e;
    }
    _getPopperConfig() {
      const e = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      return (this._inNavbar || this._config.display === "static") && (ua.setDataAttribute(this._menu, "popper", "static"), e.modifiers = [{
        name: "applyStyles",
        enabled: !1
      }]), {
        ...e,
        ...mn(this._config.popperConfig, [void 0, e])
      };
    }
    _selectMenuItem({
      key: e,
      target: i
    }) {
      const r = et.find(H8, this._menu).filter((n) => Id(n));
      r.length && gI(r, i, e === $Q, !r.includes(i)).focus();
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = Gs.getOrCreateInstance(this, e);
        if (typeof e == "string") {
          if (typeof i[e] > "u")
            throw new TypeError(`No method named "${e}"`);
          i[e]();
        }
      });
    }
    static clearMenus(e) {
      if (e.button === D8 || e.type === "keyup" && e.key !== qQ)
        return;
      const i = et.find(O8);
      for (const r of i) {
        const n = Gs.getInstance(r);
        if (!n || n._config.autoClose === !1)
          continue;
        const s = e.composedPath(), o = s.includes(n._menu);
        if (s.includes(n._element) || n._config.autoClose === "inside" && !o || n._config.autoClose === "outside" && o || n._menu.contains(e.target) && (e.type === "keyup" && e.key === qQ || /input|select|option|textarea|form/i.test(e.target.tagName)))
          continue;
        const a = {
          relatedTarget: n._element
        };
        e.type === "click" && (a.clickEvent = e), n._completeHide(a);
      }
    }
    static dataApiKeydownHandler(e) {
      const i = /input|textarea/i.test(e.target.tagName), r = e.key === F8, n = [S8, $Q].includes(e.key);
      if (!n && !r || i && !r)
        return;
      e.preventDefault();
      const s = this.matches(cl) ? this : et.prev(this, cl)[0] || et.next(this, cl)[0] || et.findOne(cl, e.delegateTarget.parentNode), o = Gs.getOrCreateInstance(s);
      if (n) {
        e.stopPropagation(), o.show(), o._selectMenuItem(e);
        return;
      }
      o._isShown() && (e.stopPropagation(), o.hide(), s.focus());
    }
  }
  Ee.on(document, sY, cl, Gs.dataApiKeydownHandler);
  Ee.on(document, sY, qp, Gs.dataApiKeydownHandler);
  Ee.on(document, nY, Gs.clearMenus);
  Ee.on(document, Y8, Gs.clearMenus);
  Ee.on(document, nY, cl, function(t) {
    t.preventDefault(), Gs.getOrCreateInstance(this).toggle();
  });
  ms(Gs);
  const oY = "backdrop", i5 = "fade", eF = "show", tF = `mousedown.bs.${oY}`, r5 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: !1,
    isVisible: !0,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body"
    // give the choice to place backdrop under different elements
  }, n5 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
  };
  class aY extends Og {
    constructor(e) {
      super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null;
    }
    // Getters
    static get Default() {
      return r5;
    }
    static get DefaultType() {
      return n5;
    }
    static get NAME() {
      return oY;
    }
    // Public
    show(e) {
      if (!this._config.isVisible) {
        mn(e);
        return;
      }
      this._append();
      const i = this._getElement();
      this._config.isAnimated && Pg(i), i.classList.add(eF), this._emulateAnimation(() => {
        mn(e);
      });
    }
    hide(e) {
      if (!this._config.isVisible) {
        mn(e);
        return;
      }
      this._getElement().classList.remove(eF), this._emulateAnimation(() => {
        this.dispose(), mn(e);
      });
    }
    dispose() {
      this._isAppended && (Ee.off(this._element, tF), this._element.remove(), this._isAppended = !1);
    }
    // Private
    _getElement() {
      if (!this._element) {
        const e = document.createElement("div");
        e.className = this._config.className, this._config.isAnimated && e.classList.add(i5), this._element = e;
      }
      return this._element;
    }
    _configAfterMerge(e) {
      return e.rootElement = CA(e.rootElement), e;
    }
    _append() {
      if (this._isAppended)
        return;
      const e = this._getElement();
      this._config.rootElement.append(e), Ee.on(e, tF, () => {
        mn(this._config.clickCallback);
      }), this._isAppended = !0;
    }
    _emulateAnimation(e) {
      Jk(e, this._getElement(), this._config.isAnimated);
    }
  }
  const s5 = "focustrap", o5 = "bs.focustrap", nE = `.${o5}`, a5 = `focusin${nE}`, A5 = `keydown.tab${nE}`, l5 = "Tab", c5 = "forward", iF = "backward", u5 = {
    autofocus: !0,
    trapElement: null
    // The element to trap focus inside of
  }, d5 = {
    autofocus: "boolean",
    trapElement: "element"
  };
  class AY extends Og {
    constructor(e) {
      super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
      return u5;
    }
    static get DefaultType() {
      return d5;
    }
    static get NAME() {
      return s5;
    }
    // Public
    activate() {
      this._isActive || (this._config.autofocus && this._config.trapElement.focus(), Ee.off(document, nE), Ee.on(document, a5, (e) => this._handleFocusin(e)), Ee.on(document, A5, (e) => this._handleKeydown(e)), this._isActive = !0);
    }
    deactivate() {
      this._isActive && (this._isActive = !1, Ee.off(document, nE));
    }
    // Private
    _handleFocusin(e) {
      const {
        trapElement: i
      } = this._config;
      if (e.target === document || e.target === i || i.contains(e.target))
        return;
      const r = et.focusableChildren(i);
      r.length === 0 ? i.focus() : this._lastTabNavDirection === iF ? r[r.length - 1].focus() : r[0].focus();
    }
    _handleKeydown(e) {
      e.key === l5 && (this._lastTabNavDirection = e.shiftKey ? iF : c5);
    }
  }
  const rF = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", nF = ".sticky-top", Hf = "padding-right", sF = "margin-right";
  class XC {
    constructor() {
      this._element = document.body;
    }
    // Public
    getWidth() {
      const e = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - e);
    }
    hide() {
      const e = this.getWidth();
      this._disableOverFlow(), this._setElementAttributes(this._element, Hf, (i) => i + e), this._setElementAttributes(rF, Hf, (i) => i + e), this._setElementAttributes(nF, sF, (i) => i - e);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Hf), this._resetElementAttributes(rF, Hf), this._resetElementAttributes(nF, sF);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
    }
    _setElementAttributes(e, i, r) {
      const n = this.getWidth(), s = (o) => {
        if (o !== this._element && window.innerWidth > o.clientWidth + n)
          return;
        this._saveInitialAttribute(o, i);
        const a = window.getComputedStyle(o).getPropertyValue(i);
        o.style.setProperty(i, `${r(Number.parseFloat(a))}px`);
      };
      this._applyManipulationCallback(e, s);
    }
    _saveInitialAttribute(e, i) {
      const r = e.style.getPropertyValue(i);
      r && ua.setDataAttribute(e, i, r);
    }
    _resetElementAttributes(e, i) {
      const r = (n) => {
        const s = ua.getDataAttribute(n, i);
        if (s === null) {
          n.style.removeProperty(i);
          return;
        }
        ua.removeDataAttribute(n, i), n.style.setProperty(i, s);
      };
      this._applyManipulationCallback(e, r);
    }
    _applyManipulationCallback(e, i) {
      if (ca(e)) {
        i(e);
        return;
      }
      for (const r of et.find(e, this._element))
        i(r);
    }
  }
  const h5 = "modal", g5 = "bs.modal", ds = `.${g5}`, f5 = ".data-api", p5 = "Escape", m5 = `hide${ds}`, E5 = `hidePrevented${ds}`, lY = `hidden${ds}`, cY = `show${ds}`, y5 = `shown${ds}`, B5 = `resize${ds}`, w5 = `click.dismiss${ds}`, C5 = `mousedown.dismiss${ds}`, b5 = `keydown.dismiss${ds}`, M5 = `click${ds}${f5}`, oF = "modal-open", I5 = "fade", aF = "show", ww = "modal-static", v5 = ".modal.show", x5 = ".modal-dialog", Q5 = ".modal-body", F5 = '[data-bs-toggle="modal"]', S5 = {
    backdrop: !0,
    focus: !0,
    keyboard: !0
  }, D5 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
  };
  class Ul extends io {
    constructor(e, i) {
      super(e, i), this._dialog = et.findOne(x5, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new XC(), this._addEventListeners();
    }
    // Getters
    static get Default() {
      return S5;
    }
    static get DefaultType() {
      return D5;
    }
    static get NAME() {
      return h5;
    }
    // Public
    toggle(e) {
      return this._isShown ? this.hide() : this.show(e);
    }
    show(e) {
      this._isShown || this._isTransitioning || Ee.trigger(this._element, cY, {
        relatedTarget: e
      }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(oF), this._adjustDialog(), this._backdrop.show(() => this._showElement(e)));
    }
    hide() {
      !this._isShown || this._isTransitioning || Ee.trigger(this._element, m5).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(aF), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()));
    }
    dispose() {
      Ee.off(window, ds), Ee.off(this._dialog, ds), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
      return new aY({
        isVisible: !!this._config.backdrop,
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new AY({
        trapElement: this._element
      });
    }
    _showElement(e) {
      document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
      const i = et.findOne(Q5, this._dialog);
      i && (i.scrollTop = 0), Pg(this._element), this._element.classList.add(aF);
      const r = () => {
        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, Ee.trigger(this._element, y5, {
          relatedTarget: e
        });
      };
      this._queueCallback(r, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      Ee.on(this._element, b5, (e) => {
        if (e.key === p5) {
          if (this._config.keyboard) {
            this.hide();
            return;
          }
          this._triggerBackdropTransition();
        }
      }), Ee.on(window, B5, () => {
        this._isShown && !this._isTransitioning && this._adjustDialog();
      }), Ee.on(this._element, C5, (e) => {
        Ee.one(this._element, w5, (i) => {
          if (!(this._element !== e.target || this._element !== i.target)) {
            if (this._config.backdrop === "static") {
              this._triggerBackdropTransition();
              return;
            }
            this._config.backdrop && this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
        document.body.classList.remove(oF), this._resetAdjustments(), this._scrollBar.reset(), Ee.trigger(this._element, lY);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(I5);
    }
    _triggerBackdropTransition() {
      if (Ee.trigger(this._element, E5).defaultPrevented)
        return;
      const i = this._element.scrollHeight > document.documentElement.clientHeight, r = this._element.style.overflowY;
      r === "hidden" || this._element.classList.contains(ww) || (i || (this._element.style.overflowY = "hidden"), this._element.classList.add(ww), this._queueCallback(() => {
        this._element.classList.remove(ww), this._queueCallback(() => {
          this._element.style.overflowY = r;
        }, this._dialog);
      }, this._dialog), this._element.focus());
    }
    /**
     * The following methods are used to handle overflowing modals
     */
    _adjustDialog() {
      const e = this._element.scrollHeight > document.documentElement.clientHeight, i = this._scrollBar.getWidth(), r = i > 0;
      if (r && !e) {
        const n = us() ? "paddingLeft" : "paddingRight";
        this._element.style[n] = `${i}px`;
      }
      if (!r && e) {
        const n = us() ? "paddingRight" : "paddingLeft";
        this._element.style[n] = `${i}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }
    // Static
    static jQueryInterface(e, i) {
      return this.each(function() {
        const r = Ul.getOrCreateInstance(this, e);
        if (typeof e == "string") {
          if (typeof r[e] > "u")
            throw new TypeError(`No method named "${e}"`);
          r[e](i);
        }
      });
    }
  }
  Ee.on(document, M5, F5, function(t) {
    const e = et.getElementFromSelector(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), Ee.one(e, cY, (n) => {
      n.defaultPrevented || Ee.one(e, lY, () => {
        Id(this) && this.focus();
      });
    });
    const i = et.findOne(v5);
    i && Ul.getInstance(i).hide(), Ul.getOrCreateInstance(e).toggle(this);
  });
  _y(Ul);
  ms(Ul);
  const T5 = "offcanvas", R5 = "bs.offcanvas", Ua = `.${R5}`, uY = ".data-api", _5 = `load${Ua}${uY}`, k5 = "Escape", AF = "show", lF = "showing", cF = "hiding", Y5 = "offcanvas-backdrop", dY = ".offcanvas.show", N5 = `show${Ua}`, U5 = `shown${Ua}`, L5 = `hide${Ua}`, uF = `hidePrevented${Ua}`, hY = `hidden${Ua}`, z5 = `resize${Ua}`, P5 = `click${Ua}${uY}`, O5 = `keydown.dismiss${Ua}`, G5 = '[data-bs-toggle="offcanvas"]', j5 = {
    backdrop: !0,
    keyboard: !0,
    scroll: !1
  }, H5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean"
  };
  class Ia extends io {
    constructor(e, i) {
      super(e, i), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
    }
    // Getters
    static get Default() {
      return j5;
    }
    static get DefaultType() {
      return H5;
    }
    static get NAME() {
      return T5;
    }
    // Public
    toggle(e) {
      return this._isShown ? this.hide() : this.show(e);
    }
    show(e) {
      if (this._isShown || Ee.trigger(this._element, N5, {
        relatedTarget: e
      }).defaultPrevented)
        return;
      this._isShown = !0, this._backdrop.show(), this._config.scroll || new XC().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(lF);
      const r = () => {
        (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(AF), this._element.classList.remove(lF), Ee.trigger(this._element, U5, {
          relatedTarget: e
        });
      };
      this._queueCallback(r, this._element, !0);
    }
    hide() {
      if (!this._isShown || Ee.trigger(this._element, L5).defaultPrevented)
        return;
      this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(cF), this._backdrop.hide();
      const i = () => {
        this._element.classList.remove(AF, cF), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new XC().reset(), Ee.trigger(this._element, hY);
      };
      this._queueCallback(i, this._element, !0);
    }
    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    // Private
    _initializeBackDrop() {
      const e = () => {
        if (this._config.backdrop === "static") {
          Ee.trigger(this._element, uF);
          return;
        }
        this.hide();
      }, i = !!this._config.backdrop;
      return new aY({
        className: Y5,
        isVisible: i,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: i ? e : null
      });
    }
    _initializeFocusTrap() {
      return new AY({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      Ee.on(this._element, O5, (e) => {
        if (e.key === k5) {
          if (this._config.keyboard) {
            this.hide();
            return;
          }
          Ee.trigger(this._element, uF);
        }
      });
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = Ia.getOrCreateInstance(this, e);
        if (typeof e == "string") {
          if (i[e] === void 0 || e.startsWith("_") || e === "constructor")
            throw new TypeError(`No method named "${e}"`);
          i[e](this);
        }
      });
    }
  }
  Ee.on(document, P5, G5, function(t) {
    const e = et.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), bA(this))
      return;
    Ee.one(e, hY, () => {
      Id(this) && this.focus();
    });
    const i = et.findOne(dY);
    i && i !== e && Ia.getInstance(i).hide(), Ia.getOrCreateInstance(e).toggle(this);
  });
  Ee.on(window, _5, () => {
    for (const t of et.find(dY))
      Ia.getOrCreateInstance(t).show();
  });
  Ee.on(window, z5, () => {
    for (const t of et.find("[aria-modal][class*=show][class*=offcanvas-]"))
      getComputedStyle(t).position !== "fixed" && Ia.getOrCreateInstance(t).hide();
  });
  _y(Ia);
  ms(Ia);
  const J5 = /^aria-[\w-]*$/i, gY = {
    // Global attributes allowed on any supplied element below.
    "*": ["class", "dir", "id", "lang", "role", J5],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    dd: [],
    div: [],
    dl: [],
    dt: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  }, V5 = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), W5 = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, K5 = (t, e) => {
    const i = t.nodeName.toLowerCase();
    return e.includes(i) ? V5.has(i) ? !!W5.test(t.nodeValue) : !0 : e.filter((r) => r instanceof RegExp).some((r) => r.test(i));
  };
  function X5(t, e, i) {
    if (!t.length)
      return t;
    if (i && typeof i == "function")
      return i(t);
    const n = new window.DOMParser().parseFromString(t, "text/html"), s = [].concat(...n.body.querySelectorAll("*"));
    for (const o of s) {
      const a = o.nodeName.toLowerCase();
      if (!Object.keys(e).includes(a)) {
        o.remove();
        continue;
      }
      const A = [].concat(...o.attributes), l = [].concat(e["*"] || [], e[a] || []);
      for (const c of A)
        K5(c, l) || o.removeAttribute(c.nodeName);
    }
    return n.body.innerHTML;
  }
  const Z5 = "TemplateFactory", q5 = {
    allowList: gY,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: "",
    html: !1,
    sanitize: !0,
    sanitizeFn: null,
    template: "<div></div>"
  }, $5 = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string"
  }, eJ = {
    entry: "(string|element|function|null)",
    selector: "(string|element)"
  };
  class tJ extends Og {
    constructor(e) {
      super(), this._config = this._getConfig(e);
    }
    // Getters
    static get Default() {
      return q5;
    }
    static get DefaultType() {
      return $5;
    }
    static get NAME() {
      return Z5;
    }
    // Public
    getContent() {
      return Object.values(this._config.content).map((e) => this._resolvePossibleFunction(e)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(e) {
      return this._checkContent(e), this._config.content = {
        ...this._config.content,
        ...e
      }, this;
    }
    toHtml() {
      const e = document.createElement("div");
      e.innerHTML = this._maybeSanitize(this._config.template);
      for (const [n, s] of Object.entries(this._config.content))
        this._setContent(e, s, n);
      const i = e.children[0], r = this._resolvePossibleFunction(this._config.extraClass);
      return r && i.classList.add(...r.split(" ")), i;
    }
    // Private
    _typeCheckConfig(e) {
      super._typeCheckConfig(e), this._checkContent(e.content);
    }
    _checkContent(e) {
      for (const [i, r] of Object.entries(e))
        super._typeCheckConfig({
          selector: i,
          entry: r
        }, eJ);
    }
    _setContent(e, i, r) {
      const n = et.findOne(r, e);
      if (n) {
        if (i = this._resolvePossibleFunction(i), !i) {
          n.remove();
          return;
        }
        if (ca(i)) {
          this._putElementInTemplate(CA(i), n);
          return;
        }
        if (this._config.html) {
          n.innerHTML = this._maybeSanitize(i);
          return;
        }
        n.textContent = i;
      }
    }
    _maybeSanitize(e) {
      return this._config.sanitize ? X5(e, this._config.allowList, this._config.sanitizeFn) : e;
    }
    _resolvePossibleFunction(e) {
      return mn(e, [void 0, this]);
    }
    _putElementInTemplate(e, i) {
      if (this._config.html) {
        i.innerHTML = "", i.append(e);
        return;
      }
      i.textContent = e.textContent;
    }
  }
  const iJ = "tooltip", rJ = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), Cw = "fade", nJ = "modal", Jf = "show", sJ = ".tooltip-inner", dF = `.${nJ}`, hF = "hide.bs.modal", Zd = "hover", bw = "focus", oJ = "click", aJ = "manual", AJ = "hide", lJ = "hidden", cJ = "show", uJ = "shown", dJ = "inserted", hJ = "click", gJ = "focusin", fJ = "focusout", pJ = "mouseenter", mJ = "mouseleave", EJ = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: us() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: us() ? "right" : "left"
  }, yJ = {
    allowList: gY,
    animation: !0,
    boundary: "clippingParents",
    container: !1,
    customClass: "",
    delay: 0,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    html: !1,
    offset: [0, 6],
    placement: "top",
    popperConfig: null,
    sanitize: !0,
    sanitizeFn: null,
    selector: !1,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: "",
    trigger: "hover focus"
  }, BJ = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string"
  };
  class $l extends io {
    constructor(e, i) {
      if (typeof Pk > "u")
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
      super(e, i), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
    }
    // Getters
    static get Default() {
      return yJ;
    }
    static get DefaultType() {
      return BJ;
    }
    static get NAME() {
      return iJ;
    }
    // Public
    enable() {
      this._isEnabled = !0;
    }
    disable() {
      this._isEnabled = !1;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (this._isEnabled) {
        if (this._isShown()) {
          this._leave();
          return;
        }
        this._enter();
      }
    }
    dispose() {
      clearTimeout(this._timeout), Ee.off(this._element.closest(dF), hF, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
    }
    show() {
      if (this._element.style.display === "none")
        throw new Error("Please use show on visible elements");
      if (!(this._isWithContent() && this._isEnabled))
        return;
      const e = Ee.trigger(this._element, this.constructor.eventName(cJ)), r = (jk(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
      if (e.defaultPrevented || !r)
        return;
      this._disposePopper();
      const n = this._getTipElement();
      this._element.setAttribute("aria-describedby", n.getAttribute("id"));
      const {
        container: s
      } = this._config;
      if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(n), Ee.trigger(this._element, this.constructor.eventName(dJ))), this._popper = this._createPopper(n), n.classList.add(Jf), "ontouchstart" in document.documentElement)
        for (const a of [].concat(...document.body.children))
          Ee.on(a, "mouseover", iE);
      const o = () => {
        Ee.trigger(this._element, this.constructor.eventName(uJ)), this._isHovered === !1 && this._leave(), this._isHovered = !1;
      };
      this._queueCallback(o, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown() || Ee.trigger(this._element, this.constructor.eventName(AJ)).defaultPrevented)
        return;
      if (this._getTipElement().classList.remove(Jf), "ontouchstart" in document.documentElement)
        for (const n of [].concat(...document.body.children))
          Ee.off(n, "mouseover", iE);
      this._activeTrigger[oJ] = !1, this._activeTrigger[bw] = !1, this._activeTrigger[Zd] = !1, this._isHovered = null;
      const r = () => {
        this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), Ee.trigger(this._element, this.constructor.eventName(lJ)));
      };
      this._queueCallback(r, this.tip, this._isAnimated());
    }
    update() {
      this._popper && this._popper.update();
    }
    // Protected
    _isWithContent() {
      return !!this._getTitle();
    }
    _getTipElement() {
      return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
    }
    _createTipElement(e) {
      const i = this._getTemplateFactory(e).toHtml();
      if (!i)
        return null;
      i.classList.remove(Cw, Jf), i.classList.add(`bs-${this.constructor.NAME}-auto`);
      const r = oH(this.constructor.NAME).toString();
      return i.setAttribute("id", r), this._isAnimated() && i.classList.add(Cw), i;
    }
    setContent(e) {
      this._newContent = e, this._isShown() && (this._disposePopper(), this.show());
    }
    _getTemplateFactory(e) {
      return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new tJ({
        ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content: e,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      }), this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [sJ]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    // Private
    _initializeOnDelegatedTarget(e) {
      return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(Cw);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(Jf);
    }
    _createPopper(e) {
      const i = mn(this._config.placement, [this, e, this._element]), r = EJ[i.toUpperCase()];
      return hI(this._element, e, this._getPopperConfig(r));
    }
    _getOffset() {
      const {
        offset: e
      } = this._config;
      return typeof e == "string" ? e.split(",").map((i) => Number.parseInt(i, 10)) : typeof e == "function" ? (i) => e(i, this._element) : e;
    }
    _resolvePossibleFunction(e) {
      return mn(e, [this._element, this._element]);
    }
    _getPopperConfig(e) {
      const i = {
        placement: e,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: !0,
          phase: "beforeMain",
          fn: (r) => {
            this._getTipElement().setAttribute("data-popper-placement", r.state.placement);
          }
        }]
      };
      return {
        ...i,
        ...mn(this._config.popperConfig, [void 0, i])
      };
    }
    _setListeners() {
      const e = this._config.trigger.split(" ");
      for (const i of e)
        if (i === "click")
          Ee.on(this._element, this.constructor.eventName(hJ), this._config.selector, (r) => {
            this._initializeOnDelegatedTarget(r).toggle();
          });
        else if (i !== aJ) {
          const r = i === Zd ? this.constructor.eventName(pJ) : this.constructor.eventName(gJ), n = i === Zd ? this.constructor.eventName(mJ) : this.constructor.eventName(fJ);
          Ee.on(this._element, r, this._config.selector, (s) => {
            const o = this._initializeOnDelegatedTarget(s);
            o._activeTrigger[s.type === "focusin" ? bw : Zd] = !0, o._enter();
          }), Ee.on(this._element, n, this._config.selector, (s) => {
            const o = this._initializeOnDelegatedTarget(s);
            o._activeTrigger[s.type === "focusout" ? bw : Zd] = o._element.contains(s.relatedTarget), o._leave();
          });
        }
      this._hideModalHandler = () => {
        this._element && this.hide();
      }, Ee.on(this._element.closest(dF), hF, this._hideModalHandler);
    }
    _fixTitle() {
      const e = this._element.getAttribute("title");
      e && (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", e), this._element.setAttribute("data-bs-original-title", e), this._element.removeAttribute("title"));
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = !0;
        return;
      }
      this._isHovered = !0, this._setTimeout(() => {
        this._isHovered && this.show();
      }, this._config.delay.show);
    }
    _leave() {
      this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
        this._isHovered || this.hide();
      }, this._config.delay.hide));
    }
    _setTimeout(e, i) {
      clearTimeout(this._timeout), this._timeout = setTimeout(e, i);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(!0);
    }
    _getConfig(e) {
      const i = ua.getDataAttributes(this._element);
      for (const r of Object.keys(i))
        rJ.has(r) && delete i[r];
      return e = {
        ...i,
        ...typeof e == "object" && e ? e : {}
      }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e;
    }
    _configAfterMerge(e) {
      return e.container = e.container === !1 ? document.body : CA(e.container), typeof e.delay == "number" && (e.delay = {
        show: e.delay,
        hide: e.delay
      }), typeof e.title == "number" && (e.title = e.title.toString()), typeof e.content == "number" && (e.content = e.content.toString()), e;
    }
    _getDelegateConfig() {
      const e = {};
      for (const [i, r] of Object.entries(this._config))
        this.constructor.Default[i] !== r && (e[i] = r);
      return e.selector = !1, e.trigger = "manual", e;
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = $l.getOrCreateInstance(this, e);
        if (typeof e == "string") {
          if (typeof i[e] > "u")
            throw new TypeError(`No method named "${e}"`);
          i[e]();
        }
      });
    }
  }
  ms($l);
  const wJ = "popover", CJ = ".popover-header", bJ = ".popover-body", MJ = {
    ...$l.Default,
    content: "",
    offset: [0, 8],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
  }, IJ = {
    ...$l.DefaultType,
    content: "(null|string|element|function)"
  };
  class ky extends $l {
    // Getters
    static get Default() {
      return MJ;
    }
    static get DefaultType() {
      return IJ;
    }
    static get NAME() {
      return wJ;
    }
    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    // Private
    _getContentForTemplate() {
      return {
        [CJ]: this._getTitle(),
        [bJ]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = ky.getOrCreateInstance(this, e);
        if (typeof e == "string") {
          if (typeof i[e] > "u")
            throw new TypeError(`No method named "${e}"`);
          i[e]();
        }
      });
    }
  }
  ms(ky);
  const vJ = "scrollspy", xJ = "bs.scrollspy", mI = `.${xJ}`, QJ = ".data-api", FJ = `activate${mI}`, gF = `click${mI}`, SJ = `load${mI}${QJ}`, DJ = "dropdown-item", Ec = "active", TJ = '[data-bs-spy="scroll"]', Mw = "[href]", RJ = ".nav, .list-group", fF = ".nav-link", _J = ".nav-item", kJ = ".list-group-item", YJ = `${fF}, ${_J} > ${fF}, ${kJ}`, NJ = ".dropdown", UJ = ".dropdown-toggle", LJ = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "0px 0px -25%",
    smoothScroll: !1,
    target: null,
    threshold: [0.1, 0.5, 1]
  }, zJ = {
    offset: "(number|null)",
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element",
    threshold: "array"
  };
  class Jg extends io {
    constructor(e, i) {
      super(e, i), this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      }, this.refresh();
    }
    // Getters
    static get Default() {
      return LJ;
    }
    static get DefaultType() {
      return zJ;
    }
    static get NAME() {
      return vJ;
    }
    // Public
    refresh() {
      this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
      for (const e of this._observableSections.values())
        this._observer.observe(e);
    }
    dispose() {
      this._observer.disconnect(), super.dispose();
    }
    // Private
    _configAfterMerge(e) {
      return e.target = CA(e.target) || document.body, e.rootMargin = e.offset ? `${e.offset}px 0px -30%` : e.rootMargin, typeof e.threshold == "string" && (e.threshold = e.threshold.split(",").map((i) => Number.parseFloat(i))), e;
    }
    _maybeEnableSmoothScroll() {
      this._config.smoothScroll && (Ee.off(this._config.target, gF), Ee.on(this._config.target, gF, Mw, (e) => {
        const i = this._observableSections.get(e.target.hash);
        if (i) {
          e.preventDefault();
          const r = this._rootElement || window, n = i.offsetTop - this._element.offsetTop;
          if (r.scrollTo) {
            r.scrollTo({
              top: n,
              behavior: "smooth"
            });
            return;
          }
          r.scrollTop = n;
        }
      }));
    }
    _getNewObserver() {
      const e = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver((i) => this._observerCallback(i), e);
    }
    // The logic of selection
    _observerCallback(e) {
      const i = (o) => this._targetLinks.get(`#${o.target.id}`), r = (o) => {
        this._previousScrollData.visibleEntryTop = o.target.offsetTop, this._process(i(o));
      }, n = (this._rootElement || document.documentElement).scrollTop, s = n >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = n;
      for (const o of e) {
        if (!o.isIntersecting) {
          this._activeTarget = null, this._clearActiveClass(i(o));
          continue;
        }
        const a = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (s && a) {
          if (r(o), !n)
            return;
          continue;
        }
        !s && !a && r(o);
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
      const e = et.find(Mw, this._config.target);
      for (const i of e) {
        if (!i.hash || bA(i))
          continue;
        const r = et.findOne(decodeURI(i.hash), this._element);
        Id(r) && (this._targetLinks.set(decodeURI(i.hash), i), this._observableSections.set(i.hash, r));
      }
    }
    _process(e) {
      this._activeTarget !== e && (this._clearActiveClass(this._config.target), this._activeTarget = e, e.classList.add(Ec), this._activateParents(e), Ee.trigger(this._element, FJ, {
        relatedTarget: e
      }));
    }
    _activateParents(e) {
      if (e.classList.contains(DJ)) {
        et.findOne(UJ, e.closest(NJ)).classList.add(Ec);
        return;
      }
      for (const i of et.parents(e, RJ))
        for (const r of et.prev(i, YJ))
          r.classList.add(Ec);
    }
    _clearActiveClass(e) {
      e.classList.remove(Ec);
      const i = et.find(`${Mw}.${Ec}`, e);
      for (const r of i)
        r.classList.remove(Ec);
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = Jg.getOrCreateInstance(this, e);
        if (typeof e == "string") {
          if (i[e] === void 0 || e.startsWith("_") || e === "constructor")
            throw new TypeError(`No method named "${e}"`);
          i[e]();
        }
      });
    }
  }
  Ee.on(window, SJ, () => {
    for (const t of et.find(TJ))
      Jg.getOrCreateInstance(t);
  });
  ms(Jg);
  const PJ = "tab", OJ = "bs.tab", ec = `.${OJ}`, GJ = `hide${ec}`, jJ = `hidden${ec}`, HJ = `show${ec}`, JJ = `shown${ec}`, VJ = `click${ec}`, WJ = `keydown${ec}`, KJ = `load${ec}`, XJ = "ArrowLeft", pF = "ArrowRight", ZJ = "ArrowUp", mF = "ArrowDown", Iw = "Home", EF = "End", ul = "active", yF = "fade", vw = "show", qJ = "dropdown", fY = ".dropdown-toggle", $J = ".dropdown-menu", xw = `:not(${fY})`, eV = '.list-group, .nav, [role="tablist"]', tV = ".nav-item, .list-group-item", iV = `.nav-link${xw}, .list-group-item${xw}, [role="tab"]${xw}`, pY = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', Qw = `${iV}, ${pY}`, rV = `.${ul}[data-bs-toggle="tab"], .${ul}[data-bs-toggle="pill"], .${ul}[data-bs-toggle="list"]`;
  class Ll extends io {
    constructor(e) {
      super(e), this._parent = this._element.closest(eV), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), Ee.on(this._element, WJ, (i) => this._keydown(i)));
    }
    // Getters
    static get NAME() {
      return PJ;
    }
    // Public
    show() {
      const e = this._element;
      if (this._elemIsActive(e))
        return;
      const i = this._getActiveElem(), r = i ? Ee.trigger(i, GJ, {
        relatedTarget: e
      }) : null;
      Ee.trigger(e, HJ, {
        relatedTarget: i
      }).defaultPrevented || r && r.defaultPrevented || (this._deactivate(i, e), this._activate(e, i));
    }
    // Private
    _activate(e, i) {
      if (!e)
        return;
      e.classList.add(ul), this._activate(et.getElementFromSelector(e));
      const r = () => {
        if (e.getAttribute("role") !== "tab") {
          e.classList.add(vw);
          return;
        }
        e.removeAttribute("tabindex"), e.setAttribute("aria-selected", !0), this._toggleDropDown(e, !0), Ee.trigger(e, JJ, {
          relatedTarget: i
        });
      };
      this._queueCallback(r, e, e.classList.contains(yF));
    }
    _deactivate(e, i) {
      if (!e)
        return;
      e.classList.remove(ul), e.blur(), this._deactivate(et.getElementFromSelector(e));
      const r = () => {
        if (e.getAttribute("role") !== "tab") {
          e.classList.remove(vw);
          return;
        }
        e.setAttribute("aria-selected", !1), e.setAttribute("tabindex", "-1"), this._toggleDropDown(e, !1), Ee.trigger(e, jJ, {
          relatedTarget: i
        });
      };
      this._queueCallback(r, e, e.classList.contains(yF));
    }
    _keydown(e) {
      if (![XJ, pF, ZJ, mF, Iw, EF].includes(e.key))
        return;
      e.stopPropagation(), e.preventDefault();
      const i = this._getChildren().filter((n) => !bA(n));
      let r;
      if ([Iw, EF].includes(e.key))
        r = i[e.key === Iw ? 0 : i.length - 1];
      else {
        const n = [pF, mF].includes(e.key);
        r = gI(i, e.target, n, !0);
      }
      r && (r.focus({
        preventScroll: !0
      }), Ll.getOrCreateInstance(r).show());
    }
    _getChildren() {
      return et.find(Qw, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((e) => this._elemIsActive(e)) || null;
    }
    _setInitialAttributes(e, i) {
      this._setAttributeIfNotExists(e, "role", "tablist");
      for (const r of i)
        this._setInitialAttributesOnChild(r);
    }
    _setInitialAttributesOnChild(e) {
      e = this._getInnerElement(e);
      const i = this._elemIsActive(e), r = this._getOuterElement(e);
      e.setAttribute("aria-selected", i), r !== e && this._setAttributeIfNotExists(r, "role", "presentation"), i || e.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e, "role", "tab"), this._setInitialAttributesOnTargetPanel(e);
    }
    _setInitialAttributesOnTargetPanel(e) {
      const i = et.getElementFromSelector(e);
      i && (this._setAttributeIfNotExists(i, "role", "tabpanel"), e.id && this._setAttributeIfNotExists(i, "aria-labelledby", `${e.id}`));
    }
    _toggleDropDown(e, i) {
      const r = this._getOuterElement(e);
      if (!r.classList.contains(qJ))
        return;
      const n = (s, o) => {
        const a = et.findOne(s, r);
        a && a.classList.toggle(o, i);
      };
      n(fY, ul), n($J, vw), r.setAttribute("aria-expanded", i);
    }
    _setAttributeIfNotExists(e, i, r) {
      e.hasAttribute(i) || e.setAttribute(i, r);
    }
    _elemIsActive(e) {
      return e.classList.contains(ul);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(e) {
      return e.matches(Qw) ? e : et.findOne(Qw, e);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(e) {
      return e.closest(tV) || e;
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = Ll.getOrCreateInstance(this);
        if (typeof e == "string") {
          if (i[e] === void 0 || e.startsWith("_") || e === "constructor")
            throw new TypeError(`No method named "${e}"`);
          i[e]();
        }
      });
    }
  }
  Ee.on(document, VJ, pY, function(t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), !bA(this) && Ll.getOrCreateInstance(this).show();
  });
  Ee.on(window, KJ, () => {
    for (const t of et.find(rV))
      Ll.getOrCreateInstance(t);
  });
  ms(Ll);
  const nV = "toast", sV = "bs.toast", LA = `.${sV}`, oV = `mouseover${LA}`, aV = `mouseout${LA}`, AV = `focusin${LA}`, lV = `focusout${LA}`, cV = `hide${LA}`, uV = `hidden${LA}`, dV = `show${LA}`, hV = `shown${LA}`, gV = "fade", BF = "hide", Vf = "show", Wf = "showing", fV = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  }, pV = {
    animation: !0,
    autohide: !0,
    delay: 5e3
  };
  class Vg extends io {
    constructor(e, i) {
      super(e, i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
    }
    // Getters
    static get Default() {
      return pV;
    }
    static get DefaultType() {
      return fV;
    }
    static get NAME() {
      return nV;
    }
    // Public
    show() {
      if (Ee.trigger(this._element, dV).defaultPrevented)
        return;
      this._clearTimeout(), this._config.animation && this._element.classList.add(gV);
      const i = () => {
        this._element.classList.remove(Wf), Ee.trigger(this._element, hV), this._maybeScheduleHide();
      };
      this._element.classList.remove(BF), Pg(this._element), this._element.classList.add(Vf, Wf), this._queueCallback(i, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown() || Ee.trigger(this._element, cV).defaultPrevented)
        return;
      const i = () => {
        this._element.classList.add(BF), this._element.classList.remove(Wf, Vf), Ee.trigger(this._element, uV);
      };
      this._element.classList.add(Wf), this._queueCallback(i, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout(), this.isShown() && this._element.classList.remove(Vf), super.dispose();
    }
    isShown() {
      return this._element.classList.contains(Vf);
    }
    // Private
    _maybeScheduleHide() {
      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay)));
    }
    _onInteraction(e, i) {
      switch (e.type) {
        case "mouseover":
        case "mouseout": {
          this._hasMouseInteraction = i;
          break;
        }
        case "focusin":
        case "focusout": {
          this._hasKeyboardInteraction = i;
          break;
        }
      }
      if (i) {
        this._clearTimeout();
        return;
      }
      const r = e.relatedTarget;
      this._element === r || this._element.contains(r) || this._maybeScheduleHide();
    }
    _setListeners() {
      Ee.on(this._element, oV, (e) => this._onInteraction(e, !0)), Ee.on(this._element, aV, (e) => this._onInteraction(e, !1)), Ee.on(this._element, AV, (e) => this._onInteraction(e, !0)), Ee.on(this._element, lV, (e) => this._onInteraction(e, !1));
    }
    _clearTimeout() {
      clearTimeout(this._timeout), this._timeout = null;
    }
    // Static
    static jQueryInterface(e) {
      return this.each(function() {
        const i = Vg.getOrCreateInstance(this, e);
        if (typeof e == "string") {
          if (typeof i[e] > "u")
            throw new TypeError(`No method named "${e}"`);
          i[e](this);
        }
      });
    }
  }
  _y(Vg);
  ms(Vg);
  const mV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Alert: Gg,
    Button: jg,
    Carousel: xd,
    Collapse: Zu,
    Dropdown: Gs,
    Modal: Ul,
    Offcanvas: Ia,
    Popover: ky,
    ScrollSpy: Jg,
    Tab: Ll,
    Toast: Vg,
    Tooltip: $l
  }, Symbol.toStringTag, { value: "Module" }));
  function mY(t) {
    return t instanceof Date || Object.prototype.toString.call(t) === "[object Date]";
  }
  function Yy(t) {
    return mY(t) ? new Date(t.getTime()) : t == null ? /* @__PURE__ */ new Date(NaN) : new Date(t);
  }
  function EV(t) {
    return mY(t) && !isNaN(t.getTime());
  }
  function EY(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!(e >= 0 && e <= 6))
      throw new RangeError("weekStartsOn must be between 0 and 6");
    var i = Yy(t), r = i.getDay(), n = (r + 7 - e) % 7;
    return i.setDate(i.getDate() - n), i.setHours(0, 0, 0, 0), i;
  }
  function yY(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = e.firstDayOfWeek, r = i === void 0 ? 0 : i, n = e.firstWeekContainsDate, s = n === void 0 ? 1 : n;
    if (!(s >= 1 && s <= 7))
      throw new RangeError("firstWeekContainsDate must be between 1 and 7");
    for (var o = Yy(t), a = o.getFullYear(), A = /* @__PURE__ */ new Date(0), l = a + 1; l >= a - 1 && (A.setFullYear(l, 0, s), A.setHours(0, 0, 0, 0), A = EY(A, r), !(o.getTime() >= A.getTime())); l--)
      ;
    return A;
  }
  function EI(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = e.firstDayOfWeek, r = i === void 0 ? 0 : i, n = e.firstWeekContainsDate, s = n === void 0 ? 1 : n, o = Yy(t), a = EY(o, r), A = yY(o, {
      firstDayOfWeek: r,
      firstWeekContainsDate: s
    }), l = a.getTime() - A.getTime();
    return Math.round(l / (7 * 24 * 3600 * 1e3)) + 1;
  }
  var yI = {
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    weekdaysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    firstDayOfWeek: 0,
    firstWeekContainsDate: 1
  }, yV = /\[([^\]]+)]|YYYY|YY?|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|Z{1,2}|S{1,3}|w{1,2}|x|X|a|A/g;
  function Rn(t) {
    for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, i = "".concat(Math.abs(t)), r = t < 0 ? "-" : ""; i.length < e; )
      i = "0".concat(i);
    return r + i;
  }
  function wF(t) {
    return Math.round(t.getTimezoneOffset() / 15) * 15;
  }
  function CF(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", i = t > 0 ? "-" : "+", r = Math.abs(t), n = Math.floor(r / 60), s = r % 60;
    return i + Rn(n, 2) + e + Rn(s, 2);
  }
  var bF = function(e, i, r) {
    var n = e < 12 ? "AM" : "PM";
    return r ? n.toLocaleLowerCase() : n;
  }, kh = {
    Y: function(e) {
      var i = e.getFullYear();
      return i <= 9999 ? "".concat(i) : "+".concat(i);
    },
    // Year: 00, 01, ..., 99
    YY: function(e) {
      return Rn(e.getFullYear(), 4).substr(2);
    },
    // Year: 1900, 1901, ..., 2099
    YYYY: function(e) {
      return Rn(e.getFullYear(), 4);
    },
    // Month: 1, 2, ..., 12
    M: function(e) {
      return e.getMonth() + 1;
    },
    // Month: 01, 02, ..., 12
    MM: function(e) {
      return Rn(e.getMonth() + 1, 2);
    },
    MMM: function(e, i) {
      return i.monthsShort[e.getMonth()];
    },
    MMMM: function(e, i) {
      return i.months[e.getMonth()];
    },
    // Day of month: 1, 2, ..., 31
    D: function(e) {
      return e.getDate();
    },
    // Day of month: 01, 02, ..., 31
    DD: function(e) {
      return Rn(e.getDate(), 2);
    },
    // Hour: 0, 1, ... 23
    H: function(e) {
      return e.getHours();
    },
    // Hour: 00, 01, ..., 23
    HH: function(e) {
      return Rn(e.getHours(), 2);
    },
    // Hour: 1, 2, ..., 12
    h: function(e) {
      var i = e.getHours();
      return i === 0 ? 12 : i > 12 ? i % 12 : i;
    },
    // Hour: 01, 02, ..., 12
    hh: function() {
      var e = kh.h.apply(kh, arguments);
      return Rn(e, 2);
    },
    // Minute: 0, 1, ..., 59
    m: function(e) {
      return e.getMinutes();
    },
    // Minute: 00, 01, ..., 59
    mm: function(e) {
      return Rn(e.getMinutes(), 2);
    },
    // Second: 0, 1, ..., 59
    s: function(e) {
      return e.getSeconds();
    },
    // Second: 00, 01, ..., 59
    ss: function(e) {
      return Rn(e.getSeconds(), 2);
    },
    // 1/10 of second: 0, 1, ..., 9
    S: function(e) {
      return Math.floor(e.getMilliseconds() / 100);
    },
    // 1/100 of second: 00, 01, ..., 99
    SS: function(e) {
      return Rn(Math.floor(e.getMilliseconds() / 10), 2);
    },
    // Millisecond: 000, 001, ..., 999
    SSS: function(e) {
      return Rn(e.getMilliseconds(), 3);
    },
    // Day of week: 0, 1, ..., 6
    d: function(e) {
      return e.getDay();
    },
    // Day of week: 'Su', 'Mo', ..., 'Sa'
    dd: function(e, i) {
      return i.weekdaysMin[e.getDay()];
    },
    // Day of week: 'Sun', 'Mon',..., 'Sat'
    ddd: function(e, i) {
      return i.weekdaysShort[e.getDay()];
    },
    // Day of week: 'Sunday', 'Monday', ...,'Saturday'
    dddd: function(e, i) {
      return i.weekdays[e.getDay()];
    },
    // AM, PM
    A: function(e, i) {
      var r = i.meridiem || bF;
      return r(e.getHours(), e.getMinutes(), !1);
    },
    // am, pm
    a: function(e, i) {
      var r = i.meridiem || bF;
      return r(e.getHours(), e.getMinutes(), !0);
    },
    // Timezone: -01:00, +00:00, ... +12:00
    Z: function(e) {
      return CF(wF(e), ":");
    },
    // Timezone: -0100, +0000, ... +1200
    ZZ: function(e) {
      return CF(wF(e));
    },
    // Seconds timestamp: 512969520
    X: function(e) {
      return Math.floor(e.getTime() / 1e3);
    },
    // Milliseconds timestamp: 512969520900
    x: function(e) {
      return e.getTime();
    },
    w: function(e, i) {
      return EI(e, {
        firstDayOfWeek: i.firstDayOfWeek,
        firstWeekContainsDate: i.firstWeekContainsDate
      });
    },
    ww: function(e, i) {
      return Rn(kh.w(e, i), 2);
    }
  };
  function BI(t, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = e ? String(e) : "YYYY-MM-DDTHH:mm:ss.SSSZ", n = Yy(t);
    if (!EV(n))
      return "Invalid Date";
    var s = i.locale || yI;
    return r.replace(yV, function(o, a) {
      return a || (typeof kh[o] == "function" ? "".concat(kh[o](n, s)) : o);
    });
  }
  function MF(t) {
    return CV(t) || wV(t) || BV();
  }
  function BV() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
  function wV(t) {
    if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === "[object Arguments]") return Array.from(t);
  }
  function CV(t) {
    if (Array.isArray(t)) {
      for (var e = 0, i = new Array(t.length); e < t.length; e++)
        i[e] = t[e];
      return i;
    }
  }
  function IF(t, e) {
    var i = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(t);
      e && (r = r.filter(function(n) {
        return Object.getOwnPropertyDescriptor(t, n).enumerable;
      })), i.push.apply(i, r);
    }
    return i;
  }
  function bV(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i = arguments[e] != null ? arguments[e] : {};
      e % 2 ? IF(i, !0).forEach(function(r) {
        zA(t, r, i[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : IF(i).forEach(function(r) {
        Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(i, r));
      });
    }
    return t;
  }
  function MV(t, e) {
    return xV(t) || vV(t, e) || IV();
  }
  function IV() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  function vV(t, e) {
    if (Symbol.iterator in Object(t) || Object.prototype.toString.call(t) === "[object Arguments]") {
      var i = [], r = !0, n = !1, s = void 0;
      try {
        for (var o = t[Symbol.iterator](), a; !(r = (a = o.next()).done) && (i.push(a.value), !(e && i.length === e)); r = !0)
          ;
      } catch (A) {
        n = !0, s = A;
      } finally {
        try {
          !r && o.return != null && o.return();
        } finally {
          if (n) throw s;
        }
      }
      return i;
    }
  }
  function xV(t) {
    if (Array.isArray(t)) return t;
  }
  function zA(t, e, i) {
    return e in t ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = i, t;
  }
  var QV = /(\[[^\[]*\])|(MM?M?M?|Do|DD?|ddd?d?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|S{1,3}|x|X|ZZ?|.)/g, BY = /\d/, PA = /\d\d/, FV = /\d{3}/, SV = /\d{4}/, Qd = /\d\d?/, DV = /[+-]\d\d:?\d\d/, wY = /[+-]?\d+/, TV = /[+-]?\d+(\.\d{1,3})?/, wI = "year", Ny = "month", CY = "day", bY = "hour", MY = "minute", IY = "second", CI = "millisecond", vY = {}, ci = function(e, i, r) {
    var n = Array.isArray(e) ? e : [e], s;
    typeof r == "string" ? s = function(a) {
      var A = parseInt(a, 10);
      return zA({}, r, A);
    } : s = r, n.forEach(function(o) {
      vY[o] = [i, s];
    });
  }, RV = function(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }, Wg = function(e) {
    return function(i) {
      var r = i[e];
      if (!Array.isArray(r))
        throw new Error("Locale[".concat(e, "] need an array"));
      return new RegExp(r.map(RV).join("|"));
    };
  }, Kg = function(e, i) {
    return function(r, n) {
      var s = n[e];
      if (!Array.isArray(s))
        throw new Error("Locale[".concat(e, "] need an array"));
      var o = s.indexOf(r);
      if (o < 0)
        throw new Error("Invalid Word");
      return zA({}, i, o);
    };
  };
  ci("Y", wY, wI);
  ci("YY", PA, function(t) {
    var e = (/* @__PURE__ */ new Date()).getFullYear(), i = Math.floor(e / 100), r = parseInt(t, 10);
    return r = (r > 68 ? i - 1 : i) * 100 + r, zA({}, wI, r);
  });
  ci("YYYY", SV, wI);
  ci("M", Qd, function(t) {
    return zA({}, Ny, parseInt(t, 10) - 1);
  });
  ci("MM", PA, function(t) {
    return zA({}, Ny, parseInt(t, 10) - 1);
  });
  ci("MMM", Wg("monthsShort"), Kg("monthsShort", Ny));
  ci("MMMM", Wg("months"), Kg("months", Ny));
  ci("D", Qd, CY);
  ci("DD", PA, CY);
  ci(["H", "h"], Qd, bY);
  ci(["HH", "hh"], PA, bY);
  ci("m", Qd, MY);
  ci("mm", PA, MY);
  ci("s", Qd, IY);
  ci("ss", PA, IY);
  ci("S", BY, function(t) {
    return zA({}, CI, parseInt(t, 10) * 100);
  });
  ci("SS", PA, function(t) {
    return zA({}, CI, parseInt(t, 10) * 10);
  });
  ci("SSS", FV, CI);
  function _V(t) {
    return t.meridiemParse || /[ap]\.?m?\.?/i;
  }
  function kV(t) {
    return "".concat(t).toLowerCase().charAt(0) === "p";
  }
  ci(["A", "a"], _V, function(t, e) {
    var i = typeof e.isPM == "function" ? e.isPM(t) : kV(t);
    return {
      isPM: i
    };
  });
  function YV(t) {
    var e = t.match(/([+-]|\d\d)/g) || ["-", "0", "0"], i = MV(e, 3), r = i[0], n = i[1], s = i[2], o = parseInt(n, 10) * 60 + parseInt(s, 10);
    return o === 0 ? 0 : r === "+" ? -o : +o;
  }
  ci(["Z", "ZZ"], DV, function(t) {
    return {
      offset: YV(t)
    };
  });
  ci("x", wY, function(t) {
    return {
      date: new Date(parseInt(t, 10))
    };
  });
  ci("X", TV, function(t) {
    return {
      date: new Date(parseFloat(t) * 1e3)
    };
  });
  ci("d", BY, "weekday");
  ci("dd", Wg("weekdaysMin"), Kg("weekdaysMin", "weekday"));
  ci("ddd", Wg("weekdaysShort"), Kg("weekdaysShort", "weekday"));
  ci("dddd", Wg("weekdays"), Kg("weekdays", "weekday"));
  ci("w", Qd, "week");
  ci("ww", PA, "week");
  function NV(t, e) {
    if (t !== void 0 && e !== void 0) {
      if (e) {
        if (t < 12)
          return t + 12;
      } else if (t === 12)
        return 0;
    }
    return t;
  }
  function UV(t) {
    for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Date(), i = [0, 0, 1, 0, 0, 0, 0], r = [e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()], n = !0, s = 0; s < 7; s++)
      t[s] === void 0 ? i[s] = n ? r[s] : i[s] : (i[s] = t[s], n = !1);
    return i;
  }
  function LV(t, e, i, r, n, s, o) {
    var a;
    return t < 100 && t >= 0 ? (a = new Date(t + 400, e, i, r, n, s, o), isFinite(a.getFullYear()) && a.setFullYear(t)) : a = new Date(t, e, i, r, n, s, o), a;
  }
  function zV() {
    for (var t, e = arguments.length, i = new Array(e), r = 0; r < e; r++)
      i[r] = arguments[r];
    var n = i[0];
    return n < 100 && n >= 0 ? (i[0] += 400, t = new Date(Date.UTC.apply(Date, i)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(n)) : t = new Date(Date.UTC.apply(Date, i)), t;
  }
  function PV(t, e, i) {
    var r = e.match(QV);
    if (!r)
      throw new Error();
    for (var n = r.length, s = {}, o = 0; o < n; o += 1) {
      var a = r[o], A = vY[a];
      if (A) {
        var c = typeof A[0] == "function" ? A[0](i) : A[0], u = A[1], d = (c.exec(t) || [])[0], h = u(d, i);
        s = bV({}, s, {}, h), t = t.replace(d, "");
      } else {
        var l = a.replace(/^\[|\]$/g, "");
        if (t.indexOf(l) === 0)
          t = t.substr(l.length);
        else
          throw new Error("not match");
      }
    }
    return s;
  }
  function OV(t, e) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    try {
      var r = i.locale, n = r === void 0 ? yI : r, s = i.backupDate, o = s === void 0 ? /* @__PURE__ */ new Date() : s, a = PV(t, e, n), A = a.year, l = a.month, c = a.day, u = a.hour, d = a.minute, h = a.second, g = a.millisecond, f = a.isPM, p = a.date, m = a.offset, E = a.weekday, y = a.week;
      if (p)
        return p;
      var C = [A, l, c, u, d, h, g];
      if (C[3] = NV(C[3], f), y !== void 0 && l === void 0 && c === void 0) {
        var w = yY(A === void 0 ? o : new Date(A, 3), {
          firstDayOfWeek: n.firstDayOfWeek,
          firstWeekContainsDate: n.firstWeekContainsDate
        });
        return new Date(w.getTime() + (y - 1) * 7 * 24 * 3600 * 1e3);
      }
      var M, I = UV(C, o);
      return m !== void 0 ? (I[6] += m * 60 * 1e3, M = zV.apply(void 0, MF(I))) : M = LV.apply(void 0, MF(I)), E !== void 0 && M.getDay() !== E ? /* @__PURE__ */ new Date(NaN) : M;
    } catch {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var GV = Object.defineProperty, jV = Object.defineProperties, HV = Object.getOwnPropertyDescriptors, sE = Object.getOwnPropertySymbols, xY = Object.prototype.hasOwnProperty, QY = Object.prototype.propertyIsEnumerable, vF = (t, e, i) => e in t ? GV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, ur = (t, e) => {
    for (var i in e || (e = {}))
      xY.call(e, i) && vF(t, i, e[i]);
    if (sE)
      for (var i of sE(e))
        QY.call(e, i) && vF(t, i, e[i]);
    return t;
  }, hs = (t, e) => jV(t, HV(e)), JV = (t, e) => {
    var i = {};
    for (var r in t)
      xY.call(t, r) && e.indexOf(r) < 0 && (i[r] = t[r]);
    if (t != null && sE)
      for (var r of sE(t))
        e.indexOf(r) < 0 && QY.call(t, r) && (i[r] = t[r]);
    return i;
  };
  const VV = {
    formatLocale: yI,
    yearFormat: "YYYY",
    monthFormat: "MMM",
    monthBeforeYear: !0
  };
  let gh = "en";
  const jc = {};
  jc[gh] = VV;
  function FY(t, e, i = !1) {
    if (typeof t != "string")
      return jc[gh];
    let r = gh;
    return jc[t] && (r = t), e && (jc[t] = e, r = t), i || (gh = r), jc[t] || jc[gh];
  }
  function ZC(t) {
    return FY(t, void 0, !0);
  }
  function bI(t, e) {
    if (!Array.isArray(t))
      return [];
    const i = [], r = t.length;
    let n = 0;
    for (e = e || r; n < r; )
      i.push(t.slice(n, n += e));
    return i;
  }
  function xF(t) {
    return Array.isArray(t) ? t[t.length - 1] : void 0;
  }
  function lA(t) {
    return Object.prototype.toString.call(t) === "[object Object]";
  }
  function da(t, e) {
    const i = {};
    return lA(t) && (Array.isArray(e) || (e = [e]), e.forEach((r) => {
      Object.prototype.hasOwnProperty.call(t, r) && (i[r] = t[r]);
    })), i;
  }
  function SY(t, e) {
    if (!lA(t))
      return {};
    let i = t;
    return lA(e) && Object.keys(e).forEach((r) => {
      let n = e[r];
      const s = t[r];
      lA(n) && lA(s) && (n = SY(s, n)), i = hs(ur({}, i), { [r]: n });
    }), i;
  }
  function Fw(t) {
    const e = parseInt(String(t), 10);
    return e < 10 ? `0${e}` : `${e}`;
  }
  function WV(t) {
    const e = /-(\w)/g;
    return t.replace(e, (i, r) => r ? r.toUpperCase() : "");
  }
  const DY = "datepicker_locale", TY = "datepicker_prefixClass", RY = "datepicker_getWeek";
  function MI() {
    return bo(DY, MG(ZC()));
  }
  function KV(t) {
    const e = O(() => lA(t.value) ? SY(ZC(), t.value) : ZC(t.value));
    return bd(DY, e), e;
  }
  function XV(t) {
    bd(TY, t);
  }
  function sn() {
    return bo(TY, "mx");
  }
  function ZV(t) {
    bd(RY, t);
  }
  function qV() {
    return bo(RY, EI);
  }
  function $V(t) {
    const e = t.style.display, i = t.style.visibility;
    t.style.display = "block", t.style.visibility = "hidden";
    const r = window.getComputedStyle(t), n = t.offsetWidth + parseInt(r.marginLeft, 10) + parseInt(r.marginRight, 10), s = t.offsetHeight + parseInt(r.marginTop, 10) + parseInt(r.marginBottom, 10);
    return t.style.display = e, t.style.visibility = i, { width: n, height: s };
  }
  function eW(t, e, i, r) {
    let n = 0, s = 0, o = 0, a = 0;
    const A = t.getBoundingClientRect(), l = document.documentElement.clientWidth, c = document.documentElement.clientHeight;
    return r && (o = window.pageXOffset + A.left, a = window.pageYOffset + A.top), l - A.left < e && A.right < e ? n = o - A.left + 1 : A.left + A.width / 2 <= l / 2 ? n = o : n = o + A.width - e, A.top <= i && c - A.bottom <= i ? s = a + c - A.top - i : A.top + A.height / 2 <= c / 2 ? s = a + A.height : s = a - i, { left: `${n}px`, top: `${s}px` };
  }
  function II(t, e = document.body) {
    if (!t || t === e)
      return null;
    const i = (s, o) => getComputedStyle(s, null).getPropertyValue(o);
    return /(auto|scroll)/.test(i(t, "overflow") + i(t, "overflow-y") + i(t, "overflow-x")) ? t : II(t.parentElement, e);
  }
  let Kf;
  function tW() {
    if (typeof window > "u")
      return 0;
    if (Kf !== void 0)
      return Kf;
    const t = document.createElement("div");
    t.style.visibility = "hidden", t.style.overflow = "scroll", t.style.width = "100px", t.style.position = "absolute", t.style.top = "-9999px", document.body.appendChild(t);
    const e = document.createElement("div");
    return e.style.width = "100%", t.appendChild(e), Kf = t.offsetWidth - e.offsetWidth, t.parentNode.removeChild(t), Kf;
  }
  const QF = "ontouchend" in document ? "touchstart" : "mousedown";
  function iW(t) {
    let e = !1;
    return function(...r) {
      e || (e = !0, requestAnimationFrame(() => {
        e = !1, t.apply(this, r);
      }));
    };
  }
  function La(t, e) {
    return { setup: t, name: t.name, props: e };
  }
  function za(t, e) {
    return new Proxy(t, {
      get(r, n) {
        const s = r[n];
        return s !== void 0 ? s : e[n];
      }
    });
  }
  const OA = () => (t) => t, rW = (t, e) => {
    const i = {};
    for (const r in t)
      if (Object.prototype.hasOwnProperty.call(t, r)) {
        const n = WV(r);
        let s = t[r];
        e.indexOf(n) !== -1 && s === "" && (s = !0), i[n] = s;
      }
    return i;
  };
  function nW(t, {
    slots: e
  }) {
    const i = za(t, {
      appendToBody: !0
    }), r = sn(), n = ue(null), s = ue({
      left: "",
      top: ""
    }), o = () => {
      if (!i.visible || !n.value)
        return;
      const A = i.getRelativeElement();
      if (!A)
        return;
      const {
        width: l,
        height: c
      } = $V(n.value);
      s.value = eW(A, l, c, i.appendToBody);
    };
    vi(o, {
      flush: "post"
    }), vi((A) => {
      const l = i.getRelativeElement();
      if (!l)
        return;
      const c = II(l) || window, u = iW(o);
      c.addEventListener("scroll", u), window.addEventListener("resize", u), A(() => {
        c.removeEventListener("scroll", u), window.removeEventListener("resize", u);
      });
    }, {
      flush: "post"
    });
    const a = (A) => {
      if (!i.visible)
        return;
      const l = A.target, c = n.value, u = i.getRelativeElement();
      c && !c.contains(l) && u && !u.contains(l) && i.onClickOutside(A);
    };
    return vi((A) => {
      document.addEventListener(QF, a), A(() => {
        document.removeEventListener(QF, a);
      });
    }), () => ee(WM, {
      to: "body",
      disabled: !i.appendToBody
    }, {
      default: () => [ee(Ws, {
        name: `${r}-zoom-in-down`
      }, {
        default: () => {
          var A;
          return [i.visible && ee("div", {
            ref: n,
            class: `${r}-datepicker-main ${r}-datepicker-popup ${i.className}`,
            style: [ur({
              position: "absolute"
            }, s.value), i.style || {}]
          }, [(A = e.default) == null ? void 0 : A.call(e)])];
        }
      })]
    });
  }
  const sW = OA()(["style", "className", "visible", "appendToBody", "onClickOutside", "getRelativeElement"]);
  var oW = La(nW, sW);
  const aW = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em"
  }, AW = /* @__PURE__ */ be("path", { d: "M940.218 107.055H730.764v-60.51H665.6v60.51H363.055v-60.51H297.89v60.51H83.78c-18.617 0-32.581 13.963-32.581 32.581v805.237c0 18.618 13.964 32.582 32.582 32.582h861.09c18.619 0 32.583-13.964 32.583-32.582V139.636c-4.655-18.618-18.619-32.581-37.237-32.581zm-642.327 65.163v60.51h65.164v-60.51h307.2v60.51h65.163v-60.51h176.873v204.8H116.364v-204.8H297.89zM116.364 912.291V442.18H912.29v470.11H116.364z" }, null, -1), lW = [
    AW
  ];
  function _Y(t, e) {
    return G(), X("svg", aW, lW);
  }
  const cW = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em"
  }, uW = /* @__PURE__ */ be("path", { d: "M810.005 274.005 572.011 512l237.994 237.995-60.01 60.01L512 572.011 274.005 810.005l-60.01-60.01L451.989 512 213.995 274.005l60.01-60.01L512 451.989l237.995-237.994z" }, null, -1), dW = [
    uW
  ];
  function hW(t, e) {
    return G(), X("svg", cW, dW);
  }
  const gW = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: "1em",
    height: "1em"
  }, fW = /* @__PURE__ */ be("path", {
    d: "M0 0h24v24H0z",
    fill: "none"
  }, null, -1), pW = /* @__PURE__ */ be("path", { d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" }, null, -1), mW = /* @__PURE__ */ be("path", { d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z" }, null, -1), EW = [
    fW,
    pW,
    mW
  ];
  function yW(t, e) {
    return G(), X("svg", gW, EW);
  }
  function dl(t, e = 0, i = 1, r = 0, n = 0, s = 0, o = 0) {
    const a = new Date(t, e, i, r, n, s, o);
    return t < 100 && t >= 0 && a.setFullYear(t), a;
  }
  function va(t) {
    return t instanceof Date && !isNaN(t.getTime());
  }
  function hl(t) {
    return Array.isArray(t) && t.length === 2 && t.every(va) && t[0] <= t[1];
  }
  function BW(t) {
    return Array.isArray(t) && t.every(va);
  }
  function Uy(...t) {
    if (t[0] !== void 0 && t[0] !== null) {
      const i = new Date(t[0]);
      if (va(i))
        return i;
    }
    const e = t.slice(1);
    return e.length ? Uy(...e) : /* @__PURE__ */ new Date();
  }
  function wW(t) {
    const e = new Date(t);
    return e.setMonth(0, 1), e.setHours(0, 0, 0, 0), e;
  }
  function FF(t) {
    const e = new Date(t);
    return e.setDate(1), e.setHours(0, 0, 0, 0), e;
  }
  function MA(t) {
    const e = new Date(t);
    return e.setHours(0, 0, 0, 0), e;
  }
  function CW({
    firstDayOfWeek: t,
    year: e,
    month: i
  }) {
    const r = [], n = dl(e, i, 0), s = n.getDate(), o = s - (n.getDay() + 7 - t) % 7;
    for (let c = o; c <= s; c++)
      r.push(dl(e, i, c - s));
    n.setMonth(i + 1, 0);
    const a = n.getDate();
    for (let c = 1; c <= a; c++)
      r.push(dl(e, i, c));
    const A = s - o + 1, l = 6 * 7 - A - a;
    for (let c = 1; c <= l; c++)
      r.push(dl(e, i, a + c));
    return r;
  }
  function oE(t, e) {
    const i = new Date(t), r = typeof e == "function" ? e(i.getMonth()) : Number(e), n = i.getFullYear(), s = dl(n, r + 1, 0).getDate(), o = i.getDate();
    return i.setMonth(r, Math.min(o, s)), i;
  }
  function au(t, e) {
    const i = new Date(t), r = typeof e == "function" ? e(i.getFullYear()) : e;
    return i.setFullYear(r), i;
  }
  function bW(t, e) {
    const i = new Date(e), r = new Date(t), n = i.getFullYear() - r.getFullYear(), s = i.getMonth() - r.getMonth();
    return n * 12 + s;
  }
  function aE(t, e) {
    const i = new Date(t), r = new Date(e);
    return i.setHours(r.getHours(), r.getMinutes(), r.getSeconds()), i;
  }
  function MW(t, {
    slots: e
  }) {
    const i = za(t, {
      editable: !0,
      disabled: !1,
      clearable: !0,
      range: !1,
      multiple: !1
    }), r = sn(), n = ue(null), s = O(() => i.separator || (i.range ? " ~ " : ",")), o = (h) => i.range ? hl(h) : i.multiple ? BW(h) : va(h), a = (h) => Array.isArray(h) ? h.some((g) => i.disabledDate(g)) : i.disabledDate(h), A = O(() => n.value !== null ? n.value : typeof i.renderInputText == "function" ? i.renderInputText(i.value) : o(i.value) ? Array.isArray(i.value) ? i.value.map((h) => i.formatDate(h)).join(s.value) : i.formatDate(i.value) : ""), l = (h) => {
      var g;
      h && h.stopPropagation(), i.onChange(i.range ? [null, null] : null), (g = i.onClear) == null || g.call(i);
    }, c = () => {
      var h;
      if (!i.editable || n.value === null)
        return;
      const g = n.value.trim();
      if (n.value = null, g === "") {
        l();
        return;
      }
      let f;
      if (i.range) {
        let p = g.split(s.value);
        p.length !== 2 && (p = g.split(s.value.trim())), f = p.map((m) => i.parseDate(m.trim()));
      } else i.multiple ? f = g.split(s.value).map((p) => i.parseDate(p.trim())) : f = i.parseDate(g);
      o(f) && !a(f) ? i.onChange(f) : (h = i.onInputError) == null || h.call(i, g);
    }, u = (h) => {
      n.value = typeof h == "string" ? h : h.target.value;
    }, d = (h) => {
      const {
        keyCode: g
      } = h;
      g === 9 ? i.onBlur() : g === 13 && c();
    };
    return () => {
      var h, g, f;
      const p = !i.disabled && i.clearable && A.value, m = hs(ur({
        name: "date",
        type: "text",
        autocomplete: "off",
        value: A.value,
        class: i.inputClass || `${r}-input`,
        readonly: !i.editable,
        disabled: i.disabled,
        placeholder: i.placeholder
      }, i.inputAttr), {
        onFocus: i.onFocus,
        onKeydown: d,
        onInput: u,
        onChange: c
      });
      return ee("div", {
        class: `${r}-input-wrapper`,
        onClick: i.onClick
      }, [((h = e.input) == null ? void 0 : h.call(e, m)) || ee("input", m, null), p ? ee("i", {
        class: `${r}-icon-clear`,
        onClick: l
      }, [((g = e["icon-clear"]) == null ? void 0 : g.call(e)) || ee(hW, null, null)]) : null, ee("i", {
        class: `${r}-icon-calendar`
      }, [((f = e["icon-calendar"]) == null ? void 0 : f.call(e)) || ee(_Y, null, null)])]);
    };
  }
  const vI = OA()(["placeholder", "editable", "disabled", "clearable", "inputClass", "inputAttr", "range", "multiple", "separator", "renderInputText", "onInputError", "onClear"]), IW = OA()(["value", "formatDate", "parseDate", "disabledDate", "onChange", "onFocus", "onBlur", "onClick", ...vI]);
  var vW = La(MW, IW);
  function xW(t, {
    slots: e
  }) {
    var i;
    const r = za(t, {
      prefixClass: "mx",
      valueType: "date",
      format: "YYYY-MM-DD",
      type: "date",
      disabledDate: () => !1,
      disabledTime: () => !1,
      confirmText: "OK"
    });
    XV(r.prefixClass), ZV(((i = r.formatter) == null ? void 0 : i.getWeek) || EI);
    const n = KV(sk(t, "lang")), s = ue(), o = () => s.value, a = ue(!1), A = O(() => !r.disabled && (typeof r.open == "boolean" ? r.open : a.value)), l = () => {
      var M, I;
      r.disabled || A.value || (a.value = !0, (M = r["onUpdate:open"]) == null || M.call(r, !0), (I = r.onOpen) == null || I.call(r));
    }, c = () => {
      var M, I;
      A.value && (a.value = !1, (M = r["onUpdate:open"]) == null || M.call(r, !1), (I = r.onClose) == null || I.call(r));
    }, u = (M, I) => (I = I || r.format, lA(r.formatter) && typeof r.formatter.stringify == "function" ? r.formatter.stringify(M, I) : BI(M, I, {
      locale: n.value.formatLocale
    })), d = (M, I) => {
      if (I = I || r.format, lA(r.formatter) && typeof r.formatter.parse == "function")
        return r.formatter.parse(M, I);
      const b = /* @__PURE__ */ new Date();
      return OV(M, I, {
        locale: n.value.formatLocale,
        backupDate: b
      });
    }, h = (M) => {
      switch (r.valueType) {
        case "date":
          return M instanceof Date ? new Date(M.getTime()) : /* @__PURE__ */ new Date(NaN);
        case "timestamp":
          return typeof M == "number" ? new Date(M) : /* @__PURE__ */ new Date(NaN);
        case "format":
          return typeof M == "string" ? d(M) : /* @__PURE__ */ new Date(NaN);
        default:
          return typeof M == "string" ? d(M, r.valueType) : /* @__PURE__ */ new Date(NaN);
      }
    }, g = (M) => {
      if (!va(M))
        return null;
      switch (r.valueType) {
        case "date":
          return M;
        case "timestamp":
          return M.getTime();
        case "format":
          return u(M);
        default:
          return u(M, r.valueType);
      }
    }, f = O(() => {
      const M = r.value;
      return r.range ? (Array.isArray(M) ? M.slice(0, 2) : [null, null]).map(h) : r.multiple ? (Array.isArray(M) ? M : []).map(h) : h(M);
    }), p = (M, I, b = !0) => {
      var B, x;
      const Q = Array.isArray(M) ? M.map(g) : g(M);
      return (B = r["onUpdate:value"]) == null || B.call(r, Q), (x = r.onChange) == null || x.call(r, Q, I), b && c(), Q;
    }, m = ue(/* @__PURE__ */ new Date());
    vi(() => {
      A.value && (m.value = f.value);
    });
    const E = (M, I) => {
      r.confirm ? m.value = M : p(M, I, !r.multiple && (I === r.type || I === "time"));
    }, y = () => {
      var M;
      const I = p(m.value);
      (M = r.onConfirm) == null || M.call(r, I);
    }, C = (M) => r.disabledDate(M) || r.disabledTime(M), w = (M) => {
      var I;
      const {
        prefixClass: b
      } = r;
      return ee("div", {
        class: `${b}-datepicker-sidebar`
      }, [(I = e.sidebar) == null ? void 0 : I.call(e, M), (r.shortcuts || []).map((B, x) => ee("button", {
        key: x,
        "data-index": x,
        type: "button",
        class: `${b}-btn ${b}-btn-text ${b}-btn-shortcut`,
        onClick: () => {
          var Q;
          const v = (Q = B.onClick) == null ? void 0 : Q.call(B);
          v && p(v);
        }
      }, [B.text]))]);
    };
    return () => {
      var M, I;
      const {
        prefixClass: b,
        disabled: B,
        confirm: x,
        range: Q,
        popupClass: v,
        popupStyle: T,
        appendToBody: S
      } = r, D = {
        value: m.value,
        "onUpdate:value": E,
        emit: p
      }, F = e.header && ee("div", {
        class: `${b}-datepicker-header`
      }, [e.header(D)]), R = (e.footer || x) && ee("div", {
        class: `${b}-datepicker-footer`
      }, [(M = e.footer) == null ? void 0 : M.call(e, D), x && ee("button", {
        type: "button",
        class: `${b}-btn ${b}-datepicker-btn-confirm`,
        onClick: y
      }, [r.confirmText])]), Y = (I = e.content) == null ? void 0 : I.call(e, D), L = (e.sidebar || r.shortcuts) && w(D);
      return ee("div", {
        ref: s,
        class: {
          [`${b}-datepicker`]: !0,
          [`${b}-datepicker-range`]: Q,
          disabled: B
        }
      }, [ee(vW, hs(ur({}, da(r, vI)), {
        value: f.value,
        formatDate: u,
        parseDate: d,
        disabledDate: C,
        onChange: p,
        onClick: l,
        onFocus: l,
        onBlur: c
      }), da(e, ["icon-calendar", "icon-clear", "input"])), ee(oW, {
        className: v,
        style: T,
        visible: A.value,
        appendToBody: S,
        getRelativeElement: o,
        onClickOutside: c
      }, {
        default: () => [L, ee("div", {
          class: `${b}-datepicker-content`
        }, [F, Y, R])]
      })]);
    };
  }
  const QW = OA()(["value", "valueType", "type", "format", "formatter", "lang", "prefixClass", "appendToBody", "open", "popupClass", "popupStyle", "confirm", "confirmText", "shortcuts", "disabledDate", "disabledTime", "onOpen", "onClose", "onConfirm", "onChange", "onUpdate:open", "onUpdate:value"]), FW = [...QW, ...vI];
  var SF = La(xW, FW);
  function Xf(t) {
    var e = t, {
      value: i
    } = e, r = JV(e, [
      "value"
    ]);
    const n = sn();
    return ee("button", hs(ur({}, r), {
      type: "button",
      class: `${n}-btn ${n}-btn-text ${n}-btn-icon-${i}`
    }), [ee("i", {
      class: `${n}-icon-${i}`
    }, null)]);
  }
  function xI({
    type: t,
    calendar: e,
    onUpdateCalendar: i
  }, {
    slots: r
  }) {
    var n;
    const s = sn(), o = () => {
      i(oE(e, (d) => d - 1));
    }, a = () => {
      i(oE(e, (d) => d + 1));
    }, A = () => {
      i(au(e, (d) => d - 1));
    }, l = () => {
      i(au(e, (d) => d + 1));
    }, c = () => {
      i(au(e, (d) => d - 10));
    }, u = () => {
      i(au(e, (d) => d + 10));
    };
    return ee("div", {
      class: `${s}-calendar-header`
    }, [ee(Xf, {
      value: "double-left",
      onClick: t === "year" ? c : A
    }, null), t === "date" && ee(Xf, {
      value: "left",
      onClick: o
    }, null), ee(Xf, {
      value: "double-right",
      onClick: t === "year" ? u : l
    }, null), t === "date" && ee(Xf, {
      value: "right",
      onClick: a
    }, null), ee("span", {
      class: `${s}-calendar-header-label`
    }, [(n = r.default) == null ? void 0 : n.call(r)])]);
  }
  function SW({
    calendar: t,
    isWeekMode: e,
    showWeekNumber: i,
    titleFormat: r,
    getWeekActive: n,
    getCellClasses: s,
    onSelect: o,
    onUpdatePanel: a,
    onUpdateCalendar: A,
    onDateMouseEnter: l,
    onDateMouseLeave: c
  }) {
    const u = sn(), d = qV(), h = MI().value, {
      yearFormat: g,
      monthBeforeYear: f,
      monthFormat: p = "MMM",
      formatLocale: m
    } = h, E = m.firstDayOfWeek || 0;
    let y = h.days || m.weekdaysMin;
    y = y.concat(y).slice(E, E + 7);
    const C = t.getFullYear(), w = t.getMonth(), M = bI(CW({
      firstDayOfWeek: E,
      year: C,
      month: w
    }), 7), I = (D, F) => BI(D, F, {
      locale: h.formatLocale
    }), b = (D) => {
      a(D);
    }, B = (D) => {
      const F = D.getAttribute("data-index"), [R, Y] = F.split(",").map((N) => parseInt(N, 10)), L = M[R][Y];
      return new Date(L);
    }, x = (D) => {
      o(B(D.currentTarget));
    }, Q = (D) => {
      l && l(B(D.currentTarget));
    }, v = (D) => {
      c && c(B(D.currentTarget));
    }, T = ee("button", {
      type: "button",
      class: `${u}-btn ${u}-btn-text ${u}-btn-current-year`,
      onClick: () => b("year")
    }, [I(t, g)]), S = ee("button", {
      type: "button",
      class: `${u}-btn ${u}-btn-text ${u}-btn-current-month`,
      onClick: () => b("month")
    }, [I(t, p)]);
    return i = typeof i == "boolean" ? i : e, ee("div", {
      class: [`${u}-calendar ${u}-calendar-panel-date`, {
        [`${u}-calendar-week-mode`]: e
      }]
    }, [ee(xI, {
      type: "date",
      calendar: t,
      onUpdateCalendar: A
    }, {
      default: () => [f ? [S, T] : [T, S]]
    }), ee("div", {
      class: `${u}-calendar-content`
    }, [ee("table", {
      class: `${u}-table ${u}-table-date`
    }, [ee("thead", null, [ee("tr", null, [i && ee("th", {
      class: `${u}-week-number-header`
    }, null), y.map((D) => ee("th", {
      key: D
    }, [D]))])]), ee("tbody", null, [M.map((D, F) => ee("tr", {
      key: F,
      class: [`${u}-date-row`, {
        [`${u}-active-week`]: n(D)
      }]
    }, [i && ee("td", {
      class: `${u}-week-number`,
      "data-index": `${F},0`,
      onClick: x
    }, [ee("div", null, [d(D[0])])]), D.map((R, Y) => ee("td", {
      key: Y,
      class: ["cell", s(R)],
      title: I(R, r),
      "data-index": `${F},${Y}`,
      onClick: x,
      onMouseenter: Q,
      onMouseleave: v
    }, [ee("div", null, [R.getDate()])]))]))])])])]);
  }
  function DW({
    calendar: t,
    getCellClasses: e,
    onSelect: i,
    onUpdateCalendar: r,
    onUpdatePanel: n
  }) {
    const s = sn(), o = MI().value, a = o.months || o.formatLocale.monthsShort, A = (c) => dl(t.getFullYear(), c), l = (c) => {
      const d = c.currentTarget.getAttribute("data-month");
      i(A(parseInt(d, 10)));
    };
    return ee("div", {
      class: `${s}-calendar ${s}-calendar-panel-month`
    }, [ee(xI, {
      type: "month",
      calendar: t,
      onUpdateCalendar: r
    }, {
      default: () => [ee("button", {
        type: "button",
        class: `${s}-btn ${s}-btn-text ${s}-btn-current-year`,
        onClick: () => n("year")
      }, [t.getFullYear()])]
    }), ee("div", {
      class: `${s}-calendar-content`
    }, [ee("table", {
      class: `${s}-table ${s}-table-month`
    }, [bI(a, 3).map((c, u) => ee("tr", {
      key: u
    }, [c.map((d, h) => {
      const g = u * 3 + h;
      return ee("td", {
        key: h,
        class: ["cell", e(A(g))],
        "data-month": g,
        onClick: l
      }, [ee("div", null, [d])]);
    })]))])])]);
  }
  const TW = (t) => {
    const e = Math.floor(t.getFullYear() / 10) * 10, i = [];
    for (let r = 0; r < 10; r++)
      i.push(e + r);
    return bI(i, 2);
  };
  function RW({
    calendar: t,
    getCellClasses: e = () => [],
    getYearPanel: i = TW,
    onSelect: r,
    onUpdateCalendar: n
  }) {
    const s = sn(), o = (u) => dl(u, 0), a = (u) => {
      const h = u.currentTarget.getAttribute("data-year");
      r(o(parseInt(h, 10)));
    }, A = i(new Date(t)), l = A[0][0], c = xF(xF(A));
    return ee("div", {
      class: `${s}-calendar ${s}-calendar-panel-year`
    }, [ee(xI, {
      type: "year",
      calendar: t,
      onUpdateCalendar: n
    }, {
      default: () => [ee("span", null, [l]), ee("span", {
        class: `${s}-calendar-decade-separator`
      }, null), ee("span", null, [c])]
    }), ee("div", {
      class: `${s}-calendar-content`
    }, [ee("table", {
      class: `${s}-table ${s}-table-year`
    }, [A.map((u, d) => ee("tr", {
      key: d
    }, [u.map((h, g) => ee("td", {
      key: g,
      class: ["cell", e(o(h))],
      "data-year": h,
      onClick: a
    }, [ee("div", null, [h])]))]))])])]);
  }
  function _W(t) {
    const e = za(t, {
      defaultValue: MA(/* @__PURE__ */ new Date()),
      type: "date",
      disabledDate: () => !1,
      getClasses: () => [],
      titleFormat: "YYYY-MM-DD"
    }), i = O(() => (Array.isArray(e.value) ? e.value : [e.value]).filter(va).map((E) => e.type === "year" ? wW(E) : e.type === "month" ? FF(E) : MA(E))), r = ue(/* @__PURE__ */ new Date());
    vi(() => {
      let m = e.calendar;
      if (!va(m)) {
        const {
          length: E
        } = i.value;
        m = Uy(E > 0 ? i.value[E - 1] : e.defaultValue);
      }
      r.value = FF(m);
    });
    const n = (m) => {
      var E;
      r.value = m, (E = e.onCalendarChange) == null || E.call(e, m);
    }, s = ue("date");
    vi(() => {
      const m = ["date", "month", "year"], E = Math.max(m.indexOf(e.type), m.indexOf(e.defaultPanel));
      s.value = E !== -1 ? m[E] : "date";
    });
    const o = (m) => {
      var E;
      const y = s.value;
      s.value = m, (E = e.onPanelChange) == null || E.call(e, m, y);
    }, a = (m) => e.disabledDate(new Date(m), i.value), A = (m, E) => {
      var y, C, w;
      if (!a(m))
        if ((y = e.onPick) == null || y.call(e, m), e.multiple === !0) {
          const M = i.value.filter((I) => I.getTime() !== m.getTime());
          M.length === i.value.length && M.push(m), (C = e["onUpdate:value"]) == null || C.call(e, M, E);
        } else
          (w = e["onUpdate:value"]) == null || w.call(e, m, E);
    }, l = (m) => {
      A(m, e.type === "week" ? "week" : "date");
    }, c = (m) => {
      if (e.type === "year")
        A(m, "year");
      else if (n(m), o("month"), e.partialUpdate && i.value.length === 1) {
        const E = au(i.value[0], m.getFullYear());
        A(E, "year");
      }
    }, u = (m) => {
      if (e.type === "month")
        A(m, "month");
      else if (n(m), o("date"), e.partialUpdate && i.value.length === 1) {
        const E = oE(au(i.value[0], m.getFullYear()), m.getMonth());
        A(E, "month");
      }
    }, d = (m, E = []) => (a(m) ? E.push("disabled") : i.value.some((y) => y.getTime() === m.getTime()) && E.push("active"), E.concat(e.getClasses(m, i.value, E.join(" ")))), h = (m) => {
      const E = m.getMonth() !== r.value.getMonth(), y = [];
      return m.getTime() === (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0) && y.push("today"), E && y.push("not-current-month"), d(m, y);
    }, g = (m) => e.type !== "month" ? r.value.getMonth() === m.getMonth() ? "active" : "" : d(m), f = (m) => e.type !== "year" ? r.value.getFullYear() === m.getFullYear() ? "active" : "" : d(m), p = (m) => {
      if (e.type !== "week")
        return !1;
      const E = m[0].getTime(), y = m[6].getTime();
      return i.value.some((C) => {
        const w = C.getTime();
        return w >= E && w <= y;
      });
    };
    return () => s.value === "year" ? ee(RW, {
      calendar: r.value,
      getCellClasses: f,
      getYearPanel: e.getYearPanel,
      onSelect: c,
      onUpdateCalendar: n
    }, null) : s.value === "month" ? ee(DW, {
      calendar: r.value,
      getCellClasses: g,
      onSelect: u,
      onUpdatePanel: o,
      onUpdateCalendar: n
    }, null) : ee(SW, {
      isWeekMode: e.type === "week",
      showWeekNumber: e.showWeekNumber,
      titleFormat: e.titleFormat,
      calendar: r.value,
      getCellClasses: h,
      getWeekActive: p,
      onSelect: l,
      onUpdatePanel: o,
      onUpdateCalendar: n,
      onDateMouseEnter: e.onDateMouseEnter,
      onDateMouseLeave: e.onDateMouseLeave
    }, null);
  }
  const Ly = OA()(["type", "value", "defaultValue", "defaultPanel", "disabledDate", "getClasses", "calendar", "multiple", "partialUpdate", "showWeekNumber", "titleFormat", "getYearPanel", "onDateMouseEnter", "onDateMouseLeave", "onCalendarChange", "onPanelChange", "onUpdate:value", "onPick"]);
  var zy = La(_W, Ly);
  const DF = (t, e) => {
    const i = t.getTime();
    let [r, n] = e.map((s) => s.getTime());
    return r > n && ([r, n] = [n, r]), i > r && i < n;
  };
  function kW(t) {
    const e = za(t, {
      defaultValue: /* @__PURE__ */ new Date(),
      type: "date"
    }), i = sn(), r = O(() => {
      let p = Array.isArray(e.defaultValue) ? e.defaultValue : [e.defaultValue, e.defaultValue];
      return p = p.map((m) => MA(m)), hl(p) ? p : [/* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()].map((m) => MA(m));
    }), n = ue([/* @__PURE__ */ new Date(NaN), /* @__PURE__ */ new Date(NaN)]);
    vi(() => {
      hl(e.value) && (n.value = e.value);
    });
    const s = (p, m) => {
      var E;
      const [y, C] = n.value;
      va(y) && !va(C) ? (y.getTime() > p.getTime() ? n.value = [p, y] : n.value = [y, p], (E = e["onUpdate:value"]) == null || E.call(e, n.value, m)) : n.value = [p, /* @__PURE__ */ new Date(NaN)];
    }, o = ue([/* @__PURE__ */ new Date(), /* @__PURE__ */ new Date()]), a = O(() => hl(e.calendar) ? e.calendar : o.value), A = O(() => e.type === "year" ? 10 * 12 : e.type === "month" ? 1 * 12 : 1), l = (p, m) => {
      var E;
      const y = bW(p[0], p[1]), C = A.value - y;
      if (C > 0) {
        const w = m === 1 ? 0 : 1;
        p[w] = oE(p[w], (M) => M + (w === 0 ? -C : C));
      }
      o.value = p, (E = e.onCalendarChange) == null || E.call(e, p, m);
    }, c = (p) => {
      l([p, a.value[1]], 0);
    }, u = (p) => {
      l([a.value[0], p], 1);
    };
    vi(() => {
      const p = hl(e.value) ? e.value : r.value;
      l(p.slice(0, 2));
    });
    const d = ue(null), h = (p) => d.value = p, g = () => d.value = null, f = (p, m, E) => {
      const y = e.getClasses ? e.getClasses(p, m, E) : [], C = Array.isArray(y) ? y : [y];
      return /disabled|active/.test(E) ? C : (m.length === 2 && DF(p, m) && C.push("in-range"), m.length === 1 && d.value && DF(p, [m[0], d.value]) ? C.concat("hover-in-range") : C);
    };
    return () => {
      const p = a.value.map((m, E) => {
        const y = hs(ur({}, e), {
          calendar: m,
          value: n.value,
          defaultValue: r.value[E],
          getClasses: f,
          partialUpdate: !1,
          multiple: !1,
          "onUpdate:value": s,
          onCalendarChange: E === 0 ? c : u,
          onDateMouseLeave: g,
          onDateMouseEnter: h
        });
        return ee(zy, y, null);
      });
      return ee("div", {
        class: `${i}-calendar-range`
      }, [p]);
    };
  }
  const QI = Ly;
  var FI = La(kW, QI);
  const kY = je({
    setup(t, {
      slots: e
    }) {
      const i = sn(), r = ue(), n = ue(""), s = ue("");
      er(() => {
        if (!r.value)
          return;
        const g = r.value, f = g.clientHeight * 100 / g.scrollHeight;
        n.value = f < 100 ? `${f}%` : "";
      });
      const a = tW(), A = (g) => {
        const f = g.currentTarget, {
          scrollHeight: p,
          scrollTop: m
        } = f;
        s.value = `${m * 100 / p}%`;
      };
      let l = !1, c = 0;
      const u = (g) => {
        g.stopImmediatePropagation();
        const f = g.currentTarget, {
          offsetTop: p
        } = f;
        l = !0, c = g.clientY - p;
      }, d = (g) => {
        if (!l || !r.value)
          return;
        const {
          clientY: f
        } = g, {
          scrollHeight: p,
          clientHeight: m
        } = r.value, y = (f - c) * p / m;
        r.value.scrollTop = y;
      }, h = () => {
        l = !1;
      };
      return er(() => {
        document.addEventListener("mousemove", d), document.addEventListener("mouseup", h);
      }), Fs(() => {
        document.addEventListener("mousemove", d), document.addEventListener("mouseup", h);
      }), () => {
        var g;
        return ee("div", {
          class: `${i}-scrollbar`,
          style: {
            position: "relative",
            overflow: "hidden"
          }
        }, [ee("div", {
          ref: r,
          class: `${i}-scrollbar-wrap`,
          style: {
            marginRight: `-${a}px`
          },
          onScroll: A
        }, [(g = e.default) == null ? void 0 : g.call(e)]), ee("div", {
          class: `${i}-scrollbar-track`
        }, [ee("div", {
          class: `${i}-scrollbar-thumb`,
          style: {
            height: n.value,
            top: s.value
          },
          onMousedown: u
        }, null)])]);
      };
    }
  });
  function YW({
    options: t,
    getClasses: e,
    onSelect: i
  }) {
    const r = sn(), n = (s) => {
      const o = s.target, a = s.currentTarget;
      if (o.tagName.toUpperCase() !== "LI")
        return;
      const A = a.getAttribute("data-type"), l = parseInt(a.getAttribute("data-index"), 10), c = parseInt(o.getAttribute("data-index"), 10), u = t[l].list[c].value;
      i(u, A);
    };
    return ee("div", {
      class: `${r}-time-columns`
    }, [t.map((s, o) => ee(kY, {
      key: s.type,
      class: `${r}-time-column`
    }, {
      default: () => [ee("ul", {
        class: `${r}-time-list`,
        "data-index": o,
        "data-type": s.type,
        onClick: n
      }, [s.list.map((a, A) => ee("li", {
        key: a.text,
        "data-index": A,
        class: [`${r}-time-item`, e(a.value, s.type)]
      }, [a.text]))])]
    }))]);
  }
  function NW(t) {
    return typeof t == "function" || Object.prototype.toString.call(t) === "[object Object]" && !IG(t);
  }
  function UW(t) {
    let e;
    const i = sn();
    return ee(kY, null, NW(e = t.options.map((r) => ee("div", {
      key: r.text,
      class: [`${i}-time-option`, t.getClasses(r.value, "time")],
      onClick: () => t.onSelect(r.value, "time")
    }, [r.text]))) ? e : {
      default: () => [e]
    });
  }
  function Sw({
    length: t,
    step: e = 1,
    options: i
  }) {
    if (Array.isArray(i))
      return i.filter((n) => n >= 0 && n < t);
    e <= 0 && (e = 1);
    const r = [];
    for (let n = 0; n < t; n += e)
      r.push(n);
    return r;
  }
  function LW(t, e) {
    let { showHour: i, showMinute: r, showSecond: n, use12h: s } = e;
    const o = e.format || "HH:mm:ss";
    i = typeof i == "boolean" ? i : /[HhKk]/.test(o), r = typeof r == "boolean" ? r : /m/.test(o), n = typeof n == "boolean" ? n : /s/.test(o), s = typeof s == "boolean" ? s : /a/i.test(o);
    const a = [], A = s && t.getHours() >= 12;
    return i && a.push({
      type: "hour",
      list: Sw({
        length: s ? 12 : 24,
        step: e.hourStep,
        options: e.hourOptions
      }).map((l) => {
        const c = l === 0 && s ? "12" : Fw(l), u = new Date(t);
        return u.setHours(A ? l + 12 : l), { value: u, text: c };
      })
    }), r && a.push({
      type: "minute",
      list: Sw({
        length: 60,
        step: e.minuteStep,
        options: e.minuteOptions
      }).map((l) => {
        const c = new Date(t);
        return c.setMinutes(l), { value: c, text: Fw(l) };
      })
    }), n && a.push({
      type: "second",
      list: Sw({
        length: 60,
        step: e.secondStep,
        options: e.secondOptions
      }).map((l) => {
        const c = new Date(t);
        return c.setSeconds(l), { value: c, text: Fw(l) };
      })
    }), s && a.push({
      type: "ampm",
      list: ["AM", "PM"].map((l, c) => {
        const u = new Date(t);
        return u.setHours(u.getHours() % 12 + c * 12), { text: l, value: u };
      })
    }), a;
  }
  function Dw(t = "") {
    const e = t.split(":");
    if (e.length >= 2) {
      const i = parseInt(e[0], 10), r = parseInt(e[1], 10);
      return {
        hours: i,
        minutes: r
      };
    }
    return null;
  }
  function zW({
    date: t,
    option: e,
    format: i,
    formatDate: r
  }) {
    const n = [];
    if (typeof e == "function")
      return e() || [];
    const s = Dw(e.start), o = Dw(e.end), a = Dw(e.step), A = e.format || i;
    if (s && o && a) {
      const l = s.minutes + s.hours * 60, c = o.minutes + o.hours * 60, u = a.minutes + a.hours * 60, d = Math.floor((c - l) / u);
      for (let h = 0; h <= d; h++) {
        const g = l + h * u, f = Math.floor(g / 60), p = g % 60, m = new Date(t);
        m.setHours(f, p, 0), n.push({
          value: m,
          text: r(m, A)
        });
      }
    }
    return n;
  }
  const YY = (t, e, i = 0) => {
    if (i <= 0) {
      requestAnimationFrame(() => {
        t.scrollTop = e;
      });
      return;
    }
    const n = (e - t.scrollTop) / i * 10;
    requestAnimationFrame(() => {
      const s = t.scrollTop + n;
      if (s >= e) {
        t.scrollTop = e;
        return;
      }
      t.scrollTop = s, YY(t, e, i - 10);
    });
  };
  function PW(t) {
    const e = za(t, {
      defaultValue: MA(/* @__PURE__ */ new Date()),
      format: "HH:mm:ss",
      timeTitleFormat: "YYYY-MM-DD",
      disabledTime: () => !1,
      scrollDuration: 100
    }), i = sn(), r = MI(), n = (f, p) => BI(f, p, {
      locale: r.value.formatLocale
    }), s = ue(/* @__PURE__ */ new Date());
    vi(() => {
      s.value = Uy(e.value, e.defaultValue);
    });
    const o = (f) => Array.isArray(f) ? f.every((p) => e.disabledTime(new Date(p))) : e.disabledTime(new Date(f)), a = (f) => {
      const p = new Date(f);
      return o([p.getTime(), p.setMinutes(0, 0, 0), p.setMinutes(59, 59, 999)]);
    }, A = (f) => {
      const p = new Date(f);
      return o([p.getTime(), p.setSeconds(0, 0), p.setSeconds(59, 999)]);
    }, l = (f) => {
      const p = new Date(f), m = p.getHours() < 12 ? 0 : 12, E = m + 11;
      return o([p.getTime(), p.setHours(m, 0, 0, 0), p.setHours(E, 59, 59, 999)]);
    }, c = (f, p) => p === "hour" ? a(f) : p === "minute" ? A(f) : p === "ampm" ? l(f) : o(f), u = (f, p) => {
      var m;
      if (!c(f, p)) {
        const E = new Date(f);
        s.value = E, o(E) || (m = e["onUpdate:value"]) == null || m.call(e, E, p);
      }
    }, d = (f, p) => c(f, p) ? "disabled" : f.getTime() === s.value.getTime() ? "active" : "", h = ue(), g = (f) => {
      if (!h.value)
        return;
      const p = h.value.querySelectorAll(".active");
      for (let m = 0; m < p.length; m++) {
        const E = p[m], y = II(E, h.value);
        if (y) {
          const C = E.offsetTop;
          YY(y, C, f);
        }
      }
    };
    return er(() => g(0)), ct(s, () => g(e.scrollDuration), {
      flush: "post"
    }), () => {
      let f;
      return e.timePickerOptions ? f = ee(UW, {
        onSelect: u,
        getClasses: d,
        options: zW({
          date: s.value,
          format: e.format,
          option: e.timePickerOptions,
          formatDate: n
        })
      }, null) : f = ee(YW, {
        options: LW(s.value, e),
        onSelect: u,
        getClasses: d
      }, null), ee("div", {
        class: `${i}-time`,
        ref: h
      }, [e.showTimeHeader && ee("div", {
        class: `${i}-time-header`
      }, [ee("button", {
        type: "button",
        class: `${i}-btn ${i}-btn-text ${i}-time-header-title`,
        onClick: e.onClickTitle
      }, [n(s.value, e.timeTitleFormat)])]), ee("div", {
        class: `${i}-time-content`
      }, [f])]);
    };
  }
  const Py = OA()(["value", "defaultValue", "format", "timeTitleFormat", "showTimeHeader", "disabledTime", "timePickerOptions", "hourOptions", "minuteOptions", "secondOptions", "hourStep", "minuteStep", "secondStep", "showHour", "showMinute", "showSecond", "use12h", "scrollDuration", "onClickTitle", "onUpdate:value"]);
  var tg = La(PW, Py);
  function OW(t) {
    const e = za(t, {
      defaultValue: MA(/* @__PURE__ */ new Date()),
      disabledTime: () => !1
    }), i = sn(), r = ue([/* @__PURE__ */ new Date(NaN), /* @__PURE__ */ new Date(NaN)]);
    vi(() => {
      hl(e.value) ? r.value = e.value : r.value = [/* @__PURE__ */ new Date(NaN), /* @__PURE__ */ new Date(NaN)];
    });
    const n = (l, c) => {
      var u;
      (u = e["onUpdate:value"]) == null || u.call(e, r.value, l === "time" ? "time-range" : l, c);
    }, s = (l, c) => {
      r.value[0] = l, r.value[1].getTime() >= l.getTime() || (r.value[1] = l), n(c, 0);
    }, o = (l, c) => {
      r.value[1] = l, r.value[0].getTime() <= l.getTime() || (r.value[0] = l), n(c, 1);
    }, a = (l) => e.disabledTime(l, 0), A = (l) => l.getTime() < r.value[0].getTime() || e.disabledTime(l, 1);
    return () => {
      const l = Array.isArray(e.defaultValue) ? e.defaultValue : [e.defaultValue, e.defaultValue];
      return ee("div", {
        class: `${i}-time-range`
      }, [ee(tg, hs(ur({}, e), {
        "onUpdate:value": s,
        value: r.value[0],
        defaultValue: l[0],
        disabledTime: a
      }), null), ee(tg, hs(ur({}, e), {
        "onUpdate:value": o,
        value: r.value[1],
        defaultValue: l[1],
        disabledTime: A
      }), null)]);
    };
  }
  const SI = Py;
  var DI = La(OW, SI);
  function NY(t) {
    const e = ue(!1), i = () => {
      var s;
      e.value = !1, (s = t.onShowTimePanelChange) == null || s.call(t, !1);
    }, r = () => {
      var s;
      e.value = !0, (s = t.onShowTimePanelChange) == null || s.call(t, !0);
    };
    return { timeVisible: O(() => typeof t.showTimePanel == "boolean" ? t.showTimePanel : e.value), openTimePanel: r, closeTimePanel: i };
  }
  function GW(t) {
    const e = za(t, {
      disabledTime: () => !1,
      defaultValue: MA(/* @__PURE__ */ new Date())
    }), i = ue(e.value);
    vi(() => {
      i.value = e.value;
    });
    const {
      openTimePanel: r,
      closeTimePanel: n,
      timeVisible: s
    } = NY(e), o = (a, A) => {
      var l;
      A === "date" && r();
      let c = aE(a, Uy(e.value, e.defaultValue));
      if (e.disabledTime(new Date(c)) && (c = aE(a, e.defaultValue), e.disabledTime(new Date(c)))) {
        i.value = c;
        return;
      }
      (l = e["onUpdate:value"]) == null || l.call(e, c, A);
    };
    return () => {
      const a = sn(), A = hs(ur({}, da(e, Ly)), {
        multiple: !1,
        type: "date",
        value: i.value,
        "onUpdate:value": o
      }), l = hs(ur({}, da(e, Py)), {
        showTimeHeader: !0,
        value: i.value,
        "onUpdate:value": e["onUpdate:value"],
        onClickTitle: n
      });
      return ee("div", {
        class: `${a}-date-time`
      }, [ee(zy, A, null), s.value && ee(tg, l, null)]);
    };
  }
  const UY = OA()(["showTimePanel", "onShowTimePanelChange"]), jW = [...UY, ...Ly, ...Py];
  var LY = La(GW, jW);
  function HW(t) {
    const e = za(t, {
      defaultValue: MA(/* @__PURE__ */ new Date()),
      disabledTime: () => !1
    }), i = ue(e.value);
    vi(() => {
      i.value = e.value;
    });
    const {
      openTimePanel: r,
      closeTimePanel: n,
      timeVisible: s
    } = NY(e), o = (a, A) => {
      var l;
      A === "date" && r();
      const c = Array.isArray(e.defaultValue) ? e.defaultValue : [e.defaultValue, e.defaultValue];
      let u = a.map((d, h) => {
        const g = hl(e.value) ? e.value[h] : c[h];
        return aE(d, g);
      });
      if (u[1].getTime() < u[0].getTime() && (u = [u[0], u[0]]), u.some(e.disabledTime) && (u = a.map((d, h) => aE(d, c[h])), u.some(e.disabledTime))) {
        i.value = u;
        return;
      }
      (l = e["onUpdate:value"]) == null || l.call(e, u, A);
    };
    return () => {
      const a = sn(), A = hs(ur({}, da(e, QI)), {
        type: "date",
        value: i.value,
        "onUpdate:value": o
      }), l = hs(ur({}, da(e, SI)), {
        showTimeHeader: !0,
        value: i.value,
        "onUpdate:value": e["onUpdate:value"],
        onClickTitle: n
      });
      return ee("div", {
        class: `${a}-date-time-range`
      }, [ee(FI, A, null), s.value && ee(DI, l, null)]);
    };
  }
  const JW = [...UY, ...SI, ...QI];
  var zY = La(HW, JW);
  const VW = OA()(["range", "open", "appendToBody", "clearable", "confirm", "disabled", "editable", "multiple", "partialUpdate", "showHour", "showMinute", "showSecond", "showTimeHeader", "showTimePanel", "showWeekNumber", "use12h"]), TF = {
    date: "YYYY-MM-DD",
    datetime: "YYYY-MM-DD HH:mm:ss",
    year: "YYYY",
    month: "YYYY-MM",
    time: "HH:mm:ss",
    week: "w"
  };
  function PY(t, {
    slots: e
  }) {
    const i = t.type || "date", r = t.format || TF[i] || TF.date, n = hs(ur({}, rW(t, VW)), {
      type: i,
      format: r
    });
    return ee(SF, da(n, SF.props), ur({
      content: (s) => {
        if (n.range) {
          const o = i === "time" ? DI : i === "datetime" ? zY : FI;
          return ju(o, da(ur(ur({}, n), s), o.props));
        } else {
          const o = i === "time" ? tg : i === "datetime" ? LY : zy;
          return ju(o, da(ur(ur({}, n), s), o.props));
        }
      },
      "icon-calendar": () => i === "time" ? ee(yW, null, null) : ee(_Y, null, null)
    }, e));
  }
  const WW = {
    locale: FY,
    install: (t) => {
      t.component("DatePicker", PY);
    }
  };
  var KW = Object.assign(PY, WW, {
    Calendar: zy,
    CalendarRange: FI,
    TimePanel: tg,
    TimeRange: DI,
    DateTime: LY,
    DateTimeRange: zY
  });
  //! moment.js
  //! version : 2.30.1
  //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
  //! license : MIT
  //! momentjs.com
  var OY;
  function _e() {
    return OY.apply(null, arguments);
  }
  function XW(t) {
    OY = t;
  }
  function Ks(t) {
    return t instanceof Array || Object.prototype.toString.call(t) === "[object Array]";
  }
  function Il(t) {
    return t != null && Object.prototype.toString.call(t) === "[object Object]";
  }
  function Wt(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  function TI(t) {
    if (Object.getOwnPropertyNames)
      return Object.getOwnPropertyNames(t).length === 0;
    var e;
    for (e in t)
      if (Wt(t, e))
        return !1;
    return !0;
  }
  function hn(t) {
    return t === void 0;
  }
  function xa(t) {
    return typeof t == "number" || Object.prototype.toString.call(t) === "[object Number]";
  }
  function Xg(t) {
    return t instanceof Date || Object.prototype.toString.call(t) === "[object Date]";
  }
  function GY(t, e) {
    var i = [], r, n = t.length;
    for (r = 0; r < n; ++r)
      i.push(e(t[r], r));
    return i;
  }
  function cA(t, e) {
    for (var i in e)
      Wt(e, i) && (t[i] = e[i]);
    return Wt(e, "toString") && (t.toString = e.toString), Wt(e, "valueOf") && (t.valueOf = e.valueOf), t;
  }
  function Oo(t, e, i, r) {
    return dN(t, e, i, r, !0).utc();
  }
  function ZW() {
    return {
      empty: !1,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: !1,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: !1,
      userInvalidated: !1,
      iso: !1,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: !1,
      weekdayMismatch: !1
    };
  }
  function xt(t) {
    return t._pf == null && (t._pf = ZW()), t._pf;
  }
  var qC;
  Array.prototype.some ? qC = Array.prototype.some : qC = function(t) {
    var e = Object(this), i = e.length >>> 0, r;
    for (r = 0; r < i; r++)
      if (r in e && t.call(this, e[r], r, e))
        return !0;
    return !1;
  };
  function RI(t) {
    var e = null, i = !1, r = t._d && !isNaN(t._d.getTime());
    if (r && (e = xt(t), i = qC.call(e.parsedDateParts, function(n) {
      return n != null;
    }), r = e.overflow < 0 && !e.empty && !e.invalidEra && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && i), t._strict && (r = r && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && e.bigHour === void 0)), Object.isFrozen == null || !Object.isFrozen(t))
      t._isValid = r;
    else
      return r;
    return t._isValid;
  }
  function Oy(t) {
    var e = Oo(NaN);
    return t != null ? cA(xt(e), t) : xt(e).userInvalidated = !0, e;
  }
  var RF = _e.momentProperties = [], Tw = !1;
  function _I(t, e) {
    var i, r, n, s = RF.length;
    if (hn(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), hn(e._i) || (t._i = e._i), hn(e._f) || (t._f = e._f), hn(e._l) || (t._l = e._l), hn(e._strict) || (t._strict = e._strict), hn(e._tzm) || (t._tzm = e._tzm), hn(e._isUTC) || (t._isUTC = e._isUTC), hn(e._offset) || (t._offset = e._offset), hn(e._pf) || (t._pf = xt(e)), hn(e._locale) || (t._locale = e._locale), s > 0)
      for (i = 0; i < s; i++)
        r = RF[i], n = e[r], hn(n) || (t[r] = n);
    return t;
  }
  function Zg(t) {
    _I(this, t), this._d = new Date(t._d != null ? t._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Tw === !1 && (Tw = !0, _e.updateOffset(this), Tw = !1);
  }
  function Xs(t) {
    return t instanceof Zg || t != null && t._isAMomentObject != null;
  }
  function jY(t) {
    _e.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + t);
  }
  function Es(t, e) {
    var i = !0;
    return cA(function() {
      if (_e.deprecationHandler != null && _e.deprecationHandler(null, t), i) {
        var r = [], n, s, o, a = arguments.length;
        for (s = 0; s < a; s++) {
          if (n = "", typeof arguments[s] == "object") {
            n += `
[` + s + "] ";
            for (o in arguments[0])
              Wt(arguments[0], o) && (n += o + ": " + arguments[0][o] + ", ");
            n = n.slice(0, -2);
          } else
            n = arguments[s];
          r.push(n);
        }
        jY(
          t + `
Arguments: ` + Array.prototype.slice.call(r).join("") + `
` + new Error().stack
        ), i = !1;
      }
      return e.apply(this, arguments);
    }, e);
  }
  var _F = {};
  function HY(t, e) {
    _e.deprecationHandler != null && _e.deprecationHandler(t, e), _F[t] || (jY(e), _F[t] = !0);
  }
  _e.suppressDeprecationWarnings = !1;
  _e.deprecationHandler = null;
  function Go(t) {
    return typeof Function < "u" && t instanceof Function || Object.prototype.toString.call(t) === "[object Function]";
  }
  function qW(t) {
    var e, i;
    for (i in t)
      Wt(t, i) && (e = t[i], Go(e) ? this[i] = e : this["_" + i] = e);
    this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp(
      (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
    );
  }
  function $C(t, e) {
    var i = cA({}, t), r;
    for (r in e)
      Wt(e, r) && (Il(t[r]) && Il(e[r]) ? (i[r] = {}, cA(i[r], t[r]), cA(i[r], e[r])) : e[r] != null ? i[r] = e[r] : delete i[r]);
    for (r in t)
      Wt(t, r) && !Wt(e, r) && Il(t[r]) && (i[r] = cA({}, i[r]));
    return i;
  }
  function kI(t) {
    t != null && this.set(t);
  }
  var eb;
  Object.keys ? eb = Object.keys : eb = function(t) {
    var e, i = [];
    for (e in t)
      Wt(t, e) && i.push(e);
    return i;
  };
  var $W = {
    sameDay: "[Today at] LT",
    nextDay: "[Tomorrow at] LT",
    nextWeek: "dddd [at] LT",
    lastDay: "[Yesterday at] LT",
    lastWeek: "[Last] dddd [at] LT",
    sameElse: "L"
  };
  function eK(t, e, i) {
    var r = this._calendar[t] || this._calendar.sameElse;
    return Go(r) ? r.call(e, i) : r;
  }
  function zo(t, e, i) {
    var r = "" + Math.abs(t), n = e - r.length, s = t >= 0;
    return (s ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, n)).toString().substr(1) + r;
  }
  var YI = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Zf = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Rw = {}, Iu = {};
  function qe(t, e, i, r) {
    var n = r;
    typeof r == "string" && (n = function() {
      return this[r]();
    }), t && (Iu[t] = n), e && (Iu[e[0]] = function() {
      return zo(n.apply(this, arguments), e[1], e[2]);
    }), i && (Iu[i] = function() {
      return this.localeData().ordinal(
        n.apply(this, arguments),
        t
      );
    });
  }
  function tK(t) {
    return t.match(/\[[\s\S]/) ? t.replace(/^\[|\]$/g, "") : t.replace(/\\/g, "");
  }
  function iK(t) {
    var e = t.match(YI), i, r;
    for (i = 0, r = e.length; i < r; i++)
      Iu[e[i]] ? e[i] = Iu[e[i]] : e[i] = tK(e[i]);
    return function(n) {
      var s = "", o;
      for (o = 0; o < r; o++)
        s += Go(e[o]) ? e[o].call(n, t) : e[o];
      return s;
    };
  }
  function $p(t, e) {
    return t.isValid() ? (e = JY(e, t.localeData()), Rw[e] = Rw[e] || iK(e), Rw[e](t)) : t.localeData().invalidDate();
  }
  function JY(t, e) {
    var i = 5;
    function r(n) {
      return e.longDateFormat(n) || n;
    }
    for (Zf.lastIndex = 0; i >= 0 && Zf.test(t); )
      t = t.replace(
        Zf,
        r
      ), Zf.lastIndex = 0, i -= 1;
    return t;
  }
  var rK = {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "MM/DD/YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A"
  };
  function nK(t) {
    var e = this._longDateFormat[t], i = this._longDateFormat[t.toUpperCase()];
    return e || !i ? e : (this._longDateFormat[t] = i.match(YI).map(function(r) {
      return r === "MMMM" || r === "MM" || r === "DD" || r === "dddd" ? r.slice(1) : r;
    }).join(""), this._longDateFormat[t]);
  }
  var sK = "Invalid date";
  function oK() {
    return this._invalidDate;
  }
  var aK = "%d", AK = /\d{1,2}/;
  function lK(t) {
    return this._ordinal.replace("%d", t);
  }
  var cK = {
    future: "in %s",
    past: "%s ago",
    s: "a few seconds",
    ss: "%d seconds",
    m: "a minute",
    mm: "%d minutes",
    h: "an hour",
    hh: "%d hours",
    d: "a day",
    dd: "%d days",
    w: "a week",
    ww: "%d weeks",
    M: "a month",
    MM: "%d months",
    y: "a year",
    yy: "%d years"
  };
  function uK(t, e, i, r) {
    var n = this._relativeTime[i];
    return Go(n) ? n(t, e, i, r) : n.replace(/%d/i, t);
  }
  function dK(t, e) {
    var i = this._relativeTime[t > 0 ? "future" : "past"];
    return Go(i) ? i(e) : i.replace(/%s/i, e);
  }
  var kF = {
    D: "date",
    dates: "date",
    date: "date",
    d: "day",
    days: "day",
    day: "day",
    e: "weekday",
    weekdays: "weekday",
    weekday: "weekday",
    E: "isoWeekday",
    isoweekdays: "isoWeekday",
    isoweekday: "isoWeekday",
    DDD: "dayOfYear",
    dayofyears: "dayOfYear",
    dayofyear: "dayOfYear",
    h: "hour",
    hours: "hour",
    hour: "hour",
    ms: "millisecond",
    milliseconds: "millisecond",
    millisecond: "millisecond",
    m: "minute",
    minutes: "minute",
    minute: "minute",
    M: "month",
    months: "month",
    month: "month",
    Q: "quarter",
    quarters: "quarter",
    quarter: "quarter",
    s: "second",
    seconds: "second",
    second: "second",
    gg: "weekYear",
    weekyears: "weekYear",
    weekyear: "weekYear",
    GG: "isoWeekYear",
    isoweekyears: "isoWeekYear",
    isoweekyear: "isoWeekYear",
    w: "week",
    weeks: "week",
    week: "week",
    W: "isoWeek",
    isoweeks: "isoWeek",
    isoweek: "isoWeek",
    y: "year",
    years: "year",
    year: "year"
  };
  function ys(t) {
    return typeof t == "string" ? kF[t] || kF[t.toLowerCase()] : void 0;
  }
  function NI(t) {
    var e = {}, i, r;
    for (r in t)
      Wt(t, r) && (i = ys(r), i && (e[i] = t[r]));
    return e;
  }
  var hK = {
    date: 9,
    day: 11,
    weekday: 11,
    isoWeekday: 11,
    dayOfYear: 4,
    hour: 13,
    millisecond: 16,
    minute: 14,
    month: 8,
    quarter: 7,
    second: 15,
    weekYear: 1,
    isoWeekYear: 1,
    week: 5,
    isoWeek: 5,
    year: 1
  };
  function gK(t) {
    var e = [], i;
    for (i in t)
      Wt(t, i) && e.push({ unit: i, priority: hK[i] });
    return e.sort(function(r, n) {
      return r.priority - n.priority;
    }), e;
  }
  var VY = /\d/, Jn = /\d\d/, WY = /\d{3}/, UI = /\d{4}/, Gy = /[+-]?\d{6}/, Ci = /\d\d?/, KY = /\d\d\d\d?/, XY = /\d\d\d\d\d\d?/, jy = /\d{1,3}/, LI = /\d{1,4}/, Hy = /[+-]?\d{1,6}/, Fd = /\d+/, Jy = /[+-]?\d+/, fK = /Z|[+-]\d\d:?\d\d/gi, Vy = /Z|[+-]\d\d(?::?\d\d)?/gi, pK = /[+-]?\d+(\.\d{1,3})?/, qg = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, Sd = /^[1-9]\d?/, zI = /^([1-9]\d|\d)/, AE;
  AE = {};
  function Ue(t, e, i) {
    AE[t] = Go(e) ? e : function(r, n) {
      return r && i ? i : e;
    };
  }
  function mK(t, e) {
    return Wt(AE, t) ? AE[t](e._strict, e._locale) : new RegExp(EK(t));
  }
  function EK(t) {
    return ha(
      t.replace("\\", "").replace(
        /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
        function(e, i, r, n, s) {
          return i || r || n || s;
        }
      )
    );
  }
  function ha(t) {
    return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function es(t) {
    return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
  }
  function Nt(t) {
    var e = +t, i = 0;
    return e !== 0 && isFinite(e) && (i = es(e)), i;
  }
  var tb = {};
  function ui(t, e) {
    var i, r = e, n;
    for (typeof t == "string" && (t = [t]), xa(e) && (r = function(s, o) {
      o[e] = Nt(s);
    }), n = t.length, i = 0; i < n; i++)
      tb[t[i]] = r;
  }
  function $g(t, e) {
    ui(t, function(i, r, n, s) {
      n._w = n._w || {}, e(i, n._w, n, s);
    });
  }
  function yK(t, e, i) {
    e != null && Wt(tb, t) && tb[t](e, i._a, i, t);
  }
  function Wy(t) {
    return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0;
  }
  var Ur = 0, oa = 1, wo = 2, or = 3, ks = 4, aa = 5, gl = 6, BK = 7, wK = 8;
  qe("Y", 0, 0, function() {
    var t = this.year();
    return t <= 9999 ? zo(t, 4) : "+" + t;
  });
  qe(0, ["YY", 2], 0, function() {
    return this.year() % 100;
  });
  qe(0, ["YYYY", 4], 0, "year");
  qe(0, ["YYYYY", 5], 0, "year");
  qe(0, ["YYYYYY", 6, !0], 0, "year");
  Ue("Y", Jy);
  Ue("YY", Ci, Jn);
  Ue("YYYY", LI, UI);
  Ue("YYYYY", Hy, Gy);
  Ue("YYYYYY", Hy, Gy);
  ui(["YYYYY", "YYYYYY"], Ur);
  ui("YYYY", function(t, e) {
    e[Ur] = t.length === 2 ? _e.parseTwoDigitYear(t) : Nt(t);
  });
  ui("YY", function(t, e) {
    e[Ur] = _e.parseTwoDigitYear(t);
  });
  ui("Y", function(t, e) {
    e[Ur] = parseInt(t, 10);
  });
  function Yh(t) {
    return Wy(t) ? 366 : 365;
  }
  _e.parseTwoDigitYear = function(t) {
    return Nt(t) + (Nt(t) > 68 ? 1900 : 2e3);
  };
  var ZY = Dd("FullYear", !0);
  function CK() {
    return Wy(this.year());
  }
  function Dd(t, e) {
    return function(i) {
      return i != null ? (qY(this, t, i), _e.updateOffset(this, e), this) : ig(this, t);
    };
  }
  function ig(t, e) {
    if (!t.isValid())
      return NaN;
    var i = t._d, r = t._isUTC;
    switch (e) {
      case "Milliseconds":
        return r ? i.getUTCMilliseconds() : i.getMilliseconds();
      case "Seconds":
        return r ? i.getUTCSeconds() : i.getSeconds();
      case "Minutes":
        return r ? i.getUTCMinutes() : i.getMinutes();
      case "Hours":
        return r ? i.getUTCHours() : i.getHours();
      case "Date":
        return r ? i.getUTCDate() : i.getDate();
      case "Day":
        return r ? i.getUTCDay() : i.getDay();
      case "Month":
        return r ? i.getUTCMonth() : i.getMonth();
      case "FullYear":
        return r ? i.getUTCFullYear() : i.getFullYear();
      default:
        return NaN;
    }
  }
  function qY(t, e, i) {
    var r, n, s, o, a;
    if (!(!t.isValid() || isNaN(i))) {
      switch (r = t._d, n = t._isUTC, e) {
        case "Milliseconds":
          return void (n ? r.setUTCMilliseconds(i) : r.setMilliseconds(i));
        case "Seconds":
          return void (n ? r.setUTCSeconds(i) : r.setSeconds(i));
        case "Minutes":
          return void (n ? r.setUTCMinutes(i) : r.setMinutes(i));
        case "Hours":
          return void (n ? r.setUTCHours(i) : r.setHours(i));
        case "Date":
          return void (n ? r.setUTCDate(i) : r.setDate(i));
        // case 'Day': // Not real
        //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
        // case 'Month': // Not used because we need to pass two variables
        //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
        case "FullYear":
          break;
        // See below ...
        default:
          return;
      }
      s = i, o = t.month(), a = t.date(), a = a === 29 && o === 1 && !Wy(s) ? 28 : a, n ? r.setUTCFullYear(s, o, a) : r.setFullYear(s, o, a);
    }
  }
  function bK(t) {
    return t = ys(t), Go(this[t]) ? this[t]() : this;
  }
  function MK(t, e) {
    if (typeof t == "object") {
      t = NI(t);
      var i = gK(t), r, n = i.length;
      for (r = 0; r < n; r++)
        this[i[r].unit](t[i[r].unit]);
    } else if (t = ys(t), Go(this[t]))
      return this[t](e);
    return this;
  }
  function IK(t, e) {
    return (t % e + e) % e;
  }
  var Pi;
  Array.prototype.indexOf ? Pi = Array.prototype.indexOf : Pi = function(t) {
    var e;
    for (e = 0; e < this.length; ++e)
      if (this[e] === t)
        return e;
    return -1;
  };
  function PI(t, e) {
    if (isNaN(t) || isNaN(e))
      return NaN;
    var i = IK(e, 12);
    return t += (e - i) / 12, i === 1 ? Wy(t) ? 29 : 28 : 31 - i % 7 % 2;
  }
  qe("M", ["MM", 2], "Mo", function() {
    return this.month() + 1;
  });
  qe("MMM", 0, 0, function(t) {
    return this.localeData().monthsShort(this, t);
  });
  qe("MMMM", 0, 0, function(t) {
    return this.localeData().months(this, t);
  });
  Ue("M", Ci, Sd);
  Ue("MM", Ci, Jn);
  Ue("MMM", function(t, e) {
    return e.monthsShortRegex(t);
  });
  Ue("MMMM", function(t, e) {
    return e.monthsRegex(t);
  });
  ui(["M", "MM"], function(t, e) {
    e[oa] = Nt(t) - 1;
  });
  ui(["MMM", "MMMM"], function(t, e, i, r) {
    var n = i._locale.monthsParse(t, r, i._strict);
    n != null ? e[oa] = n : xt(i).invalidMonth = t;
  });
  var vK = "January_February_March_April_May_June_July_August_September_October_November_December".split(
    "_"
  ), $Y = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), eN = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, xK = qg, QK = qg;
  function FK(t, e) {
    return t ? Ks(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || eN).test(e) ? "format" : "standalone"][t.month()] : Ks(this._months) ? this._months : this._months.standalone;
  }
  function SK(t, e) {
    return t ? Ks(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[eN.test(e) ? "format" : "standalone"][t.month()] : Ks(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
  }
  function DK(t, e, i) {
    var r, n, s, o = t.toLocaleLowerCase();
    if (!this._monthsParse)
      for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], r = 0; r < 12; ++r)
        s = Oo([2e3, r]), this._shortMonthsParse[r] = this.monthsShort(
          s,
          ""
        ).toLocaleLowerCase(), this._longMonthsParse[r] = this.months(s, "").toLocaleLowerCase();
    return i ? e === "MMM" ? (n = Pi.call(this._shortMonthsParse, o), n !== -1 ? n : null) : (n = Pi.call(this._longMonthsParse, o), n !== -1 ? n : null) : e === "MMM" ? (n = Pi.call(this._shortMonthsParse, o), n !== -1 ? n : (n = Pi.call(this._longMonthsParse, o), n !== -1 ? n : null)) : (n = Pi.call(this._longMonthsParse, o), n !== -1 ? n : (n = Pi.call(this._shortMonthsParse, o), n !== -1 ? n : null));
  }
  function TK(t, e, i) {
    var r, n, s;
    if (this._monthsParseExact)
      return DK.call(this, t, e, i);
    for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), r = 0; r < 12; r++) {
      if (n = Oo([2e3, r]), i && !this._longMonthsParse[r] && (this._longMonthsParse[r] = new RegExp(
        "^" + this.months(n, "").replace(".", "") + "$",
        "i"
      ), this._shortMonthsParse[r] = new RegExp(
        "^" + this.monthsShort(n, "").replace(".", "") + "$",
        "i"
      )), !i && !this._monthsParse[r] && (s = "^" + this.months(n, "") + "|^" + this.monthsShort(n, ""), this._monthsParse[r] = new RegExp(s.replace(".", ""), "i")), i && e === "MMMM" && this._longMonthsParse[r].test(t))
        return r;
      if (i && e === "MMM" && this._shortMonthsParse[r].test(t))
        return r;
      if (!i && this._monthsParse[r].test(t))
        return r;
    }
  }
  function tN(t, e) {
    if (!t.isValid())
      return t;
    if (typeof e == "string") {
      if (/^\d+$/.test(e))
        e = Nt(e);
      else if (e = t.localeData().monthsParse(e), !xa(e))
        return t;
    }
    var i = e, r = t.date();
    return r = r < 29 ? r : Math.min(r, PI(t.year(), i)), t._isUTC ? t._d.setUTCMonth(i, r) : t._d.setMonth(i, r), t;
  }
  function iN(t) {
    return t != null ? (tN(this, t), _e.updateOffset(this, !0), this) : ig(this, "Month");
  }
  function RK() {
    return PI(this.year(), this.month());
  }
  function _K(t) {
    return this._monthsParseExact ? (Wt(this, "_monthsRegex") || rN.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (Wt(this, "_monthsShortRegex") || (this._monthsShortRegex = xK), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex);
  }
  function kK(t) {
    return this._monthsParseExact ? (Wt(this, "_monthsRegex") || rN.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (Wt(this, "_monthsRegex") || (this._monthsRegex = QK), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex);
  }
  function rN() {
    function t(A, l) {
      return l.length - A.length;
    }
    var e = [], i = [], r = [], n, s, o, a;
    for (n = 0; n < 12; n++)
      s = Oo([2e3, n]), o = ha(this.monthsShort(s, "")), a = ha(this.months(s, "")), e.push(o), i.push(a), r.push(a), r.push(o);
    e.sort(t), i.sort(t), r.sort(t), this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
      "^(" + i.join("|") + ")",
      "i"
    ), this._monthsShortStrictRegex = new RegExp(
      "^(" + e.join("|") + ")",
      "i"
    );
  }
  function YK(t, e, i, r, n, s, o) {
    var a;
    return t < 100 && t >= 0 ? (a = new Date(t + 400, e, i, r, n, s, o), isFinite(a.getFullYear()) && a.setFullYear(t)) : a = new Date(t, e, i, r, n, s, o), a;
  }
  function rg(t) {
    var e, i;
    return t < 100 && t >= 0 ? (i = Array.prototype.slice.call(arguments), i[0] = t + 400, e = new Date(Date.UTC.apply(null, i)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t)) : e = new Date(Date.UTC.apply(null, arguments)), e;
  }
  function lE(t, e, i) {
    var r = 7 + e - i, n = (7 + rg(t, 0, r).getUTCDay() - e) % 7;
    return -n + r - 1;
  }
  function nN(t, e, i, r, n) {
    var s = (7 + i - r) % 7, o = lE(t, r, n), a = 1 + 7 * (e - 1) + s + o, A, l;
    return a <= 0 ? (A = t - 1, l = Yh(A) + a) : a > Yh(t) ? (A = t + 1, l = a - Yh(t)) : (A = t, l = a), {
      year: A,
      dayOfYear: l
    };
  }
  function ng(t, e, i) {
    var r = lE(t.year(), e, i), n = Math.floor((t.dayOfYear() - r - 1) / 7) + 1, s, o;
    return n < 1 ? (o = t.year() - 1, s = n + ga(o, e, i)) : n > ga(t.year(), e, i) ? (s = n - ga(t.year(), e, i), o = t.year() + 1) : (o = t.year(), s = n), {
      week: s,
      year: o
    };
  }
  function ga(t, e, i) {
    var r = lE(t, e, i), n = lE(t + 1, e, i);
    return (Yh(t) - r + n) / 7;
  }
  qe("w", ["ww", 2], "wo", "week");
  qe("W", ["WW", 2], "Wo", "isoWeek");
  Ue("w", Ci, Sd);
  Ue("ww", Ci, Jn);
  Ue("W", Ci, Sd);
  Ue("WW", Ci, Jn);
  $g(
    ["w", "ww", "W", "WW"],
    function(t, e, i, r) {
      e[r.substr(0, 1)] = Nt(t);
    }
  );
  function NK(t) {
    return ng(t, this._week.dow, this._week.doy).week;
  }
  var UK = {
    dow: 0,
    // Sunday is the first day of the week.
    doy: 6
    // The week that contains Jan 6th is the first week of the year.
  };
  function LK() {
    return this._week.dow;
  }
  function zK() {
    return this._week.doy;
  }
  function PK(t) {
    var e = this.localeData().week(this);
    return t == null ? e : this.add((t - e) * 7, "d");
  }
  function OK(t) {
    var e = ng(this, 1, 4).week;
    return t == null ? e : this.add((t - e) * 7, "d");
  }
  qe("d", 0, "do", "day");
  qe("dd", 0, 0, function(t) {
    return this.localeData().weekdaysMin(this, t);
  });
  qe("ddd", 0, 0, function(t) {
    return this.localeData().weekdaysShort(this, t);
  });
  qe("dddd", 0, 0, function(t) {
    return this.localeData().weekdays(this, t);
  });
  qe("e", 0, 0, "weekday");
  qe("E", 0, 0, "isoWeekday");
  Ue("d", Ci);
  Ue("e", Ci);
  Ue("E", Ci);
  Ue("dd", function(t, e) {
    return e.weekdaysMinRegex(t);
  });
  Ue("ddd", function(t, e) {
    return e.weekdaysShortRegex(t);
  });
  Ue("dddd", function(t, e) {
    return e.weekdaysRegex(t);
  });
  $g(["dd", "ddd", "dddd"], function(t, e, i, r) {
    var n = i._locale.weekdaysParse(t, r, i._strict);
    n != null ? e.d = n : xt(i).invalidWeekday = t;
  });
  $g(["d", "e", "E"], function(t, e, i, r) {
    e[r] = Nt(t);
  });
  function GK(t, e) {
    return typeof t != "string" ? t : isNaN(t) ? (t = e.weekdaysParse(t), typeof t == "number" ? t : null) : parseInt(t, 10);
  }
  function jK(t, e) {
    return typeof t == "string" ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t;
  }
  function OI(t, e) {
    return t.slice(e, 7).concat(t.slice(0, e));
  }
  var HK = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), sN = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), JK = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), VK = qg, WK = qg, KK = qg;
  function XK(t, e) {
    var i = Ks(this._weekdays) ? this._weekdays : this._weekdays[t && t !== !0 && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
    return t === !0 ? OI(i, this._week.dow) : t ? i[t.day()] : i;
  }
  function ZK(t) {
    return t === !0 ? OI(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort;
  }
  function qK(t) {
    return t === !0 ? OI(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin;
  }
  function $K(t, e, i) {
    var r, n, s, o = t.toLocaleLowerCase();
    if (!this._weekdaysParse)
      for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], r = 0; r < 7; ++r)
        s = Oo([2e3, 1]).day(r), this._minWeekdaysParse[r] = this.weekdaysMin(
          s,
          ""
        ).toLocaleLowerCase(), this._shortWeekdaysParse[r] = this.weekdaysShort(
          s,
          ""
        ).toLocaleLowerCase(), this._weekdaysParse[r] = this.weekdays(s, "").toLocaleLowerCase();
    return i ? e === "dddd" ? (n = Pi.call(this._weekdaysParse, o), n !== -1 ? n : null) : e === "ddd" ? (n = Pi.call(this._shortWeekdaysParse, o), n !== -1 ? n : null) : (n = Pi.call(this._minWeekdaysParse, o), n !== -1 ? n : null) : e === "dddd" ? (n = Pi.call(this._weekdaysParse, o), n !== -1 || (n = Pi.call(this._shortWeekdaysParse, o), n !== -1) ? n : (n = Pi.call(this._minWeekdaysParse, o), n !== -1 ? n : null)) : e === "ddd" ? (n = Pi.call(this._shortWeekdaysParse, o), n !== -1 || (n = Pi.call(this._weekdaysParse, o), n !== -1) ? n : (n = Pi.call(this._minWeekdaysParse, o), n !== -1 ? n : null)) : (n = Pi.call(this._minWeekdaysParse, o), n !== -1 || (n = Pi.call(this._weekdaysParse, o), n !== -1) ? n : (n = Pi.call(this._shortWeekdaysParse, o), n !== -1 ? n : null));
  }
  function e6(t, e, i) {
    var r, n, s;
    if (this._weekdaysParseExact)
      return $K.call(this, t, e, i);
    for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), r = 0; r < 7; r++) {
      if (n = Oo([2e3, 1]).day(r), i && !this._fullWeekdaysParse[r] && (this._fullWeekdaysParse[r] = new RegExp(
        "^" + this.weekdays(n, "").replace(".", "\\.?") + "$",
        "i"
      ), this._shortWeekdaysParse[r] = new RegExp(
        "^" + this.weekdaysShort(n, "").replace(".", "\\.?") + "$",
        "i"
      ), this._minWeekdaysParse[r] = new RegExp(
        "^" + this.weekdaysMin(n, "").replace(".", "\\.?") + "$",
        "i"
      )), this._weekdaysParse[r] || (s = "^" + this.weekdays(n, "") + "|^" + this.weekdaysShort(n, "") + "|^" + this.weekdaysMin(n, ""), this._weekdaysParse[r] = new RegExp(s.replace(".", ""), "i")), i && e === "dddd" && this._fullWeekdaysParse[r].test(t))
        return r;
      if (i && e === "ddd" && this._shortWeekdaysParse[r].test(t))
        return r;
      if (i && e === "dd" && this._minWeekdaysParse[r].test(t))
        return r;
      if (!i && this._weekdaysParse[r].test(t))
        return r;
    }
  }
  function t6(t) {
    if (!this.isValid())
      return t != null ? this : NaN;
    var e = ig(this, "Day");
    return t != null ? (t = GK(t, this.localeData()), this.add(t - e, "d")) : e;
  }
  function i6(t) {
    if (!this.isValid())
      return t != null ? this : NaN;
    var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return t == null ? e : this.add(t - e, "d");
  }
  function r6(t) {
    if (!this.isValid())
      return t != null ? this : NaN;
    if (t != null) {
      var e = jK(t, this.localeData());
      return this.day(this.day() % 7 ? e : e - 7);
    } else
      return this.day() || 7;
  }
  function n6(t) {
    return this._weekdaysParseExact ? (Wt(this, "_weekdaysRegex") || GI.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (Wt(this, "_weekdaysRegex") || (this._weekdaysRegex = VK), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex);
  }
  function s6(t) {
    return this._weekdaysParseExact ? (Wt(this, "_weekdaysRegex") || GI.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (Wt(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = WK), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
  }
  function o6(t) {
    return this._weekdaysParseExact ? (Wt(this, "_weekdaysRegex") || GI.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (Wt(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = KK), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
  }
  function GI() {
    function t(c, u) {
      return u.length - c.length;
    }
    var e = [], i = [], r = [], n = [], s, o, a, A, l;
    for (s = 0; s < 7; s++)
      o = Oo([2e3, 1]).day(s), a = ha(this.weekdaysMin(o, "")), A = ha(this.weekdaysShort(o, "")), l = ha(this.weekdays(o, "")), e.push(a), i.push(A), r.push(l), n.push(a), n.push(A), n.push(l);
    e.sort(t), i.sort(t), r.sort(t), n.sort(t), this._weekdaysRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
      "^(" + r.join("|") + ")",
      "i"
    ), this._weekdaysShortStrictRegex = new RegExp(
      "^(" + i.join("|") + ")",
      "i"
    ), this._weekdaysMinStrictRegex = new RegExp(
      "^(" + e.join("|") + ")",
      "i"
    );
  }
  function jI() {
    return this.hours() % 12 || 12;
  }
  function a6() {
    return this.hours() || 24;
  }
  qe("H", ["HH", 2], 0, "hour");
  qe("h", ["hh", 2], 0, jI);
  qe("k", ["kk", 2], 0, a6);
  qe("hmm", 0, 0, function() {
    return "" + jI.apply(this) + zo(this.minutes(), 2);
  });
  qe("hmmss", 0, 0, function() {
    return "" + jI.apply(this) + zo(this.minutes(), 2) + zo(this.seconds(), 2);
  });
  qe("Hmm", 0, 0, function() {
    return "" + this.hours() + zo(this.minutes(), 2);
  });
  qe("Hmmss", 0, 0, function() {
    return "" + this.hours() + zo(this.minutes(), 2) + zo(this.seconds(), 2);
  });
  function oN(t, e) {
    qe(t, 0, 0, function() {
      return this.localeData().meridiem(
        this.hours(),
        this.minutes(),
        e
      );
    });
  }
  oN("a", !0);
  oN("A", !1);
  function aN(t, e) {
    return e._meridiemParse;
  }
  Ue("a", aN);
  Ue("A", aN);
  Ue("H", Ci, zI);
  Ue("h", Ci, Sd);
  Ue("k", Ci, Sd);
  Ue("HH", Ci, Jn);
  Ue("hh", Ci, Jn);
  Ue("kk", Ci, Jn);
  Ue("hmm", KY);
  Ue("hmmss", XY);
  Ue("Hmm", KY);
  Ue("Hmmss", XY);
  ui(["H", "HH"], or);
  ui(["k", "kk"], function(t, e, i) {
    var r = Nt(t);
    e[or] = r === 24 ? 0 : r;
  });
  ui(["a", "A"], function(t, e, i) {
    i._isPm = i._locale.isPM(t), i._meridiem = t;
  });
  ui(["h", "hh"], function(t, e, i) {
    e[or] = Nt(t), xt(i).bigHour = !0;
  });
  ui("hmm", function(t, e, i) {
    var r = t.length - 2;
    e[or] = Nt(t.substr(0, r)), e[ks] = Nt(t.substr(r)), xt(i).bigHour = !0;
  });
  ui("hmmss", function(t, e, i) {
    var r = t.length - 4, n = t.length - 2;
    e[or] = Nt(t.substr(0, r)), e[ks] = Nt(t.substr(r, 2)), e[aa] = Nt(t.substr(n)), xt(i).bigHour = !0;
  });
  ui("Hmm", function(t, e, i) {
    var r = t.length - 2;
    e[or] = Nt(t.substr(0, r)), e[ks] = Nt(t.substr(r));
  });
  ui("Hmmss", function(t, e, i) {
    var r = t.length - 4, n = t.length - 2;
    e[or] = Nt(t.substr(0, r)), e[ks] = Nt(t.substr(r, 2)), e[aa] = Nt(t.substr(n));
  });
  function A6(t) {
    return (t + "").toLowerCase().charAt(0) === "p";
  }
  var l6 = /[ap]\.?m?\.?/i, c6 = Dd("Hours", !0);
  function u6(t, e, i) {
    return t > 11 ? i ? "pm" : "PM" : i ? "am" : "AM";
  }
  var AN = {
    calendar: $W,
    longDateFormat: rK,
    invalidDate: sK,
    ordinal: aK,
    dayOfMonthOrdinalParse: AK,
    relativeTime: cK,
    months: vK,
    monthsShort: $Y,
    week: UK,
    weekdays: HK,
    weekdaysMin: JK,
    weekdaysShort: sN,
    meridiemParse: l6
  }, Mi = {}, qd = {}, sg;
  function d6(t, e) {
    var i, r = Math.min(t.length, e.length);
    for (i = 0; i < r; i += 1)
      if (t[i] !== e[i])
        return i;
    return r;
  }
  function YF(t) {
    return t && t.toLowerCase().replace("_", "-");
  }
  function h6(t) {
    for (var e = 0, i, r, n, s; e < t.length; ) {
      for (s = YF(t[e]).split("-"), i = s.length, r = YF(t[e + 1]), r = r ? r.split("-") : null; i > 0; ) {
        if (n = Ky(s.slice(0, i).join("-")), n)
          return n;
        if (r && r.length >= i && d6(s, r) >= i - 1)
          break;
        i--;
      }
      e++;
    }
    return sg;
  }
  function g6(t) {
    return !!(t && t.match("^[^/\\\\]*$"));
  }
  function Ky(t) {
    var e = null, i;
    if (Mi[t] === void 0 && typeof ss < "u" && ss && ss.exports && g6(t))
      try {
        e = sg._abbr, i = require, i("./locale/" + t), yA(e);
      } catch {
        Mi[t] = null;
      }
    return Mi[t];
  }
  function yA(t, e) {
    var i;
    return t && (hn(e) ? i = Pa(t) : i = HI(t, e), i ? sg = i : typeof console < "u" && console.warn && console.warn(
      "Locale " + t + " not found. Did you forget to load it?"
    )), sg._abbr;
  }
  function HI(t, e) {
    if (e !== null) {
      var i, r = AN;
      if (e.abbr = t, Mi[t] != null)
        HY(
          "defineLocaleOverride",
          "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
        ), r = Mi[t]._config;
      else if (e.parentLocale != null)
        if (Mi[e.parentLocale] != null)
          r = Mi[e.parentLocale]._config;
        else if (i = Ky(e.parentLocale), i != null)
          r = i._config;
        else
          return qd[e.parentLocale] || (qd[e.parentLocale] = []), qd[e.parentLocale].push({
            name: t,
            config: e
          }), null;
      return Mi[t] = new kI($C(r, e)), qd[t] && qd[t].forEach(function(n) {
        HI(n.name, n.config);
      }), yA(t), Mi[t];
    } else
      return delete Mi[t], null;
  }
  function f6(t, e) {
    if (e != null) {
      var i, r, n = AN;
      Mi[t] != null && Mi[t].parentLocale != null ? Mi[t].set($C(Mi[t]._config, e)) : (r = Ky(t), r != null && (n = r._config), e = $C(n, e), r == null && (e.abbr = t), i = new kI(e), i.parentLocale = Mi[t], Mi[t] = i), yA(t);
    } else
      Mi[t] != null && (Mi[t].parentLocale != null ? (Mi[t] = Mi[t].parentLocale, t === yA() && yA(t)) : Mi[t] != null && delete Mi[t]);
    return Mi[t];
  }
  function Pa(t) {
    var e;
    if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t)
      return sg;
    if (!Ks(t)) {
      if (e = Ky(t), e)
        return e;
      t = [t];
    }
    return h6(t);
  }
  function p6() {
    return eb(Mi);
  }
  function JI(t) {
    var e, i = t._a;
    return i && xt(t).overflow === -2 && (e = i[oa] < 0 || i[oa] > 11 ? oa : i[wo] < 1 || i[wo] > PI(i[Ur], i[oa]) ? wo : i[or] < 0 || i[or] > 24 || i[or] === 24 && (i[ks] !== 0 || i[aa] !== 0 || i[gl] !== 0) ? or : i[ks] < 0 || i[ks] > 59 ? ks : i[aa] < 0 || i[aa] > 59 ? aa : i[gl] < 0 || i[gl] > 999 ? gl : -1, xt(t)._overflowDayOfYear && (e < Ur || e > wo) && (e = wo), xt(t)._overflowWeeks && e === -1 && (e = BK), xt(t)._overflowWeekday && e === -1 && (e = wK), xt(t).overflow = e), t;
  }
  var m6 = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, E6 = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, y6 = /Z|[+-]\d\d(?::?\d\d)?/, qf = [
    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
    ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
    ["YYYY-DDD", /\d{4}-\d{3}/],
    ["YYYY-MM", /\d{4}-\d\d/, !1],
    ["YYYYYYMMDD", /[+-]\d{10}/],
    ["YYYYMMDD", /\d{8}/],
    ["GGGG[W]WWE", /\d{4}W\d{3}/],
    ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
    ["YYYYDDD", /\d{7}/],
    ["YYYYMM", /\d{6}/, !1],
    ["YYYY", /\d{4}/, !1]
  ], _w = [
    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
    ["HH:mm", /\d\d:\d\d/],
    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
    ["HHmmss", /\d\d\d\d\d\d/],
    ["HHmm", /\d\d\d\d/],
    ["HH", /\d\d/]
  ], B6 = /^\/?Date\((-?\d+)/i, w6 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, C6 = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function lN(t) {
    var e, i, r = t._i, n = m6.exec(r) || E6.exec(r), s, o, a, A, l = qf.length, c = _w.length;
    if (n) {
      for (xt(t).iso = !0, e = 0, i = l; e < i; e++)
        if (qf[e][1].exec(n[1])) {
          o = qf[e][0], s = qf[e][2] !== !1;
          break;
        }
      if (o == null) {
        t._isValid = !1;
        return;
      }
      if (n[3]) {
        for (e = 0, i = c; e < i; e++)
          if (_w[e][1].exec(n[3])) {
            a = (n[2] || " ") + _w[e][0];
            break;
          }
        if (a == null) {
          t._isValid = !1;
          return;
        }
      }
      if (!s && a != null) {
        t._isValid = !1;
        return;
      }
      if (n[4])
        if (y6.exec(n[4]))
          A = "Z";
        else {
          t._isValid = !1;
          return;
        }
      t._f = o + (a || "") + (A || ""), WI(t);
    } else
      t._isValid = !1;
  }
  function b6(t, e, i, r, n, s) {
    var o = [
      M6(t),
      $Y.indexOf(e),
      parseInt(i, 10),
      parseInt(r, 10),
      parseInt(n, 10)
    ];
    return s && o.push(parseInt(s, 10)), o;
  }
  function M6(t) {
    var e = parseInt(t, 10);
    return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e;
  }
  function I6(t) {
    return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function v6(t, e, i) {
    if (t) {
      var r = sN.indexOf(t), n = new Date(
        e[0],
        e[1],
        e[2]
      ).getDay();
      if (r !== n)
        return xt(i).weekdayMismatch = !0, i._isValid = !1, !1;
    }
    return !0;
  }
  function x6(t, e, i) {
    if (t)
      return C6[t];
    if (e)
      return 0;
    var r = parseInt(i, 10), n = r % 100, s = (r - n) / 100;
    return s * 60 + n;
  }
  function cN(t) {
    var e = w6.exec(I6(t._i)), i;
    if (e) {
      if (i = b6(
        e[4],
        e[3],
        e[2],
        e[5],
        e[6],
        e[7]
      ), !v6(e[1], i, t))
        return;
      t._a = i, t._tzm = x6(e[8], e[9], e[10]), t._d = rg.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), xt(t).rfc2822 = !0;
    } else
      t._isValid = !1;
  }
  function Q6(t) {
    var e = B6.exec(t._i);
    if (e !== null) {
      t._d = /* @__PURE__ */ new Date(+e[1]);
      return;
    }
    if (lN(t), t._isValid === !1)
      delete t._isValid;
    else
      return;
    if (cN(t), t._isValid === !1)
      delete t._isValid;
    else
      return;
    t._strict ? t._isValid = !1 : _e.createFromInputFallback(t);
  }
  _e.createFromInputFallback = Es(
    "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
    function(t) {
      t._d = /* @__PURE__ */ new Date(t._i + (t._useUTC ? " UTC" : ""));
    }
  );
  function Hc(t, e, i) {
    return t ?? e ?? i;
  }
  function F6(t) {
    var e = new Date(_e.now());
    return t._useUTC ? [
      e.getUTCFullYear(),
      e.getUTCMonth(),
      e.getUTCDate()
    ] : [e.getFullYear(), e.getMonth(), e.getDate()];
  }
  function VI(t) {
    var e, i, r = [], n, s, o;
    if (!t._d) {
      for (n = F6(t), t._w && t._a[wo] == null && t._a[oa] == null && S6(t), t._dayOfYear != null && (o = Hc(t._a[Ur], n[Ur]), (t._dayOfYear > Yh(o) || t._dayOfYear === 0) && (xt(t)._overflowDayOfYear = !0), i = rg(o, 0, t._dayOfYear), t._a[oa] = i.getUTCMonth(), t._a[wo] = i.getUTCDate()), e = 0; e < 3 && t._a[e] == null; ++e)
        t._a[e] = r[e] = n[e];
      for (; e < 7; e++)
        t._a[e] = r[e] = t._a[e] == null ? e === 2 ? 1 : 0 : t._a[e];
      t._a[or] === 24 && t._a[ks] === 0 && t._a[aa] === 0 && t._a[gl] === 0 && (t._nextDay = !0, t._a[or] = 0), t._d = (t._useUTC ? rg : YK).apply(
        null,
        r
      ), s = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), t._tzm != null && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[or] = 24), t._w && typeof t._w.d < "u" && t._w.d !== s && (xt(t).weekdayMismatch = !0);
    }
  }
  function S6(t) {
    var e, i, r, n, s, o, a, A, l;
    e = t._w, e.GG != null || e.W != null || e.E != null ? (s = 1, o = 4, i = Hc(
      e.GG,
      t._a[Ur],
      ng(wi(), 1, 4).year
    ), r = Hc(e.W, 1), n = Hc(e.E, 1), (n < 1 || n > 7) && (A = !0)) : (s = t._locale._week.dow, o = t._locale._week.doy, l = ng(wi(), s, o), i = Hc(e.gg, t._a[Ur], l.year), r = Hc(e.w, l.week), e.d != null ? (n = e.d, (n < 0 || n > 6) && (A = !0)) : e.e != null ? (n = e.e + s, (e.e < 0 || e.e > 6) && (A = !0)) : n = s), r < 1 || r > ga(i, s, o) ? xt(t)._overflowWeeks = !0 : A != null ? xt(t)._overflowWeekday = !0 : (a = nN(i, r, n, s, o), t._a[Ur] = a.year, t._dayOfYear = a.dayOfYear);
  }
  _e.ISO_8601 = function() {
  };
  _e.RFC_2822 = function() {
  };
  function WI(t) {
    if (t._f === _e.ISO_8601) {
      lN(t);
      return;
    }
    if (t._f === _e.RFC_2822) {
      cN(t);
      return;
    }
    t._a = [], xt(t).empty = !0;
    var e = "" + t._i, i, r, n, s, o, a = e.length, A = 0, l, c;
    for (n = JY(t._f, t._locale).match(YI) || [], c = n.length, i = 0; i < c; i++)
      s = n[i], r = (e.match(mK(s, t)) || [])[0], r && (o = e.substr(0, e.indexOf(r)), o.length > 0 && xt(t).unusedInput.push(o), e = e.slice(
        e.indexOf(r) + r.length
      ), A += r.length), Iu[s] ? (r ? xt(t).empty = !1 : xt(t).unusedTokens.push(s), yK(s, r, t)) : t._strict && !r && xt(t).unusedTokens.push(s);
    xt(t).charsLeftOver = a - A, e.length > 0 && xt(t).unusedInput.push(e), t._a[or] <= 12 && xt(t).bigHour === !0 && t._a[or] > 0 && (xt(t).bigHour = void 0), xt(t).parsedDateParts = t._a.slice(0), xt(t).meridiem = t._meridiem, t._a[or] = D6(
      t._locale,
      t._a[or],
      t._meridiem
    ), l = xt(t).era, l !== null && (t._a[Ur] = t._locale.erasConvertYear(l, t._a[Ur])), VI(t), JI(t);
  }
  function D6(t, e, i) {
    var r;
    return i == null ? e : t.meridiemHour != null ? t.meridiemHour(e, i) : (t.isPM != null && (r = t.isPM(i), r && e < 12 && (e += 12), !r && e === 12 && (e = 0)), e);
  }
  function T6(t) {
    var e, i, r, n, s, o, a = !1, A = t._f.length;
    if (A === 0) {
      xt(t).invalidFormat = !0, t._d = /* @__PURE__ */ new Date(NaN);
      return;
    }
    for (n = 0; n < A; n++)
      s = 0, o = !1, e = _I({}, t), t._useUTC != null && (e._useUTC = t._useUTC), e._f = t._f[n], WI(e), RI(e) && (o = !0), s += xt(e).charsLeftOver, s += xt(e).unusedTokens.length * 10, xt(e).score = s, a ? s < r && (r = s, i = e) : (r == null || s < r || o) && (r = s, i = e, o && (a = !0));
    cA(t, i || e);
  }
  function R6(t) {
    if (!t._d) {
      var e = NI(t._i), i = e.day === void 0 ? e.date : e.day;
      t._a = GY(
        [e.year, e.month, i, e.hour, e.minute, e.second, e.millisecond],
        function(r) {
          return r && parseInt(r, 10);
        }
      ), VI(t);
    }
  }
  function _6(t) {
    var e = new Zg(JI(uN(t)));
    return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e;
  }
  function uN(t) {
    var e = t._i, i = t._f;
    return t._locale = t._locale || Pa(t._l), e === null || i === void 0 && e === "" ? Oy({ nullInput: !0 }) : (typeof e == "string" && (t._i = e = t._locale.preparse(e)), Xs(e) ? new Zg(JI(e)) : (Xg(e) ? t._d = e : Ks(i) ? T6(t) : i ? WI(t) : k6(t), RI(t) || (t._d = null), t));
  }
  function k6(t) {
    var e = t._i;
    hn(e) ? t._d = new Date(_e.now()) : Xg(e) ? t._d = new Date(e.valueOf()) : typeof e == "string" ? Q6(t) : Ks(e) ? (t._a = GY(e.slice(0), function(i) {
      return parseInt(i, 10);
    }), VI(t)) : Il(e) ? R6(t) : xa(e) ? t._d = new Date(e) : _e.createFromInputFallback(t);
  }
  function dN(t, e, i, r, n) {
    var s = {};
    return (e === !0 || e === !1) && (r = e, e = void 0), (i === !0 || i === !1) && (r = i, i = void 0), (Il(t) && TI(t) || Ks(t) && t.length === 0) && (t = void 0), s._isAMomentObject = !0, s._useUTC = s._isUTC = n, s._l = i, s._i = t, s._f = e, s._strict = r, _6(s);
  }
  function wi(t, e, i, r) {
    return dN(t, e, i, r, !1);
  }
  var Y6 = Es(
    "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
    function() {
      var t = wi.apply(null, arguments);
      return this.isValid() && t.isValid() ? t < this ? this : t : Oy();
    }
  ), N6 = Es(
    "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
    function() {
      var t = wi.apply(null, arguments);
      return this.isValid() && t.isValid() ? t > this ? this : t : Oy();
    }
  );
  function hN(t, e) {
    var i, r;
    if (e.length === 1 && Ks(e[0]) && (e = e[0]), !e.length)
      return wi();
    for (i = e[0], r = 1; r < e.length; ++r)
      (!e[r].isValid() || e[r][t](i)) && (i = e[r]);
    return i;
  }
  function U6() {
    var t = [].slice.call(arguments, 0);
    return hN("isBefore", t);
  }
  function L6() {
    var t = [].slice.call(arguments, 0);
    return hN("isAfter", t);
  }
  var z6 = function() {
    return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
  }, $d = [
    "year",
    "quarter",
    "month",
    "week",
    "day",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  function P6(t) {
    var e, i = !1, r, n = $d.length;
    for (e in t)
      if (Wt(t, e) && !(Pi.call($d, e) !== -1 && (t[e] == null || !isNaN(t[e]))))
        return !1;
    for (r = 0; r < n; ++r)
      if (t[$d[r]]) {
        if (i)
          return !1;
        parseFloat(t[$d[r]]) !== Nt(t[$d[r]]) && (i = !0);
      }
    return !0;
  }
  function O6() {
    return this._isValid;
  }
  function G6() {
    return ro(NaN);
  }
  function Xy(t) {
    var e = NI(t), i = e.year || 0, r = e.quarter || 0, n = e.month || 0, s = e.week || e.isoWeek || 0, o = e.day || 0, a = e.hour || 0, A = e.minute || 0, l = e.second || 0, c = e.millisecond || 0;
    this._isValid = P6(e), this._milliseconds = +c + l * 1e3 + // 1000
    A * 6e4 + // 1000 * 60
    a * 1e3 * 60 * 60, this._days = +o + s * 7, this._months = +n + r * 3 + i * 12, this._data = {}, this._locale = Pa(), this._bubble();
  }
  function em(t) {
    return t instanceof Xy;
  }
  function ib(t) {
    return t < 0 ? Math.round(-1 * t) * -1 : Math.round(t);
  }
  function j6(t, e, i) {
    var r = Math.min(t.length, e.length), n = Math.abs(t.length - e.length), s = 0, o;
    for (o = 0; o < r; o++)
      Nt(t[o]) !== Nt(e[o]) && s++;
    return s + n;
  }
  function gN(t, e) {
    qe(t, 0, 0, function() {
      var i = this.utcOffset(), r = "+";
      return i < 0 && (i = -i, r = "-"), r + zo(~~(i / 60), 2) + e + zo(~~i % 60, 2);
    });
  }
  gN("Z", ":");
  gN("ZZ", "");
  Ue("Z", Vy);
  Ue("ZZ", Vy);
  ui(["Z", "ZZ"], function(t, e, i) {
    i._useUTC = !0, i._tzm = KI(Vy, t);
  });
  var H6 = /([\+\-]|\d\d)/gi;
  function KI(t, e) {
    var i = (e || "").match(t), r, n, s;
    return i === null ? null : (r = i[i.length - 1] || [], n = (r + "").match(H6) || ["-", 0, 0], s = +(n[1] * 60) + Nt(n[2]), s === 0 ? 0 : n[0] === "+" ? s : -s);
  }
  function XI(t, e) {
    var i, r;
    return e._isUTC ? (i = e.clone(), r = (Xs(t) || Xg(t) ? t.valueOf() : wi(t).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + r), _e.updateOffset(i, !1), i) : wi(t).local();
  }
  function rb(t) {
    return -Math.round(t._d.getTimezoneOffset());
  }
  _e.updateOffset = function() {
  };
  function J6(t, e, i) {
    var r = this._offset || 0, n;
    if (!this.isValid())
      return t != null ? this : NaN;
    if (t != null) {
      if (typeof t == "string") {
        if (t = KI(Vy, t), t === null)
          return this;
      } else Math.abs(t) < 16 && !i && (t = t * 60);
      return !this._isUTC && e && (n = rb(this)), this._offset = t, this._isUTC = !0, n != null && this.add(n, "m"), r !== t && (!e || this._changeInProgress ? mN(
        this,
        ro(t - r, "m"),
        1,
        !1
      ) : this._changeInProgress || (this._changeInProgress = !0, _e.updateOffset(this, !0), this._changeInProgress = null)), this;
    } else
      return this._isUTC ? r : rb(this);
  }
  function V6(t, e) {
    return t != null ? (typeof t != "string" && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset();
  }
  function W6(t) {
    return this.utcOffset(0, t);
  }
  function K6(t) {
    return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(rb(this), "m")), this;
  }
  function X6() {
    if (this._tzm != null)
      this.utcOffset(this._tzm, !1, !0);
    else if (typeof this._i == "string") {
      var t = KI(fK, this._i);
      t != null ? this.utcOffset(t) : this.utcOffset(0, !0);
    }
    return this;
  }
  function Z6(t) {
    return this.isValid() ? (t = t ? wi(t).utcOffset() : 0, (this.utcOffset() - t) % 60 === 0) : !1;
  }
  function q6() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function $6() {
    if (!hn(this._isDSTShifted))
      return this._isDSTShifted;
    var t = {}, e;
    return _I(t, this), t = uN(t), t._a ? (e = t._isUTC ? Oo(t._a) : wi(t._a), this._isDSTShifted = this.isValid() && j6(t._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
  }
  function e7() {
    return this.isValid() ? !this._isUTC : !1;
  }
  function t7() {
    return this.isValid() ? this._isUTC : !1;
  }
  function fN() {
    return this.isValid() ? this._isUTC && this._offset === 0 : !1;
  }
  var i7 = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, r7 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function ro(t, e) {
    var i = t, r = null, n, s, o;
    return em(t) ? i = {
      ms: t._milliseconds,
      d: t._days,
      M: t._months
    } : xa(t) || !isNaN(+t) ? (i = {}, e ? i[e] = +t : i.milliseconds = +t) : (r = i7.exec(t)) ? (n = r[1] === "-" ? -1 : 1, i = {
      y: 0,
      d: Nt(r[wo]) * n,
      h: Nt(r[or]) * n,
      m: Nt(r[ks]) * n,
      s: Nt(r[aa]) * n,
      ms: Nt(ib(r[gl] * 1e3)) * n
      // the millisecond decimal point is included in the match
    }) : (r = r7.exec(t)) ? (n = r[1] === "-" ? -1 : 1, i = {
      y: $A(r[2], n),
      M: $A(r[3], n),
      w: $A(r[4], n),
      d: $A(r[5], n),
      h: $A(r[6], n),
      m: $A(r[7], n),
      s: $A(r[8], n)
    }) : i == null ? i = {} : typeof i == "object" && ("from" in i || "to" in i) && (o = n7(
      wi(i.from),
      wi(i.to)
    ), i = {}, i.ms = o.milliseconds, i.M = o.months), s = new Xy(i), em(t) && Wt(t, "_locale") && (s._locale = t._locale), em(t) && Wt(t, "_isValid") && (s._isValid = t._isValid), s;
  }
  ro.fn = Xy.prototype;
  ro.invalid = G6;
  function $A(t, e) {
    var i = t && parseFloat(t.replace(",", "."));
    return (isNaN(i) ? 0 : i) * e;
  }
  function NF(t, e) {
    var i = {};
    return i.months = e.month() - t.month() + (e.year() - t.year()) * 12, t.clone().add(i.months, "M").isAfter(e) && --i.months, i.milliseconds = +e - +t.clone().add(i.months, "M"), i;
  }
  function n7(t, e) {
    var i;
    return t.isValid() && e.isValid() ? (e = XI(e, t), t.isBefore(e) ? i = NF(t, e) : (i = NF(e, t), i.milliseconds = -i.milliseconds, i.months = -i.months), i) : { milliseconds: 0, months: 0 };
  }
  function pN(t, e) {
    return function(i, r) {
      var n, s;
      return r !== null && !isNaN(+r) && (HY(
        e,
        "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      ), s = i, i = r, r = s), n = ro(i, r), mN(this, n, t), this;
    };
  }
  function mN(t, e, i, r) {
    var n = e._milliseconds, s = ib(e._days), o = ib(e._months);
    t.isValid() && (r = r ?? !0, o && tN(t, ig(t, "Month") + o * i), s && qY(t, "Date", ig(t, "Date") + s * i), n && t._d.setTime(t._d.valueOf() + n * i), r && _e.updateOffset(t, s || o));
  }
  var s7 = pN(1, "add"), o7 = pN(-1, "subtract");
  function EN(t) {
    return typeof t == "string" || t instanceof String;
  }
  function a7(t) {
    return Xs(t) || Xg(t) || EN(t) || xa(t) || l7(t) || A7(t) || t === null || t === void 0;
  }
  function A7(t) {
    var e = Il(t) && !TI(t), i = !1, r = [
      "years",
      "year",
      "y",
      "months",
      "month",
      "M",
      "days",
      "day",
      "d",
      "dates",
      "date",
      "D",
      "hours",
      "hour",
      "h",
      "minutes",
      "minute",
      "m",
      "seconds",
      "second",
      "s",
      "milliseconds",
      "millisecond",
      "ms"
    ], n, s, o = r.length;
    for (n = 0; n < o; n += 1)
      s = r[n], i = i || Wt(t, s);
    return e && i;
  }
  function l7(t) {
    var e = Ks(t), i = !1;
    return e && (i = t.filter(function(r) {
      return !xa(r) && EN(t);
    }).length === 0), e && i;
  }
  function c7(t) {
    var e = Il(t) && !TI(t), i = !1, r = [
      "sameDay",
      "nextDay",
      "lastDay",
      "nextWeek",
      "lastWeek",
      "sameElse"
    ], n, s;
    for (n = 0; n < r.length; n += 1)
      s = r[n], i = i || Wt(t, s);
    return e && i;
  }
  function u7(t, e) {
    var i = t.diff(e, "days", !0);
    return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse";
  }
  function d7(t, e) {
    arguments.length === 1 && (arguments[0] ? a7(arguments[0]) ? (t = arguments[0], e = void 0) : c7(arguments[0]) && (e = arguments[0], t = void 0) : (t = void 0, e = void 0));
    var i = t || wi(), r = XI(i, this).startOf("day"), n = _e.calendarFormat(this, r) || "sameElse", s = e && (Go(e[n]) ? e[n].call(this, i) : e[n]);
    return this.format(
      s || this.localeData().calendar(n, this, wi(i))
    );
  }
  function h7() {
    return new Zg(this);
  }
  function g7(t, e) {
    var i = Xs(t) ? t : wi(t);
    return this.isValid() && i.isValid() ? (e = ys(e) || "millisecond", e === "millisecond" ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(e).valueOf()) : !1;
  }
  function f7(t, e) {
    var i = Xs(t) ? t : wi(t);
    return this.isValid() && i.isValid() ? (e = ys(e) || "millisecond", e === "millisecond" ? this.valueOf() < i.valueOf() : this.clone().endOf(e).valueOf() < i.valueOf()) : !1;
  }
  function p7(t, e, i, r) {
    var n = Xs(t) ? t : wi(t), s = Xs(e) ? e : wi(e);
    return this.isValid() && n.isValid() && s.isValid() ? (r = r || "()", (r[0] === "(" ? this.isAfter(n, i) : !this.isBefore(n, i)) && (r[1] === ")" ? this.isBefore(s, i) : !this.isAfter(s, i))) : !1;
  }
  function m7(t, e) {
    var i = Xs(t) ? t : wi(t), r;
    return this.isValid() && i.isValid() ? (e = ys(e) || "millisecond", e === "millisecond" ? this.valueOf() === i.valueOf() : (r = i.valueOf(), this.clone().startOf(e).valueOf() <= r && r <= this.clone().endOf(e).valueOf())) : !1;
  }
  function E7(t, e) {
    return this.isSame(t, e) || this.isAfter(t, e);
  }
  function y7(t, e) {
    return this.isSame(t, e) || this.isBefore(t, e);
  }
  function B7(t, e, i) {
    var r, n, s;
    if (!this.isValid())
      return NaN;
    if (r = XI(t, this), !r.isValid())
      return NaN;
    switch (n = (r.utcOffset() - this.utcOffset()) * 6e4, e = ys(e), e) {
      case "year":
        s = tm(this, r) / 12;
        break;
      case "month":
        s = tm(this, r);
        break;
      case "quarter":
        s = tm(this, r) / 3;
        break;
      case "second":
        s = (this - r) / 1e3;
        break;
      // 1000
      case "minute":
        s = (this - r) / 6e4;
        break;
      // 1000 * 60
      case "hour":
        s = (this - r) / 36e5;
        break;
      // 1000 * 60 * 60
      case "day":
        s = (this - r - n) / 864e5;
        break;
      // 1000 * 60 * 60 * 24, negate dst
      case "week":
        s = (this - r - n) / 6048e5;
        break;
      // 1000 * 60 * 60 * 24 * 7, negate dst
      default:
        s = this - r;
    }
    return i ? s : es(s);
  }
  function tm(t, e) {
    if (t.date() < e.date())
      return -tm(e, t);
    var i = (e.year() - t.year()) * 12 + (e.month() - t.month()), r = t.clone().add(i, "months"), n, s;
    return e - r < 0 ? (n = t.clone().add(i - 1, "months"), s = (e - r) / (r - n)) : (n = t.clone().add(i + 1, "months"), s = (e - r) / (n - r)), -(i + s) || 0;
  }
  _e.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
  _e.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
  function w7() {
    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
  }
  function C7(t) {
    if (!this.isValid())
      return null;
    var e = t !== !0, i = e ? this.clone().utc() : this;
    return i.year() < 0 || i.year() > 9999 ? $p(
      i,
      e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    ) : Go(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", $p(i, "Z")) : $p(
      i,
      e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  function b7() {
    if (!this.isValid())
      return "moment.invalid(/* " + this._i + " */)";
    var t = "moment", e = "", i, r, n, s;
    return this.isLocal() || (t = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", e = "Z"), i = "[" + t + '("]', r = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", n = "-MM-DD[T]HH:mm:ss.SSS", s = e + '[")]', this.format(i + r + n + s);
  }
  function M7(t) {
    t || (t = this.isUtc() ? _e.defaultFormatUtc : _e.defaultFormat);
    var e = $p(this, t);
    return this.localeData().postformat(e);
  }
  function I7(t, e) {
    return this.isValid() && (Xs(t) && t.isValid() || wi(t).isValid()) ? ro({ to: this, from: t }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
  }
  function v7(t) {
    return this.from(wi(), t);
  }
  function x7(t, e) {
    return this.isValid() && (Xs(t) && t.isValid() || wi(t).isValid()) ? ro({ from: this, to: t }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
  }
  function Q7(t) {
    return this.to(wi(), t);
  }
  function yN(t) {
    var e;
    return t === void 0 ? this._locale._abbr : (e = Pa(t), e != null && (this._locale = e), this);
  }
  var BN = Es(
    "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
    function(t) {
      return t === void 0 ? this.localeData() : this.locale(t);
    }
  );
  function wN() {
    return this._locale;
  }
  var cE = 1e3, vu = 60 * cE, uE = 60 * vu, CN = (365 * 400 + 97) * 24 * uE;
  function xu(t, e) {
    return (t % e + e) % e;
  }
  function bN(t, e, i) {
    return t < 100 && t >= 0 ? new Date(t + 400, e, i) - CN : new Date(t, e, i).valueOf();
  }
  function MN(t, e, i) {
    return t < 100 && t >= 0 ? Date.UTC(t + 400, e, i) - CN : Date.UTC(t, e, i);
  }
  function F7(t) {
    var e, i;
    if (t = ys(t), t === void 0 || t === "millisecond" || !this.isValid())
      return this;
    switch (i = this._isUTC ? MN : bN, t) {
      case "year":
        e = i(this.year(), 0, 1);
        break;
      case "quarter":
        e = i(
          this.year(),
          this.month() - this.month() % 3,
          1
        );
        break;
      case "month":
        e = i(this.year(), this.month(), 1);
        break;
      case "week":
        e = i(
          this.year(),
          this.month(),
          this.date() - this.weekday()
        );
        break;
      case "isoWeek":
        e = i(
          this.year(),
          this.month(),
          this.date() - (this.isoWeekday() - 1)
        );
        break;
      case "day":
      case "date":
        e = i(this.year(), this.month(), this.date());
        break;
      case "hour":
        e = this._d.valueOf(), e -= xu(
          e + (this._isUTC ? 0 : this.utcOffset() * vu),
          uE
        );
        break;
      case "minute":
        e = this._d.valueOf(), e -= xu(e, vu);
        break;
      case "second":
        e = this._d.valueOf(), e -= xu(e, cE);
        break;
    }
    return this._d.setTime(e), _e.updateOffset(this, !0), this;
  }
  function S7(t) {
    var e, i;
    if (t = ys(t), t === void 0 || t === "millisecond" || !this.isValid())
      return this;
    switch (i = this._isUTC ? MN : bN, t) {
      case "year":
        e = i(this.year() + 1, 0, 1) - 1;
        break;
      case "quarter":
        e = i(
          this.year(),
          this.month() - this.month() % 3 + 3,
          1
        ) - 1;
        break;
      case "month":
        e = i(this.year(), this.month() + 1, 1) - 1;
        break;
      case "week":
        e = i(
          this.year(),
          this.month(),
          this.date() - this.weekday() + 7
        ) - 1;
        break;
      case "isoWeek":
        e = i(
          this.year(),
          this.month(),
          this.date() - (this.isoWeekday() - 1) + 7
        ) - 1;
        break;
      case "day":
      case "date":
        e = i(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case "hour":
        e = this._d.valueOf(), e += uE - xu(
          e + (this._isUTC ? 0 : this.utcOffset() * vu),
          uE
        ) - 1;
        break;
      case "minute":
        e = this._d.valueOf(), e += vu - xu(e, vu) - 1;
        break;
      case "second":
        e = this._d.valueOf(), e += cE - xu(e, cE) - 1;
        break;
    }
    return this._d.setTime(e), _e.updateOffset(this, !0), this;
  }
  function D7() {
    return this._d.valueOf() - (this._offset || 0) * 6e4;
  }
  function T7() {
    return Math.floor(this.valueOf() / 1e3);
  }
  function R7() {
    return new Date(this.valueOf());
  }
  function _7() {
    var t = this;
    return [
      t.year(),
      t.month(),
      t.date(),
      t.hour(),
      t.minute(),
      t.second(),
      t.millisecond()
    ];
  }
  function k7() {
    var t = this;
    return {
      years: t.year(),
      months: t.month(),
      date: t.date(),
      hours: t.hours(),
      minutes: t.minutes(),
      seconds: t.seconds(),
      milliseconds: t.milliseconds()
    };
  }
  function Y7() {
    return this.isValid() ? this.toISOString() : null;
  }
  function N7() {
    return RI(this);
  }
  function U7() {
    return cA({}, xt(this));
  }
  function L7() {
    return xt(this).overflow;
  }
  function z7() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }
  qe("N", 0, 0, "eraAbbr");
  qe("NN", 0, 0, "eraAbbr");
  qe("NNN", 0, 0, "eraAbbr");
  qe("NNNN", 0, 0, "eraName");
  qe("NNNNN", 0, 0, "eraNarrow");
  qe("y", ["y", 1], "yo", "eraYear");
  qe("y", ["yy", 2], 0, "eraYear");
  qe("y", ["yyy", 3], 0, "eraYear");
  qe("y", ["yyyy", 4], 0, "eraYear");
  Ue("N", ZI);
  Ue("NN", ZI);
  Ue("NNN", ZI);
  Ue("NNNN", Z7);
  Ue("NNNNN", q7);
  ui(
    ["N", "NN", "NNN", "NNNN", "NNNNN"],
    function(t, e, i, r) {
      var n = i._locale.erasParse(t, r, i._strict);
      n ? xt(i).era = n : xt(i).invalidEra = t;
    }
  );
  Ue("y", Fd);
  Ue("yy", Fd);
  Ue("yyy", Fd);
  Ue("yyyy", Fd);
  Ue("yo", $7);
  ui(["y", "yy", "yyy", "yyyy"], Ur);
  ui(["yo"], function(t, e, i, r) {
    var n;
    i._locale._eraYearOrdinalRegex && (n = t.match(i._locale._eraYearOrdinalRegex)), i._locale.eraYearOrdinalParse ? e[Ur] = i._locale.eraYearOrdinalParse(t, n) : e[Ur] = parseInt(t, 10);
  });
  function P7(t, e) {
    var i, r, n, s = this._eras || Pa("en")._eras;
    for (i = 0, r = s.length; i < r; ++i) {
      switch (typeof s[i].since) {
        case "string":
          n = _e(s[i].since).startOf("day"), s[i].since = n.valueOf();
          break;
      }
      switch (typeof s[i].until) {
        case "undefined":
          s[i].until = 1 / 0;
          break;
        case "string":
          n = _e(s[i].until).startOf("day").valueOf(), s[i].until = n.valueOf();
          break;
      }
    }
    return s;
  }
  function O7(t, e, i) {
    var r, n, s = this.eras(), o, a, A;
    for (t = t.toUpperCase(), r = 0, n = s.length; r < n; ++r)
      if (o = s[r].name.toUpperCase(), a = s[r].abbr.toUpperCase(), A = s[r].narrow.toUpperCase(), i)
        switch (e) {
          case "N":
          case "NN":
          case "NNN":
            if (a === t)
              return s[r];
            break;
          case "NNNN":
            if (o === t)
              return s[r];
            break;
          case "NNNNN":
            if (A === t)
              return s[r];
            break;
        }
      else if ([o, a, A].indexOf(t) >= 0)
        return s[r];
  }
  function G7(t, e) {
    var i = t.since <= t.until ? 1 : -1;
    return e === void 0 ? _e(t.since).year() : _e(t.since).year() + (e - t.offset) * i;
  }
  function j7() {
    var t, e, i, r = this.localeData().eras();
    for (t = 0, e = r.length; t < e; ++t)
      if (i = this.clone().startOf("day").valueOf(), r[t].since <= i && i <= r[t].until || r[t].until <= i && i <= r[t].since)
        return r[t].name;
    return "";
  }
  function H7() {
    var t, e, i, r = this.localeData().eras();
    for (t = 0, e = r.length; t < e; ++t)
      if (i = this.clone().startOf("day").valueOf(), r[t].since <= i && i <= r[t].until || r[t].until <= i && i <= r[t].since)
        return r[t].narrow;
    return "";
  }
  function J7() {
    var t, e, i, r = this.localeData().eras();
    for (t = 0, e = r.length; t < e; ++t)
      if (i = this.clone().startOf("day").valueOf(), r[t].since <= i && i <= r[t].until || r[t].until <= i && i <= r[t].since)
        return r[t].abbr;
    return "";
  }
  function V7() {
    var t, e, i, r, n = this.localeData().eras();
    for (t = 0, e = n.length; t < e; ++t)
      if (i = n[t].since <= n[t].until ? 1 : -1, r = this.clone().startOf("day").valueOf(), n[t].since <= r && r <= n[t].until || n[t].until <= r && r <= n[t].since)
        return (this.year() - _e(n[t].since).year()) * i + n[t].offset;
    return this.year();
  }
  function W7(t) {
    return Wt(this, "_erasNameRegex") || qI.call(this), t ? this._erasNameRegex : this._erasRegex;
  }
  function K7(t) {
    return Wt(this, "_erasAbbrRegex") || qI.call(this), t ? this._erasAbbrRegex : this._erasRegex;
  }
  function X7(t) {
    return Wt(this, "_erasNarrowRegex") || qI.call(this), t ? this._erasNarrowRegex : this._erasRegex;
  }
  function ZI(t, e) {
    return e.erasAbbrRegex(t);
  }
  function Z7(t, e) {
    return e.erasNameRegex(t);
  }
  function q7(t, e) {
    return e.erasNarrowRegex(t);
  }
  function $7(t, e) {
    return e._eraYearOrdinalRegex || Fd;
  }
  function qI() {
    var t = [], e = [], i = [], r = [], n, s, o, a, A, l = this.eras();
    for (n = 0, s = l.length; n < s; ++n)
      o = ha(l[n].name), a = ha(l[n].abbr), A = ha(l[n].narrow), e.push(o), t.push(a), i.push(A), r.push(o), r.push(a), r.push(A);
    this._erasRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + t.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
      "^(" + i.join("|") + ")",
      "i"
    );
  }
  qe(0, ["gg", 2], 0, function() {
    return this.weekYear() % 100;
  });
  qe(0, ["GG", 2], 0, function() {
    return this.isoWeekYear() % 100;
  });
  function Zy(t, e) {
    qe(0, [t, t.length], 0, e);
  }
  Zy("gggg", "weekYear");
  Zy("ggggg", "weekYear");
  Zy("GGGG", "isoWeekYear");
  Zy("GGGGG", "isoWeekYear");
  Ue("G", Jy);
  Ue("g", Jy);
  Ue("GG", Ci, Jn);
  Ue("gg", Ci, Jn);
  Ue("GGGG", LI, UI);
  Ue("gggg", LI, UI);
  Ue("GGGGG", Hy, Gy);
  Ue("ggggg", Hy, Gy);
  $g(
    ["gggg", "ggggg", "GGGG", "GGGGG"],
    function(t, e, i, r) {
      e[r.substr(0, 2)] = Nt(t);
    }
  );
  $g(["gg", "GG"], function(t, e, i, r) {
    e[r] = _e.parseTwoDigitYear(t);
  });
  function e9(t) {
    return IN.call(
      this,
      t,
      this.week(),
      this.weekday() + this.localeData()._week.dow,
      this.localeData()._week.dow,
      this.localeData()._week.doy
    );
  }
  function t9(t) {
    return IN.call(
      this,
      t,
      this.isoWeek(),
      this.isoWeekday(),
      1,
      4
    );
  }
  function i9() {
    return ga(this.year(), 1, 4);
  }
  function r9() {
    return ga(this.isoWeekYear(), 1, 4);
  }
  function n9() {
    var t = this.localeData()._week;
    return ga(this.year(), t.dow, t.doy);
  }
  function s9() {
    var t = this.localeData()._week;
    return ga(this.weekYear(), t.dow, t.doy);
  }
  function IN(t, e, i, r, n) {
    var s;
    return t == null ? ng(this, r, n).year : (s = ga(t, r, n), e > s && (e = s), o9.call(this, t, e, i, r, n));
  }
  function o9(t, e, i, r, n) {
    var s = nN(t, e, i, r, n), o = rg(s.year, 0, s.dayOfYear);
    return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this;
  }
  qe("Q", 0, "Qo", "quarter");
  Ue("Q", VY);
  ui("Q", function(t, e) {
    e[oa] = (Nt(t) - 1) * 3;
  });
  function a9(t) {
    return t == null ? Math.ceil((this.month() + 1) / 3) : this.month((t - 1) * 3 + this.month() % 3);
  }
  qe("D", ["DD", 2], "Do", "date");
  Ue("D", Ci, Sd);
  Ue("DD", Ci, Jn);
  Ue("Do", function(t, e) {
    return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
  });
  ui(["D", "DD"], wo);
  ui("Do", function(t, e) {
    e[wo] = Nt(t.match(Ci)[0]);
  });
  var vN = Dd("Date", !0);
  qe("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
  Ue("DDD", jy);
  Ue("DDDD", WY);
  ui(["DDD", "DDDD"], function(t, e, i) {
    i._dayOfYear = Nt(t);
  });
  function A9(t) {
    var e = Math.round(
      (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
    ) + 1;
    return t == null ? e : this.add(t - e, "d");
  }
  qe("m", ["mm", 2], 0, "minute");
  Ue("m", Ci, zI);
  Ue("mm", Ci, Jn);
  ui(["m", "mm"], ks);
  var l9 = Dd("Minutes", !1);
  qe("s", ["ss", 2], 0, "second");
  Ue("s", Ci, zI);
  Ue("ss", Ci, Jn);
  ui(["s", "ss"], aa);
  var c9 = Dd("Seconds", !1);
  qe("S", 0, 0, function() {
    return ~~(this.millisecond() / 100);
  });
  qe(0, ["SS", 2], 0, function() {
    return ~~(this.millisecond() / 10);
  });
  qe(0, ["SSS", 3], 0, "millisecond");
  qe(0, ["SSSS", 4], 0, function() {
    return this.millisecond() * 10;
  });
  qe(0, ["SSSSS", 5], 0, function() {
    return this.millisecond() * 100;
  });
  qe(0, ["SSSSSS", 6], 0, function() {
    return this.millisecond() * 1e3;
  });
  qe(0, ["SSSSSSS", 7], 0, function() {
    return this.millisecond() * 1e4;
  });
  qe(0, ["SSSSSSSS", 8], 0, function() {
    return this.millisecond() * 1e5;
  });
  qe(0, ["SSSSSSSSS", 9], 0, function() {
    return this.millisecond() * 1e6;
  });
  Ue("S", jy, VY);
  Ue("SS", jy, Jn);
  Ue("SSS", jy, WY);
  var uA, xN;
  for (uA = "SSSS"; uA.length <= 9; uA += "S")
    Ue(uA, Fd);
  function u9(t, e) {
    e[gl] = Nt(("0." + t) * 1e3);
  }
  for (uA = "S"; uA.length <= 9; uA += "S")
    ui(uA, u9);
  xN = Dd("Milliseconds", !1);
  qe("z", 0, 0, "zoneAbbr");
  qe("zz", 0, 0, "zoneName");
  function d9() {
    return this._isUTC ? "UTC" : "";
  }
  function h9() {
    return this._isUTC ? "Coordinated Universal Time" : "";
  }
  var Ie = Zg.prototype;
  Ie.add = s7;
  Ie.calendar = d7;
  Ie.clone = h7;
  Ie.diff = B7;
  Ie.endOf = S7;
  Ie.format = M7;
  Ie.from = I7;
  Ie.fromNow = v7;
  Ie.to = x7;
  Ie.toNow = Q7;
  Ie.get = bK;
  Ie.invalidAt = L7;
  Ie.isAfter = g7;
  Ie.isBefore = f7;
  Ie.isBetween = p7;
  Ie.isSame = m7;
  Ie.isSameOrAfter = E7;
  Ie.isSameOrBefore = y7;
  Ie.isValid = N7;
  Ie.lang = BN;
  Ie.locale = yN;
  Ie.localeData = wN;
  Ie.max = N6;
  Ie.min = Y6;
  Ie.parsingFlags = U7;
  Ie.set = MK;
  Ie.startOf = F7;
  Ie.subtract = o7;
  Ie.toArray = _7;
  Ie.toObject = k7;
  Ie.toDate = R7;
  Ie.toISOString = C7;
  Ie.inspect = b7;
  typeof Symbol < "u" && Symbol.for != null && (Ie[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  });
  Ie.toJSON = Y7;
  Ie.toString = w7;
  Ie.unix = T7;
  Ie.valueOf = D7;
  Ie.creationData = z7;
  Ie.eraName = j7;
  Ie.eraNarrow = H7;
  Ie.eraAbbr = J7;
  Ie.eraYear = V7;
  Ie.year = ZY;
  Ie.isLeapYear = CK;
  Ie.weekYear = e9;
  Ie.isoWeekYear = t9;
  Ie.quarter = Ie.quarters = a9;
  Ie.month = iN;
  Ie.daysInMonth = RK;
  Ie.week = Ie.weeks = PK;
  Ie.isoWeek = Ie.isoWeeks = OK;
  Ie.weeksInYear = n9;
  Ie.weeksInWeekYear = s9;
  Ie.isoWeeksInYear = i9;
  Ie.isoWeeksInISOWeekYear = r9;
  Ie.date = vN;
  Ie.day = Ie.days = t6;
  Ie.weekday = i6;
  Ie.isoWeekday = r6;
  Ie.dayOfYear = A9;
  Ie.hour = Ie.hours = c6;
  Ie.minute = Ie.minutes = l9;
  Ie.second = Ie.seconds = c9;
  Ie.millisecond = Ie.milliseconds = xN;
  Ie.utcOffset = J6;
  Ie.utc = W6;
  Ie.local = K6;
  Ie.parseZone = X6;
  Ie.hasAlignedHourOffset = Z6;
  Ie.isDST = q6;
  Ie.isLocal = e7;
  Ie.isUtcOffset = t7;
  Ie.isUtc = fN;
  Ie.isUTC = fN;
  Ie.zoneAbbr = d9;
  Ie.zoneName = h9;
  Ie.dates = Es(
    "dates accessor is deprecated. Use date instead.",
    vN
  );
  Ie.months = Es(
    "months accessor is deprecated. Use month instead",
    iN
  );
  Ie.years = Es(
    "years accessor is deprecated. Use year instead",
    ZY
  );
  Ie.zone = Es(
    "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
    V6
  );
  Ie.isDSTShifted = Es(
    "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
    $6
  );
  function g9(t) {
    return wi(t * 1e3);
  }
  function f9() {
    return wi.apply(null, arguments).parseZone();
  }
  function QN(t) {
    return t;
  }
  var Kt = kI.prototype;
  Kt.calendar = eK;
  Kt.longDateFormat = nK;
  Kt.invalidDate = oK;
  Kt.ordinal = lK;
  Kt.preparse = QN;
  Kt.postformat = QN;
  Kt.relativeTime = uK;
  Kt.pastFuture = dK;
  Kt.set = qW;
  Kt.eras = P7;
  Kt.erasParse = O7;
  Kt.erasConvertYear = G7;
  Kt.erasAbbrRegex = K7;
  Kt.erasNameRegex = W7;
  Kt.erasNarrowRegex = X7;
  Kt.months = FK;
  Kt.monthsShort = SK;
  Kt.monthsParse = TK;
  Kt.monthsRegex = kK;
  Kt.monthsShortRegex = _K;
  Kt.week = NK;
  Kt.firstDayOfYear = zK;
  Kt.firstDayOfWeek = LK;
  Kt.weekdays = XK;
  Kt.weekdaysMin = qK;
  Kt.weekdaysShort = ZK;
  Kt.weekdaysParse = e6;
  Kt.weekdaysRegex = n6;
  Kt.weekdaysShortRegex = s6;
  Kt.weekdaysMinRegex = o6;
  Kt.isPM = A6;
  Kt.meridiem = u6;
  function dE(t, e, i, r) {
    var n = Pa(), s = Oo().set(r, e);
    return n[i](s, t);
  }
  function FN(t, e, i) {
    if (xa(t) && (e = t, t = void 0), t = t || "", e != null)
      return dE(t, e, i, "month");
    var r, n = [];
    for (r = 0; r < 12; r++)
      n[r] = dE(t, r, i, "month");
    return n;
  }
  function $I(t, e, i, r) {
    typeof t == "boolean" ? (xa(e) && (i = e, e = void 0), e = e || "") : (e = t, i = e, t = !1, xa(e) && (i = e, e = void 0), e = e || "");
    var n = Pa(), s = t ? n._week.dow : 0, o, a = [];
    if (i != null)
      return dE(e, (i + s) % 7, r, "day");
    for (o = 0; o < 7; o++)
      a[o] = dE(e, (o + s) % 7, r, "day");
    return a;
  }
  function p9(t, e) {
    return FN(t, e, "months");
  }
  function m9(t, e) {
    return FN(t, e, "monthsShort");
  }
  function E9(t, e, i) {
    return $I(t, e, i, "weekdays");
  }
  function y9(t, e, i) {
    return $I(t, e, i, "weekdaysShort");
  }
  function B9(t, e, i) {
    return $I(t, e, i, "weekdaysMin");
  }
  yA("en", {
    eras: [
      {
        since: "0001-01-01",
        until: 1 / 0,
        offset: 1,
        name: "Anno Domini",
        narrow: "AD",
        abbr: "AD"
      },
      {
        since: "0000-12-31",
        until: -1 / 0,
        offset: 1,
        name: "Before Christ",
        narrow: "BC",
        abbr: "BC"
      }
    ],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function(t) {
      var e = t % 10, i = Nt(t % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th";
      return t + i;
    }
  });
  _e.lang = Es(
    "moment.lang is deprecated. Use moment.locale instead.",
    yA
  );
  _e.langData = Es(
    "moment.langData is deprecated. Use moment.localeData instead.",
    Pa
  );
  var Jo = Math.abs;
  function w9() {
    var t = this._data;
    return this._milliseconds = Jo(this._milliseconds), this._days = Jo(this._days), this._months = Jo(this._months), t.milliseconds = Jo(t.milliseconds), t.seconds = Jo(t.seconds), t.minutes = Jo(t.minutes), t.hours = Jo(t.hours), t.months = Jo(t.months), t.years = Jo(t.years), this;
  }
  function SN(t, e, i, r) {
    var n = ro(e, i);
    return t._milliseconds += r * n._milliseconds, t._days += r * n._days, t._months += r * n._months, t._bubble();
  }
  function C9(t, e) {
    return SN(this, t, e, 1);
  }
  function b9(t, e) {
    return SN(this, t, e, -1);
  }
  function UF(t) {
    return t < 0 ? Math.floor(t) : Math.ceil(t);
  }
  function M9() {
    var t = this._milliseconds, e = this._days, i = this._months, r = this._data, n, s, o, a, A;
    return t >= 0 && e >= 0 && i >= 0 || t <= 0 && e <= 0 && i <= 0 || (t += UF(nb(i) + e) * 864e5, e = 0, i = 0), r.milliseconds = t % 1e3, n = es(t / 1e3), r.seconds = n % 60, s = es(n / 60), r.minutes = s % 60, o = es(s / 60), r.hours = o % 24, e += es(o / 24), A = es(DN(e)), i += A, e -= UF(nb(A)), a = es(i / 12), i %= 12, r.days = e, r.months = i, r.years = a, this;
  }
  function DN(t) {
    return t * 4800 / 146097;
  }
  function nb(t) {
    return t * 146097 / 4800;
  }
  function I9(t) {
    if (!this.isValid())
      return NaN;
    var e, i, r = this._milliseconds;
    if (t = ys(t), t === "month" || t === "quarter" || t === "year")
      switch (e = this._days + r / 864e5, i = this._months + DN(e), t) {
        case "month":
          return i;
        case "quarter":
          return i / 3;
        case "year":
          return i / 12;
      }
    else
      switch (e = this._days + Math.round(nb(this._months)), t) {
        case "week":
          return e / 7 + r / 6048e5;
        case "day":
          return e + r / 864e5;
        case "hour":
          return e * 24 + r / 36e5;
        case "minute":
          return e * 1440 + r / 6e4;
        case "second":
          return e * 86400 + r / 1e3;
        // Math.floor prevents floating point math errors here
        case "millisecond":
          return Math.floor(e * 864e5) + r;
        default:
          throw new Error("Unknown unit " + t);
      }
  }
  function Oa(t) {
    return function() {
      return this.as(t);
    };
  }
  var TN = Oa("ms"), v9 = Oa("s"), x9 = Oa("m"), Q9 = Oa("h"), F9 = Oa("d"), S9 = Oa("w"), D9 = Oa("M"), T9 = Oa("Q"), R9 = Oa("y"), _9 = TN;
  function k9() {
    return ro(this);
  }
  function Y9(t) {
    return t = ys(t), this.isValid() ? this[t + "s"]() : NaN;
  }
  function tc(t) {
    return function() {
      return this.isValid() ? this._data[t] : NaN;
    };
  }
  var N9 = tc("milliseconds"), U9 = tc("seconds"), L9 = tc("minutes"), z9 = tc("hours"), P9 = tc("days"), O9 = tc("months"), G9 = tc("years");
  function j9() {
    return es(this.days() / 7);
  }
  var Zo = Math.round, Au = {
    ss: 44,
    // a few seconds to seconds
    s: 45,
    // seconds to minute
    m: 45,
    // minutes to hour
    h: 22,
    // hours to day
    d: 26,
    // days to month/week
    w: null,
    // weeks to month
    M: 11
    // months to year
  };
  function H9(t, e, i, r, n) {
    return n.relativeTime(e || 1, !!i, t, r);
  }
  function J9(t, e, i, r) {
    var n = ro(t).abs(), s = Zo(n.as("s")), o = Zo(n.as("m")), a = Zo(n.as("h")), A = Zo(n.as("d")), l = Zo(n.as("M")), c = Zo(n.as("w")), u = Zo(n.as("y")), d = s <= i.ss && ["s", s] || s < i.s && ["ss", s] || o <= 1 && ["m"] || o < i.m && ["mm", o] || a <= 1 && ["h"] || a < i.h && ["hh", a] || A <= 1 && ["d"] || A < i.d && ["dd", A];
    return i.w != null && (d = d || c <= 1 && ["w"] || c < i.w && ["ww", c]), d = d || l <= 1 && ["M"] || l < i.M && ["MM", l] || u <= 1 && ["y"] || ["yy", u], d[2] = e, d[3] = +t > 0, d[4] = r, H9.apply(null, d);
  }
  function V9(t) {
    return t === void 0 ? Zo : typeof t == "function" ? (Zo = t, !0) : !1;
  }
  function W9(t, e) {
    return Au[t] === void 0 ? !1 : e === void 0 ? Au[t] : (Au[t] = e, t === "s" && (Au.ss = e - 1), !0);
  }
  function K9(t, e) {
    if (!this.isValid())
      return this.localeData().invalidDate();
    var i = !1, r = Au, n, s;
    return typeof t == "object" && (e = t, t = !1), typeof t == "boolean" && (i = t), typeof e == "object" && (r = Object.assign({}, Au, e), e.s != null && e.ss == null && (r.ss = e.s - 1)), n = this.localeData(), s = J9(this, !i, r, n), i && (s = n.pastFuture(+this, s)), n.postformat(s);
  }
  var kw = Math.abs;
  function yc(t) {
    return (t > 0) - (t < 0) || +t;
  }
  function qy() {
    if (!this.isValid())
      return this.localeData().invalidDate();
    var t = kw(this._milliseconds) / 1e3, e = kw(this._days), i = kw(this._months), r, n, s, o, a = this.asSeconds(), A, l, c, u;
    return a ? (r = es(t / 60), n = es(r / 60), t %= 60, r %= 60, s = es(i / 12), i %= 12, o = t ? t.toFixed(3).replace(/\.?0+$/, "") : "", A = a < 0 ? "-" : "", l = yc(this._months) !== yc(a) ? "-" : "", c = yc(this._days) !== yc(a) ? "-" : "", u = yc(this._milliseconds) !== yc(a) ? "-" : "", A + "P" + (s ? l + s + "Y" : "") + (i ? l + i + "M" : "") + (e ? c + e + "D" : "") + (n || r || t ? "T" : "") + (n ? u + n + "H" : "") + (r ? u + r + "M" : "") + (t ? u + o + "S" : "")) : "P0D";
  }
  var Gt = Xy.prototype;
  Gt.isValid = O6;
  Gt.abs = w9;
  Gt.add = C9;
  Gt.subtract = b9;
  Gt.as = I9;
  Gt.asMilliseconds = TN;
  Gt.asSeconds = v9;
  Gt.asMinutes = x9;
  Gt.asHours = Q9;
  Gt.asDays = F9;
  Gt.asWeeks = S9;
  Gt.asMonths = D9;
  Gt.asQuarters = T9;
  Gt.asYears = R9;
  Gt.valueOf = _9;
  Gt._bubble = M9;
  Gt.clone = k9;
  Gt.get = Y9;
  Gt.milliseconds = N9;
  Gt.seconds = U9;
  Gt.minutes = L9;
  Gt.hours = z9;
  Gt.days = P9;
  Gt.weeks = j9;
  Gt.months = O9;
  Gt.years = G9;
  Gt.humanize = K9;
  Gt.toISOString = qy;
  Gt.toString = qy;
  Gt.toJSON = qy;
  Gt.locale = yN;
  Gt.localeData = wN;
  Gt.toIsoString = Es(
    "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
    qy
  );
  Gt.lang = BN;
  qe("X", 0, 0, "unix");
  qe("x", 0, 0, "valueOf");
  Ue("x", Jy);
  Ue("X", pK);
  ui("X", function(t, e, i) {
    i._d = new Date(parseFloat(t) * 1e3);
  });
  ui("x", function(t, e, i) {
    i._d = new Date(Nt(t));
  });
  //! moment.js
  _e.version = "2.30.1";
  XW(wi);
  _e.fn = Ie;
  _e.min = U6;
  _e.max = L6;
  _e.now = z6;
  _e.utc = Oo;
  _e.unix = g9;
  _e.months = p9;
  _e.isDate = Xg;
  _e.locale = yA;
  _e.invalid = Oy;
  _e.duration = ro;
  _e.isMoment = Xs;
  _e.weekdays = E9;
  _e.parseZone = f9;
  _e.localeData = Pa;
  _e.isDuration = em;
  _e.monthsShort = m9;
  _e.weekdaysMin = B9;
  _e.defineLocale = HI;
  _e.updateLocale = f6;
  _e.locales = p6;
  _e.weekdaysShort = y9;
  _e.normalizeUnits = ys;
  _e.relativeTimeRounding = V9;
  _e.relativeTimeThreshold = W9;
  _e.calendarFormat = u7;
  _e.prototype = Ie;
  _e.HTML5_FMT = {
    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
    // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
    // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
    // <input type="datetime-local" step="0.001" />
    DATE: "YYYY-MM-DD",
    // <input type="date" />
    TIME: "HH:mm",
    // <input type="time" />
    TIME_SECONDS: "HH:mm:ss",
    // <input type="time" step="1" />
    TIME_MS: "HH:mm:ss.SSS",
    // <input type="time" step="0.001" />
    WEEK: "GGGG-[W]WW",
    // <input type="week" />
    MONTH: "YYYY-MM"
    // <input type="month" />
  };
  let X9 = 0;
  function vn(t = "", e = "") {
    const i = Math.random().toString(16).substring(2);
    return `${t}${i}${X9++}${e}`;
  }
  const Z9 = je({
    name: "DpsIconButton",
    props: {
      /**
       * Icon to be displayed in the button.
       */
      icon: {
        type: String,
        required: !0
      },
      /**
       * Applies the 'danger' styles to the button.
       * @default false
       */
      danger: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * Disables the button.
       * @default false
       */
      disabled: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * Show a loading spinner.
       * @default undefined
       */
      loading: {
        type: Boolean,
        default: void 0,
        required: !1
      },
      /**
       * The HTML button type attribute. If undefined
       * the type defaults to 'button'.
       * @default undefined
       */
      type: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * The URL that the hyperlink points to.
       * If href is set an anchor
       * element is rendered instead of a button.
       * @default undefined
       */
      href: {
        type: String,
        required: !1,
        default: void 0
      }
    },
    emits: [
      /**
       * Emitted when the button gets clicked.
       */
      "click"
    ],
    computed: {
      typeAttribute() {
        if (!this.href)
          return this.type ? this.type : "button";
      }
    },
    methods: {
      handleClick(t) {
        this.disabled || this.loading ? t.preventDefault() : this.$emit("click", t);
      }
    }
  }), Vn = (t, e) => {
    const i = t.__vccOpts || t;
    for (const [r, n] of e)
      i[r] = n;
    return i;
  }, q9 = ["role"];
  function $9(t, e, i, r, n, s) {
    return G(), De(Nr(t.href ? "a" : "button"), {
      class: he(["dps-icon-button", {
        "dps-icon-button--danger": t.danger,
        "dps-icon-button--disabled": t.disabled,
        "dps-icon-button--loading": t.loading
      }]),
      type: t.typeAttribute,
      href: t.href,
      disabled: t.disabled || t.loading,
      onClick: t.handleClick
    }, {
      default: Ye(() => [
        be("span", {
          class: he(["dps-icon", {
            "dps-icon--ladeanimation": t.loading,
            ["dps-icon--" + t.icon]: !t.loading
          }]),
          role: t.loading ? "status" : void 0,
          "aria-hidden": "true"
        }, null, 10, q9)
      ]),
      _: 1
    }, 8, ["class", "type", "href", "disabled", "onClick"]);
  }
  const RN = /* @__PURE__ */ Vn(Z9, [["render", $9]]);
  je({
    name: "DpsActionMenu",
    components: { DpsIconButton: RN },
    props: {
      /**
       * The unique identifier for the menu.
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * The HTML tag to be used for the menu container.
       * @default "ul"
       */
      tag: {
        type: String,
        default: "ul",
        required: !1
      },
      /**
       * The icon to be used for the trigger button.
       * @default "more-horiz"
       */
      icon: {
        type: String,
        default: "more-horiz",
        required: !1
      },
      /**
       * The label for the trigger button.
       * @default ""
       */
      label: {
        type: String,
        default: "",
        required: !1
      },
      /**
       * The title attribute for the trigger button.
       * @default "Aktions-Menu öffnen"
       */
      title: {
        type: String,
        default: "Aktions-Menu öffnen",
        required: !1
      },
      /**
       * Whether to show a close button in the menu.
       * @default false
       */
      showCloseButton: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * Whether to show a chevron icon in the trigger button.
       * @default false
       */
      showTriggerChevron: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * The headline text for the menu.
       * @default undefined
       */
      headline: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * Whether the menu should automatically close after an action is selected.
       * @default true
       */
      autoClose: {
        type: Boolean,
        default: !0,
        required: !1
      },
      /**
       * Whether the menu is disabled.
       * @default false
       */
      disabled: {
        type: Boolean,
        default: !1,
        required: !1
      }
    },
    emits: [
      /**
       * Emitted when the menu is hidden.
       * @event module:DpsActionMenu#hide
       */
      "hide",
      /**
       * Emitted when the menu is shown.
       * @event module:DpsActionMenu#show
       */
      "show"
    ],
    computed: {
      uniqueId() {
        return this.id ? this.id : vn("dps-action-menu-");
      },
      dropdownElement() {
        return document.getElementById(this.uniqueId);
      },
      dropdownBootstrapElement() {
        if (this.dropdownElement)
          return new window.Bootstrap.Dropdown(this.dropdownElement);
      },
      isHeaderVisible() {
        return this.showCloseButton || this.headline;
      }
    },
    mounted() {
      this.dropdownElement && (this.dropdownElement.addEventListener("hide.bs.dropdown", (t) => {
        this.$emit("hide", t);
      }), this.dropdownElement.addEventListener("show.bs.dropdown", (t) => {
        this.$emit("show", t);
      }));
    }
  });
  je({
    name: "DpsActionMenuItem",
    props: {
      /**
       * The icon displayed before the menu item
       * @default undefined
       */
      icon: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * The title attribute of the menu item
       * @default undefined
       */
      title: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * Disables the menu item.
       * @default false
       */
      disabled: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * The link target attribute.(e.g.: _blank)
       * @default undefined
       */
      target: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * The URL that the hyperlink points to.
       * @default undefined
       */
      href: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * The relationship of the linked URL as space-separated link types.
       * @default undefined
       */
      rel: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * Applies the 'danger' styles (red on hover).
       * @default false
       */
      danger: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * HTML tag of the wrapper element.
       * @default 'li'
       */
      tag: {
        type: String,
        default: "li"
      }
    },
    emits: [
      /**
       * Emitted when the element is clicked.
       * @event module:DPSActionMenuItem#click
       */
      "click"
    ],
    methods: {
      handleClick(t) {
        this.disabled || this.$emit("click", t);
      }
    }
  });
  je({
    name: "DpsAlphabeticFilter",
    props: {
      /**
       * Array of available filter options.
       * @default ["A-G", "H-N", "O-U", "V-Z"]
       */
      options: {
        type: Array,
        default: () => ["A-G", "H-N", "O-U", "V-Z"],
        required: !1
      },
      /**
       * The modelValue
       * @default undefined
       */
      modelValue: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * Requires some option to be active.
       * @default false
       */
      required: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * Disables the component.
       * @default false
       */
      disabled: {
        type: Boolean,
        default: !1,
        required: !1
      }
    },
    emits: [
      /**
       * Emitted when the selected value changes.
       * @event module:DpsAlphabeticFilter#update:modelValue
       */
      "update:modelValue"
    ],
    methods: {
      selectOption(t) {
        let e = t;
        this.disabled || (this.required ? e !== this.modelValue && this.$emit("update:modelValue", e) : (e = e === this.modelValue ? void 0 : t, this.$emit("update:modelValue", e)));
      }
    }
  });
  const eX = je({
    name: "DpsBadge",
    props: {
      /**
       * Determines the styling of the badge.
       * @default undefined
       */
      variant: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Rounds the badge.
       * @default false
       */
      rounded: {
        type: Boolean,
        default: !1
      }
    }
  });
  function tX(t, e, i, r, n, s) {
    return G(), X("span", {
      class: he(["dps-badge", {
        ["dps-badge--" + t.variant]: t.variant,
        "dps-badge--rounded": t.rounded
      }])
    }, [
      ge(t.$slots, "default")
    ], 2);
  }
  const iX = /* @__PURE__ */ Vn(eX, [["render", tX]]), rX = je({
    name: "DpsButton",
    props: {
      /**
       * The HTML button type (ignored when used as a link).
       * When not set defaults to 'button'.
       * @default undefined
       */
      type: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * The URL that the hyperlink points to.
       * When set the component will be rendered as an anchor element.
       * @default undefined
       */
      href: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Disables the button.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Determines the styling of the component.
       * @default undefined
       */
      variant: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Determines the size of the button.
       * @default undefined
       */
      size: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Squared edges.
       * @default false
       */
      squared: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Optional icon displayed inside the button.
       * @default undefined
       */
      icon: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Position of the icon.
       * @default 'start'
       */
      iconPosition: {
        type: String,
        required: !1,
        default: "start"
      },
      /**
       * Removes the padding.
       * @default false
       */
      noPadding: {
        type: Boolean,
        required: !1,
        default: !1
      },
      loading: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the button gets clicked.
       * @event module:DpsButton#click
       */
      "click"
    ],
    computed: {
      typeAttribute() {
        if (!this.href)
          return this.type ? this.type : "button";
      }
    },
    methods: {
      handleClick(t) {
        this.disabled || this.loading ? t.preventDefault() : this.$emit("click", t);
      }
    }
  }), nX = ["role"], sX = {
    key: 1,
    class: "dps-button__text"
  }, oX = ["role"], aX = {
    key: 1,
    class: "dps-button__text"
  };
  function AX(t, e, i, r, n, s) {
    return G(), De(Nr(t.href ? "a" : "button"), {
      class: he(["dps-button", {
        "dps-button--squared": t.squared,
        ["dps-button--size-" + t.size]: t.size,
        ["dps-button--" + t.variant]: t.variant,
        "dps-button--disabled": t.disabled,
        "dps-button--loading": t.loading,
        "dps-button--no-padding": t.noPadding
      }]),
      type: t.typeAttribute,
      href: t.href,
      disabled: t.disabled || t.loading,
      onClick: t.handleClick
    }, {
      default: Ye(() => [
        t.icon || t.loading ? (G(), X(ht, { key: 0 }, [
          t.iconPosition === "start" ? (G(), X("span", {
            key: 0,
            class: he(["dps-icon", {
              "dps-icon--ladeanimation": t.loading,
              ["dps-icon--" + t.icon]: !t.loading
            }]),
            role: t.loading ? "status" : void 0,
            "aria-hidden": "true"
          }, null, 10, nX)) : de("", !0),
          t.$slots.default ? (G(), X("span", sX, [
            ge(t.$slots, "default")
          ])) : de("", !0),
          t.iconPosition === "end" ? (G(), X("span", {
            key: 2,
            class: he(["dps-icon", {
              "dps-icon--ladeanimation": t.loading,
              ["dps-icon--" + t.icon]: !t.loading
            }]),
            role: t.loading ? "status" : void 0,
            "aria-hidden": "true"
          }, null, 10, oX)) : de("", !0)
        ], 64)) : t.variant === "link" || t.variant === "link-darker" ? (G(), X("span", aX, [
          ge(t.$slots, "default")
        ])) : ge(t.$slots, "default", { key: 2 })
      ]),
      _: 3
    }, 8, ["class", "type", "href", "disabled", "onClick"]);
  }
  const vl = /* @__PURE__ */ Vn(rX, [["render", AX]]);
  je({
    name: "DpsCollapsible",
    props: {
      /**
       * The unique identifier for the menu (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Collapsible expanded.
       * @default false
       */
      expanded: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Whether the collapsible can not be interacted with.
       * @default false
       */
      locked: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Size of the collapsible.
       * @default undefined
       */
      size: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Styling of the collapsible.
       * @default undefined
       */
      variant: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Headline text when collapsible is expanded.
       * @default undefined
       */
      toggleTextExpanded: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Headline text when collapsible is not expanded.
       * @default undefined
       */
      toggleText: {
        type: String,
        required: !1,
        default: void 0
      }
    },
    emits: [
      /**
       * Emitted immediately when collapsible content gets hidden.
       * @event module:DpsCollapsible#hide-collapsible
       */
      "hide-collapsible",
      /**
       * Emitted when collapsible content has been hidden (after CSS transitions).
       * @event module:DpsCollapsible#hidden-collapsible
       */
      "hidden-collapsible",
      /**
       * Emitted immediately when collapsible content gets shown.
       * @event module:DpsCollapsible#show-collapsible
       */
      "show-collapsible",
      /**
       * Emitted when collapsible content has been made visible (after CSS transitions).
       * @event module:DpsCollapsible#shown-collapsible
       */
      "shown-collapsible"
    ],
    data() {
      return {
        isExpanded: !1
      };
    },
    computed: {
      uniqueId() {
        return this.id ? this.id : vn("dps-collapsible-");
      }
    },
    watch: {
      expanded(t) {
        this.isExpanded = t;
      }
    },
    mounted() {
      const t = this.$refs.collapsible;
      this.isExpanded = this.expanded, t && (t.addEventListener("hide.bs.collapse", (e) => {
        e.target === e.currentTarget && (e.stopPropagation(), this.isExpanded = !1, this.$emit("hide-collapsible", e));
      }), t.addEventListener("hidden.bs.collapse", (e) => {
        e.target === e.currentTarget && (e.stopPropagation(), this.$emit("hidden-collapsible", e));
      }), t.addEventListener("show.bs.collapse", (e) => {
        e.target === e.currentTarget && (e.stopPropagation(), this.isExpanded = !0, this.$emit("show-collapsible", e));
      }), t.addEventListener("shown.bs.collapse", (e) => {
        e.target === e.currentTarget && (e.stopPropagation(), this.$emit("shown-collapsible", e));
      }));
    }
  });
  const lX = je({
    name: "DpsFilterButton",
    props: {
      /**
       * Disables the button.
       * @default false
       */
      disabled: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * Makes the button readonly.
       * @default false
       */
      readonly: {
        type: Boolean,
        default: !1,
        required: !1
      },
      /**
       * Title attribute of the button.
       * @default undefined
       */
      title: {
        type: String,
        default: void 0,
        required: !1
      }
    },
    emits: [
      /**
       * Emitted when the button is clicked.
       * @event module:DpsFilterButton#click
       */
      "click"
    ],
    computed: {
      titleAttribute() {
        return this.title ? this.title : "Filter entfernen";
      }
    },
    methods: {
      handleClick(t) {
        this.disabled || this.$emit("click", t);
      }
    }
  }), cX = ["title", "disabled"], uX = /* @__PURE__ */ be("span", { class: "dps-icon dps-icon--close" }, null, -1);
  function dX(t, e, i, r, n, s) {
    return G(), X("button", {
      class: he(["dps-filter-button", {
        "dps-filter-button--disabled": t.disabled,
        "dps-filter-button--readonly": t.readonly
      }]),
      type: "button",
      title: t.titleAttribute,
      disabled: t.disabled || t.readonly,
      onClick: e[0] || (e[0] = (...o) => t.handleClick && t.handleClick(...o))
    }, [
      be("span", null, [
        ge(t.$slots, "default")
      ]),
      uX
    ], 10, cX);
  }
  const hX = /* @__PURE__ */ Vn(lX, [["render", dX]]), gX = je({
    name: "DpsFormCheckbox",
    props: {
      /**
       * The unique identifier for the checkbox (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * modelValue of the checkbox.
       * @default undefined
       */
      modelValue: {
        type: [String, Boolean, Number, Array],
        required: !1,
        default: void 0
      },
      /**
       * Name attribute of the input.
       * @default undefined
       */
      name: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Value attribute of the input.
       * @default true
       */
      value: {
        type: [String, Boolean, Number],
        required: !1,
        default: !0
      },
      /**
       * Title attribute of the component.
       * @default undefined
       */
      tooltip: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Disables the checkbox.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      readonly: {
        type: Boolean,
        required: !1,
        default: !1
      },
      error: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Checkbox is displayed as block.
       * @default false
       */
      block: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Truncates the label.
       * @default false
       */
      truncate: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Hides the label.
       * @default false
       */
      hideLabel: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * The size of the component.
       * @default undefined
       */
      size: {
        type: String,
        required: !1,
        default: void 0
      }
    },
    emits: [
      /**
       * Emitted when the value changes.
       * @event module:DpsFormCheckbox#update:modelValue
       */
      "update:modelValue"
    ],
    computed: {
      uniqueId() {
        return this.id ? this.id : vn("dps-form-checkbox-");
      },
      isChecked() {
        return Array.isArray(this.modelValue) ? this.modelValue.includes(this.value) : this.modelValue === this.value;
      }
    },
    methods: {
      handleChange(t) {
        const e = t.target.value;
        let i;
        Array.isArray(this.modelValue) ? (i = [...this.modelValue], this.modelValue.includes(e) ? i = i.filter((r) => r !== e) : i = [...i, e]) : typeof this.modelValue == "boolean" ? (i = !1, this.modelValue !== !!e && (i = !!e)) : typeof this.modelValue == "number" ? (i = 0, this.modelValue !== Number(e) && (i = Number(e))) : (i = "", this.modelValue !== e && (i = e)), this.$emit("update:modelValue", i);
      }
    }
  }), fX = ["id", "name", "value", "checked", "disabled", "readonly"], pX = ["for", "title"], mX = {
    key: 0,
    class: "sr-only"
  };
  function EX(t, e, i, r, n, s) {
    return G(), X("div", {
      class: he(["dps-form-checkbox dps-input-wrapper", {
        ["dps-form-checkbox--size-" + t.size]: t.size,
        "dps-form-checkbox--block": t.block || t.truncate
      }])
    }, [
      be("input", {
        id: t.uniqueId,
        class: he(["dps-form-checkbox__input dps-checkbox", {
          ["dps-checkbox--size-" + t.size]: t.size,
          "dps-checkbox--error": t.error
        }]),
        type: "checkbox",
        name: t.name,
        value: t.value,
        checked: t.isChecked,
        disabled: t.disabled || t.readonly,
        readonly: t.readonly,
        onChange: e[0] || (e[0] = (...o) => t.handleChange && t.handleChange(...o))
      }, null, 42, fX),
      be("label", {
        for: t.uniqueId,
        title: t.tooltip,
        class: he(["dps-form-checkbox__label dps-label", {
          "dps-form-checkbox__label--input-only": t.hideLabel,
          "dps-text--ellipse": t.truncate
        }])
      }, [
        t.hideLabel ? (G(), X("span", mX, [
          ge(t.$slots, "default")
        ])) : ge(t.$slots, "default", { key: 1 })
      ], 10, pX)
    ], 2);
  }
  const _N = /* @__PURE__ */ Vn(gX, [["render", EX]]);
  function yX(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  function BX(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
      var i = function r() {
        return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
      };
      i.prototype = e.prototype;
    } else i = {};
    return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
      var n = Object.getOwnPropertyDescriptor(t, r);
      Object.defineProperty(i, r, n.get ? n : {
        enumerable: !0,
        get: function() {
          return t[r];
        }
      });
    }), i;
  }
  var oo = {}, Is = {}, LF = {}, ao = {}, Yw = {}, zF;
  function wX() {
    return zF || (zF = 1, Object.defineProperty(Yw, "__esModule", { value: !0 }), Yw.default = new Uint16Array(
      // prettier-ignore
      'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map(function(t) {
        return t.charCodeAt(0);
      })
    )), Yw;
  }
  var Nw = {}, PF;
  function CX() {
    return PF || (PF = 1, Object.defineProperty(Nw, "__esModule", { value: !0 }), Nw.default = new Uint16Array(
      // prettier-ignore
      "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map(function(t) {
        return t.charCodeAt(0);
      })
    )), Nw;
  }
  var OF = {}, GF;
  function jF() {
    return GF || (GF = 1, function(t) {
      var e;
      Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceCodePoint = t.fromCodePoint = void 0;
      var i = /* @__PURE__ */ new Map([
        [0, 65533],
        // C1 Unicode control character reference replacements
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376]
      ]);
      t.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
      (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(s) {
        var o = "";
        return s > 65535 && (s -= 65536, o += String.fromCharCode(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), o += String.fromCharCode(s), o;
      };
      function r(s) {
        var o;
        return s >= 55296 && s <= 57343 || s > 1114111 ? 65533 : (o = i.get(s)) !== null && o !== void 0 ? o : s;
      }
      t.replaceCodePoint = r;
      function n(s) {
        return (0, t.fromCodePoint)(r(s));
      }
      t.default = n;
    }(OF)), OF;
  }
  var HF;
  function hE() {
    return HF || (HF = 1, function(t) {
      var e = ao && ao.__createBinding || (Object.create ? function(Q, v, T, S) {
        S === void 0 && (S = T);
        var D = Object.getOwnPropertyDescriptor(v, T);
        (!D || ("get" in D ? !v.__esModule : D.writable || D.configurable)) && (D = { enumerable: !0, get: function() {
          return v[T];
        } }), Object.defineProperty(Q, S, D);
      } : function(Q, v, T, S) {
        S === void 0 && (S = T), Q[S] = v[T];
      }), i = ao && ao.__setModuleDefault || (Object.create ? function(Q, v) {
        Object.defineProperty(Q, "default", { enumerable: !0, value: v });
      } : function(Q, v) {
        Q.default = v;
      }), r = ao && ao.__importStar || function(Q) {
        if (Q && Q.__esModule) return Q;
        var v = {};
        if (Q != null) for (var T in Q) T !== "default" && Object.prototype.hasOwnProperty.call(Q, T) && e(v, Q, T);
        return i(v, Q), v;
      }, n = ao && ao.__importDefault || function(Q) {
        return Q && Q.__esModule ? Q : { default: Q };
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.decodeXML = t.decodeHTMLStrict = t.decodeHTMLAttribute = t.decodeHTML = t.determineBranch = t.EntityDecoder = t.DecodingMode = t.BinTrieFlags = t.fromCodePoint = t.replaceCodePoint = t.decodeCodePoint = t.xmlDecodeTree = t.htmlDecodeTree = void 0;
      var s = n(/* @__PURE__ */ wX());
      t.htmlDecodeTree = s.default;
      var o = n(/* @__PURE__ */ CX());
      t.xmlDecodeTree = o.default;
      var a = r(/* @__PURE__ */ jF());
      t.decodeCodePoint = a.default;
      var A = /* @__PURE__ */ jF();
      Object.defineProperty(t, "replaceCodePoint", { enumerable: !0, get: function() {
        return A.replaceCodePoint;
      } }), Object.defineProperty(t, "fromCodePoint", { enumerable: !0, get: function() {
        return A.fromCodePoint;
      } });
      var l;
      (function(Q) {
        Q[Q.NUM = 35] = "NUM", Q[Q.SEMI = 59] = "SEMI", Q[Q.EQUALS = 61] = "EQUALS", Q[Q.ZERO = 48] = "ZERO", Q[Q.NINE = 57] = "NINE", Q[Q.LOWER_A = 97] = "LOWER_A", Q[Q.LOWER_F = 102] = "LOWER_F", Q[Q.LOWER_X = 120] = "LOWER_X", Q[Q.LOWER_Z = 122] = "LOWER_Z", Q[Q.UPPER_A = 65] = "UPPER_A", Q[Q.UPPER_F = 70] = "UPPER_F", Q[Q.UPPER_Z = 90] = "UPPER_Z";
      })(l || (l = {}));
      var c = 32, u;
      (function(Q) {
        Q[Q.VALUE_LENGTH = 49152] = "VALUE_LENGTH", Q[Q.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", Q[Q.JUMP_TABLE = 127] = "JUMP_TABLE";
      })(u = t.BinTrieFlags || (t.BinTrieFlags = {}));
      function d(Q) {
        return Q >= l.ZERO && Q <= l.NINE;
      }
      function h(Q) {
        return Q >= l.UPPER_A && Q <= l.UPPER_F || Q >= l.LOWER_A && Q <= l.LOWER_F;
      }
      function g(Q) {
        return Q >= l.UPPER_A && Q <= l.UPPER_Z || Q >= l.LOWER_A && Q <= l.LOWER_Z || d(Q);
      }
      function f(Q) {
        return Q === l.EQUALS || g(Q);
      }
      var p;
      (function(Q) {
        Q[Q.EntityStart = 0] = "EntityStart", Q[Q.NumericStart = 1] = "NumericStart", Q[Q.NumericDecimal = 2] = "NumericDecimal", Q[Q.NumericHex = 3] = "NumericHex", Q[Q.NamedEntity = 4] = "NamedEntity";
      })(p || (p = {}));
      var m;
      (function(Q) {
        Q[Q.Legacy = 0] = "Legacy", Q[Q.Strict = 1] = "Strict", Q[Q.Attribute = 2] = "Attribute";
      })(m = t.DecodingMode || (t.DecodingMode = {}));
      var E = (
        /** @class */
        function() {
          function Q(v, T, S) {
            this.decodeTree = v, this.emitCodePoint = T, this.errors = S, this.state = p.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = m.Strict;
          }
          return Q.prototype.startEntity = function(v) {
            this.decodeMode = v, this.state = p.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
          }, Q.prototype.write = function(v, T) {
            switch (this.state) {
              case p.EntityStart:
                return v.charCodeAt(T) === l.NUM ? (this.state = p.NumericStart, this.consumed += 1, this.stateNumericStart(v, T + 1)) : (this.state = p.NamedEntity, this.stateNamedEntity(v, T));
              case p.NumericStart:
                return this.stateNumericStart(v, T);
              case p.NumericDecimal:
                return this.stateNumericDecimal(v, T);
              case p.NumericHex:
                return this.stateNumericHex(v, T);
              case p.NamedEntity:
                return this.stateNamedEntity(v, T);
            }
          }, Q.prototype.stateNumericStart = function(v, T) {
            return T >= v.length ? -1 : (v.charCodeAt(T) | c) === l.LOWER_X ? (this.state = p.NumericHex, this.consumed += 1, this.stateNumericHex(v, T + 1)) : (this.state = p.NumericDecimal, this.stateNumericDecimal(v, T));
          }, Q.prototype.addToNumericResult = function(v, T, S, D) {
            if (T !== S) {
              var F = S - T;
              this.result = this.result * Math.pow(D, F) + parseInt(v.substr(T, F), D), this.consumed += F;
            }
          }, Q.prototype.stateNumericHex = function(v, T) {
            for (var S = T; T < v.length; ) {
              var D = v.charCodeAt(T);
              if (d(D) || h(D))
                T += 1;
              else
                return this.addToNumericResult(v, S, T, 16), this.emitNumericEntity(D, 3);
            }
            return this.addToNumericResult(v, S, T, 16), -1;
          }, Q.prototype.stateNumericDecimal = function(v, T) {
            for (var S = T; T < v.length; ) {
              var D = v.charCodeAt(T);
              if (d(D))
                T += 1;
              else
                return this.addToNumericResult(v, S, T, 10), this.emitNumericEntity(D, 2);
            }
            return this.addToNumericResult(v, S, T, 10), -1;
          }, Q.prototype.emitNumericEntity = function(v, T) {
            var S;
            if (this.consumed <= T)
              return (S = this.errors) === null || S === void 0 || S.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
            if (v === l.SEMI)
              this.consumed += 1;
            else if (this.decodeMode === m.Strict)
              return 0;
            return this.emitCodePoint((0, a.replaceCodePoint)(this.result), this.consumed), this.errors && (v !== l.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
          }, Q.prototype.stateNamedEntity = function(v, T) {
            for (var S = this.decodeTree, D = S[this.treeIndex], F = (D & u.VALUE_LENGTH) >> 14; T < v.length; T++, this.excess++) {
              var R = v.charCodeAt(T);
              if (this.treeIndex = C(S, D, this.treeIndex + Math.max(1, F), R), this.treeIndex < 0)
                return this.result === 0 || // If we are parsing an attribute
                this.decodeMode === m.Attribute && // We shouldn't have consumed any characters after the entity,
                (F === 0 || // And there should be no invalid characters.
                f(R)) ? 0 : this.emitNotTerminatedNamedEntity();
              if (D = S[this.treeIndex], F = (D & u.VALUE_LENGTH) >> 14, F !== 0) {
                if (R === l.SEMI)
                  return this.emitNamedEntityData(this.treeIndex, F, this.consumed + this.excess);
                this.decodeMode !== m.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
              }
            }
            return -1;
          }, Q.prototype.emitNotTerminatedNamedEntity = function() {
            var v, T = this, S = T.result, D = T.decodeTree, F = (D[S] & u.VALUE_LENGTH) >> 14;
            return this.emitNamedEntityData(S, F, this.consumed), (v = this.errors) === null || v === void 0 || v.missingSemicolonAfterCharacterReference(), this.consumed;
          }, Q.prototype.emitNamedEntityData = function(v, T, S) {
            var D = this.decodeTree;
            return this.emitCodePoint(T === 1 ? D[v] & ~u.VALUE_LENGTH : D[v + 1], S), T === 3 && this.emitCodePoint(D[v + 2], S), S;
          }, Q.prototype.end = function() {
            var v;
            switch (this.state) {
              case p.NamedEntity:
                return this.result !== 0 && (this.decodeMode !== m.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
              // Otherwise, emit a numeric entity if we have one.
              case p.NumericDecimal:
                return this.emitNumericEntity(0, 2);
              case p.NumericHex:
                return this.emitNumericEntity(0, 3);
              case p.NumericStart:
                return (v = this.errors) === null || v === void 0 || v.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
              case p.EntityStart:
                return 0;
            }
          }, Q;
        }()
      );
      t.EntityDecoder = E;
      function y(Q) {
        var v = "", T = new E(Q, function(S) {
          return v += (0, a.fromCodePoint)(S);
        });
        return function(S, D) {
          for (var F = 0, R = 0; (R = S.indexOf("&", R)) >= 0; ) {
            v += S.slice(F, R), T.startEntity(D);
            var Y = T.write(
              S,
              // Skip the "&"
              R + 1
            );
            if (Y < 0) {
              F = R + T.end();
              break;
            }
            F = R + Y, R = Y === 0 ? F + 1 : F;
          }
          var L = v + S.slice(F);
          return v = "", L;
        };
      }
      function C(Q, v, T, S) {
        var D = (v & u.BRANCH_LENGTH) >> 7, F = v & u.JUMP_TABLE;
        if (D === 0)
          return F !== 0 && S === F ? T : -1;
        if (F) {
          var R = S - F;
          return R < 0 || R >= D ? -1 : Q[T + R] - 1;
        }
        for (var Y = T, L = Y + D - 1; Y <= L; ) {
          var N = Y + L >>> 1, H = Q[N];
          if (H < S)
            Y = N + 1;
          else if (H > S)
            L = N - 1;
          else
            return Q[N + D];
        }
        return -1;
      }
      t.determineBranch = C;
      var w = y(s.default), M = y(o.default);
      function I(Q, v) {
        return v === void 0 && (v = m.Legacy), w(Q, v);
      }
      t.decodeHTML = I;
      function b(Q) {
        return w(Q, m.Attribute);
      }
      t.decodeHTMLAttribute = b;
      function B(Q) {
        return w(Q, m.Strict);
      }
      t.decodeHTMLStrict = B;
      function x(Q) {
        return M(Q, m.Strict);
      }
      t.decodeXML = x;
    }(ao)), ao;
  }
  var JF;
  function kN() {
    return JF || (JF = 1, function(t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.QuoteType = void 0;
      var e = /* @__PURE__ */ hE(), i;
      (function(d) {
        d[d.Tab = 9] = "Tab", d[d.NewLine = 10] = "NewLine", d[d.FormFeed = 12] = "FormFeed", d[d.CarriageReturn = 13] = "CarriageReturn", d[d.Space = 32] = "Space", d[d.ExclamationMark = 33] = "ExclamationMark", d[d.Number = 35] = "Number", d[d.Amp = 38] = "Amp", d[d.SingleQuote = 39] = "SingleQuote", d[d.DoubleQuote = 34] = "DoubleQuote", d[d.Dash = 45] = "Dash", d[d.Slash = 47] = "Slash", d[d.Zero = 48] = "Zero", d[d.Nine = 57] = "Nine", d[d.Semi = 59] = "Semi", d[d.Lt = 60] = "Lt", d[d.Eq = 61] = "Eq", d[d.Gt = 62] = "Gt", d[d.Questionmark = 63] = "Questionmark", d[d.UpperA = 65] = "UpperA", d[d.LowerA = 97] = "LowerA", d[d.UpperF = 70] = "UpperF", d[d.LowerF = 102] = "LowerF", d[d.UpperZ = 90] = "UpperZ", d[d.LowerZ = 122] = "LowerZ", d[d.LowerX = 120] = "LowerX", d[d.OpeningSquareBracket = 91] = "OpeningSquareBracket";
      })(i || (i = {}));
      var r;
      (function(d) {
        d[d.Text = 1] = "Text", d[d.BeforeTagName = 2] = "BeforeTagName", d[d.InTagName = 3] = "InTagName", d[d.InSelfClosingTag = 4] = "InSelfClosingTag", d[d.BeforeClosingTagName = 5] = "BeforeClosingTagName", d[d.InClosingTagName = 6] = "InClosingTagName", d[d.AfterClosingTagName = 7] = "AfterClosingTagName", d[d.BeforeAttributeName = 8] = "BeforeAttributeName", d[d.InAttributeName = 9] = "InAttributeName", d[d.AfterAttributeName = 10] = "AfterAttributeName", d[d.BeforeAttributeValue = 11] = "BeforeAttributeValue", d[d.InAttributeValueDq = 12] = "InAttributeValueDq", d[d.InAttributeValueSq = 13] = "InAttributeValueSq", d[d.InAttributeValueNq = 14] = "InAttributeValueNq", d[d.BeforeDeclaration = 15] = "BeforeDeclaration", d[d.InDeclaration = 16] = "InDeclaration", d[d.InProcessingInstruction = 17] = "InProcessingInstruction", d[d.BeforeComment = 18] = "BeforeComment", d[d.CDATASequence = 19] = "CDATASequence", d[d.InSpecialComment = 20] = "InSpecialComment", d[d.InCommentLike = 21] = "InCommentLike", d[d.BeforeSpecialS = 22] = "BeforeSpecialS", d[d.SpecialStartSequence = 23] = "SpecialStartSequence", d[d.InSpecialTag = 24] = "InSpecialTag", d[d.BeforeEntity = 25] = "BeforeEntity", d[d.BeforeNumericEntity = 26] = "BeforeNumericEntity", d[d.InNamedEntity = 27] = "InNamedEntity", d[d.InNumericEntity = 28] = "InNumericEntity", d[d.InHexEntity = 29] = "InHexEntity";
      })(r || (r = {}));
      function n(d) {
        return d === i.Space || d === i.NewLine || d === i.Tab || d === i.FormFeed || d === i.CarriageReturn;
      }
      function s(d) {
        return d === i.Slash || d === i.Gt || n(d);
      }
      function o(d) {
        return d >= i.Zero && d <= i.Nine;
      }
      function a(d) {
        return d >= i.LowerA && d <= i.LowerZ || d >= i.UpperA && d <= i.UpperZ;
      }
      function A(d) {
        return d >= i.UpperA && d <= i.UpperF || d >= i.LowerA && d <= i.LowerF;
      }
      var l;
      (function(d) {
        d[d.NoValue = 0] = "NoValue", d[d.Unquoted = 1] = "Unquoted", d[d.Single = 2] = "Single", d[d.Double = 3] = "Double";
      })(l = t.QuoteType || (t.QuoteType = {}));
      var c = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
        CdataEnd: new Uint8Array([93, 93, 62]),
        CommentEnd: new Uint8Array([45, 45, 62]),
        ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
        StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
        TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
        // `</title`
      }, u = (
        /** @class */
        function() {
          function d(h, g) {
            var f = h.xmlMode, p = f === void 0 ? !1 : f, m = h.decodeEntities, E = m === void 0 ? !0 : m;
            this.cbs = g, this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = p, this.decodeEntities = E, this.entityTrie = p ? e.xmlDecodeTree : e.htmlDecodeTree;
          }
          return d.prototype.reset = function() {
            this.state = r.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = r.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
          }, d.prototype.write = function(h) {
            this.offset += this.buffer.length, this.buffer = h, this.parse();
          }, d.prototype.end = function() {
            this.running && this.finish();
          }, d.prototype.pause = function() {
            this.running = !1;
          }, d.prototype.resume = function() {
            this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
          }, d.prototype.getIndex = function() {
            return this.index;
          }, d.prototype.getSectionStart = function() {
            return this.sectionStart;
          }, d.prototype.stateText = function(h) {
            h === i.Lt || !this.decodeEntities && this.fastForwardTo(i.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = r.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && h === i.Amp && (this.state = r.BeforeEntity);
          }, d.prototype.stateSpecialStartSequence = function(h) {
            var g = this.sequenceIndex === this.currentSequence.length, f = g ? (
              // If we are at the end of the sequence, make sure the tag name has ended
              s(h)
            ) : (
              // Otherwise, do a case-insensitive comparison
              (h | 32) === this.currentSequence[this.sequenceIndex]
            );
            if (!f)
              this.isSpecial = !1;
            else if (!g) {
              this.sequenceIndex++;
              return;
            }
            this.sequenceIndex = 0, this.state = r.InTagName, this.stateInTagName(h);
          }, d.prototype.stateInSpecialTag = function(h) {
            if (this.sequenceIndex === this.currentSequence.length) {
              if (h === i.Gt || n(h)) {
                var g = this.index - this.currentSequence.length;
                if (this.sectionStart < g) {
                  var f = this.index;
                  this.index = g, this.cbs.ontext(this.sectionStart, g), this.index = f;
                }
                this.isSpecial = !1, this.sectionStart = g + 2, this.stateInClosingTagName(h);
                return;
              }
              this.sequenceIndex = 0;
            }
            (h | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === c.TitleEnd ? this.decodeEntities && h === i.Amp && (this.state = r.BeforeEntity) : this.fastForwardTo(i.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(h === i.Lt);
          }, d.prototype.stateCDATASequence = function(h) {
            h === c.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === c.Cdata.length && (this.state = r.InCommentLike, this.currentSequence = c.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = r.InDeclaration, this.stateInDeclaration(h));
          }, d.prototype.fastForwardTo = function(h) {
            for (; ++this.index < this.buffer.length + this.offset; )
              if (this.buffer.charCodeAt(this.index - this.offset) === h)
                return !0;
            return this.index = this.buffer.length + this.offset - 1, !1;
          }, d.prototype.stateInCommentLike = function(h) {
            h === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = r.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : h !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
          }, d.prototype.isTagStartChar = function(h) {
            return this.xmlMode ? !s(h) : a(h);
          }, d.prototype.startSpecial = function(h, g) {
            this.isSpecial = !0, this.currentSequence = h, this.sequenceIndex = g, this.state = r.SpecialStartSequence;
          }, d.prototype.stateBeforeTagName = function(h) {
            if (h === i.ExclamationMark)
              this.state = r.BeforeDeclaration, this.sectionStart = this.index + 1;
            else if (h === i.Questionmark)
              this.state = r.InProcessingInstruction, this.sectionStart = this.index + 1;
            else if (this.isTagStartChar(h)) {
              var g = h | 32;
              this.sectionStart = this.index, !this.xmlMode && g === c.TitleEnd[2] ? this.startSpecial(c.TitleEnd, 3) : this.state = !this.xmlMode && g === c.ScriptEnd[2] ? r.BeforeSpecialS : r.InTagName;
            } else h === i.Slash ? this.state = r.BeforeClosingTagName : (this.state = r.Text, this.stateText(h));
          }, d.prototype.stateInTagName = function(h) {
            s(h) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h));
          }, d.prototype.stateBeforeClosingTagName = function(h) {
            n(h) || (h === i.Gt ? this.state = r.Text : (this.state = this.isTagStartChar(h) ? r.InClosingTagName : r.InSpecialComment, this.sectionStart = this.index));
          }, d.prototype.stateInClosingTagName = function(h) {
            (h === i.Gt || n(h)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterClosingTagName, this.stateAfterClosingTagName(h));
          }, d.prototype.stateAfterClosingTagName = function(h) {
            (h === i.Gt || this.fastForwardTo(i.Gt)) && (this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1);
          }, d.prototype.stateBeforeAttributeName = function(h) {
            h === i.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = r.InSpecialTag, this.sequenceIndex = 0) : this.state = r.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : h === i.Slash ? this.state = r.InSelfClosingTag : n(h) || (this.state = r.InAttributeName, this.sectionStart = this.index);
          }, d.prototype.stateInSelfClosingTag = function(h) {
            h === i.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = r.Text, this.baseState = r.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : n(h) || (this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h));
          }, d.prototype.stateInAttributeName = function(h) {
            (h === i.Eq || s(h)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = r.AfterAttributeName, this.stateAfterAttributeName(h));
          }, d.prototype.stateAfterAttributeName = function(h) {
            h === i.Eq ? this.state = r.BeforeAttributeValue : h === i.Slash || h === i.Gt ? (this.cbs.onattribend(l.NoValue, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h)) : n(h) || (this.cbs.onattribend(l.NoValue, this.index), this.state = r.InAttributeName, this.sectionStart = this.index);
          }, d.prototype.stateBeforeAttributeValue = function(h) {
            h === i.DoubleQuote ? (this.state = r.InAttributeValueDq, this.sectionStart = this.index + 1) : h === i.SingleQuote ? (this.state = r.InAttributeValueSq, this.sectionStart = this.index + 1) : n(h) || (this.sectionStart = this.index, this.state = r.InAttributeValueNq, this.stateInAttributeValueNoQuotes(h));
          }, d.prototype.handleInAttributeValue = function(h, g) {
            h === g || !this.decodeEntities && this.fastForwardTo(g) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(g === i.DoubleQuote ? l.Double : l.Single, this.index), this.state = r.BeforeAttributeName) : this.decodeEntities && h === i.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
          }, d.prototype.stateInAttributeValueDoubleQuotes = function(h) {
            this.handleInAttributeValue(h, i.DoubleQuote);
          }, d.prototype.stateInAttributeValueSingleQuotes = function(h) {
            this.handleInAttributeValue(h, i.SingleQuote);
          }, d.prototype.stateInAttributeValueNoQuotes = function(h) {
            n(h) || h === i.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(l.Unquoted, this.index), this.state = r.BeforeAttributeName, this.stateBeforeAttributeName(h)) : this.decodeEntities && h === i.Amp && (this.baseState = this.state, this.state = r.BeforeEntity);
          }, d.prototype.stateBeforeDeclaration = function(h) {
            h === i.OpeningSquareBracket ? (this.state = r.CDATASequence, this.sequenceIndex = 0) : this.state = h === i.Dash ? r.BeforeComment : r.InDeclaration;
          }, d.prototype.stateInDeclaration = function(h) {
            (h === i.Gt || this.fastForwardTo(i.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
          }, d.prototype.stateInProcessingInstruction = function(h) {
            (h === i.Gt || this.fastForwardTo(i.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = r.Text, this.sectionStart = this.index + 1);
          }, d.prototype.stateBeforeComment = function(h) {
            h === i.Dash ? (this.state = r.InCommentLike, this.currentSequence = c.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = r.InDeclaration;
          }, d.prototype.stateInSpecialComment = function(h) {
            (h === i.Gt || this.fastForwardTo(i.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = r.Text, this.sectionStart = this.index + 1);
          }, d.prototype.stateBeforeSpecialS = function(h) {
            var g = h | 32;
            g === c.ScriptEnd[3] ? this.startSpecial(c.ScriptEnd, 4) : g === c.StyleEnd[3] ? this.startSpecial(c.StyleEnd, 4) : (this.state = r.InTagName, this.stateInTagName(h));
          }, d.prototype.stateBeforeEntity = function(h) {
            this.entityExcess = 1, this.entityResult = 0, h === i.Number ? this.state = r.BeforeNumericEntity : h === i.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = r.InNamedEntity, this.stateInNamedEntity(h));
          }, d.prototype.stateInNamedEntity = function(h) {
            if (this.entityExcess += 1, this.trieIndex = (0, e.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, h), this.trieIndex < 0) {
              this.emitNamedEntity(), this.index--;
              return;
            }
            this.trieCurrent = this.entityTrie[this.trieIndex];
            var g = this.trieCurrent & e.BinTrieFlags.VALUE_LENGTH;
            if (g) {
              var f = (g >> 14) - 1;
              if (!this.allowLegacyEntity() && h !== i.Semi)
                this.trieIndex += f;
              else {
                var p = this.index - this.entityExcess + 1;
                p > this.sectionStart && this.emitPartial(this.sectionStart, p), this.entityResult = this.trieIndex, this.trieIndex += f, this.entityExcess = 0, this.sectionStart = this.index + 1, f === 0 && this.emitNamedEntity();
              }
            }
          }, d.prototype.emitNamedEntity = function() {
            if (this.state = this.baseState, this.entityResult !== 0) {
              var h = (this.entityTrie[this.entityResult] & e.BinTrieFlags.VALUE_LENGTH) >> 14;
              switch (h) {
                case 1: {
                  this.emitCodePoint(this.entityTrie[this.entityResult] & ~e.BinTrieFlags.VALUE_LENGTH);
                  break;
                }
                case 2: {
                  this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                  break;
                }
                case 3:
                  this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
              }
            }
          }, d.prototype.stateBeforeNumericEntity = function(h) {
            (h | 32) === i.LowerX ? (this.entityExcess++, this.state = r.InHexEntity) : (this.state = r.InNumericEntity, this.stateInNumericEntity(h));
          }, d.prototype.emitNumericEntity = function(h) {
            var g = this.index - this.entityExcess - 1, f = g + 2 + +(this.state === r.InHexEntity);
            f !== this.index && (g > this.sectionStart && this.emitPartial(this.sectionStart, g), this.sectionStart = this.index + Number(h), this.emitCodePoint((0, e.replaceCodePoint)(this.entityResult))), this.state = this.baseState;
          }, d.prototype.stateInNumericEntity = function(h) {
            h === i.Semi ? this.emitNumericEntity(!0) : o(h) ? (this.entityResult = this.entityResult * 10 + (h - i.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
          }, d.prototype.stateInHexEntity = function(h) {
            h === i.Semi ? this.emitNumericEntity(!0) : o(h) ? (this.entityResult = this.entityResult * 16 + (h - i.Zero), this.entityExcess++) : A(h) ? (this.entityResult = this.entityResult * 16 + ((h | 32) - i.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
          }, d.prototype.allowLegacyEntity = function() {
            return !this.xmlMode && (this.baseState === r.Text || this.baseState === r.InSpecialTag);
          }, d.prototype.cleanup = function() {
            this.running && this.sectionStart !== this.index && (this.state === r.Text || this.state === r.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === r.InAttributeValueDq || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
          }, d.prototype.shouldContinue = function() {
            return this.index < this.buffer.length + this.offset && this.running;
          }, d.prototype.parse = function() {
            for (; this.shouldContinue(); ) {
              var h = this.buffer.charCodeAt(this.index - this.offset);
              switch (this.state) {
                case r.Text: {
                  this.stateText(h);
                  break;
                }
                case r.SpecialStartSequence: {
                  this.stateSpecialStartSequence(h);
                  break;
                }
                case r.InSpecialTag: {
                  this.stateInSpecialTag(h);
                  break;
                }
                case r.CDATASequence: {
                  this.stateCDATASequence(h);
                  break;
                }
                case r.InAttributeValueDq: {
                  this.stateInAttributeValueDoubleQuotes(h);
                  break;
                }
                case r.InAttributeName: {
                  this.stateInAttributeName(h);
                  break;
                }
                case r.InCommentLike: {
                  this.stateInCommentLike(h);
                  break;
                }
                case r.InSpecialComment: {
                  this.stateInSpecialComment(h);
                  break;
                }
                case r.BeforeAttributeName: {
                  this.stateBeforeAttributeName(h);
                  break;
                }
                case r.InTagName: {
                  this.stateInTagName(h);
                  break;
                }
                case r.InClosingTagName: {
                  this.stateInClosingTagName(h);
                  break;
                }
                case r.BeforeTagName: {
                  this.stateBeforeTagName(h);
                  break;
                }
                case r.AfterAttributeName: {
                  this.stateAfterAttributeName(h);
                  break;
                }
                case r.InAttributeValueSq: {
                  this.stateInAttributeValueSingleQuotes(h);
                  break;
                }
                case r.BeforeAttributeValue: {
                  this.stateBeforeAttributeValue(h);
                  break;
                }
                case r.BeforeClosingTagName: {
                  this.stateBeforeClosingTagName(h);
                  break;
                }
                case r.AfterClosingTagName: {
                  this.stateAfterClosingTagName(h);
                  break;
                }
                case r.BeforeSpecialS: {
                  this.stateBeforeSpecialS(h);
                  break;
                }
                case r.InAttributeValueNq: {
                  this.stateInAttributeValueNoQuotes(h);
                  break;
                }
                case r.InSelfClosingTag: {
                  this.stateInSelfClosingTag(h);
                  break;
                }
                case r.InDeclaration: {
                  this.stateInDeclaration(h);
                  break;
                }
                case r.BeforeDeclaration: {
                  this.stateBeforeDeclaration(h);
                  break;
                }
                case r.BeforeComment: {
                  this.stateBeforeComment(h);
                  break;
                }
                case r.InProcessingInstruction: {
                  this.stateInProcessingInstruction(h);
                  break;
                }
                case r.InNamedEntity: {
                  this.stateInNamedEntity(h);
                  break;
                }
                case r.BeforeEntity: {
                  this.stateBeforeEntity(h);
                  break;
                }
                case r.InHexEntity: {
                  this.stateInHexEntity(h);
                  break;
                }
                case r.InNumericEntity: {
                  this.stateInNumericEntity(h);
                  break;
                }
                default:
                  this.stateBeforeNumericEntity(h);
              }
              this.index++;
            }
            this.cleanup();
          }, d.prototype.finish = function() {
            this.state === r.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
          }, d.prototype.handleTrailingData = function() {
            var h = this.buffer.length + this.offset;
            this.state === r.InCommentLike ? this.currentSequence === c.CdataEnd ? this.cbs.oncdata(this.sectionStart, h, 0) : this.cbs.oncomment(this.sectionStart, h, 0) : this.state === r.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === r.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === r.InTagName || this.state === r.BeforeAttributeName || this.state === r.BeforeAttributeValue || this.state === r.AfterAttributeName || this.state === r.InAttributeName || this.state === r.InAttributeValueSq || this.state === r.InAttributeValueDq || this.state === r.InAttributeValueNq || this.state === r.InClosingTagName || this.cbs.ontext(this.sectionStart, h);
          }, d.prototype.emitPartial = function(h, g) {
            this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribdata(h, g) : this.cbs.ontext(h, g);
          }, d.prototype.emitCodePoint = function(h) {
            this.baseState !== r.Text && this.baseState !== r.InSpecialTag ? this.cbs.onattribentity(h) : this.cbs.ontextentity(h);
          }, d;
        }()
      );
      t.default = u;
    }(LF)), LF;
  }
  var VF;
  function WF() {
    if (VF) return Is;
    VF = 1;
    var t = Is && Is.__createBinding || (Object.create ? function(p, m, E, y) {
      y === void 0 && (y = E);
      var C = Object.getOwnPropertyDescriptor(m, E);
      (!C || ("get" in C ? !m.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
        return m[E];
      } }), Object.defineProperty(p, y, C);
    } : function(p, m, E, y) {
      y === void 0 && (y = E), p[y] = m[E];
    }), e = Is && Is.__setModuleDefault || (Object.create ? function(p, m) {
      Object.defineProperty(p, "default", { enumerable: !0, value: m });
    } : function(p, m) {
      p.default = m;
    }), i = Is && Is.__importStar || function(p) {
      if (p && p.__esModule) return p;
      var m = {};
      if (p != null) for (var E in p) E !== "default" && Object.prototype.hasOwnProperty.call(p, E) && t(m, p, E);
      return e(m, p), m;
    };
    Object.defineProperty(Is, "__esModule", { value: !0 }), Is.Parser = void 0;
    var r = i(/* @__PURE__ */ kN()), n = /* @__PURE__ */ hE(), s = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]), o = /* @__PURE__ */ new Set(["p"]), a = /* @__PURE__ */ new Set(["thead", "tbody"]), A = /* @__PURE__ */ new Set(["dd", "dt"]), l = /* @__PURE__ */ new Set(["rt", "rp"]), c = /* @__PURE__ */ new Map([
      ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
      ["th", /* @__PURE__ */ new Set(["th"])],
      ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
      ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
      ["li", /* @__PURE__ */ new Set(["li"])],
      ["p", o],
      ["h1", o],
      ["h2", o],
      ["h3", o],
      ["h4", o],
      ["h5", o],
      ["h6", o],
      ["select", s],
      ["input", s],
      ["output", s],
      ["button", s],
      ["datalist", s],
      ["textarea", s],
      ["option", /* @__PURE__ */ new Set(["option"])],
      ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
      ["dd", A],
      ["dt", A],
      ["address", o],
      ["article", o],
      ["aside", o],
      ["blockquote", o],
      ["details", o],
      ["div", o],
      ["dl", o],
      ["fieldset", o],
      ["figcaption", o],
      ["figure", o],
      ["footer", o],
      ["form", o],
      ["header", o],
      ["hr", o],
      ["main", o],
      ["nav", o],
      ["ol", o],
      ["pre", o],
      ["section", o],
      ["table", o],
      ["ul", o],
      ["rt", l],
      ["rp", l],
      ["tbody", a],
      ["tfoot", a]
    ]), u = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]), d = /* @__PURE__ */ new Set(["math", "svg"]), h = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]), g = /\s|\//, f = (
      /** @class */
      function() {
        function p(m, E) {
          E === void 0 && (E = {});
          var y, C, w, M, I;
          this.options = E, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = m ?? {}, this.lowerCaseTagNames = (y = E.lowerCaseTags) !== null && y !== void 0 ? y : !E.xmlMode, this.lowerCaseAttributeNames = (C = E.lowerCaseAttributeNames) !== null && C !== void 0 ? C : !E.xmlMode, this.tokenizer = new ((w = E.Tokenizer) !== null && w !== void 0 ? w : r.default)(this.options, this), (I = (M = this.cbs).onparserinit) === null || I === void 0 || I.call(M, this);
        }
        return p.prototype.ontext = function(m, E) {
          var y, C, w = this.getSlice(m, E);
          this.endIndex = E - 1, (C = (y = this.cbs).ontext) === null || C === void 0 || C.call(y, w), this.startIndex = E;
        }, p.prototype.ontextentity = function(m) {
          var E, y, C = this.tokenizer.getSectionStart();
          this.endIndex = C - 1, (y = (E = this.cbs).ontext) === null || y === void 0 || y.call(E, (0, n.fromCodePoint)(m)), this.startIndex = C;
        }, p.prototype.isVoidElement = function(m) {
          return !this.options.xmlMode && u.has(m);
        }, p.prototype.onopentagname = function(m, E) {
          this.endIndex = E;
          var y = this.getSlice(m, E);
          this.lowerCaseTagNames && (y = y.toLowerCase()), this.emitOpenTag(y);
        }, p.prototype.emitOpenTag = function(m) {
          var E, y, C, w;
          this.openTagStart = this.startIndex, this.tagname = m;
          var M = !this.options.xmlMode && c.get(m);
          if (M)
            for (; this.stack.length > 0 && M.has(this.stack[this.stack.length - 1]); ) {
              var I = this.stack.pop();
              (y = (E = this.cbs).onclosetag) === null || y === void 0 || y.call(E, I, !0);
            }
          this.isVoidElement(m) || (this.stack.push(m), d.has(m) ? this.foreignContext.push(!0) : h.has(m) && this.foreignContext.push(!1)), (w = (C = this.cbs).onopentagname) === null || w === void 0 || w.call(C, m), this.cbs.onopentag && (this.attribs = {});
        }, p.prototype.endOpenTag = function(m) {
          var E, y;
          this.startIndex = this.openTagStart, this.attribs && ((y = (E = this.cbs).onopentag) === null || y === void 0 || y.call(E, this.tagname, this.attribs, m), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
        }, p.prototype.onopentagend = function(m) {
          this.endIndex = m, this.endOpenTag(!1), this.startIndex = m + 1;
        }, p.prototype.onclosetag = function(m, E) {
          var y, C, w, M, I, b;
          this.endIndex = E;
          var B = this.getSlice(m, E);
          if (this.lowerCaseTagNames && (B = B.toLowerCase()), (d.has(B) || h.has(B)) && this.foreignContext.pop(), this.isVoidElement(B))
            !this.options.xmlMode && B === "br" && ((C = (y = this.cbs).onopentagname) === null || C === void 0 || C.call(y, "br"), (M = (w = this.cbs).onopentag) === null || M === void 0 || M.call(w, "br", {}, !0), (b = (I = this.cbs).onclosetag) === null || b === void 0 || b.call(I, "br", !1));
          else {
            var x = this.stack.lastIndexOf(B);
            if (x !== -1)
              if (this.cbs.onclosetag)
                for (var Q = this.stack.length - x; Q--; )
                  this.cbs.onclosetag(this.stack.pop(), Q !== 0);
              else
                this.stack.length = x;
            else !this.options.xmlMode && B === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
          }
          this.startIndex = E + 1;
        }, p.prototype.onselfclosingtag = function(m) {
          this.endIndex = m, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = m + 1) : this.onopentagend(m);
        }, p.prototype.closeCurrentTag = function(m) {
          var E, y, C = this.tagname;
          this.endOpenTag(m), this.stack[this.stack.length - 1] === C && ((y = (E = this.cbs).onclosetag) === null || y === void 0 || y.call(E, C, !m), this.stack.pop());
        }, p.prototype.onattribname = function(m, E) {
          this.startIndex = m;
          var y = this.getSlice(m, E);
          this.attribname = this.lowerCaseAttributeNames ? y.toLowerCase() : y;
        }, p.prototype.onattribdata = function(m, E) {
          this.attribvalue += this.getSlice(m, E);
        }, p.prototype.onattribentity = function(m) {
          this.attribvalue += (0, n.fromCodePoint)(m);
        }, p.prototype.onattribend = function(m, E) {
          var y, C;
          this.endIndex = E, (C = (y = this.cbs).onattribute) === null || C === void 0 || C.call(y, this.attribname, this.attribvalue, m === r.QuoteType.Double ? '"' : m === r.QuoteType.Single ? "'" : m === r.QuoteType.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
        }, p.prototype.getInstructionName = function(m) {
          var E = m.search(g), y = E < 0 ? m : m.substr(0, E);
          return this.lowerCaseTagNames && (y = y.toLowerCase()), y;
        }, p.prototype.ondeclaration = function(m, E) {
          this.endIndex = E;
          var y = this.getSlice(m, E);
          if (this.cbs.onprocessinginstruction) {
            var C = this.getInstructionName(y);
            this.cbs.onprocessinginstruction("!".concat(C), "!".concat(y));
          }
          this.startIndex = E + 1;
        }, p.prototype.onprocessinginstruction = function(m, E) {
          this.endIndex = E;
          var y = this.getSlice(m, E);
          if (this.cbs.onprocessinginstruction) {
            var C = this.getInstructionName(y);
            this.cbs.onprocessinginstruction("?".concat(C), "?".concat(y));
          }
          this.startIndex = E + 1;
        }, p.prototype.oncomment = function(m, E, y) {
          var C, w, M, I;
          this.endIndex = E, (w = (C = this.cbs).oncomment) === null || w === void 0 || w.call(C, this.getSlice(m, E - y)), (I = (M = this.cbs).oncommentend) === null || I === void 0 || I.call(M), this.startIndex = E + 1;
        }, p.prototype.oncdata = function(m, E, y) {
          var C, w, M, I, b, B, x, Q, v, T;
          this.endIndex = E;
          var S = this.getSlice(m, E - y);
          this.options.xmlMode || this.options.recognizeCDATA ? ((w = (C = this.cbs).oncdatastart) === null || w === void 0 || w.call(C), (I = (M = this.cbs).ontext) === null || I === void 0 || I.call(M, S), (B = (b = this.cbs).oncdataend) === null || B === void 0 || B.call(b)) : ((Q = (x = this.cbs).oncomment) === null || Q === void 0 || Q.call(x, "[CDATA[".concat(S, "]]")), (T = (v = this.cbs).oncommentend) === null || T === void 0 || T.call(v)), this.startIndex = E + 1;
        }, p.prototype.onend = function() {
          var m, E;
          if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var y = this.stack.length; y > 0; this.cbs.onclosetag(this.stack[--y], !0))
              ;
          }
          (E = (m = this.cbs).onend) === null || E === void 0 || E.call(m);
        }, p.prototype.reset = function() {
          var m, E, y, C;
          (E = (m = this.cbs).onreset) === null || E === void 0 || E.call(m), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (C = (y = this.cbs).onparserinit) === null || C === void 0 || C.call(y, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
        }, p.prototype.parseComplete = function(m) {
          this.reset(), this.end(m);
        }, p.prototype.getSlice = function(m, E) {
          for (; m - this.bufferOffset >= this.buffers[0].length; )
            this.shiftBuffer();
          for (var y = this.buffers[0].slice(m - this.bufferOffset, E - this.bufferOffset); E - this.bufferOffset > this.buffers[0].length; )
            this.shiftBuffer(), y += this.buffers[0].slice(0, E - this.bufferOffset);
          return y;
        }, p.prototype.shiftBuffer = function() {
          this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
        }, p.prototype.write = function(m) {
          var E, y;
          if (this.ended) {
            (y = (E = this.cbs).onerror) === null || y === void 0 || y.call(E, new Error(".write() after done!"));
            return;
          }
          this.buffers.push(m), this.tokenizer.running && (this.tokenizer.write(m), this.writeIndex++);
        }, p.prototype.end = function(m) {
          var E, y;
          if (this.ended) {
            (y = (E = this.cbs).onerror) === null || y === void 0 || y.call(E, new Error(".end() after done!"));
            return;
          }
          m && this.write(m), this.ended = !0, this.tokenizer.end();
        }, p.prototype.pause = function() {
          this.tokenizer.pause();
        }, p.prototype.resume = function() {
          for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
            this.tokenizer.write(this.buffers[this.writeIndex++]);
          this.ended && this.tokenizer.end();
        }, p.prototype.parseChunk = function(m) {
          this.write(m);
        }, p.prototype.done = function(m) {
          this.end(m);
        }, p;
      }()
    );
    return Is.Parser = f, Is;
  }
  var Bc = {}, KF = {}, XF;
  function ef() {
    return XF || (XF = 1, function(t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0;
      var e;
      (function(r) {
        r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
      })(e = t.ElementType || (t.ElementType = {}));
      function i(r) {
        return r.type === e.Tag || r.type === e.Script || r.type === e.Style;
      }
      t.isTag = i, t.Root = e.Root, t.Text = e.Text, t.Directive = e.Directive, t.Comment = e.Comment, t.Script = e.Script, t.Style = e.Style, t.Tag = e.Tag, t.CDATA = e.CDATA, t.Doctype = e.Doctype;
    }(KF)), KF;
  }
  var It = {}, ZF;
  function qF() {
    if (ZF) return It;
    ZF = 1;
    var t = It && It.__extends || /* @__PURE__ */ function() {
      var w = function(M, I) {
        return w = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(b, B) {
          b.__proto__ = B;
        } || function(b, B) {
          for (var x in B) Object.prototype.hasOwnProperty.call(B, x) && (b[x] = B[x]);
        }, w(M, I);
      };
      return function(M, I) {
        if (typeof I != "function" && I !== null)
          throw new TypeError("Class extends value " + String(I) + " is not a constructor or null");
        w(M, I);
        function b() {
          this.constructor = M;
        }
        M.prototype = I === null ? Object.create(I) : (b.prototype = I.prototype, new b());
      };
    }(), e = It && It.__assign || function() {
      return e = Object.assign || function(w) {
        for (var M, I = 1, b = arguments.length; I < b; I++) {
          M = arguments[I];
          for (var B in M) Object.prototype.hasOwnProperty.call(M, B) && (w[B] = M[B]);
        }
        return w;
      }, e.apply(this, arguments);
    };
    Object.defineProperty(It, "__esModule", { value: !0 }), It.cloneNode = It.hasChildren = It.isDocument = It.isDirective = It.isComment = It.isText = It.isCDATA = It.isTag = It.Element = It.Document = It.CDATA = It.NodeWithChildren = It.ProcessingInstruction = It.Comment = It.Text = It.DataNode = It.Node = void 0;
    var i = /* @__PURE__ */ ef(), r = (
      /** @class */
      function() {
        function w() {
          this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
        }
        return Object.defineProperty(w.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(M) {
            this.parent = M;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(w.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(M) {
            this.prev = M;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(w.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(M) {
            this.next = M;
          },
          enumerable: !1,
          configurable: !0
        }), w.prototype.cloneNode = function(M) {
          return M === void 0 && (M = !1), y(this, M);
        }, w;
      }()
    );
    It.Node = r;
    var n = (
      /** @class */
      function(w) {
        t(M, w);
        function M(I) {
          var b = w.call(this) || this;
          return b.data = I, b;
        }
        return Object.defineProperty(M.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(I) {
            this.data = I;
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(r)
    );
    It.DataNode = n;
    var s = (
      /** @class */
      function(w) {
        t(M, w);
        function M() {
          var I = w !== null && w.apply(this, arguments) || this;
          return I.type = i.ElementType.Text, I;
        }
        return Object.defineProperty(M.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(n)
    );
    It.Text = s;
    var o = (
      /** @class */
      function(w) {
        t(M, w);
        function M() {
          var I = w !== null && w.apply(this, arguments) || this;
          return I.type = i.ElementType.Comment, I;
        }
        return Object.defineProperty(M.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(n)
    );
    It.Comment = o;
    var a = (
      /** @class */
      function(w) {
        t(M, w);
        function M(I, b) {
          var B = w.call(this, b) || this;
          return B.name = I, B.type = i.ElementType.Directive, B;
        }
        return Object.defineProperty(M.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(n)
    );
    It.ProcessingInstruction = a;
    var A = (
      /** @class */
      function(w) {
        t(M, w);
        function M(I) {
          var b = w.call(this) || this;
          return b.children = I, b;
        }
        return Object.defineProperty(M.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var I;
            return (I = this.children[0]) !== null && I !== void 0 ? I : null;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(M.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(M.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(I) {
            this.children = I;
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(r)
    );
    It.NodeWithChildren = A;
    var l = (
      /** @class */
      function(w) {
        t(M, w);
        function M() {
          var I = w !== null && w.apply(this, arguments) || this;
          return I.type = i.ElementType.CDATA, I;
        }
        return Object.defineProperty(M.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(A)
    );
    It.CDATA = l;
    var c = (
      /** @class */
      function(w) {
        t(M, w);
        function M() {
          var I = w !== null && w.apply(this, arguments) || this;
          return I.type = i.ElementType.Root, I;
        }
        return Object.defineProperty(M.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(A)
    );
    It.Document = c;
    var u = (
      /** @class */
      function(w) {
        t(M, w);
        function M(I, b, B, x) {
          B === void 0 && (B = []), x === void 0 && (x = I === "script" ? i.ElementType.Script : I === "style" ? i.ElementType.Style : i.ElementType.Tag);
          var Q = w.call(this, B) || this;
          return Q.name = I, Q.attribs = b, Q.type = x, Q;
        }
        return Object.defineProperty(M.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(M.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(I) {
            this.name = I;
          },
          enumerable: !1,
          configurable: !0
        }), Object.defineProperty(M.prototype, "attributes", {
          get: function() {
            var I = this;
            return Object.keys(this.attribs).map(function(b) {
              var B, x;
              return {
                name: b,
                value: I.attribs[b],
                namespace: (B = I["x-attribsNamespace"]) === null || B === void 0 ? void 0 : B[b],
                prefix: (x = I["x-attribsPrefix"]) === null || x === void 0 ? void 0 : x[b]
              };
            });
          },
          enumerable: !1,
          configurable: !0
        }), M;
      }(A)
    );
    It.Element = u;
    function d(w) {
      return (0, i.isTag)(w);
    }
    It.isTag = d;
    function h(w) {
      return w.type === i.ElementType.CDATA;
    }
    It.isCDATA = h;
    function g(w) {
      return w.type === i.ElementType.Text;
    }
    It.isText = g;
    function f(w) {
      return w.type === i.ElementType.Comment;
    }
    It.isComment = f;
    function p(w) {
      return w.type === i.ElementType.Directive;
    }
    It.isDirective = p;
    function m(w) {
      return w.type === i.ElementType.Root;
    }
    It.isDocument = m;
    function E(w) {
      return Object.prototype.hasOwnProperty.call(w, "children");
    }
    It.hasChildren = E;
    function y(w, M) {
      M === void 0 && (M = !1);
      var I;
      if (g(w))
        I = new s(w.data);
      else if (f(w))
        I = new o(w.data);
      else if (d(w)) {
        var b = M ? C(w.children) : [], B = new u(w.name, e({}, w.attribs), b);
        b.forEach(function(T) {
          return T.parent = B;
        }), w.namespace != null && (B.namespace = w.namespace), w["x-attribsNamespace"] && (B["x-attribsNamespace"] = e({}, w["x-attribsNamespace"])), w["x-attribsPrefix"] && (B["x-attribsPrefix"] = e({}, w["x-attribsPrefix"])), I = B;
      } else if (h(w)) {
        var b = M ? C(w.children) : [], x = new l(b);
        b.forEach(function(S) {
          return S.parent = x;
        }), I = x;
      } else if (m(w)) {
        var b = M ? C(w.children) : [], Q = new c(b);
        b.forEach(function(S) {
          return S.parent = Q;
        }), w["x-mode"] && (Q["x-mode"] = w["x-mode"]), I = Q;
      } else if (p(w)) {
        var v = new a(w.name, w.data);
        w["x-name"] != null && (v["x-name"] = w["x-name"], v["x-publicId"] = w["x-publicId"], v["x-systemId"] = w["x-systemId"]), I = v;
      } else
        throw new Error("Not implemented yet: ".concat(w.type));
      return I.startIndex = w.startIndex, I.endIndex = w.endIndex, w.sourceCodeLocation != null && (I.sourceCodeLocation = w.sourceCodeLocation), I;
    }
    It.cloneNode = y;
    function C(w) {
      for (var M = w.map(function(b) {
        return y(b, !0);
      }), I = 1; I < M.length; I++)
        M[I].prev = M[I - 1], M[I - 1].next = M[I];
      return M;
    }
    return It;
  }
  var $F;
  function IA() {
    return $F || ($F = 1, function(t) {
      var e = Bc && Bc.__createBinding || (Object.create ? function(a, A, l, c) {
        c === void 0 && (c = l);
        var u = Object.getOwnPropertyDescriptor(A, l);
        (!u || ("get" in u ? !A.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
          return A[l];
        } }), Object.defineProperty(a, c, u);
      } : function(a, A, l, c) {
        c === void 0 && (c = l), a[c] = A[l];
      }), i = Bc && Bc.__exportStar || function(a, A) {
        for (var l in a) l !== "default" && !Object.prototype.hasOwnProperty.call(A, l) && e(A, a, l);
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DomHandler = void 0;
      var r = /* @__PURE__ */ ef(), n = /* @__PURE__ */ qF();
      i(/* @__PURE__ */ qF(), t);
      var s = {
        withStartIndices: !1,
        withEndIndices: !1,
        xmlMode: !1
      }, o = (
        /** @class */
        function() {
          function a(A, l, c) {
            this.dom = [], this.root = new n.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof l == "function" && (c = l, l = s), typeof A == "object" && (l = A, A = void 0), this.callback = A ?? null, this.options = l ?? s, this.elementCB = c ?? null;
          }
          return a.prototype.onparserinit = function(A) {
            this.parser = A;
          }, a.prototype.onreset = function() {
            this.dom = [], this.root = new n.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
          }, a.prototype.onend = function() {
            this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
          }, a.prototype.onerror = function(A) {
            this.handleCallback(A);
          }, a.prototype.onclosetag = function() {
            this.lastNode = null;
            var A = this.tagStack.pop();
            this.options.withEndIndices && (A.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(A);
          }, a.prototype.onopentag = function(A, l) {
            var c = this.options.xmlMode ? r.ElementType.Tag : void 0, u = new n.Element(A, l, void 0, c);
            this.addNode(u), this.tagStack.push(u);
          }, a.prototype.ontext = function(A) {
            var l = this.lastNode;
            if (l && l.type === r.ElementType.Text)
              l.data += A, this.options.withEndIndices && (l.endIndex = this.parser.endIndex);
            else {
              var c = new n.Text(A);
              this.addNode(c), this.lastNode = c;
            }
          }, a.prototype.oncomment = function(A) {
            if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
              this.lastNode.data += A;
              return;
            }
            var l = new n.Comment(A);
            this.addNode(l), this.lastNode = l;
          }, a.prototype.oncommentend = function() {
            this.lastNode = null;
          }, a.prototype.oncdatastart = function() {
            var A = new n.Text(""), l = new n.CDATA([A]);
            this.addNode(l), A.parent = l, this.lastNode = A;
          }, a.prototype.oncdataend = function() {
            this.lastNode = null;
          }, a.prototype.onprocessinginstruction = function(A, l) {
            var c = new n.ProcessingInstruction(A, l);
            this.addNode(c);
          }, a.prototype.handleCallback = function(A) {
            if (typeof this.callback == "function")
              this.callback(A, this.dom);
            else if (A)
              throw A;
          }, a.prototype.addNode = function(A) {
            var l = this.tagStack[this.tagStack.length - 1], c = l.children[l.children.length - 1];
            this.options.withStartIndices && (A.startIndex = this.parser.startIndex), this.options.withEndIndices && (A.endIndex = this.parser.endIndex), l.children.push(A), c && (A.prev = c, c.next = A), A.parent = l, this.lastNode = null;
          }, a;
        }()
      );
      t.DomHandler = o, t.default = o;
    }(Bc)), Bc;
  }
  var wc = {}, Pr = {}, ln = {}, eS = {}, Vo = {}, $f = {}, tS;
  function bX() {
    if (tS) return $f;
    tS = 1, Object.defineProperty($f, "__esModule", { value: !0 });
    function t(e) {
      for (var i = 1; i < e.length; i++)
        e[i][0] += e[i - 1][0] + 1;
      return e;
    }
    return $f.default = new Map(/* @__PURE__ */ t([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ t([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ t([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ t([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]])), $f;
  }
  var iS = {}, rS;
  function sb() {
    return rS || (rS = 1, function(t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.escapeText = t.escapeAttribute = t.escapeUTF8 = t.escape = t.encodeXML = t.getCodePoint = t.xmlReplacer = void 0, t.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
      var e = /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"]
      ]);
      t.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? function(n, s) {
        return n.codePointAt(s);
      } : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function(n, s) {
          return (n.charCodeAt(s) & 64512) === 55296 ? (n.charCodeAt(s) - 55296) * 1024 + n.charCodeAt(s + 1) - 56320 + 65536 : n.charCodeAt(s);
        }
      );
      function i(n) {
        for (var s = "", o = 0, a; (a = t.xmlReplacer.exec(n)) !== null; ) {
          var A = a.index, l = n.charCodeAt(A), c = e.get(l);
          c !== void 0 ? (s += n.substring(o, A) + c, o = A + 1) : (s += "".concat(n.substring(o, A), "&#x").concat((0, t.getCodePoint)(n, A).toString(16), ";"), o = t.xmlReplacer.lastIndex += +((l & 64512) === 55296));
        }
        return s + n.substr(o);
      }
      t.encodeXML = i, t.escape = i;
      function r(n, s) {
        return function(o) {
          for (var a, A = 0, l = ""; a = n.exec(o); )
            A !== a.index && (l += o.substring(A, a.index)), l += s.get(a[0].charCodeAt(0)), A = a.index + 1;
          return l + o.substring(A);
        };
      }
      t.escapeUTF8 = r(/[&<>'"]/g, e), t.escapeAttribute = r(/["&\u00A0]/g, /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"]
      ])), t.escapeText = r(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"]
      ]));
    }(iS)), iS;
  }
  var nS;
  function sS() {
    if (nS) return Vo;
    nS = 1;
    var t = Vo && Vo.__importDefault || function(a) {
      return a && a.__esModule ? a : { default: a };
    };
    Object.defineProperty(Vo, "__esModule", { value: !0 }), Vo.encodeNonAsciiHTML = Vo.encodeHTML = void 0;
    var e = t(/* @__PURE__ */ bX()), i = /* @__PURE__ */ sb(), r = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function n(a) {
      return o(r, a);
    }
    Vo.encodeHTML = n;
    function s(a) {
      return o(i.xmlReplacer, a);
    }
    Vo.encodeNonAsciiHTML = s;
    function o(a, A) {
      for (var l = "", c = 0, u; (u = a.exec(A)) !== null; ) {
        var d = u.index;
        l += A.substring(c, d);
        var h = A.charCodeAt(d), g = e.default.get(h);
        if (typeof g == "object") {
          if (d + 1 < A.length) {
            var f = A.charCodeAt(d + 1), p = typeof g.n == "number" ? g.n === f ? g.o : void 0 : g.n.get(f);
            if (p !== void 0) {
              l += p, c = a.lastIndex += 1;
              continue;
            }
          }
          g = g.v;
        }
        if (g !== void 0)
          l += g, c = d + 1;
        else {
          var m = (0, i.getCodePoint)(A, d);
          l += "&#x".concat(m.toString(16), ";"), c = a.lastIndex += +(m !== h);
        }
      }
      return l + A.substr(c);
    }
    return Vo;
  }
  var oS;
  function MX() {
    return oS || (oS = 1, function(t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.decodeXMLStrict = t.decodeHTML5Strict = t.decodeHTML4Strict = t.decodeHTML5 = t.decodeHTML4 = t.decodeHTMLAttribute = t.decodeHTMLStrict = t.decodeHTML = t.decodeXML = t.DecodingMode = t.EntityDecoder = t.encodeHTML5 = t.encodeHTML4 = t.encodeNonAsciiHTML = t.encodeHTML = t.escapeText = t.escapeAttribute = t.escapeUTF8 = t.escape = t.encodeXML = t.encode = t.decodeStrict = t.decode = t.EncodingMode = t.EntityLevel = void 0;
      var e = /* @__PURE__ */ hE(), i = /* @__PURE__ */ sS(), r = /* @__PURE__ */ sb(), n;
      (function(d) {
        d[d.XML = 0] = "XML", d[d.HTML = 1] = "HTML";
      })(n = t.EntityLevel || (t.EntityLevel = {}));
      var s;
      (function(d) {
        d[d.UTF8 = 0] = "UTF8", d[d.ASCII = 1] = "ASCII", d[d.Extensive = 2] = "Extensive", d[d.Attribute = 3] = "Attribute", d[d.Text = 4] = "Text";
      })(s = t.EncodingMode || (t.EncodingMode = {}));
      function o(d, h) {
        h === void 0 && (h = n.XML);
        var g = typeof h == "number" ? h : h.level;
        if (g === n.HTML) {
          var f = typeof h == "object" ? h.mode : void 0;
          return (0, e.decodeHTML)(d, f);
        }
        return (0, e.decodeXML)(d);
      }
      t.decode = o;
      function a(d, h) {
        var g;
        h === void 0 && (h = n.XML);
        var f = typeof h == "number" ? { level: h } : h;
        return (g = f.mode) !== null && g !== void 0 || (f.mode = e.DecodingMode.Strict), o(d, f);
      }
      t.decodeStrict = a;
      function A(d, h) {
        h === void 0 && (h = n.XML);
        var g = typeof h == "number" ? { level: h } : h;
        return g.mode === s.UTF8 ? (0, r.escapeUTF8)(d) : g.mode === s.Attribute ? (0, r.escapeAttribute)(d) : g.mode === s.Text ? (0, r.escapeText)(d) : g.level === n.HTML ? g.mode === s.ASCII ? (0, i.encodeNonAsciiHTML)(d) : (0, i.encodeHTML)(d) : (0, r.encodeXML)(d);
      }
      t.encode = A;
      var l = /* @__PURE__ */ sb();
      Object.defineProperty(t, "encodeXML", { enumerable: !0, get: function() {
        return l.encodeXML;
      } }), Object.defineProperty(t, "escape", { enumerable: !0, get: function() {
        return l.escape;
      } }), Object.defineProperty(t, "escapeUTF8", { enumerable: !0, get: function() {
        return l.escapeUTF8;
      } }), Object.defineProperty(t, "escapeAttribute", { enumerable: !0, get: function() {
        return l.escapeAttribute;
      } }), Object.defineProperty(t, "escapeText", { enumerable: !0, get: function() {
        return l.escapeText;
      } });
      var c = /* @__PURE__ */ sS();
      Object.defineProperty(t, "encodeHTML", { enumerable: !0, get: function() {
        return c.encodeHTML;
      } }), Object.defineProperty(t, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
        return c.encodeNonAsciiHTML;
      } }), Object.defineProperty(t, "encodeHTML4", { enumerable: !0, get: function() {
        return c.encodeHTML;
      } }), Object.defineProperty(t, "encodeHTML5", { enumerable: !0, get: function() {
        return c.encodeHTML;
      } });
      var u = /* @__PURE__ */ hE();
      Object.defineProperty(t, "EntityDecoder", { enumerable: !0, get: function() {
        return u.EntityDecoder;
      } }), Object.defineProperty(t, "DecodingMode", { enumerable: !0, get: function() {
        return u.DecodingMode;
      } }), Object.defineProperty(t, "decodeXML", { enumerable: !0, get: function() {
        return u.decodeXML;
      } }), Object.defineProperty(t, "decodeHTML", { enumerable: !0, get: function() {
        return u.decodeHTML;
      } }), Object.defineProperty(t, "decodeHTMLStrict", { enumerable: !0, get: function() {
        return u.decodeHTMLStrict;
      } }), Object.defineProperty(t, "decodeHTMLAttribute", { enumerable: !0, get: function() {
        return u.decodeHTMLAttribute;
      } }), Object.defineProperty(t, "decodeHTML4", { enumerable: !0, get: function() {
        return u.decodeHTML;
      } }), Object.defineProperty(t, "decodeHTML5", { enumerable: !0, get: function() {
        return u.decodeHTML;
      } }), Object.defineProperty(t, "decodeHTML4Strict", { enumerable: !0, get: function() {
        return u.decodeHTMLStrict;
      } }), Object.defineProperty(t, "decodeHTML5Strict", { enumerable: !0, get: function() {
        return u.decodeHTMLStrict;
      } }), Object.defineProperty(t, "decodeXMLStrict", { enumerable: !0, get: function() {
        return u.decodeXML;
      } });
    }(eS)), eS;
  }
  var Cc = {}, aS;
  function IX() {
    return aS || (aS = 1, Object.defineProperty(Cc, "__esModule", { value: !0 }), Cc.attributeNames = Cc.elementNames = void 0, Cc.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(t) {
      return [t.toLowerCase(), t];
    })), Cc.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(t) {
      return [t.toLowerCase(), t];
    }))), Cc;
  }
  var AS;
  function vX() {
    if (AS) return ln;
    AS = 1;
    var t = ln && ln.__assign || function() {
      return t = Object.assign || function(C) {
        for (var w, M = 1, I = arguments.length; M < I; M++) {
          w = arguments[M];
          for (var b in w) Object.prototype.hasOwnProperty.call(w, b) && (C[b] = w[b]);
        }
        return C;
      }, t.apply(this, arguments);
    }, e = ln && ln.__createBinding || (Object.create ? function(C, w, M, I) {
      I === void 0 && (I = M);
      var b = Object.getOwnPropertyDescriptor(w, M);
      (!b || ("get" in b ? !w.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
        return w[M];
      } }), Object.defineProperty(C, I, b);
    } : function(C, w, M, I) {
      I === void 0 && (I = M), C[I] = w[M];
    }), i = ln && ln.__setModuleDefault || (Object.create ? function(C, w) {
      Object.defineProperty(C, "default", { enumerable: !0, value: w });
    } : function(C, w) {
      C.default = w;
    }), r = ln && ln.__importStar || function(C) {
      if (C && C.__esModule) return C;
      var w = {};
      if (C != null) for (var M in C) M !== "default" && Object.prototype.hasOwnProperty.call(C, M) && e(w, C, M);
      return i(w, C), w;
    };
    Object.defineProperty(ln, "__esModule", { value: !0 }), ln.render = void 0;
    var n = r(/* @__PURE__ */ ef()), s = /* @__PURE__ */ MX(), o = /* @__PURE__ */ IX(), a = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function A(C) {
      return C.replace(/"/g, "&quot;");
    }
    function l(C, w) {
      var M;
      if (C) {
        var I = ((M = w.encodeEntities) !== null && M !== void 0 ? M : w.decodeEntities) === !1 ? A : w.xmlMode || w.encodeEntities !== "utf8" ? s.encodeXML : s.escapeAttribute;
        return Object.keys(C).map(function(b) {
          var B, x, Q = (B = C[b]) !== null && B !== void 0 ? B : "";
          return w.xmlMode === "foreign" && (b = (x = o.attributeNames.get(b)) !== null && x !== void 0 ? x : b), !w.emptyAttrs && !w.xmlMode && Q === "" ? b : "".concat(b, '="').concat(I(Q), '"');
        }).join(" ");
      }
    }
    var c = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function u(C, w) {
      w === void 0 && (w = {});
      for (var M = ("length" in C) ? C : [C], I = "", b = 0; b < M.length; b++)
        I += d(M[b], w);
      return I;
    }
    ln.render = u, ln.default = u;
    function d(C, w) {
      switch (C.type) {
        case n.Root:
          return u(C.children, w);
        // @ts-expect-error We don't use `Doctype` yet
        case n.Doctype:
        case n.Directive:
          return p(C);
        case n.Comment:
          return y(C);
        case n.CDATA:
          return E(C);
        case n.Script:
        case n.Style:
        case n.Tag:
          return f(C, w);
        case n.Text:
          return m(C, w);
      }
    }
    var h = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]), g = /* @__PURE__ */ new Set(["svg", "math"]);
    function f(C, w) {
      var M;
      w.xmlMode === "foreign" && (C.name = (M = o.elementNames.get(C.name)) !== null && M !== void 0 ? M : C.name, C.parent && h.has(C.parent.name) && (w = t(t({}, w), { xmlMode: !1 }))), !w.xmlMode && g.has(C.name) && (w = t(t({}, w), { xmlMode: "foreign" }));
      var I = "<".concat(C.name), b = l(C.attribs, w);
      return b && (I += " ".concat(b)), C.children.length === 0 && (w.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        w.selfClosingTags !== !1
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        w.selfClosingTags && c.has(C.name)
      )) ? (w.xmlMode || (I += " "), I += "/>") : (I += ">", C.children.length > 0 && (I += u(C.children, w)), (w.xmlMode || !c.has(C.name)) && (I += "</".concat(C.name, ">"))), I;
    }
    function p(C) {
      return "<".concat(C.data, ">");
    }
    function m(C, w) {
      var M, I = C.data || "";
      return ((M = w.encodeEntities) !== null && M !== void 0 ? M : w.decodeEntities) !== !1 && !(!w.xmlMode && C.parent && a.has(C.parent.name)) && (I = w.xmlMode || w.encodeEntities !== "utf8" ? (0, s.encodeXML)(I) : (0, s.escapeText)(I)), I;
    }
    function E(C) {
      return "<![CDATA[".concat(C.children[0].data, "]]>");
    }
    function y(C) {
      return "<!--".concat(C.data, "-->");
    }
    return ln;
  }
  var lS;
  function YN() {
    if (lS) return Pr;
    lS = 1;
    var t = Pr && Pr.__importDefault || function(l) {
      return l && l.__esModule ? l : { default: l };
    };
    Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.innerText = Pr.textContent = Pr.getText = Pr.getInnerHTML = Pr.getOuterHTML = void 0;
    var e = /* @__PURE__ */ IA(), i = t(/* @__PURE__ */ vX()), r = /* @__PURE__ */ ef();
    function n(l, c) {
      return (0, i.default)(l, c);
    }
    Pr.getOuterHTML = n;
    function s(l, c) {
      return (0, e.hasChildren)(l) ? l.children.map(function(u) {
        return n(u, c);
      }).join("") : "";
    }
    Pr.getInnerHTML = s;
    function o(l) {
      return Array.isArray(l) ? l.map(o).join("") : (0, e.isTag)(l) ? l.name === "br" ? `
` : o(l.children) : (0, e.isCDATA)(l) ? o(l.children) : (0, e.isText)(l) ? l.data : "";
    }
    Pr.getText = o;
    function a(l) {
      return Array.isArray(l) ? l.map(a).join("") : (0, e.hasChildren)(l) && !(0, e.isComment)(l) ? a(l.children) : (0, e.isText)(l) ? l.data : "";
    }
    Pr.textContent = a;
    function A(l) {
      return Array.isArray(l) ? l.map(A).join("") : (0, e.hasChildren)(l) && (l.type === r.ElementType.Tag || (0, e.isCDATA)(l)) ? A(l.children) : (0, e.isText)(l) ? l.data : "";
    }
    return Pr.innerText = A, Pr;
  }
  var rr = {}, cS;
  function xX() {
    if (cS) return rr;
    cS = 1, Object.defineProperty(rr, "__esModule", { value: !0 }), rr.prevElementSibling = rr.nextElementSibling = rr.getName = rr.hasAttrib = rr.getAttributeValue = rr.getSiblings = rr.getParent = rr.getChildren = void 0;
    var t = /* @__PURE__ */ IA();
    function e(l) {
      return (0, t.hasChildren)(l) ? l.children : [];
    }
    rr.getChildren = e;
    function i(l) {
      return l.parent || null;
    }
    rr.getParent = i;
    function r(l) {
      var c, u, d = i(l);
      if (d != null)
        return e(d);
      for (var h = [l], g = l.prev, f = l.next; g != null; )
        h.unshift(g), c = g, g = c.prev;
      for (; f != null; )
        h.push(f), u = f, f = u.next;
      return h;
    }
    rr.getSiblings = r;
    function n(l, c) {
      var u;
      return (u = l.attribs) === null || u === void 0 ? void 0 : u[c];
    }
    rr.getAttributeValue = n;
    function s(l, c) {
      return l.attribs != null && Object.prototype.hasOwnProperty.call(l.attribs, c) && l.attribs[c] != null;
    }
    rr.hasAttrib = s;
    function o(l) {
      return l.name;
    }
    rr.getName = o;
    function a(l) {
      for (var c, u = l.next; u !== null && !(0, t.isTag)(u); )
        c = u, u = c.next;
      return u;
    }
    rr.nextElementSibling = a;
    function A(l) {
      for (var c, u = l.prev; u !== null && !(0, t.isTag)(u); )
        c = u, u = c.prev;
      return u;
    }
    return rr.prevElementSibling = A, rr;
  }
  var Or = {}, uS;
  function QX() {
    if (uS) return Or;
    uS = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.prepend = Or.prependChild = Or.append = Or.appendChild = Or.replaceElement = Or.removeElement = void 0;
    function t(o) {
      if (o.prev && (o.prev.next = o.next), o.next && (o.next.prev = o.prev), o.parent) {
        var a = o.parent.children, A = a.lastIndexOf(o);
        A >= 0 && a.splice(A, 1);
      }
      o.next = null, o.prev = null, o.parent = null;
    }
    Or.removeElement = t;
    function e(o, a) {
      var A = a.prev = o.prev;
      A && (A.next = a);
      var l = a.next = o.next;
      l && (l.prev = a);
      var c = a.parent = o.parent;
      if (c) {
        var u = c.children;
        u[u.lastIndexOf(o)] = a, o.parent = null;
      }
    }
    Or.replaceElement = e;
    function i(o, a) {
      if (t(a), a.next = null, a.parent = o, o.children.push(a) > 1) {
        var A = o.children[o.children.length - 2];
        A.next = a, a.prev = A;
      } else
        a.prev = null;
    }
    Or.appendChild = i;
    function r(o, a) {
      t(a);
      var A = o.parent, l = o.next;
      if (a.next = l, a.prev = o, o.next = a, a.parent = A, l) {
        if (l.prev = a, A) {
          var c = A.children;
          c.splice(c.lastIndexOf(l), 0, a);
        }
      } else A && A.children.push(a);
    }
    Or.append = r;
    function n(o, a) {
      if (t(a), a.parent = o, a.prev = null, o.children.unshift(a) !== 1) {
        var A = o.children[1];
        A.prev = a, a.next = A;
      } else
        a.next = null;
    }
    Or.prependChild = n;
    function s(o, a) {
      t(a);
      var A = o.parent;
      if (A) {
        var l = A.children;
        l.splice(l.indexOf(o), 0, a);
      }
      o.prev && (o.prev.next = a), a.parent = A, a.prev = o.prev, a.next = o, o.prev = a;
    }
    return Or.prepend = s, Or;
  }
  var Gr = {}, dS;
  function NN() {
    if (dS) return Gr;
    dS = 1, Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.findAll = Gr.existsOne = Gr.findOne = Gr.findOneChild = Gr.find = Gr.filter = void 0;
    var t = /* @__PURE__ */ IA();
    function e(a, A, l, c) {
      return l === void 0 && (l = !0), c === void 0 && (c = 1 / 0), i(a, Array.isArray(A) ? A : [A], l, c);
    }
    Gr.filter = e;
    function i(a, A, l, c) {
      for (var u = [], d = [A], h = [0]; ; ) {
        if (h[0] >= d[0].length) {
          if (h.length === 1)
            return u;
          d.shift(), h.shift();
          continue;
        }
        var g = d[0][h[0]++];
        if (a(g) && (u.push(g), --c <= 0))
          return u;
        l && (0, t.hasChildren)(g) && g.children.length > 0 && (h.unshift(0), d.unshift(g.children));
      }
    }
    Gr.find = i;
    function r(a, A) {
      return A.find(a);
    }
    Gr.findOneChild = r;
    function n(a, A, l) {
      l === void 0 && (l = !0);
      for (var c = null, u = 0; u < A.length && !c; u++) {
        var d = A[u];
        if ((0, t.isTag)(d))
          a(d) ? c = d : l && d.children.length > 0 && (c = n(a, d.children, !0));
        else continue;
      }
      return c;
    }
    Gr.findOne = n;
    function s(a, A) {
      return A.some(function(l) {
        return (0, t.isTag)(l) && (a(l) || s(a, l.children));
      });
    }
    Gr.existsOne = s;
    function o(a, A) {
      for (var l = [], c = [A], u = [0]; ; ) {
        if (u[0] >= c[0].length) {
          if (c.length === 1)
            return l;
          c.shift(), u.shift();
          continue;
        }
        var d = c[0][u[0]++];
        (0, t.isTag)(d) && (a(d) && l.push(d), d.children.length > 0 && (u.unshift(0), c.unshift(d.children)));
      }
    }
    return Gr.findAll = o, Gr;
  }
  var Sn = {}, hS;
  function UN() {
    if (hS) return Sn;
    hS = 1, Object.defineProperty(Sn, "__esModule", { value: !0 }), Sn.getElementsByTagType = Sn.getElementsByTagName = Sn.getElementById = Sn.getElements = Sn.testElement = void 0;
    var t = /* @__PURE__ */ IA(), e = /* @__PURE__ */ NN(), i = {
      tag_name: function(u) {
        return typeof u == "function" ? function(d) {
          return (0, t.isTag)(d) && u(d.name);
        } : u === "*" ? t.isTag : function(d) {
          return (0, t.isTag)(d) && d.name === u;
        };
      },
      tag_type: function(u) {
        return typeof u == "function" ? function(d) {
          return u(d.type);
        } : function(d) {
          return d.type === u;
        };
      },
      tag_contains: function(u) {
        return typeof u == "function" ? function(d) {
          return (0, t.isText)(d) && u(d.data);
        } : function(d) {
          return (0, t.isText)(d) && d.data === u;
        };
      }
    };
    function r(u, d) {
      return typeof d == "function" ? function(h) {
        return (0, t.isTag)(h) && d(h.attribs[u]);
      } : function(h) {
        return (0, t.isTag)(h) && h.attribs[u] === d;
      };
    }
    function n(u, d) {
      return function(h) {
        return u(h) || d(h);
      };
    }
    function s(u) {
      var d = Object.keys(u).map(function(h) {
        var g = u[h];
        return Object.prototype.hasOwnProperty.call(i, h) ? i[h](g) : r(h, g);
      });
      return d.length === 0 ? null : d.reduce(n);
    }
    function o(u, d) {
      var h = s(u);
      return h ? h(d) : !0;
    }
    Sn.testElement = o;
    function a(u, d, h, g) {
      g === void 0 && (g = 1 / 0);
      var f = s(u);
      return f ? (0, e.filter)(f, d, h, g) : [];
    }
    Sn.getElements = a;
    function A(u, d, h) {
      return h === void 0 && (h = !0), Array.isArray(d) || (d = [d]), (0, e.findOne)(r("id", u), d, h);
    }
    Sn.getElementById = A;
    function l(u, d, h, g) {
      return h === void 0 && (h = !0), g === void 0 && (g = 1 / 0), (0, e.filter)(i.tag_name(u), d, h, g);
    }
    Sn.getElementsByTagName = l;
    function c(u, d, h, g) {
      return h === void 0 && (h = !0), g === void 0 && (g = 1 / 0), (0, e.filter)(i.tag_type(u), d, h, g);
    }
    return Sn.getElementsByTagType = c, Sn;
  }
  var gS = {}, fS;
  function FX() {
    return fS || (fS = 1, function(t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.uniqueSort = t.compareDocumentPosition = t.DocumentPosition = t.removeSubsets = void 0;
      var e = /* @__PURE__ */ IA();
      function i(o) {
        for (var a = o.length; --a >= 0; ) {
          var A = o[a];
          if (a > 0 && o.lastIndexOf(A, a - 1) >= 0) {
            o.splice(a, 1);
            continue;
          }
          for (var l = A.parent; l; l = l.parent)
            if (o.includes(l)) {
              o.splice(a, 1);
              break;
            }
        }
        return o;
      }
      t.removeSubsets = i;
      var r;
      (function(o) {
        o[o.DISCONNECTED = 1] = "DISCONNECTED", o[o.PRECEDING = 2] = "PRECEDING", o[o.FOLLOWING = 4] = "FOLLOWING", o[o.CONTAINS = 8] = "CONTAINS", o[o.CONTAINED_BY = 16] = "CONTAINED_BY";
      })(r = t.DocumentPosition || (t.DocumentPosition = {}));
      function n(o, a) {
        var A = [], l = [];
        if (o === a)
          return 0;
        for (var c = (0, e.hasChildren)(o) ? o : o.parent; c; )
          A.unshift(c), c = c.parent;
        for (c = (0, e.hasChildren)(a) ? a : a.parent; c; )
          l.unshift(c), c = c.parent;
        for (var u = Math.min(A.length, l.length), d = 0; d < u && A[d] === l[d]; )
          d++;
        if (d === 0)
          return r.DISCONNECTED;
        var h = A[d - 1], g = h.children, f = A[d], p = l[d];
        return g.indexOf(f) > g.indexOf(p) ? h === a ? r.FOLLOWING | r.CONTAINED_BY : r.FOLLOWING : h === o ? r.PRECEDING | r.CONTAINS : r.PRECEDING;
      }
      t.compareDocumentPosition = n;
      function s(o) {
        return o = o.filter(function(a, A, l) {
          return !l.includes(a, A + 1);
        }), o.sort(function(a, A) {
          var l = n(a, A);
          return l & r.PRECEDING ? -1 : l & r.FOLLOWING ? 1 : 0;
        }), o;
      }
      t.uniqueSort = s;
    }(gS)), gS;
  }
  var eh = {}, pS;
  function SX() {
    if (pS) return eh;
    pS = 1, Object.defineProperty(eh, "__esModule", { value: !0 }), eh.getFeed = void 0;
    var t = /* @__PURE__ */ YN(), e = /* @__PURE__ */ UN();
    function i(d) {
      var h = A(u, d);
      return h ? h.name === "feed" ? r(h) : n(h) : null;
    }
    eh.getFeed = i;
    function r(d) {
      var h, g = d.children, f = {
        type: "atom",
        items: (0, e.getElementsByTagName)("entry", g).map(function(E) {
          var y, C = E.children, w = { media: a(C) };
          c(w, "id", "id", C), c(w, "title", "title", C);
          var M = (y = A("link", C)) === null || y === void 0 ? void 0 : y.attribs.href;
          M && (w.link = M);
          var I = l("summary", C) || l("content", C);
          I && (w.description = I);
          var b = l("updated", C);
          return b && (w.pubDate = new Date(b)), w;
        })
      };
      c(f, "id", "id", g), c(f, "title", "title", g);
      var p = (h = A("link", g)) === null || h === void 0 ? void 0 : h.attribs.href;
      p && (f.link = p), c(f, "description", "subtitle", g);
      var m = l("updated", g);
      return m && (f.updated = new Date(m)), c(f, "author", "email", g, !0), f;
    }
    function n(d) {
      var h, g, f = (g = (h = A("channel", d.children)) === null || h === void 0 ? void 0 : h.children) !== null && g !== void 0 ? g : [], p = {
        type: d.name.substr(0, 3),
        id: "",
        items: (0, e.getElementsByTagName)("item", d.children).map(function(E) {
          var y = E.children, C = { media: a(y) };
          c(C, "id", "guid", y), c(C, "title", "title", y), c(C, "link", "link", y), c(C, "description", "description", y);
          var w = l("pubDate", y) || l("dc:date", y);
          return w && (C.pubDate = new Date(w)), C;
        })
      };
      c(p, "title", "title", f), c(p, "link", "link", f), c(p, "description", "description", f);
      var m = l("lastBuildDate", f);
      return m && (p.updated = new Date(m)), c(p, "author", "managingEditor", f, !0), p;
    }
    var s = ["url", "type", "lang"], o = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function a(d) {
      return (0, e.getElementsByTagName)("media:content", d).map(function(h) {
        for (var g = h.attribs, f = {
          medium: g.medium,
          isDefault: !!g.isDefault
        }, p = 0, m = s; p < m.length; p++) {
          var E = m[p];
          g[E] && (f[E] = g[E]);
        }
        for (var y = 0, C = o; y < C.length; y++) {
          var E = C[y];
          g[E] && (f[E] = parseInt(g[E], 10));
        }
        return g.expression && (f.expression = g.expression), f;
      });
    }
    function A(d, h) {
      return (0, e.getElementsByTagName)(d, h, !0, 1)[0];
    }
    function l(d, h, g) {
      return g === void 0 && (g = !1), (0, t.textContent)((0, e.getElementsByTagName)(d, h, g, 1)).trim();
    }
    function c(d, h, g, f, p) {
      p === void 0 && (p = !1);
      var m = l(g, f, p);
      m && (d[h] = m);
    }
    function u(d) {
      return d === "rss" || d === "feed" || d === "rdf:RDF";
    }
    return eh;
  }
  var mS;
  function Uw() {
    return mS || (mS = 1, function(t) {
      var e = wc && wc.__createBinding || (Object.create ? function(n, s, o, a) {
        a === void 0 && (a = o);
        var A = Object.getOwnPropertyDescriptor(s, o);
        (!A || ("get" in A ? !s.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
          return s[o];
        } }), Object.defineProperty(n, a, A);
      } : function(n, s, o, a) {
        a === void 0 && (a = o), n[a] = s[o];
      }), i = wc && wc.__exportStar || function(n, s) {
        for (var o in n) o !== "default" && !Object.prototype.hasOwnProperty.call(s, o) && e(s, n, o);
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.hasChildren = t.isDocument = t.isComment = t.isText = t.isCDATA = t.isTag = void 0, i(/* @__PURE__ */ YN(), t), i(/* @__PURE__ */ xX(), t), i(/* @__PURE__ */ QX(), t), i(/* @__PURE__ */ NN(), t), i(/* @__PURE__ */ UN(), t), i(/* @__PURE__ */ FX(), t), i(/* @__PURE__ */ SX(), t);
      var r = /* @__PURE__ */ IA();
      Object.defineProperty(t, "isTag", { enumerable: !0, get: function() {
        return r.isTag;
      } }), Object.defineProperty(t, "isCDATA", { enumerable: !0, get: function() {
        return r.isCDATA;
      } }), Object.defineProperty(t, "isText", { enumerable: !0, get: function() {
        return r.isText;
      } }), Object.defineProperty(t, "isComment", { enumerable: !0, get: function() {
        return r.isComment;
      } }), Object.defineProperty(t, "isDocument", { enumerable: !0, get: function() {
        return r.isDocument;
      } }), Object.defineProperty(t, "hasChildren", { enumerable: !0, get: function() {
        return r.hasChildren;
      } });
    }(wc)), wc;
  }
  var ES;
  function DX() {
    return ES || (ES = 1, function(t) {
      var e = oo && oo.__createBinding || (Object.create ? function(m, E, y, C) {
        C === void 0 && (C = y);
        var w = Object.getOwnPropertyDescriptor(E, y);
        (!w || ("get" in w ? !E.__esModule : w.writable || w.configurable)) && (w = { enumerable: !0, get: function() {
          return E[y];
        } }), Object.defineProperty(m, C, w);
      } : function(m, E, y, C) {
        C === void 0 && (C = y), m[C] = E[y];
      }), i = oo && oo.__setModuleDefault || (Object.create ? function(m, E) {
        Object.defineProperty(m, "default", { enumerable: !0, value: E });
      } : function(m, E) {
        m.default = E;
      }), r = oo && oo.__importStar || function(m) {
        if (m && m.__esModule) return m;
        var E = {};
        if (m != null) for (var y in m) y !== "default" && Object.prototype.hasOwnProperty.call(m, y) && e(E, m, y);
        return i(E, m), E;
      }, n = oo && oo.__importDefault || function(m) {
        return m && m.__esModule ? m : { default: m };
      };
      Object.defineProperty(t, "__esModule", { value: !0 }), t.DomUtils = t.parseFeed = t.getFeed = t.ElementType = t.Tokenizer = t.createDomStream = t.parseDOM = t.parseDocument = t.DefaultHandler = t.DomHandler = t.Parser = void 0;
      var s = /* @__PURE__ */ WF(), o = /* @__PURE__ */ WF();
      Object.defineProperty(t, "Parser", { enumerable: !0, get: function() {
        return o.Parser;
      } });
      var a = /* @__PURE__ */ IA(), A = /* @__PURE__ */ IA();
      Object.defineProperty(t, "DomHandler", { enumerable: !0, get: function() {
        return A.DomHandler;
      } }), Object.defineProperty(t, "DefaultHandler", { enumerable: !0, get: function() {
        return A.DomHandler;
      } });
      function l(m, E) {
        var y = new a.DomHandler(void 0, E);
        return new s.Parser(y, E).end(m), y.root;
      }
      t.parseDocument = l;
      function c(m, E) {
        return l(m, E).children;
      }
      t.parseDOM = c;
      function u(m, E, y) {
        var C = new a.DomHandler(m, E, y);
        return new s.Parser(C, E);
      }
      t.createDomStream = u;
      var d = /* @__PURE__ */ kN();
      Object.defineProperty(t, "Tokenizer", { enumerable: !0, get: function() {
        return n(d).default;
      } }), t.ElementType = r(/* @__PURE__ */ ef());
      var h = /* @__PURE__ */ Uw(), g = /* @__PURE__ */ Uw();
      Object.defineProperty(t, "getFeed", { enumerable: !0, get: function() {
        return g.getFeed;
      } });
      var f = { xmlMode: !0 };
      function p(m, E) {
        return E === void 0 && (E = f), (0, h.getFeed)(c(m, E));
      }
      t.parseFeed = p, t.DomUtils = r(/* @__PURE__ */ Uw());
    }(oo)), oo;
  }
  var yS, BS;
  function TX() {
    return BS || (BS = 1, yS = (t) => {
      if (typeof t != "string")
        throw new TypeError("Expected a string");
      return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    }), yS;
  }
  var ep = {}, wS;
  function RX() {
    if (wS) return ep;
    wS = 1, Object.defineProperty(ep, "__esModule", { value: !0 });
    /*!
     * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    function t(i) {
      return Object.prototype.toString.call(i) === "[object Object]";
    }
    function e(i) {
      var r, n;
      return t(i) === !1 ? !1 : (r = i.constructor, r === void 0 ? !0 : (n = r.prototype, !(t(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
    }
    return ep.isPlainObject = e, ep;
  }
  var Lw, CS;
  function _X() {
    if (CS) return Lw;
    CS = 1;
    var t = function(m) {
      return e(m) && !i(m);
    };
    function e(m) {
      return !!m && typeof m == "object";
    }
    function i(m) {
      var E = Object.prototype.toString.call(m);
      return E === "[object RegExp]" || E === "[object Date]" || s(m);
    }
    var r = typeof Symbol == "function" && Symbol.for, n = r ? Symbol.for("react.element") : 60103;
    function s(m) {
      return m.$$typeof === n;
    }
    function o(m) {
      return Array.isArray(m) ? [] : {};
    }
    function a(m, E) {
      return E.clone !== !1 && E.isMergeableObject(m) ? f(o(m), m, E) : m;
    }
    function A(m, E, y) {
      return m.concat(E).map(function(C) {
        return a(C, y);
      });
    }
    function l(m, E) {
      if (!E.customMerge)
        return f;
      var y = E.customMerge(m);
      return typeof y == "function" ? y : f;
    }
    function c(m) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(m).filter(function(E) {
        return Object.propertyIsEnumerable.call(m, E);
      }) : [];
    }
    function u(m) {
      return Object.keys(m).concat(c(m));
    }
    function d(m, E) {
      try {
        return E in m;
      } catch {
        return !1;
      }
    }
    function h(m, E) {
      return d(m, E) && !(Object.hasOwnProperty.call(m, E) && Object.propertyIsEnumerable.call(m, E));
    }
    function g(m, E, y) {
      var C = {};
      return y.isMergeableObject(m) && u(m).forEach(function(w) {
        C[w] = a(m[w], y);
      }), u(E).forEach(function(w) {
        h(m, w) || (d(m, w) && y.isMergeableObject(E[w]) ? C[w] = l(w, y)(m[w], E[w], y) : C[w] = a(E[w], y));
      }), C;
    }
    function f(m, E, y) {
      y = y || {}, y.arrayMerge = y.arrayMerge || A, y.isMergeableObject = y.isMergeableObject || t, y.cloneUnlessOtherwiseSpecified = a;
      var C = Array.isArray(E), w = Array.isArray(m), M = C === w;
      return M ? C ? y.arrayMerge(m, E, y) : g(m, E, y) : a(E, y);
    }
    f.all = function(m, E) {
      if (!Array.isArray(m))
        throw new Error("first argument should be an array");
      return m.reduce(function(y, C) {
        return f(y, C, E);
      }, {});
    };
    var p = f;
    return Lw = p, Lw;
  }
  var ob = { exports: {} }, kX = ob.exports, bS;
  function YX() {
    return bS || (bS = 1, function(t) {
      (function(e, i) {
        t.exports ? t.exports = i() : e.parseSrcset = i();
      })(kX, function() {
        return function(e) {
          function i(C) {
            return C === " " || // space
            C === "	" || // horizontal tab
            C === `
` || // new line
            C === "\f" || // form feed
            C === "\r";
          }
          function r(C) {
            var w, M = C.exec(e.substring(p));
            if (M)
              return w = M[0], p += w.length, w;
          }
          for (var n = e.length, s = /^[ \t\n\r\u000c]+/, o = /^[, \t\n\r\u000c]+/, a = /^[^ \t\n\r\u000c]+/, A = /[,]+$/, l = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, u, d, h, g, f, p = 0, m = []; ; ) {
            if (r(o), p >= n)
              return m;
            u = r(a), d = [], u.slice(-1) === "," ? (u = u.replace(A, ""), y()) : E();
          }
          function E() {
            for (r(s), h = "", g = "in descriptor"; ; ) {
              if (f = e.charAt(p), g === "in descriptor")
                if (i(f))
                  h && (d.push(h), h = "", g = "after descriptor");
                else if (f === ",") {
                  p += 1, h && d.push(h), y();
                  return;
                } else if (f === "(")
                  h = h + f, g = "in parens";
                else if (f === "") {
                  h && d.push(h), y();
                  return;
                } else
                  h = h + f;
              else if (g === "in parens")
                if (f === ")")
                  h = h + f, g = "in descriptor";
                else if (f === "") {
                  d.push(h), y();
                  return;
                } else
                  h = h + f;
              else if (g === "after descriptor" && !i(f))
                if (f === "") {
                  y();
                  return;
                } else
                  g = "in descriptor", p -= 1;
              p += 1;
            }
          }
          function y() {
            var C = !1, w, M, I, b, B = {}, x, Q, v, T, S;
            for (b = 0; b < d.length; b++)
              x = d[b], Q = x[x.length - 1], v = x.substring(0, x.length - 1), T = parseInt(v, 10), S = parseFloat(v), l.test(v) && Q === "w" ? ((w || M) && (C = !0), T === 0 ? C = !0 : w = T) : c.test(v) && Q === "x" ? ((w || M || I) && (C = !0), S < 0 ? C = !0 : M = S) : l.test(v) && Q === "h" ? ((I || M) && (C = !0), T === 0 ? C = !0 : I = T) : C = !0;
            C ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + x + "'.") : (B.url = u, w && (B.w = w), M && (B.d = M), I && (B.h = I), m.push(B));
          }
        };
      });
    }(ob)), ob.exports;
  }
  var tp = { exports: {} }, MS;
  function NX() {
    if (MS) return tp.exports;
    MS = 1;
    var t = String, e = function() {
      return { isColorSupported: !1, reset: t, bold: t, dim: t, italic: t, underline: t, inverse: t, hidden: t, strikethrough: t, black: t, red: t, green: t, yellow: t, blue: t, magenta: t, cyan: t, white: t, gray: t, bgBlack: t, bgRed: t, bgGreen: t, bgYellow: t, bgBlue: t, bgMagenta: t, bgCyan: t, bgWhite: t, blackBright: t, redBright: t, greenBright: t, yellowBright: t, blueBright: t, magentaBright: t, cyanBright: t, whiteBright: t, bgBlackBright: t, bgRedBright: t, bgGreenBright: t, bgYellowBright: t, bgBlueBright: t, bgMagentaBright: t, bgCyanBright: t, bgWhiteBright: t };
    };
    return tp.exports = e(), tp.exports.createColors = e, tp.exports;
  }
  const UX = {}, LX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: UX
  }, Symbol.toStringTag, { value: "Module" })), Ys = /* @__PURE__ */ BX(LX);
  var zw, IS;
  function ev() {
    if (IS) return zw;
    IS = 1;
    let t = /* @__PURE__ */ NX(), e = Ys;
    class i extends Error {
      constructor(n, s, o, a, A, l) {
        super(n), this.name = "CssSyntaxError", this.reason = n, A && (this.file = A), a && (this.source = a), l && (this.plugin = l), typeof s < "u" && typeof o < "u" && (typeof s == "number" ? (this.line = s, this.column = o) : (this.line = s.line, this.column = s.column, this.endLine = o.line, this.endColumn = o.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, i);
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
      }
      showSourceCode(n) {
        if (!this.source) return "";
        let s = this.source;
        n == null && (n = t.isColorSupported);
        let o = (h) => h, a = (h) => h, A = (h) => h;
        if (n) {
          let { bold: h, gray: g, red: f } = t.createColors(!0);
          a = (p) => h(f(p)), o = (p) => g(p), e && (A = (p) => e(p));
        }
        let l = s.split(/\r?\n/), c = Math.max(this.line - 3, 0), u = Math.min(this.line + 2, l.length), d = String(u).length;
        return l.slice(c, u).map((h, g) => {
          let f = c + 1 + g, p = " " + (" " + f).slice(-d) + " | ";
          if (f === this.line) {
            if (h.length > 160) {
              let E = 20, y = Math.max(0, this.column - E), C = Math.max(
                this.column + E,
                this.endColumn + E
              ), w = h.slice(y, C), M = o(p.replace(/\d/g, " ")) + h.slice(0, Math.min(this.column - 1, E - 1)).replace(/[^\t]/g, " ");
              return a(">") + o(p) + A(w) + `
 ` + M + a("^");
            }
            let m = o(p.replace(/\d/g, " ")) + h.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return a(">") + o(p) + A(h) + `
 ` + m + a("^");
          }
          return " " + o(p) + A(h);
        }).join(`
`);
      }
      toString() {
        let n = this.showSourceCode();
        return n && (n = `

` + n + `
`), this.name + ": " + this.message + n;
      }
    }
    return zw = i, i.default = i, zw;
  }
  var Pw, vS;
  function LN() {
    if (vS) return Pw;
    vS = 1;
    const t = {
      after: `
`,
      beforeClose: `
`,
      beforeComment: `
`,
      beforeDecl: `
`,
      beforeOpen: " ",
      beforeRule: `
`,
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: !1
    };
    function e(r) {
      return r[0].toUpperCase() + r.slice(1);
    }
    class i {
      constructor(n) {
        this.builder = n;
      }
      atrule(n, s) {
        let o = "@" + n.name, a = n.params ? this.rawValue(n, "params") : "";
        if (typeof n.raws.afterName < "u" ? o += n.raws.afterName : a && (o += " "), n.nodes)
          this.block(n, o + a);
        else {
          let A = (n.raws.between || "") + (s ? ";" : "");
          this.builder(o + a + A, n);
        }
      }
      beforeAfter(n, s) {
        let o;
        n.type === "decl" ? o = this.raw(n, null, "beforeDecl") : n.type === "comment" ? o = this.raw(n, null, "beforeComment") : s === "before" ? o = this.raw(n, null, "beforeRule") : o = this.raw(n, null, "beforeClose");
        let a = n.parent, A = 0;
        for (; a && a.type !== "root"; )
          A += 1, a = a.parent;
        if (o.includes(`
`)) {
          let l = this.raw(n, null, "indent");
          if (l.length)
            for (let c = 0; c < A; c++) o += l;
        }
        return o;
      }
      block(n, s) {
        let o = this.raw(n, "between", "beforeOpen");
        this.builder(s + o + "{", n, "start");
        let a;
        n.nodes && n.nodes.length ? (this.body(n), a = this.raw(n, "after")) : a = this.raw(n, "after", "emptyBody"), a && this.builder(a), this.builder("}", n, "end");
      }
      body(n) {
        let s = n.nodes.length - 1;
        for (; s > 0 && n.nodes[s].type === "comment"; )
          s -= 1;
        let o = this.raw(n, "semicolon");
        for (let a = 0; a < n.nodes.length; a++) {
          let A = n.nodes[a], l = this.raw(A, "before");
          l && this.builder(l), this.stringify(A, s !== a || o);
        }
      }
      comment(n) {
        let s = this.raw(n, "left", "commentLeft"), o = this.raw(n, "right", "commentRight");
        this.builder("/*" + s + n.text + o + "*/", n);
      }
      decl(n, s) {
        let o = this.raw(n, "between", "colon"), a = n.prop + o + this.rawValue(n, "value");
        n.important && (a += n.raws.important || " !important"), s && (a += ";"), this.builder(a, n);
      }
      document(n) {
        this.body(n);
      }
      raw(n, s, o) {
        let a;
        if (o || (o = s), s && (a = n.raws[s], typeof a < "u"))
          return a;
        let A = n.parent;
        if (o === "before" && (!A || A.type === "root" && A.first === n || A && A.type === "document"))
          return "";
        if (!A) return t[o];
        let l = n.root();
        if (l.rawCache || (l.rawCache = {}), typeof l.rawCache[o] < "u")
          return l.rawCache[o];
        if (o === "before" || o === "after")
          return this.beforeAfter(n, o);
        {
          let c = "raw" + e(o);
          this[c] ? a = this[c](l, n) : l.walk((u) => {
            if (a = u.raws[s], typeof a < "u") return !1;
          });
        }
        return typeof a > "u" && (a = t[o]), l.rawCache[o] = a, a;
      }
      rawBeforeClose(n) {
        let s;
        return n.walk((o) => {
          if (o.nodes && o.nodes.length > 0 && typeof o.raws.after < "u")
            return s = o.raws.after, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
        }), s && (s = s.replace(/\S/g, "")), s;
      }
      rawBeforeComment(n, s) {
        let o;
        return n.walkComments((a) => {
          if (typeof a.raws.before < "u")
            return o = a.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
        }), typeof o > "u" ? o = this.raw(s, null, "beforeDecl") : o && (o = o.replace(/\S/g, "")), o;
      }
      rawBeforeDecl(n, s) {
        let o;
        return n.walkDecls((a) => {
          if (typeof a.raws.before < "u")
            return o = a.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
        }), typeof o > "u" ? o = this.raw(s, null, "beforeRule") : o && (o = o.replace(/\S/g, "")), o;
      }
      rawBeforeOpen(n) {
        let s;
        return n.walk((o) => {
          if (o.type !== "decl" && (s = o.raws.between, typeof s < "u"))
            return !1;
        }), s;
      }
      rawBeforeRule(n) {
        let s;
        return n.walk((o) => {
          if (o.nodes && (o.parent !== n || n.first !== o) && typeof o.raws.before < "u")
            return s = o.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), !1;
        }), s && (s = s.replace(/\S/g, "")), s;
      }
      rawColon(n) {
        let s;
        return n.walkDecls((o) => {
          if (typeof o.raws.between < "u")
            return s = o.raws.between.replace(/[^\s:]/g, ""), !1;
        }), s;
      }
      rawEmptyBody(n) {
        let s;
        return n.walk((o) => {
          if (o.nodes && o.nodes.length === 0 && (s = o.raws.after, typeof s < "u"))
            return !1;
        }), s;
      }
      rawIndent(n) {
        if (n.raws.indent) return n.raws.indent;
        let s;
        return n.walk((o) => {
          let a = o.parent;
          if (a && a !== n && a.parent && a.parent === n && typeof o.raws.before < "u") {
            let A = o.raws.before.split(`
`);
            return s = A[A.length - 1], s = s.replace(/\S/g, ""), !1;
          }
        }), s;
      }
      rawSemicolon(n) {
        let s;
        return n.walk((o) => {
          if (o.nodes && o.nodes.length && o.last.type === "decl" && (s = o.raws.semicolon, typeof s < "u"))
            return !1;
        }), s;
      }
      rawValue(n, s) {
        let o = n[s], a = n.raws[s];
        return a && a.value === o ? a.raw : o;
      }
      root(n) {
        this.body(n), n.raws.after && this.builder(n.raws.after);
      }
      rule(n) {
        this.block(n, this.rawValue(n, "selector")), n.raws.ownSemicolon && this.builder(n.raws.ownSemicolon, n, "end");
      }
      stringify(n, s) {
        if (!this[n.type])
          throw new Error(
            "Unknown AST node type " + n.type + ". Maybe you need to change PostCSS stringifier."
          );
        this[n.type](n, s);
      }
    }
    return Pw = i, i.default = i, Pw;
  }
  var Ow, xS;
  function $y() {
    if (xS) return Ow;
    xS = 1;
    let t = LN();
    function e(i, r) {
      new t(r).stringify(i);
    }
    return Ow = e, e.default = e, Ow;
  }
  var Gw = {}, QS;
  function tv() {
    return QS || (QS = 1, Gw.isClean = Symbol("isClean"), Gw.my = Symbol("my")), Gw;
  }
  var jw, FS;
  function eB() {
    if (FS) return jw;
    FS = 1;
    let t = ev(), e = LN(), i = $y(), { isClean: r, my: n } = tv();
    function s(A, l) {
      let c = new A.constructor();
      for (let u in A) {
        if (!Object.prototype.hasOwnProperty.call(A, u) || u === "proxyCache") continue;
        let d = A[u], h = typeof d;
        u === "parent" && h === "object" ? l && (c[u] = l) : u === "source" ? c[u] = d : Array.isArray(d) ? c[u] = d.map((g) => s(g, c)) : (h === "object" && d !== null && (d = s(d)), c[u] = d);
      }
      return c;
    }
    function o(A, l) {
      if (l && typeof l.offset < "u")
        return l.offset;
      let c = 1, u = 1, d = 0;
      for (let h = 0; h < A.length; h++) {
        if (u === l.line && c === l.column) {
          d = h;
          break;
        }
        A[h] === `
` ? (c = 1, u += 1) : c += 1;
      }
      return d;
    }
    class a {
      constructor(l = {}) {
        this.raws = {}, this[r] = !1, this[n] = !0;
        for (let c in l)
          if (c === "nodes") {
            this.nodes = [];
            for (let u of l[c])
              typeof u.clone == "function" ? this.append(u.clone()) : this.append(u);
          } else
            this[c] = l[c];
      }
      addToError(l) {
        if (l.postcssNode = this, l.stack && this.source && /\n\s{4}at /.test(l.stack)) {
          let c = this.source;
          l.stack = l.stack.replace(
            /\n\s{4}at /,
            `$&${c.input.from}:${c.start.line}:${c.start.column}$&`
          );
        }
        return l;
      }
      after(l) {
        return this.parent.insertAfter(this, l), this;
      }
      assign(l = {}) {
        for (let c in l)
          this[c] = l[c];
        return this;
      }
      before(l) {
        return this.parent.insertBefore(this, l), this;
      }
      cleanRaws(l) {
        delete this.raws.before, delete this.raws.after, l || delete this.raws.between;
      }
      clone(l = {}) {
        let c = s(this);
        for (let u in l)
          c[u] = l[u];
        return c;
      }
      cloneAfter(l = {}) {
        let c = this.clone(l);
        return this.parent.insertAfter(this, c), c;
      }
      cloneBefore(l = {}) {
        let c = this.clone(l);
        return this.parent.insertBefore(this, c), c;
      }
      error(l, c = {}) {
        if (this.source) {
          let { end: u, start: d } = this.rangeBy(c);
          return this.source.input.error(
            l,
            { column: d.column, line: d.line },
            { column: u.column, line: u.line },
            c
          );
        }
        return new t(l);
      }
      getProxyProcessor() {
        return {
          get(l, c) {
            return c === "proxyOf" ? l : c === "root" ? () => l.root().toProxy() : l[c];
          },
          set(l, c, u) {
            return l[c] === u || (l[c] = u, (c === "prop" || c === "value" || c === "name" || c === "params" || c === "important" || /* c8 ignore next */
            c === "text") && l.markDirty()), !0;
          }
        };
      }
      /* c8 ignore next 3 */
      markClean() {
        this[r] = !0;
      }
      markDirty() {
        if (this[r]) {
          this[r] = !1;
          let l = this;
          for (; l = l.parent; )
            l[r] = !1;
        }
      }
      next() {
        if (!this.parent) return;
        let l = this.parent.index(this);
        return this.parent.nodes[l + 1];
      }
      positionBy(l) {
        let c = this.source.start;
        if (l.index)
          c = this.positionInside(l.index);
        else if (l.word) {
          let u = "document" in this.source.input ? this.source.input.document : this.source.input.css, d = u.slice(
            o(u, this.source.start),
            o(u, this.source.end)
          ).indexOf(l.word);
          d !== -1 && (c = this.positionInside(d));
        }
        return c;
      }
      positionInside(l) {
        let c = this.source.start.column, u = this.source.start.line, d = "document" in this.source.input ? this.source.input.document : this.source.input.css, h = o(d, this.source.start), g = h + l;
        for (let f = h; f < g; f++)
          d[f] === `
` ? (c = 1, u += 1) : c += 1;
        return { column: c, line: u };
      }
      prev() {
        if (!this.parent) return;
        let l = this.parent.index(this);
        return this.parent.nodes[l - 1];
      }
      rangeBy(l) {
        let c = {
          column: this.source.start.column,
          line: this.source.start.line
        }, u = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: c.column + 1,
          line: c.line
        };
        if (l.word) {
          let d = "document" in this.source.input ? this.source.input.document : this.source.input.css, h = d.slice(
            o(d, this.source.start),
            o(d, this.source.end)
          ).indexOf(l.word);
          h !== -1 && (c = this.positionInside(h), u = this.positionInside(
            h + l.word.length
          ));
        } else
          l.start ? c = {
            column: l.start.column,
            line: l.start.line
          } : l.index && (c = this.positionInside(l.index)), l.end ? u = {
            column: l.end.column,
            line: l.end.line
          } : typeof l.endIndex == "number" ? u = this.positionInside(l.endIndex) : l.index && (u = this.positionInside(l.index + 1));
        return (u.line < c.line || u.line === c.line && u.column <= c.column) && (u = { column: c.column + 1, line: c.line }), { end: u, start: c };
      }
      raw(l, c) {
        return new e().raw(this, l, c);
      }
      remove() {
        return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
      }
      replaceWith(...l) {
        if (this.parent) {
          let c = this, u = !1;
          for (let d of l)
            d === this ? u = !0 : u ? (this.parent.insertAfter(c, d), c = d) : this.parent.insertBefore(c, d);
          u || this.remove();
        }
        return this;
      }
      root() {
        let l = this;
        for (; l.parent && l.parent.type !== "document"; )
          l = l.parent;
        return l;
      }
      toJSON(l, c) {
        let u = {}, d = c == null;
        c = c || /* @__PURE__ */ new Map();
        let h = 0;
        for (let g in this) {
          if (!Object.prototype.hasOwnProperty.call(this, g) || g === "parent" || g === "proxyCache") continue;
          let f = this[g];
          if (Array.isArray(f))
            u[g] = f.map((p) => typeof p == "object" && p.toJSON ? p.toJSON(null, c) : p);
          else if (typeof f == "object" && f.toJSON)
            u[g] = f.toJSON(null, c);
          else if (g === "source") {
            let p = c.get(f.input);
            p == null && (p = h, c.set(f.input, h), h++), u[g] = {
              end: f.end,
              inputId: p,
              start: f.start
            };
          } else
            u[g] = f;
        }
        return d && (u.inputs = [...c.keys()].map((g) => g.toJSON())), u;
      }
      toProxy() {
        return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
      }
      toString(l = i) {
        l.stringify && (l = l.stringify);
        let c = "";
        return l(this, (u) => {
          c += u;
        }), c;
      }
      warn(l, c, u) {
        let d = { node: this };
        for (let h in u) d[h] = u[h];
        return l.warn(c, d);
      }
      get proxyOf() {
        return this;
      }
    }
    return jw = a, a.default = a, jw;
  }
  var Hw, SS;
  function tB() {
    if (SS) return Hw;
    SS = 1;
    let t = eB();
    class e extends t {
      constructor(r) {
        super(r), this.type = "comment";
      }
    }
    return Hw = e, e.default = e, Hw;
  }
  var Jw, DS;
  function iB() {
    if (DS) return Jw;
    DS = 1;
    let t = eB();
    class e extends t {
      constructor(r) {
        r && typeof r.value < "u" && typeof r.value != "string" && (r = { ...r, value: String(r.value) }), super(r), this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    }
    return Jw = e, e.default = e, Jw;
  }
  var Vw, TS;
  function ic() {
    if (TS) return Vw;
    TS = 1;
    let t = tB(), e = iB(), i = eB(), { isClean: r, my: n } = tv(), s, o, a, A;
    function l(d) {
      return d.map((h) => (h.nodes && (h.nodes = l(h.nodes)), delete h.source, h));
    }
    function c(d) {
      if (d[r] = !1, d.proxyOf.nodes)
        for (let h of d.proxyOf.nodes)
          c(h);
    }
    class u extends i {
      append(...h) {
        for (let g of h) {
          let f = this.normalize(g, this.last);
          for (let p of f) this.proxyOf.nodes.push(p);
        }
        return this.markDirty(), this;
      }
      cleanRaws(h) {
        if (super.cleanRaws(h), this.nodes)
          for (let g of this.nodes) g.cleanRaws(h);
      }
      each(h) {
        if (!this.proxyOf.nodes) return;
        let g = this.getIterator(), f, p;
        for (; this.indexes[g] < this.proxyOf.nodes.length && (f = this.indexes[g], p = h(this.proxyOf.nodes[f], f), p !== !1); )
          this.indexes[g] += 1;
        return delete this.indexes[g], p;
      }
      every(h) {
        return this.nodes.every(h);
      }
      getIterator() {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
        let h = this.lastEach;
        return this.indexes[h] = 0, h;
      }
      getProxyProcessor() {
        return {
          get(h, g) {
            return g === "proxyOf" ? h : h[g] ? g === "each" || typeof g == "string" && g.startsWith("walk") ? (...f) => h[g](
              ...f.map((p) => typeof p == "function" ? (m, E) => p(m.toProxy(), E) : p)
            ) : g === "every" || g === "some" ? (f) => h[g](
              (p, ...m) => f(p.toProxy(), ...m)
            ) : g === "root" ? () => h.root().toProxy() : g === "nodes" ? h.nodes.map((f) => f.toProxy()) : g === "first" || g === "last" ? h[g].toProxy() : h[g] : h[g];
          },
          set(h, g, f) {
            return h[g] === f || (h[g] = f, (g === "name" || g === "params" || g === "selector") && h.markDirty()), !0;
          }
        };
      }
      index(h) {
        return typeof h == "number" ? h : (h.proxyOf && (h = h.proxyOf), this.proxyOf.nodes.indexOf(h));
      }
      insertAfter(h, g) {
        let f = this.index(h), p = this.normalize(g, this.proxyOf.nodes[f]).reverse();
        f = this.index(h);
        for (let E of p) this.proxyOf.nodes.splice(f + 1, 0, E);
        let m;
        for (let E in this.indexes)
          m = this.indexes[E], f < m && (this.indexes[E] = m + p.length);
        return this.markDirty(), this;
      }
      insertBefore(h, g) {
        let f = this.index(h), p = f === 0 ? "prepend" : !1, m = this.normalize(
          g,
          this.proxyOf.nodes[f],
          p
        ).reverse();
        f = this.index(h);
        for (let y of m) this.proxyOf.nodes.splice(f, 0, y);
        let E;
        for (let y in this.indexes)
          E = this.indexes[y], f <= E && (this.indexes[y] = E + m.length);
        return this.markDirty(), this;
      }
      normalize(h, g) {
        if (typeof h == "string")
          h = l(o(h).nodes);
        else if (typeof h > "u")
          h = [];
        else if (Array.isArray(h)) {
          h = h.slice(0);
          for (let f of h)
            f.parent && f.parent.removeChild(f, "ignore");
        } else if (h.type === "root" && this.type !== "document") {
          h = h.nodes.slice(0);
          for (let f of h)
            f.parent && f.parent.removeChild(f, "ignore");
        } else if (h.type)
          h = [h];
        else if (h.prop) {
          if (typeof h.value > "u")
            throw new Error("Value field is missed in node creation");
          typeof h.value != "string" && (h.value = String(h.value)), h = [new e(h)];
        } else if (h.selector || h.selectors)
          h = [new A(h)];
        else if (h.name)
          h = [new s(h)];
        else if (h.text)
          h = [new t(h)];
        else
          throw new Error("Unknown node type in node creation");
        return h.map((f) => (f[n] || u.rebuild(f), f = f.proxyOf, f.parent && f.parent.removeChild(f), f[r] && c(f), f.raws || (f.raws = {}), typeof f.raws.before > "u" && g && typeof g.raws.before < "u" && (f.raws.before = g.raws.before.replace(/\S/g, "")), f.parent = this.proxyOf, f));
      }
      prepend(...h) {
        h = h.reverse();
        for (let g of h) {
          let f = this.normalize(g, this.first, "prepend").reverse();
          for (let p of f) this.proxyOf.nodes.unshift(p);
          for (let p in this.indexes)
            this.indexes[p] = this.indexes[p] + f.length;
        }
        return this.markDirty(), this;
      }
      push(h) {
        return h.parent = this, this.proxyOf.nodes.push(h), this;
      }
      removeAll() {
        for (let h of this.proxyOf.nodes) h.parent = void 0;
        return this.proxyOf.nodes = [], this.markDirty(), this;
      }
      removeChild(h) {
        h = this.index(h), this.proxyOf.nodes[h].parent = void 0, this.proxyOf.nodes.splice(h, 1);
        let g;
        for (let f in this.indexes)
          g = this.indexes[f], g >= h && (this.indexes[f] = g - 1);
        return this.markDirty(), this;
      }
      replaceValues(h, g, f) {
        return f || (f = g, g = {}), this.walkDecls((p) => {
          g.props && !g.props.includes(p.prop) || g.fast && !p.value.includes(g.fast) || (p.value = p.value.replace(h, f));
        }), this.markDirty(), this;
      }
      some(h) {
        return this.nodes.some(h);
      }
      walk(h) {
        return this.each((g, f) => {
          let p;
          try {
            p = h(g, f);
          } catch (m) {
            throw g.addToError(m);
          }
          return p !== !1 && g.walk && (p = g.walk(h)), p;
        });
      }
      walkAtRules(h, g) {
        return g ? h instanceof RegExp ? this.walk((f, p) => {
          if (f.type === "atrule" && h.test(f.name))
            return g(f, p);
        }) : this.walk((f, p) => {
          if (f.type === "atrule" && f.name === h)
            return g(f, p);
        }) : (g = h, this.walk((f, p) => {
          if (f.type === "atrule")
            return g(f, p);
        }));
      }
      walkComments(h) {
        return this.walk((g, f) => {
          if (g.type === "comment")
            return h(g, f);
        });
      }
      walkDecls(h, g) {
        return g ? h instanceof RegExp ? this.walk((f, p) => {
          if (f.type === "decl" && h.test(f.prop))
            return g(f, p);
        }) : this.walk((f, p) => {
          if (f.type === "decl" && f.prop === h)
            return g(f, p);
        }) : (g = h, this.walk((f, p) => {
          if (f.type === "decl")
            return g(f, p);
        }));
      }
      walkRules(h, g) {
        return g ? h instanceof RegExp ? this.walk((f, p) => {
          if (f.type === "rule" && h.test(f.selector))
            return g(f, p);
        }) : this.walk((f, p) => {
          if (f.type === "rule" && f.selector === h)
            return g(f, p);
        }) : (g = h, this.walk((f, p) => {
          if (f.type === "rule")
            return g(f, p);
        }));
      }
      get first() {
        if (this.proxyOf.nodes)
          return this.proxyOf.nodes[0];
      }
      get last() {
        if (this.proxyOf.nodes)
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
    }
    return u.registerParse = (d) => {
      o = d;
    }, u.registerRule = (d) => {
      A = d;
    }, u.registerAtRule = (d) => {
      s = d;
    }, u.registerRoot = (d) => {
      a = d;
    }, Vw = u, u.default = u, u.rebuild = (d) => {
      d.type === "atrule" ? Object.setPrototypeOf(d, s.prototype) : d.type === "rule" ? Object.setPrototypeOf(d, A.prototype) : d.type === "decl" ? Object.setPrototypeOf(d, e.prototype) : d.type === "comment" ? Object.setPrototypeOf(d, t.prototype) : d.type === "root" && Object.setPrototypeOf(d, a.prototype), d[n] = !0, d.nodes && d.nodes.forEach((h) => {
        u.rebuild(h);
      });
    }, Vw;
  }
  var Ww, RS;
  function iv() {
    if (RS) return Ww;
    RS = 1;
    let t = ic();
    class e extends t {
      constructor(r) {
        super(r), this.type = "atrule";
      }
      append(...r) {
        return this.proxyOf.nodes || (this.nodes = []), super.append(...r);
      }
      prepend(...r) {
        return this.proxyOf.nodes || (this.nodes = []), super.prepend(...r);
      }
    }
    return Ww = e, e.default = e, t.registerAtRule(e), Ww;
  }
  var Kw, _S;
  function rv() {
    if (_S) return Kw;
    _S = 1;
    let t = ic(), e, i;
    class r extends t {
      constructor(s) {
        super({ type: "document", ...s }), this.nodes || (this.nodes = []);
      }
      toResult(s = {}) {
        return new e(new i(), this, s).stringify();
      }
    }
    return r.registerLazyResult = (n) => {
      e = n;
    }, r.registerProcessor = (n) => {
      i = n;
    }, Kw = r, r.default = r, Kw;
  }
  var Xw, kS;
  function zX() {
    if (kS) return Xw;
    kS = 1;
    let t = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    return Xw = { nanoid: (e = 21) => {
      let i = "", r = e | 0;
      for (; r--; )
        i += t[Math.random() * 64 | 0];
      return i;
    }, customAlphabet: (e, i = 21) => (r = i) => {
      let n = "", s = r | 0;
      for (; s--; )
        n += e[Math.random() * e.length | 0];
      return n;
    } }, Xw;
  }
  var Zw, YS;
  function zN() {
    if (YS) return Zw;
    YS = 1;
    let { existsSync: t, readFileSync: e } = Ys, { dirname: i, join: r } = Ys, { SourceMapConsumer: n, SourceMapGenerator: s } = Ys;
    function o(A) {
      return Buffer ? Buffer.from(A, "base64").toString() : window.atob(A);
    }
    class a {
      constructor(l, c) {
        if (c.map === !1) return;
        this.loadAnnotation(l), this.inline = this.startWith(this.annotation, "data:");
        let u = c.map ? c.map.prev : void 0, d = this.loadMap(c.from, u);
        !this.mapFile && c.from && (this.mapFile = c.from), this.mapFile && (this.root = i(this.mapFile)), d && (this.text = d);
      }
      consumer() {
        return this.consumerCache || (this.consumerCache = new n(this.text)), this.consumerCache;
      }
      decodeInline(l) {
        let c = /^data:application\/json;charset=utf-?8;base64,/, u = /^data:application\/json;base64,/, d = /^data:application\/json;charset=utf-?8,/, h = /^data:application\/json,/, g = l.match(d) || l.match(h);
        if (g)
          return decodeURIComponent(l.substr(g[0].length));
        let f = l.match(c) || l.match(u);
        if (f)
          return o(l.substr(f[0].length));
        let p = l.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + p);
      }
      getAnnotationURL(l) {
        return l.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(l) {
        return typeof l != "object" ? !1 : typeof l.mappings == "string" || typeof l._mappings == "string" || Array.isArray(l.sections);
      }
      loadAnnotation(l) {
        let c = l.match(/\/\*\s*# sourceMappingURL=/g);
        if (!c) return;
        let u = l.lastIndexOf(c.pop()), d = l.indexOf("*/", u);
        u > -1 && d > -1 && (this.annotation = this.getAnnotationURL(l.substring(u, d)));
      }
      loadFile(l) {
        if (this.root = i(l), t(l))
          return this.mapFile = l, e(l, "utf-8").toString().trim();
      }
      loadMap(l, c) {
        if (c === !1) return !1;
        if (c) {
          if (typeof c == "string")
            return c;
          if (typeof c == "function") {
            let u = c(l);
            if (u) {
              let d = this.loadFile(u);
              if (!d)
                throw new Error(
                  "Unable to load previous source map: " + u.toString()
                );
              return d;
            }
          } else {
            if (c instanceof n)
              return s.fromSourceMap(c).toString();
            if (c instanceof s)
              return c.toString();
            if (this.isMap(c))
              return JSON.stringify(c);
            throw new Error(
              "Unsupported previous source map format: " + c.toString()
            );
          }
        } else {
          if (this.inline)
            return this.decodeInline(this.annotation);
          if (this.annotation) {
            let u = this.annotation;
            return l && (u = r(i(l), u)), this.loadFile(u);
          }
        }
      }
      startWith(l, c) {
        return l ? l.substr(0, c.length) === c : !1;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    }
    return Zw = a, a.default = a, Zw;
  }
  var qw, NS;
  function rB() {
    if (NS) return qw;
    NS = 1;
    let { nanoid: t } = /* @__PURE__ */ zX(), { isAbsolute: e, resolve: i } = Ys, { SourceMapConsumer: r, SourceMapGenerator: n } = Ys, { fileURLToPath: s, pathToFileURL: o } = Ys, a = ev(), A = zN(), l = Ys, c = Symbol("fromOffsetCache"), u = !!(r && n), d = !!(i && e);
    class h {
      constructor(f, p = {}) {
        if (f === null || typeof f > "u" || typeof f == "object" && !f.toString)
          throw new Error(`PostCSS received ${f} instead of CSS string`);
        if (this.css = f.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, this.document = this.css, p.document && (this.document = p.document.toString()), p.from && (!d || /^\w+:\/\//.test(p.from) || e(p.from) ? this.file = p.from : this.file = i(p.from)), d && u) {
          let m = new A(this.css, p);
          if (m.text) {
            this.map = m;
            let E = m.consumer().file;
            !this.file && E && (this.file = this.mapResolve(E));
          }
        }
        this.file || (this.id = "<input css " + t(6) + ">"), this.map && (this.map.file = this.from);
      }
      error(f, p, m, E = {}) {
        let y, C, w;
        if (p && typeof p == "object") {
          let I = p, b = m;
          if (typeof I.offset == "number") {
            let B = this.fromOffset(I.offset);
            p = B.line, m = B.col;
          } else
            p = I.line, m = I.column;
          if (typeof b.offset == "number") {
            let B = this.fromOffset(b.offset);
            C = B.line, y = B.col;
          } else
            C = b.line, y = b.column;
        } else if (!m) {
          let I = this.fromOffset(p);
          p = I.line, m = I.col;
        }
        let M = this.origin(p, m, C, y);
        return M ? w = new a(
          f,
          M.endLine === void 0 ? M.line : { column: M.column, line: M.line },
          M.endLine === void 0 ? M.column : { column: M.endColumn, line: M.endLine },
          M.source,
          M.file,
          E.plugin
        ) : w = new a(
          f,
          C === void 0 ? p : { column: m, line: p },
          C === void 0 ? m : { column: y, line: C },
          this.css,
          this.file,
          E.plugin
        ), w.input = { column: m, endColumn: y, endLine: C, line: p, source: this.css }, this.file && (o && (w.input.url = o(this.file).toString()), w.input.file = this.file), w;
      }
      fromOffset(f) {
        let p, m;
        if (this[c])
          m = this[c];
        else {
          let y = this.css.split(`
`);
          m = new Array(y.length);
          let C = 0;
          for (let w = 0, M = y.length; w < M; w++)
            m[w] = C, C += y[w].length + 1;
          this[c] = m;
        }
        p = m[m.length - 1];
        let E = 0;
        if (f >= p)
          E = m.length - 1;
        else {
          let y = m.length - 2, C;
          for (; E < y; )
            if (C = E + (y - E >> 1), f < m[C])
              y = C - 1;
            else if (f >= m[C + 1])
              E = C + 1;
            else {
              E = C;
              break;
            }
        }
        return {
          col: f - m[E] + 1,
          line: E + 1
        };
      }
      mapResolve(f) {
        return /^\w+:\/\//.test(f) ? f : i(this.map.consumer().sourceRoot || this.map.root || ".", f);
      }
      origin(f, p, m, E) {
        if (!this.map) return !1;
        let y = this.map.consumer(), C = y.originalPositionFor({ column: p, line: f });
        if (!C.source) return !1;
        let w;
        typeof m == "number" && (w = y.originalPositionFor({ column: E, line: m }));
        let M;
        e(C.source) ? M = o(C.source) : M = new URL(
          C.source,
          this.map.consumer().sourceRoot || o(this.map.mapFile)
        );
        let I = {
          column: C.column,
          endColumn: w && w.column,
          endLine: w && w.line,
          line: C.line,
          url: M.toString()
        };
        if (M.protocol === "file:")
          if (s)
            I.file = s(M);
          else
            throw new Error("file: protocol is not available in this PostCSS build");
        let b = y.sourceContentFor(C.source);
        return b && (I.source = b), I;
      }
      toJSON() {
        let f = {};
        for (let p of ["hasBOM", "css", "file", "id"])
          this[p] != null && (f[p] = this[p]);
        return this.map && (f.map = { ...this.map }, f.map.consumerCache && (f.map.consumerCache = void 0)), f;
      }
      get from() {
        return this.file || this.id;
      }
    }
    return qw = h, h.default = h, l && l.registerInput && l.registerInput(h), qw;
  }
  var $w, US;
  function tf() {
    if (US) return $w;
    US = 1;
    let t = ic(), e, i;
    class r extends t {
      constructor(s) {
        super(s), this.type = "root", this.nodes || (this.nodes = []);
      }
      normalize(s, o, a) {
        let A = super.normalize(s);
        if (o) {
          if (a === "prepend")
            this.nodes.length > 1 ? o.raws.before = this.nodes[1].raws.before : delete o.raws.before;
          else if (this.first !== o)
            for (let l of A)
              l.raws.before = o.raws.before;
        }
        return A;
      }
      removeChild(s, o) {
        let a = this.index(s);
        return !o && a === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[a].raws.before), super.removeChild(s);
      }
      toResult(s = {}) {
        return new e(new i(), this, s).stringify();
      }
    }
    return r.registerLazyResult = (n) => {
      e = n;
    }, r.registerProcessor = (n) => {
      i = n;
    }, $w = r, r.default = r, t.registerRoot(r), $w;
  }
  var e0, LS;
  function PN() {
    if (LS) return e0;
    LS = 1;
    let t = {
      comma(e) {
        return t.split(e, [","], !0);
      },
      space(e) {
        let i = [" ", `
`, "	"];
        return t.split(e, i);
      },
      split(e, i, r) {
        let n = [], s = "", o = !1, a = 0, A = !1, l = "", c = !1;
        for (let u of e)
          c ? c = !1 : u === "\\" ? c = !0 : A ? u === l && (A = !1) : u === '"' || u === "'" ? (A = !0, l = u) : u === "(" ? a += 1 : u === ")" ? a > 0 && (a -= 1) : a === 0 && i.includes(u) && (o = !0), o ? (s !== "" && n.push(s.trim()), s = "", o = !1) : s += u;
        return (r || s !== "") && n.push(s.trim()), n;
      }
    };
    return e0 = t, t.default = t, e0;
  }
  var t0, zS;
  function nv() {
    if (zS) return t0;
    zS = 1;
    let t = ic(), e = PN();
    class i extends t {
      constructor(n) {
        super(n), this.type = "rule", this.nodes || (this.nodes = []);
      }
      get selectors() {
        return e.comma(this.selector);
      }
      set selectors(n) {
        let s = this.selector ? this.selector.match(/,\s*/) : null, o = s ? s[0] : "," + this.raw("between", "beforeOpen");
        this.selector = n.join(o);
      }
    }
    return t0 = i, i.default = i, t.registerRule(i), t0;
  }
  var i0, PS;
  function PX() {
    if (PS) return i0;
    PS = 1;
    let t = iv(), e = tB(), i = iB(), r = rB(), n = zN(), s = tf(), o = nv();
    function a(A, l) {
      if (Array.isArray(A)) return A.map((d) => a(d));
      let { inputs: c, ...u } = A;
      if (c) {
        l = [];
        for (let d of c) {
          let h = { ...d, __proto__: r.prototype };
          h.map && (h.map = {
            ...h.map,
            __proto__: n.prototype
          }), l.push(h);
        }
      }
      if (u.nodes && (u.nodes = A.nodes.map((d) => a(d, l))), u.source) {
        let { inputId: d, ...h } = u.source;
        u.source = h, d != null && (u.source.input = l[d]);
      }
      if (u.type === "root")
        return new s(u);
      if (u.type === "decl")
        return new i(u);
      if (u.type === "rule")
        return new o(u);
      if (u.type === "comment")
        return new e(u);
      if (u.type === "atrule")
        return new t(u);
      throw new Error("Unknown node type: " + A.type);
    }
    return i0 = a, a.default = a, i0;
  }
  var r0, OS;
  function ON() {
    if (OS) return r0;
    OS = 1;
    let { dirname: t, relative: e, resolve: i, sep: r } = Ys, { SourceMapConsumer: n, SourceMapGenerator: s } = Ys, { pathToFileURL: o } = Ys, a = rB(), A = !!(n && s), l = !!(t && i && e && r);
    class c {
      constructor(d, h, g, f) {
        this.stringify = d, this.mapOpts = g.map || {}, this.root = h, this.opts = g, this.css = f, this.originalCSS = f, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let d;
        this.isInline() ? d = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? d = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? d = this.mapOpts.annotation(this.opts.to, this.root) : d = this.outputFile() + ".map";
        let h = `
`;
        this.css.includes(`\r
`) && (h = `\r
`), this.css += h + "/*# sourceMappingURL=" + d + " */";
      }
      applyPrevMaps() {
        for (let d of this.previous()) {
          let h = this.toUrl(this.path(d.file)), g = d.root || t(d.file), f;
          this.mapOpts.sourcesContent === !1 ? (f = new n(d.text), f.sourcesContent && (f.sourcesContent = null)) : f = d.consumer(), this.map.applySourceMap(f, h, this.toUrl(this.path(g)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation !== !1)
          if (this.root) {
            let d;
            for (let h = this.root.nodes.length - 1; h >= 0; h--)
              d = this.root.nodes[h], d.type === "comment" && d.text.startsWith("# sourceMappingURL=") && this.root.removeChild(h);
          } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
      }
      generate() {
        if (this.clearAnnotation(), l && A && this.isMap())
          return this.generateMap();
        {
          let d = "";
          return this.stringify(this.root, (h) => {
            d += h;
          }), [d];
        }
      }
      generateMap() {
        if (this.root)
          this.generateString();
        else if (this.previous().length === 1) {
          let d = this.previous()[0].consumer();
          d.file = this.outputFile(), this.map = s.fromSourceMap(d, {
            ignoreInvalidMapping: !0
          });
        } else
          this.map = new s({
            file: this.outputFile(),
            ignoreInvalidMapping: !0
          }), this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
      }
      generateString() {
        this.css = "", this.map = new s({
          file: this.outputFile(),
          ignoreInvalidMapping: !0
        });
        let d = 1, h = 1, g = "<no source>", f = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        }, p, m;
        this.stringify(this.root, (E, y, C) => {
          if (this.css += E, y && C !== "end" && (f.generated.line = d, f.generated.column = h - 1, y.source && y.source.start ? (f.source = this.sourcePath(y), f.original.line = y.source.start.line, f.original.column = y.source.start.column - 1, this.map.addMapping(f)) : (f.source = g, f.original.line = 1, f.original.column = 0, this.map.addMapping(f))), m = E.match(/\n/g), m ? (d += m.length, p = E.lastIndexOf(`
`), h = E.length - p) : h += E.length, y && C !== "start") {
            let w = y.parent || { raws: {} };
            (!(y.type === "decl" || y.type === "atrule" && !y.nodes) || y !== w.last || w.raws.semicolon) && (y.source && y.source.end ? (f.source = this.sourcePath(y), f.original.line = y.source.end.line, f.original.column = y.source.end.column - 1, f.generated.line = d, f.generated.column = h - 2, this.map.addMapping(f)) : (f.source = g, f.original.line = 1, f.original.column = 0, f.generated.line = d, f.generated.column = h - 1, this.map.addMapping(f)));
          }
        });
      }
      isAnnotation() {
        return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((d) => d.annotation) : !0;
      }
      isInline() {
        if (typeof this.mapOpts.inline < "u")
          return this.mapOpts.inline;
        let d = this.mapOpts.annotation;
        return typeof d < "u" && d !== !0 ? !1 : this.previous().length ? this.previous().some((h) => h.inline) : !0;
      }
      isMap() {
        return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
      }
      isSourcesContent() {
        return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((d) => d.withContent()) : !0;
      }
      outputFile() {
        return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
      }
      path(d) {
        if (this.mapOpts.absolute || d.charCodeAt(0) === 60 || /^\w+:\/\//.test(d)) return d;
        let h = this.memoizedPaths.get(d);
        if (h) return h;
        let g = this.opts.to ? t(this.opts.to) : ".";
        typeof this.mapOpts.annotation == "string" && (g = t(i(g, this.mapOpts.annotation)));
        let f = e(g, d);
        return this.memoizedPaths.set(d, f), f;
      }
      previous() {
        if (!this.previousMaps)
          if (this.previousMaps = [], this.root)
            this.root.walk((d) => {
              if (d.source && d.source.input.map) {
                let h = d.source.input.map;
                this.previousMaps.includes(h) || this.previousMaps.push(h);
              }
            });
          else {
            let d = new a(this.originalCSS, this.opts);
            d.map && this.previousMaps.push(d.map);
          }
        return this.previousMaps;
      }
      setSourcesContent() {
        let d = {};
        if (this.root)
          this.root.walk((h) => {
            if (h.source) {
              let g = h.source.input.from;
              if (g && !d[g]) {
                d[g] = !0;
                let f = this.usesFileUrls ? this.toFileUrl(g) : this.toUrl(this.path(g));
                this.map.setSourceContent(f, h.source.input.css);
              }
            }
          });
        else if (this.css) {
          let h = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(h, this.css);
        }
      }
      sourcePath(d) {
        return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(d.source.input.from) : this.toUrl(this.path(d.source.input.from));
      }
      toBase64(d) {
        return Buffer ? Buffer.from(d).toString("base64") : window.btoa(unescape(encodeURIComponent(d)));
      }
      toFileUrl(d) {
        let h = this.memoizedFileURLs.get(d);
        if (h) return h;
        if (o) {
          let g = o(d).toString();
          return this.memoizedFileURLs.set(d, g), g;
        } else
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
      }
      toUrl(d) {
        let h = this.memoizedURLs.get(d);
        if (h) return h;
        r === "\\" && (d = d.replace(/\\/g, "/"));
        let g = encodeURI(d).replace(/[#?]/g, encodeURIComponent);
        return this.memoizedURLs.set(d, g), g;
      }
    }
    return r0 = c, r0;
  }
  var n0, GS;
  function OX() {
    if (GS) return n0;
    GS = 1;
    const t = 39, e = 34, i = 92, r = 47, n = 10, s = 32, o = 12, a = 9, A = 13, l = 91, c = 93, u = 40, d = 41, h = 123, g = 125, f = 59, p = 42, m = 58, E = 64, y = /[\t\n\f\r "#'()/;[\\\]{}]/g, C = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, w = /.[\r\n"'(/\\]/, M = /[\da-f]/i;
    return n0 = function(I, b = {}) {
      let B = I.css.valueOf(), x = b.ignoreErrors, Q, v, T, S, D, F, R, Y, L, N, H = B.length, P = 0, ie = [], V = [];
      function Z() {
        return P;
      }
      function se(U) {
        throw I.error("Unclosed " + U, P);
      }
      function k() {
        return V.length === 0 && P >= H;
      }
      function _(U) {
        if (V.length) return V.pop();
        if (P >= H) return;
        let J = U ? U.ignoreUnclosed : !1;
        switch (Q = B.charCodeAt(P), Q) {
          case n:
          case s:
          case a:
          case A:
          case o: {
            S = P;
            do
              S += 1, Q = B.charCodeAt(S);
            while (Q === s || Q === n || Q === a || Q === A || Q === o);
            F = ["space", B.slice(P, S)], P = S - 1;
            break;
          }
          case l:
          case c:
          case h:
          case g:
          case m:
          case f:
          case d: {
            let ae = String.fromCharCode(Q);
            F = [ae, ae, P];
            break;
          }
          case u: {
            if (N = ie.length ? ie.pop()[1] : "", L = B.charCodeAt(P + 1), N === "url" && L !== t && L !== e && L !== s && L !== n && L !== a && L !== o && L !== A) {
              S = P;
              do {
                if (R = !1, S = B.indexOf(")", S + 1), S === -1)
                  if (x || J) {
                    S = P;
                    break;
                  } else
                    se("bracket");
                for (Y = S; B.charCodeAt(Y - 1) === i; )
                  Y -= 1, R = !R;
              } while (R);
              F = ["brackets", B.slice(P, S + 1), P, S], P = S;
            } else
              S = B.indexOf(")", P + 1), v = B.slice(P, S + 1), S === -1 || w.test(v) ? F = ["(", "(", P] : (F = ["brackets", v, P, S], P = S);
            break;
          }
          case t:
          case e: {
            D = Q === t ? "'" : '"', S = P;
            do {
              if (R = !1, S = B.indexOf(D, S + 1), S === -1)
                if (x || J) {
                  S = P + 1;
                  break;
                } else
                  se("string");
              for (Y = S; B.charCodeAt(Y - 1) === i; )
                Y -= 1, R = !R;
            } while (R);
            F = ["string", B.slice(P, S + 1), P, S], P = S;
            break;
          }
          case E: {
            y.lastIndex = P + 1, y.test(B), y.lastIndex === 0 ? S = B.length - 1 : S = y.lastIndex - 2, F = ["at-word", B.slice(P, S + 1), P, S], P = S;
            break;
          }
          case i: {
            for (S = P, T = !0; B.charCodeAt(S + 1) === i; )
              S += 1, T = !T;
            if (Q = B.charCodeAt(S + 1), T && Q !== r && Q !== s && Q !== n && Q !== a && Q !== A && Q !== o && (S += 1, M.test(B.charAt(S)))) {
              for (; M.test(B.charAt(S + 1)); )
                S += 1;
              B.charCodeAt(S + 1) === s && (S += 1);
            }
            F = ["word", B.slice(P, S + 1), P, S], P = S;
            break;
          }
          default: {
            Q === r && B.charCodeAt(P + 1) === p ? (S = B.indexOf("*/", P + 2) + 1, S === 0 && (x || J ? S = B.length : se("comment")), F = ["comment", B.slice(P, S + 1), P, S], P = S) : (C.lastIndex = P + 1, C.test(B), C.lastIndex === 0 ? S = B.length - 1 : S = C.lastIndex - 2, F = ["word", B.slice(P, S + 1), P, S], ie.push(F), P = S);
            break;
          }
        }
        return P++, F;
      }
      function q(U) {
        V.push(U);
      }
      return {
        back: q,
        endOfFile: k,
        nextToken: _,
        position: Z
      };
    }, n0;
  }
  var s0, jS;
  function GX() {
    if (jS) return s0;
    jS = 1;
    let t = iv(), e = tB(), i = iB(), r = tf(), n = nv(), s = OX();
    const o = {
      empty: !0,
      space: !0
    };
    function a(l) {
      for (let c = l.length - 1; c >= 0; c--) {
        let u = l[c], d = u[3] || u[2];
        if (d) return d;
      }
    }
    class A {
      constructor(c) {
        this.input = c, this.root = new r(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.createTokenizer(), this.root.source = { input: c, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(c) {
        let u = new t();
        u.name = c[1].slice(1), u.name === "" && this.unnamedAtrule(u, c), this.init(u, c[2]);
        let d, h, g, f = !1, p = !1, m = [], E = [];
        for (; !this.tokenizer.endOfFile(); ) {
          if (c = this.tokenizer.nextToken(), d = c[0], d === "(" || d === "[" ? E.push(d === "(" ? ")" : "]") : d === "{" && E.length > 0 ? E.push("}") : d === E[E.length - 1] && E.pop(), E.length === 0)
            if (d === ";") {
              u.source.end = this.getPosition(c[2]), u.source.end.offset++, this.semicolon = !0;
              break;
            } else if (d === "{") {
              p = !0;
              break;
            } else if (d === "}") {
              if (m.length > 0) {
                for (g = m.length - 1, h = m[g]; h && h[0] === "space"; )
                  h = m[--g];
                h && (u.source.end = this.getPosition(h[3] || h[2]), u.source.end.offset++);
              }
              this.end(c);
              break;
            } else
              m.push(c);
          else
            m.push(c);
          if (this.tokenizer.endOfFile()) {
            f = !0;
            break;
          }
        }
        u.raws.between = this.spacesAndCommentsFromEnd(m), m.length ? (u.raws.afterName = this.spacesAndCommentsFromStart(m), this.raw(u, "params", m), f && (c = m[m.length - 1], u.source.end = this.getPosition(c[3] || c[2]), u.source.end.offset++, this.spaces = u.raws.between, u.raws.between = "")) : (u.raws.afterName = "", u.params = ""), p && (u.nodes = [], this.current = u);
      }
      checkMissedSemicolon(c) {
        let u = this.colon(c);
        if (u === !1) return;
        let d = 0, h;
        for (let g = u - 1; g >= 0 && (h = c[g], !(h[0] !== "space" && (d += 1, d === 2))); g--)
          ;
        throw this.input.error(
          "Missed semicolon",
          h[0] === "word" ? h[3] + 1 : h[2]
        );
      }
      colon(c) {
        let u = 0, d, h, g;
        for (let [f, p] of c.entries()) {
          if (h = p, g = h[0], g === "(" && (u += 1), g === ")" && (u -= 1), u === 0 && g === ":")
            if (!d)
              this.doubleColon(h);
            else {
              if (d[0] === "word" && d[1] === "progid")
                continue;
              return f;
            }
          d = h;
        }
        return !1;
      }
      comment(c) {
        let u = new e();
        this.init(u, c[2]), u.source.end = this.getPosition(c[3] || c[2]), u.source.end.offset++;
        let d = c[1].slice(2, -2);
        if (/^\s*$/.test(d))
          u.text = "", u.raws.left = d, u.raws.right = "";
        else {
          let h = d.match(/^(\s*)([^]*\S)(\s*)$/);
          u.text = h[2], u.raws.left = h[1], u.raws.right = h[3];
        }
      }
      createTokenizer() {
        this.tokenizer = s(this.input);
      }
      decl(c, u) {
        let d = new i();
        this.init(d, c[0][2]);
        let h = c[c.length - 1];
        for (h[0] === ";" && (this.semicolon = !0, c.pop()), d.source.end = this.getPosition(
          h[3] || h[2] || a(c)
        ), d.source.end.offset++; c[0][0] !== "word"; )
          c.length === 1 && this.unknownWord(c), d.raws.before += c.shift()[1];
        for (d.source.start = this.getPosition(c[0][2]), d.prop = ""; c.length; ) {
          let m = c[0][0];
          if (m === ":" || m === "space" || m === "comment")
            break;
          d.prop += c.shift()[1];
        }
        d.raws.between = "";
        let g;
        for (; c.length; )
          if (g = c.shift(), g[0] === ":") {
            d.raws.between += g[1];
            break;
          } else
            g[0] === "word" && /\w/.test(g[1]) && this.unknownWord([g]), d.raws.between += g[1];
        (d.prop[0] === "_" || d.prop[0] === "*") && (d.raws.before += d.prop[0], d.prop = d.prop.slice(1));
        let f = [], p;
        for (; c.length && (p = c[0][0], !(p !== "space" && p !== "comment")); )
          f.push(c.shift());
        this.precheckMissedSemicolon(c);
        for (let m = c.length - 1; m >= 0; m--) {
          if (g = c[m], g[1].toLowerCase() === "!important") {
            d.important = !0;
            let E = this.stringFrom(c, m);
            E = this.spacesFromEnd(c) + E, E !== " !important" && (d.raws.important = E);
            break;
          } else if (g[1].toLowerCase() === "important") {
            let E = c.slice(0), y = "";
            for (let C = m; C > 0; C--) {
              let w = E[C][0];
              if (y.trim().startsWith("!") && w !== "space")
                break;
              y = E.pop()[1] + y;
            }
            y.trim().startsWith("!") && (d.important = !0, d.raws.important = y, c = E);
          }
          if (g[0] !== "space" && g[0] !== "comment")
            break;
        }
        c.some((m) => m[0] !== "space" && m[0] !== "comment") && (d.raws.between += f.map((m) => m[1]).join(""), f = []), this.raw(d, "value", f.concat(c), u), d.value.includes(":") && !u && this.checkMissedSemicolon(c);
      }
      doubleColon(c) {
        throw this.input.error(
          "Double colon",
          { offset: c[2] },
          { offset: c[2] + c[1].length }
        );
      }
      emptyRule(c) {
        let u = new n();
        this.init(u, c[2]), u.selector = "", u.raws.between = "", this.current = u;
      }
      end(c) {
        this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(c[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(c);
      }
      endFile() {
        this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(c) {
        if (this.spaces += c[1], this.current.nodes) {
          let u = this.current.nodes[this.current.nodes.length - 1];
          u && u.type === "rule" && !u.raws.ownSemicolon && (u.raws.ownSemicolon = this.spaces, this.spaces = "", u.source.end = this.getPosition(c[2]), u.source.end.offset += u.raws.ownSemicolon.length);
        }
      }
      // Helpers
      getPosition(c) {
        let u = this.input.fromOffset(c);
        return {
          column: u.col,
          line: u.line,
          offset: c
        };
      }
      init(c, u) {
        this.current.push(c), c.source = {
          input: this.input,
          start: this.getPosition(u)
        }, c.raws.before = this.spaces, this.spaces = "", c.type !== "comment" && (this.semicolon = !1);
      }
      other(c) {
        let u = !1, d = null, h = !1, g = null, f = [], p = c[1].startsWith("--"), m = [], E = c;
        for (; E; ) {
          if (d = E[0], m.push(E), d === "(" || d === "[")
            g || (g = E), f.push(d === "(" ? ")" : "]");
          else if (p && h && d === "{")
            g || (g = E), f.push("}");
          else if (f.length === 0)
            if (d === ";")
              if (h) {
                this.decl(m, p);
                return;
              } else
                break;
            else if (d === "{") {
              this.rule(m);
              return;
            } else if (d === "}") {
              this.tokenizer.back(m.pop()), u = !0;
              break;
            } else d === ":" && (h = !0);
          else d === f[f.length - 1] && (f.pop(), f.length === 0 && (g = null));
          E = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile() && (u = !0), f.length > 0 && this.unclosedBracket(g), u && h) {
          if (!p)
            for (; m.length && (E = m[m.length - 1][0], !(E !== "space" && E !== "comment")); )
              this.tokenizer.back(m.pop());
          this.decl(m, p);
        } else
          this.unknownWord(m);
      }
      parse() {
        let c;
        for (; !this.tokenizer.endOfFile(); )
          switch (c = this.tokenizer.nextToken(), c[0]) {
            case "space":
              this.spaces += c[1];
              break;
            case ";":
              this.freeSemicolon(c);
              break;
            case "}":
              this.end(c);
              break;
            case "comment":
              this.comment(c);
              break;
            case "at-word":
              this.atrule(c);
              break;
            case "{":
              this.emptyRule(c);
              break;
            default:
              this.other(c);
              break;
          }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(c, u, d, h) {
        let g, f, p = d.length, m = "", E = !0, y, C;
        for (let w = 0; w < p; w += 1)
          g = d[w], f = g[0], f === "space" && w === p - 1 && !h ? E = !1 : f === "comment" ? (C = d[w - 1] ? d[w - 1][0] : "empty", y = d[w + 1] ? d[w + 1][0] : "empty", !o[C] && !o[y] ? m.slice(-1) === "," ? E = !1 : m += g[1] : E = !1) : m += g[1];
        if (!E) {
          let w = d.reduce((M, I) => M + I[1], "");
          c.raws[u] = { raw: w, value: m };
        }
        c[u] = m;
      }
      rule(c) {
        c.pop();
        let u = new n();
        this.init(u, c[0][2]), u.raws.between = this.spacesAndCommentsFromEnd(c), this.raw(u, "selector", c), this.current = u;
      }
      spacesAndCommentsFromEnd(c) {
        let u, d = "";
        for (; c.length && (u = c[c.length - 1][0], !(u !== "space" && u !== "comment")); )
          d = c.pop()[1] + d;
        return d;
      }
      // Errors
      spacesAndCommentsFromStart(c) {
        let u, d = "";
        for (; c.length && (u = c[0][0], !(u !== "space" && u !== "comment")); )
          d += c.shift()[1];
        return d;
      }
      spacesFromEnd(c) {
        let u, d = "";
        for (; c.length && (u = c[c.length - 1][0], u === "space"); )
          d = c.pop()[1] + d;
        return d;
      }
      stringFrom(c, u) {
        let d = "";
        for (let h = u; h < c.length; h++)
          d += c[h][1];
        return c.splice(u, c.length - u), d;
      }
      unclosedBlock() {
        let c = this.current.source.start;
        throw this.input.error("Unclosed block", c.line, c.column);
      }
      unclosedBracket(c) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: c[2] },
          { offset: c[2] + 1 }
        );
      }
      unexpectedClose(c) {
        throw this.input.error(
          "Unexpected }",
          { offset: c[2] },
          { offset: c[2] + 1 }
        );
      }
      unknownWord(c) {
        throw this.input.error(
          "Unknown word",
          { offset: c[0][2] },
          { offset: c[0][2] + c[0][1].length }
        );
      }
      unnamedAtrule(c, u) {
        throw this.input.error(
          "At-rule without name",
          { offset: u[2] },
          { offset: u[2] + u[1].length }
        );
      }
    }
    return s0 = A, s0;
  }
  var o0, HS;
  function sv() {
    if (HS) return o0;
    HS = 1;
    let t = ic(), e = rB(), i = GX();
    function r(n, s) {
      let o = new e(n, s), a = new i(o);
      try {
        a.parse();
      } catch (A) {
        throw process.env.NODE_ENV !== "production" && A.name === "CssSyntaxError" && s && s.from && (/\.scss$/i.test(s.from) ? A.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(s.from) ? A.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(s.from) && (A.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), A;
      }
      return a.root;
    }
    return o0 = r, r.default = r, t.registerParse(r), o0;
  }
  var a0, JS;
  function GN() {
    if (JS) return a0;
    JS = 1;
    class t {
      constructor(i, r = {}) {
        if (this.type = "warning", this.text = i, r.node && r.node.source) {
          let n = r.node.rangeBy(r);
          this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
        }
        for (let n in r) this[n] = r[n];
      }
      toString() {
        return this.node ? this.node.error(this.text, {
          index: this.index,
          plugin: this.plugin,
          word: this.word
        }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
      }
    }
    return a0 = t, t.default = t, a0;
  }
  var A0, VS;
  function ov() {
    if (VS) return A0;
    VS = 1;
    let t = GN();
    class e {
      constructor(r, n, s) {
        this.processor = r, this.messages = [], this.root = n, this.opts = s, this.css = void 0, this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(r, n = {}) {
        n.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (n.plugin = this.lastPlugin.postcssPlugin);
        let s = new t(r, n);
        return this.messages.push(s), s;
      }
      warnings() {
        return this.messages.filter((r) => r.type === "warning");
      }
      get content() {
        return this.css;
      }
    }
    return A0 = e, e.default = e, A0;
  }
  var l0, WS;
  function jN() {
    if (WS) return l0;
    WS = 1;
    let t = {};
    return l0 = function(e) {
      t[e] || (t[e] = !0, typeof console < "u" && console.warn && console.warn(e));
    }, l0;
  }
  var c0, KS;
  function HN() {
    if (KS) return c0;
    KS = 1;
    let t = ic(), e = rv(), i = ON(), r = sv(), n = ov(), s = tf(), o = $y(), { isClean: a, my: A } = tv(), l = jN();
    const c = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    }, u = {
      AtRule: !0,
      AtRuleExit: !0,
      Comment: !0,
      CommentExit: !0,
      Declaration: !0,
      DeclarationExit: !0,
      Document: !0,
      DocumentExit: !0,
      Once: !0,
      OnceExit: !0,
      postcssPlugin: !0,
      prepare: !0,
      Root: !0,
      RootExit: !0,
      Rule: !0,
      RuleExit: !0
    }, d = {
      Once: !0,
      postcssPlugin: !0,
      prepare: !0
    }, h = 0;
    function g(C) {
      return typeof C == "object" && typeof C.then == "function";
    }
    function f(C) {
      let w = !1, M = c[C.type];
      return C.type === "decl" ? w = C.prop.toLowerCase() : C.type === "atrule" && (w = C.name.toLowerCase()), w && C.append ? [
        M,
        M + "-" + w,
        h,
        M + "Exit",
        M + "Exit-" + w
      ] : w ? [M, M + "-" + w, M + "Exit", M + "Exit-" + w] : C.append ? [M, h, M + "Exit"] : [M, M + "Exit"];
    }
    function p(C) {
      let w;
      return C.type === "document" ? w = ["Document", h, "DocumentExit"] : C.type === "root" ? w = ["Root", h, "RootExit"] : w = f(C), {
        eventIndex: 0,
        events: w,
        iterator: 0,
        node: C,
        visitorIndex: 0,
        visitors: []
      };
    }
    function m(C) {
      return C[a] = !1, C.nodes && C.nodes.forEach((w) => m(w)), C;
    }
    let E = {};
    class y {
      constructor(w, M, I) {
        this.stringified = !1, this.processed = !1;
        let b;
        if (typeof M == "object" && M !== null && (M.type === "root" || M.type === "document"))
          b = m(M);
        else if (M instanceof y || M instanceof n)
          b = m(M.root), M.map && (typeof I.map > "u" && (I.map = {}), I.map.inline || (I.map.inline = !1), I.map.prev = M.map);
        else {
          let B = r;
          I.syntax && (B = I.syntax.parse), I.parser && (B = I.parser), B.parse && (B = B.parse);
          try {
            b = B(M, I);
          } catch (x) {
            this.processed = !0, this.error = x;
          }
          b && !b[A] && t.rebuild(b);
        }
        this.result = new n(w, b, I), this.helpers = { ...E, postcss: E, result: this.result }, this.plugins = this.processor.plugins.map((B) => typeof B == "object" && B.prepare ? { ...B, ...B.prepare(this.result) } : B);
      }
      async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
      }
      catch(w) {
        return this.async().catch(w);
      }
      finally(w) {
        return this.async().then(w, w);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(w, M) {
        let I = this.result.lastPlugin;
        try {
          if (M && M.addToError(w), this.error = w, w.name === "CssSyntaxError" && !w.plugin)
            w.plugin = I.postcssPlugin, w.setMessage();
          else if (I.postcssVersion && process.env.NODE_ENV !== "production") {
            let b = I.postcssPlugin, B = I.postcssVersion, x = this.result.processor.version, Q = B.split("."), v = x.split(".");
            (Q[0] !== v[0] || parseInt(Q[1]) > parseInt(v[1])) && console.error(
              "Unknown error from PostCSS plugin. Your current PostCSS version is " + x + ", but " + b + " uses " + B + ". Perhaps this is the source of the error below."
            );
          }
        } catch (b) {
          console && console.error && console.error(b);
        }
        return w;
      }
      prepareVisitors() {
        this.listeners = {};
        let w = (M, I, b) => {
          this.listeners[I] || (this.listeners[I] = []), this.listeners[I].push([M, b]);
        };
        for (let M of this.plugins)
          if (typeof M == "object")
            for (let I in M) {
              if (!u[I] && /^[A-Z]/.test(I))
                throw new Error(
                  `Unknown event ${I} in ${M.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              if (!d[I])
                if (typeof M[I] == "object")
                  for (let b in M[I])
                    b === "*" ? w(M, I, M[I][b]) : w(
                      M,
                      I + "-" + b.toLowerCase(),
                      M[I][b]
                    );
                else typeof M[I] == "function" && w(M, I, M[I]);
            }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let w = 0; w < this.plugins.length; w++) {
          let M = this.plugins[w], I = this.runOnRoot(M);
          if (g(I))
            try {
              await I;
            } catch (b) {
              throw this.handleError(b);
            }
        }
        if (this.prepareVisitors(), this.hasListener) {
          let w = this.result.root;
          for (; !w[a]; ) {
            w[a] = !0;
            let M = [p(w)];
            for (; M.length > 0; ) {
              let I = this.visitTick(M);
              if (g(I))
                try {
                  await I;
                } catch (b) {
                  let B = M[M.length - 1].node;
                  throw this.handleError(b, B);
                }
            }
          }
          if (this.listeners.OnceExit)
            for (let [M, I] of this.listeners.OnceExit) {
              this.result.lastPlugin = M;
              try {
                if (w.type === "document") {
                  let b = w.nodes.map(
                    (B) => I(B, this.helpers)
                  );
                  await Promise.all(b);
                } else
                  await I(w, this.helpers);
              } catch (b) {
                throw this.handleError(b);
              }
            }
        }
        return this.processed = !0, this.stringify();
      }
      runOnRoot(w) {
        this.result.lastPlugin = w;
        try {
          if (typeof w == "object" && w.Once) {
            if (this.result.root.type === "document") {
              let M = this.result.root.nodes.map(
                (I) => w.Once(I, this.helpers)
              );
              return g(M[0]) ? Promise.all(M) : M;
            }
            return w.Once(this.result.root, this.helpers);
          } else if (typeof w == "function")
            return w(this.result.root, this.result);
        } catch (M) {
          throw this.handleError(M);
        }
      }
      stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        this.stringified = !0, this.sync();
        let w = this.result.opts, M = o;
        w.syntax && (M = w.syntax.stringify), w.stringifier && (M = w.stringifier), M.stringify && (M = M.stringify);
        let I = new i(M, this.result.root, this.result.opts).generate();
        return this.result.css = I[0], this.result.map = I[1], this.result;
      }
      sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        if (this.processed = !0, this.processing)
          throw this.getAsyncError();
        for (let w of this.plugins) {
          let M = this.runOnRoot(w);
          if (g(M))
            throw this.getAsyncError();
        }
        if (this.prepareVisitors(), this.hasListener) {
          let w = this.result.root;
          for (; !w[a]; )
            w[a] = !0, this.walkSync(w);
          if (this.listeners.OnceExit)
            if (w.type === "document")
              for (let M of w.nodes)
                this.visitSync(this.listeners.OnceExit, M);
            else
              this.visitSync(this.listeners.OnceExit, w);
        }
        return this.result;
      }
      then(w, M) {
        return process.env.NODE_ENV !== "production" && ("from" in this.opts || l(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        )), this.async().then(w, M);
      }
      toString() {
        return this.css;
      }
      visitSync(w, M) {
        for (let [I, b] of w) {
          this.result.lastPlugin = I;
          let B;
          try {
            B = b(M, this.helpers);
          } catch (x) {
            throw this.handleError(x, M.proxyOf);
          }
          if (M.type !== "root" && M.type !== "document" && !M.parent)
            return !0;
          if (g(B))
            throw this.getAsyncError();
        }
      }
      visitTick(w) {
        let M = w[w.length - 1], { node: I, visitors: b } = M;
        if (I.type !== "root" && I.type !== "document" && !I.parent) {
          w.pop();
          return;
        }
        if (b.length > 0 && M.visitorIndex < b.length) {
          let [x, Q] = b[M.visitorIndex];
          M.visitorIndex += 1, M.visitorIndex === b.length && (M.visitors = [], M.visitorIndex = 0), this.result.lastPlugin = x;
          try {
            return Q(I.toProxy(), this.helpers);
          } catch (v) {
            throw this.handleError(v, I);
          }
        }
        if (M.iterator !== 0) {
          let x = M.iterator, Q;
          for (; Q = I.nodes[I.indexes[x]]; )
            if (I.indexes[x] += 1, !Q[a]) {
              Q[a] = !0, w.push(p(Q));
              return;
            }
          M.iterator = 0, delete I.indexes[x];
        }
        let B = M.events;
        for (; M.eventIndex < B.length; ) {
          let x = B[M.eventIndex];
          if (M.eventIndex += 1, x === h) {
            I.nodes && I.nodes.length && (I[a] = !0, M.iterator = I.getIterator());
            return;
          } else if (this.listeners[x]) {
            M.visitors = this.listeners[x];
            return;
          }
        }
        w.pop();
      }
      walkSync(w) {
        w[a] = !0;
        let M = f(w);
        for (let I of M)
          if (I === h)
            w.nodes && w.each((b) => {
              b[a] || this.walkSync(b);
            });
          else {
            let b = this.listeners[I];
            if (b && this.visitSync(b, w.toProxy()))
              return;
          }
      }
      warnings() {
        return this.sync().warnings();
      }
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
    }
    return y.registerPostcss = (C) => {
      E = C;
    }, c0 = y, y.default = y, s.registerLazyResult(y), e.registerLazyResult(y), c0;
  }
  var u0, XS;
  function jX() {
    if (XS) return u0;
    XS = 1;
    let t = ON(), e = sv();
    const i = ov();
    let r = $y(), n = jN();
    class s {
      constructor(a, A, l) {
        A = A.toString(), this.stringified = !1, this._processor = a, this._css = A, this._opts = l, this._map = void 0;
        let c, u = r;
        this.result = new i(this._processor, c, this._opts), this.result.css = A;
        let d = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return d.root;
          }
        });
        let h = new t(u, c, this._opts, A);
        if (h.isMap()) {
          let [g, f] = h.generate();
          g && (this.result.css = g), f && (this.result.map = f);
        } else
          h.clearAnnotation(), this.result.css = h.css;
      }
      async() {
        return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
      }
      catch(a) {
        return this.async().catch(a);
      }
      finally(a) {
        return this.async().then(a, a);
      }
      sync() {
        if (this.error) throw this.error;
        return this.result;
      }
      then(a, A) {
        return process.env.NODE_ENV !== "production" && ("from" in this._opts || n(
          "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
        )), this.async().then(a, A);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root)
          return this._root;
        let a, A = e;
        try {
          a = A(this._css, this._opts);
        } catch (l) {
          this.error = l;
        }
        if (this.error)
          throw this.error;
        return this._root = a, a;
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
    }
    return u0 = s, s.default = s, u0;
  }
  var d0, ZS;
  function HX() {
    if (ZS) return d0;
    ZS = 1;
    let t = rv(), e = HN(), i = jX(), r = tf();
    class n {
      constructor(o = []) {
        this.version = "8.5.2", this.plugins = this.normalize(o);
      }
      normalize(o) {
        let a = [];
        for (let A of o)
          if (A.postcss === !0 ? A = A() : A.postcss && (A = A.postcss), typeof A == "object" && Array.isArray(A.plugins))
            a = a.concat(A.plugins);
          else if (typeof A == "object" && A.postcssPlugin)
            a.push(A);
          else if (typeof A == "function")
            a.push(A);
          else if (typeof A == "object" && (A.parse || A.stringify)) {
            if (process.env.NODE_ENV !== "production")
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
          } else
            throw new Error(A + " is not a PostCSS plugin");
        return a;
      }
      process(o, a = {}) {
        return !this.plugins.length && !a.parser && !a.stringifier && !a.syntax ? new i(this, o, a) : new e(this, o, a);
      }
      use(o) {
        return this.plugins = this.plugins.concat(this.normalize([o])), this;
      }
    }
    return d0 = n, n.default = n, r.registerProcessor(n), t.registerProcessor(n), d0;
  }
  var h0, qS;
  function JX() {
    if (qS) return h0;
    qS = 1;
    let t = iv(), e = tB(), i = ic(), r = ev(), n = iB(), s = rv(), o = PX(), a = rB(), A = HN(), l = PN(), c = eB(), u = sv(), d = HX(), h = ov(), g = tf(), f = nv(), p = $y(), m = GN();
    function E(...y) {
      return y.length === 1 && Array.isArray(y[0]) && (y = y[0]), new d(y);
    }
    return E.plugin = function(y, C) {
      let w = !1;
      function M(...b) {
        console && console.warn && !w && (w = !0, console.warn(
          y + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
        ), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(
          y + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`
        ));
        let B = C(...b);
        return B.postcssPlugin = y, B.postcssVersion = new d().version, B;
      }
      let I;
      return Object.defineProperty(M, "postcss", {
        get() {
          return I || (I = M()), I;
        }
      }), M.process = function(b, B, x) {
        return E([M(x)]).process(b, B);
      }, M;
    }, E.stringify = p, E.parse = u, E.fromJSON = o, E.list = l, E.comment = (y) => new e(y), E.atRule = (y) => new t(y), E.decl = (y) => new n(y), E.rule = (y) => new f(y), E.root = (y) => new g(y), E.document = (y) => new s(y), E.CssSyntaxError = r, E.Declaration = n, E.Container = i, E.Processor = d, E.Document = s, E.Comment = e, E.Warning = m, E.AtRule = t, E.Result = h, E.Input = a, E.Rule = f, E.Root = g, E.Node = c, A.registerPostcss(E), h0 = E, E.default = E, h0;
  }
  var g0, $S;
  function VX() {
    if ($S) return g0;
    $S = 1;
    const t = /* @__PURE__ */ DX(), e = TX(), { isPlainObject: i } = RX(), r = _X(), n = YX(), { parse: s } = JX(), o = [
      "img",
      "audio",
      "video",
      "picture",
      "svg",
      "object",
      "map",
      "iframe",
      "embed"
    ], a = ["script", "style"];
    function A(p, m) {
      p && Object.keys(p).forEach(function(E) {
        m(p[E], E);
      });
    }
    function l(p, m) {
      return {}.hasOwnProperty.call(p, m);
    }
    function c(p, m) {
      const E = [];
      return A(p, function(y) {
        m(y) && E.push(y);
      }), E;
    }
    function u(p) {
      for (const m in p)
        if (l(p, m))
          return !1;
      return !0;
    }
    function d(p) {
      return p.map(function(m) {
        if (!m.url)
          throw new Error("URL missing");
        return m.url + (m.w ? ` ${m.w}w` : "") + (m.h ? ` ${m.h}h` : "") + (m.d ? ` ${m.d}x` : "");
      }).join(", ");
    }
    g0 = g;
    const h = /^[^\0\t\n\f\r /<=>]+$/;
    function g(p, m, E) {
      if (p == null)
        return "";
      typeof p == "number" && (p = p.toString());
      let y = "", C = "";
      function w(J, ae) {
        const $ = this;
        this.tag = J, this.attribs = ae || {}, this.tagPosition = y.length, this.text = "", this.mediaChildren = [], this.updateParentNodeText = function() {
          if (F.length) {
            const Ce = F[F.length - 1];
            Ce.text += $.text;
          }
        }, this.updateParentNodeMediaChildren = function() {
          F.length && o.includes(this.tag) && F[F.length - 1].mediaChildren.push(this.tag);
        };
      }
      m = Object.assign({}, g.defaults, m), m.parser = Object.assign({}, f, m.parser);
      const M = function(J) {
        return m.allowedTags === !1 || (m.allowedTags || []).indexOf(J) > -1;
      };
      a.forEach(function(J) {
        M(J) && !m.allowVulnerableTags && console.warn(`

⚠️ Your \`allowedTags\` option includes, \`${J}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
      });
      const I = m.nonTextTags || [
        "script",
        "style",
        "textarea",
        "option"
      ];
      let b, B;
      m.allowedAttributes && (b = {}, B = {}, A(m.allowedAttributes, function(J, ae) {
        b[ae] = [];
        const $ = [];
        J.forEach(function(Ce) {
          typeof Ce == "string" && Ce.indexOf("*") >= 0 ? $.push(e(Ce).replace(/\\\*/g, ".*")) : b[ae].push(Ce);
        }), $.length && (B[ae] = new RegExp("^(" + $.join("|") + ")$"));
      }));
      const x = {}, Q = {}, v = {};
      A(m.allowedClasses, function(J, ae) {
        if (b && (l(b, ae) || (b[ae] = []), b[ae].push("class")), x[ae] = J, Array.isArray(J)) {
          const $ = [];
          x[ae] = [], v[ae] = [], J.forEach(function(Ce) {
            typeof Ce == "string" && Ce.indexOf("*") >= 0 ? $.push(e(Ce).replace(/\\\*/g, ".*")) : Ce instanceof RegExp ? v[ae].push(Ce) : x[ae].push(Ce);
          }), $.length && (Q[ae] = new RegExp("^(" + $.join("|") + ")$"));
        }
      });
      const T = {};
      let S;
      A(m.transformTags, function(J, ae) {
        let $;
        typeof J == "function" ? $ = J : typeof J == "string" && ($ = g.simpleTransform(J)), ae === "*" ? S = $ : T[ae] = $;
      });
      let D, F, R, Y, L, N, H = !1;
      ie();
      const P = new t.Parser({
        onopentag: function(J, ae) {
          if (m.enforceHtmlBoundary && J === "html" && ie(), L) {
            N++;
            return;
          }
          const $ = new w(J, ae);
          F.push($);
          let Ce = !1;
          const Re = !!$.text;
          let Oe;
          if (l(T, J) && (Oe = T[J](J, ae), $.attribs = ae = Oe.attribs, Oe.text !== void 0 && ($.innerText = Oe.text), J !== Oe.tagName && ($.name = J = Oe.tagName, Y[D] = Oe.tagName)), S && (Oe = S(J, ae), $.attribs = ae = Oe.attribs, J !== Oe.tagName && ($.name = J = Oe.tagName, Y[D] = Oe.tagName)), (!M(J) || m.disallowedTagsMode === "recursiveEscape" && !u(R) || m.nestingLimit != null && D >= m.nestingLimit) && (Ce = !0, R[D] = !0, (m.disallowedTagsMode === "discard" || m.disallowedTagsMode === "completelyDiscard") && I.indexOf(J) !== -1 && (L = !0, N = 1), R[D] = !0), D++, Ce) {
            if (m.disallowedTagsMode === "discard" || m.disallowedTagsMode === "completelyDiscard")
              return;
            C = y, y = "";
          }
          y += "<" + J, J === "script" && (m.allowedScriptHostnames || m.allowedScriptDomains) && ($.innerText = ""), (!b || l(b, J) || b["*"]) && A(ae, function(K, Ae) {
            if (!h.test(Ae)) {
              delete $.attribs[Ae];
              return;
            }
            if (K === "" && !m.allowedEmptyAttributes.includes(Ae) && (m.nonBooleanAttributes.includes(Ae) || m.nonBooleanAttributes.includes("*"))) {
              delete $.attribs[Ae];
              return;
            }
            let ut = !1;
            if (!b || l(b, J) && b[J].indexOf(Ae) !== -1 || b["*"] && b["*"].indexOf(Ae) !== -1 || l(B, J) && B[J].test(Ae) || B["*"] && B["*"].test(Ae))
              ut = !0;
            else if (b && b[J]) {
              for (const Me of b[J])
                if (i(Me) && Me.name && Me.name === Ae) {
                  ut = !0;
                  let Fe = "";
                  if (Me.multiple === !0) {
                    const jt = K.split(" ");
                    for (const Rt of jt)
                      Me.values.indexOf(Rt) !== -1 && (Fe === "" ? Fe = Rt : Fe += " " + Rt);
                  } else Me.values.indexOf(K) >= 0 && (Fe = K);
                  K = Fe;
                }
            }
            if (ut) {
              if (m.allowedSchemesAppliedToAttributes.indexOf(Ae) !== -1 && Z(J, K)) {
                delete $.attribs[Ae];
                return;
              }
              if (J === "script" && Ae === "src") {
                let Me = !0;
                try {
                  const Fe = se(K);
                  if (m.allowedScriptHostnames || m.allowedScriptDomains) {
                    const jt = (m.allowedScriptHostnames || []).find(function(rt) {
                      return rt === Fe.url.hostname;
                    }), Rt = (m.allowedScriptDomains || []).find(function(rt) {
                      return Fe.url.hostname === rt || Fe.url.hostname.endsWith(`.${rt}`);
                    });
                    Me = jt || Rt;
                  }
                } catch {
                  Me = !1;
                }
                if (!Me) {
                  delete $.attribs[Ae];
                  return;
                }
              }
              if (J === "iframe" && Ae === "src") {
                let Me = !0;
                try {
                  const Fe = se(K);
                  if (Fe.isRelativeUrl)
                    Me = l(m, "allowIframeRelativeUrls") ? m.allowIframeRelativeUrls : !m.allowedIframeHostnames && !m.allowedIframeDomains;
                  else if (m.allowedIframeHostnames || m.allowedIframeDomains) {
                    const jt = (m.allowedIframeHostnames || []).find(function(rt) {
                      return rt === Fe.url.hostname;
                    }), Rt = (m.allowedIframeDomains || []).find(function(rt) {
                      return Fe.url.hostname === rt || Fe.url.hostname.endsWith(`.${rt}`);
                    });
                    Me = jt || Rt;
                  }
                } catch {
                  Me = !1;
                }
                if (!Me) {
                  delete $.attribs[Ae];
                  return;
                }
              }
              if (Ae === "srcset")
                try {
                  let Me = n(K);
                  if (Me.forEach(function(Fe) {
                    Z("srcset", Fe.url) && (Fe.evil = !0);
                  }), Me = c(Me, function(Fe) {
                    return !Fe.evil;
                  }), Me.length)
                    K = d(c(Me, function(Fe) {
                      return !Fe.evil;
                    })), $.attribs[Ae] = K;
                  else {
                    delete $.attribs[Ae];
                    return;
                  }
                } catch {
                  delete $.attribs[Ae];
                  return;
                }
              if (Ae === "class") {
                const Me = x[J], Fe = x["*"], jt = Q[J], Rt = v[J], rt = Q["*"], Ke = [
                  jt,
                  rt
                ].concat(Rt).filter(function(Qt) {
                  return Qt;
                });
                if (Me && Fe ? K = U(K, r(Me, Fe), Ke) : K = U(K, Me || Fe, Ke), !K.length) {
                  delete $.attribs[Ae];
                  return;
                }
              }
              if (Ae === "style") {
                if (m.parseStyleAttributes)
                  try {
                    const Me = s(J + " {" + K + "}", { map: !1 }), Fe = k(Me, m.allowedStyles);
                    if (K = _(Fe), K.length === 0) {
                      delete $.attribs[Ae];
                      return;
                    }
                  } catch {
                    typeof window < "u" && console.warn('Failed to parse "' + J + " {" + K + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`), delete $.attribs[Ae];
                    return;
                  }
                else if (m.allowedStyles)
                  throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
              }
              y += " " + Ae, K && K.length ? y += '="' + V(K, !0) + '"' : m.allowedEmptyAttributes.includes(Ae) && (y += '=""');
            } else
              delete $.attribs[Ae];
          }), m.selfClosing.indexOf(J) !== -1 ? y += " />" : (y += ">", $.innerText && !Re && !m.textFilter && (y += V($.innerText), H = !0)), Ce && (y = C + V(y), C = "");
        },
        ontext: function(J) {
          if (L)
            return;
          const ae = F[F.length - 1];
          let $;
          if (ae && ($ = ae.tag, J = ae.innerText !== void 0 ? ae.innerText : J), m.disallowedTagsMode === "completelyDiscard" && !M($))
            J = "";
          else if ((m.disallowedTagsMode === "discard" || m.disallowedTagsMode === "completelyDiscard") && ($ === "script" || $ === "style"))
            y += J;
          else {
            const Ce = V(J, !1);
            m.textFilter && !H ? y += m.textFilter(Ce, $) : H || (y += Ce);
          }
          if (F.length) {
            const Ce = F[F.length - 1];
            Ce.text += J;
          }
        },
        onclosetag: function(J, ae) {
          if (L)
            if (N--, !N)
              L = !1;
            else
              return;
          const $ = F.pop();
          if (!$)
            return;
          if ($.tag !== J) {
            F.push($);
            return;
          }
          L = m.enforceHtmlBoundary ? J === "html" : !1, D--;
          const Ce = R[D];
          if (Ce) {
            if (delete R[D], m.disallowedTagsMode === "discard" || m.disallowedTagsMode === "completelyDiscard") {
              $.updateParentNodeText();
              return;
            }
            C = y, y = "";
          }
          if (Y[D] && (J = Y[D], delete Y[D]), m.exclusiveFilter && m.exclusiveFilter($)) {
            y = y.substr(0, $.tagPosition);
            return;
          }
          if ($.updateParentNodeMediaChildren(), $.updateParentNodeText(), // Already output />
          m.selfClosing.indexOf(J) !== -1 || // Escaped tag, closing tag is implied
          ae && !M(J) && ["escape", "recursiveEscape"].indexOf(m.disallowedTagsMode) >= 0) {
            Ce && (y = C, C = "");
            return;
          }
          y += "</" + J + ">", Ce && (y = C + V(y), C = ""), H = !1;
        }
      }, m.parser);
      return P.write(p), P.end(), y;
      function ie() {
        y = "", D = 0, F = [], R = {}, Y = {}, L = !1, N = 0;
      }
      function V(J, ae) {
        return typeof J != "string" && (J = J + ""), m.parser.decodeEntities && (J = J.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), ae && (J = J.replace(/"/g, "&quot;"))), J = J.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), ae && (J = J.replace(/"/g, "&quot;")), J;
      }
      function Z(J, ae) {
        for (ae = ae.replace(/[\x00-\x20]+/g, ""); ; ) {
          const Re = ae.indexOf("<!--");
          if (Re === -1)
            break;
          const Oe = ae.indexOf("-->", Re + 4);
          if (Oe === -1)
            break;
          ae = ae.substring(0, Re) + ae.substring(Oe + 3);
        }
        const $ = ae.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
        if (!$)
          return ae.match(/^[/\\]{2}/) ? !m.allowProtocolRelative : !1;
        const Ce = $[1].toLowerCase();
        return l(m.allowedSchemesByTag, J) ? m.allowedSchemesByTag[J].indexOf(Ce) === -1 : !m.allowedSchemes || m.allowedSchemes.indexOf(Ce) === -1;
      }
      function se(J) {
        if (J = J.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"), J.startsWith("relative:"))
          throw new Error("relative: exploit attempt");
        let ae = "relative://relative-site";
        for (let Ce = 0; Ce < 100; Ce++)
          ae += `/${Ce}`;
        const $ = new URL(J, ae);
        return {
          isRelativeUrl: $ && $.hostname === "relative-site" && $.protocol === "relative:",
          url: $
        };
      }
      function k(J, ae) {
        if (!ae)
          return J;
        const $ = J.nodes[0];
        let Ce;
        return ae[$.selector] && ae["*"] ? Ce = r(
          ae[$.selector],
          ae["*"]
        ) : Ce = ae[$.selector] || ae["*"], Ce && (J.nodes[0].nodes = $.nodes.reduce(q(Ce), [])), J;
      }
      function _(J) {
        return J.nodes[0].nodes.reduce(function(ae, $) {
          return ae.push(
            `${$.prop}:${$.value}${$.important ? " !important" : ""}`
          ), ae;
        }, []).join(";");
      }
      function q(J) {
        return function(ae, $) {
          return l(J, $.prop) && J[$.prop].some(function(Ce) {
            return Ce.test($.value);
          }) && ae.push($), ae;
        };
      }
      function U(J, ae, $) {
        return ae ? (J = J.split(/\s+/), J.filter(function(Ce) {
          return ae.indexOf(Ce) !== -1 || $.some(function(Re) {
            return Re.test(Ce);
          });
        }).join(" ")) : J;
      }
    }
    const f = {
      decodeEntities: !0
    };
    return g.defaults = {
      allowedTags: [
        // Sections derived from MDN element categories and limited to the more
        // benign categories.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
        // Content sectioning
        "address",
        "article",
        "aside",
        "footer",
        "header",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "hgroup",
        "main",
        "nav",
        "section",
        // Text content
        "blockquote",
        "dd",
        "div",
        "dl",
        "dt",
        "figcaption",
        "figure",
        "hr",
        "li",
        "main",
        "ol",
        "p",
        "pre",
        "ul",
        // Inline text semantics
        "a",
        "abbr",
        "b",
        "bdi",
        "bdo",
        "br",
        "cite",
        "code",
        "data",
        "dfn",
        "em",
        "i",
        "kbd",
        "mark",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "time",
        "u",
        "var",
        "wbr",
        // Table content
        "caption",
        "col",
        "colgroup",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr"
      ],
      // Tags that cannot be boolean
      nonBooleanAttributes: [
        "abbr",
        "accept",
        "accept-charset",
        "accesskey",
        "action",
        "allow",
        "alt",
        "as",
        "autocapitalize",
        "autocomplete",
        "blocking",
        "charset",
        "cite",
        "class",
        "color",
        "cols",
        "colspan",
        "content",
        "contenteditable",
        "coords",
        "crossorigin",
        "data",
        "datetime",
        "decoding",
        "dir",
        "dirname",
        "download",
        "draggable",
        "enctype",
        "enterkeyhint",
        "fetchpriority",
        "for",
        "form",
        "formaction",
        "formenctype",
        "formmethod",
        "formtarget",
        "headers",
        "height",
        "hidden",
        "high",
        "href",
        "hreflang",
        "http-equiv",
        "id",
        "imagesizes",
        "imagesrcset",
        "inputmode",
        "integrity",
        "is",
        "itemid",
        "itemprop",
        "itemref",
        "itemtype",
        "kind",
        "label",
        "lang",
        "list",
        "loading",
        "low",
        "max",
        "maxlength",
        "media",
        "method",
        "min",
        "minlength",
        "name",
        "nonce",
        "optimum",
        "pattern",
        "ping",
        "placeholder",
        "popover",
        "popovertarget",
        "popovertargetaction",
        "poster",
        "preload",
        "referrerpolicy",
        "rel",
        "rows",
        "rowspan",
        "sandbox",
        "scope",
        "shape",
        "size",
        "sizes",
        "slot",
        "span",
        "spellcheck",
        "src",
        "srcdoc",
        "srclang",
        "srcset",
        "start",
        "step",
        "style",
        "tabindex",
        "target",
        "title",
        "translate",
        "type",
        "usemap",
        "value",
        "width",
        "wrap",
        // Event handlers
        "onauxclick",
        "onafterprint",
        "onbeforematch",
        "onbeforeprint",
        "onbeforeunload",
        "onbeforetoggle",
        "onblur",
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncontextlost",
        "oncontextmenu",
        "oncontextrestored",
        "oncopy",
        "oncuechange",
        "oncut",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "onformdata",
        "onhashchange",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onlanguagechange",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmessage",
        "onmessageerror",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onoffline",
        "ononline",
        "onpagehide",
        "onpageshow",
        "onpaste",
        "onpause",
        "onplay",
        "onplaying",
        "onpopstate",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onrejectionhandled",
        "onscroll",
        "onscrollend",
        "onsecuritypolicyviolation",
        "onseeked",
        "onseeking",
        "onselect",
        "onslotchange",
        "onstalled",
        "onstorage",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onunhandledrejection",
        "onunload",
        "onvolumechange",
        "onwaiting",
        "onwheel"
      ],
      disallowedTagsMode: "discard",
      allowedAttributes: {
        a: ["href", "name", "target"],
        // We don't currently allow img itself by default, but
        // these attributes would make sense if we did.
        img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
      },
      allowedEmptyAttributes: [
        "alt"
      ],
      // Lots of these won't come up by default because we don't allow them
      selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
      // URL schemes we permit
      allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
      allowedSchemesByTag: {},
      allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
      allowProtocolRelative: !0,
      enforceHtmlBoundary: !1,
      parseStyleAttributes: !0
    }, g.simpleTransform = function(p, m, E) {
      return E = E === void 0 ? !0 : E, m = m || {}, function(y, C) {
        let w;
        if (E)
          for (w in m)
            C[w] = m[w];
        else
          C = m;
        return {
          tagName: p,
          attribs: C
        };
      };
    }, g0;
  }
  var WX = /* @__PURE__ */ VX();
  const av = /* @__PURE__ */ yX(WX);
  je({
    name: "DpsFormCheckboxGroup",
    components: {
      DpsFormCheckbox: _N
    },
    props: {
      /**
       * The unique identifier for the checkbox group (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * modelValue of the checkbox group.
       * @default undefined
       */
      modelValue: {
        type: Array,
        required: !1,
        default: void 0
      },
      /**
       * Name attribute of the checkboxes.
       * @default undefined
       */
      name: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Label for the checkbox group.
       * @default undefined
       */
      label: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Whether the label should be visually hidden.
       * @default false
       */
      hideLabel: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Array of checkbox data to be displayed.
       */
      options: {
        type: Array,
        required: !0
      },
      /**
       * Key to use for the checkbox values.
       * @default "value"
       */
      optionValue: {
        type: String,
        required: !1,
        default: "value"
      },
      /**
       * Key to use for the checkbox labels.
       * @default "label"
       */
      optionLabel: {
        type: String,
        required: !1,
        default: "label"
      },
      /**
       * Disables the checkbox group.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Checkboxes displayed in line.
       * @default false
       */
      inline: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Truncates the labels.
       * @default false
       */
      truncate: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Size of the checkboxes.
       * @default undefined
       */
      size: {
        type: String,
        required: !1,
        default: void 0
      }
    },
    emits: [
      /**
       * Emitted when one of the values changes.
       * @event module:DpsFormCheckboxGroup#update:modelValue
       */
      "update:modelValue"
    ],
    data() {
      return {
        selected: void 0
      };
    },
    computed: {
      mappedOptions() {
        const t = [];
        return this.options.forEach((e) => {
          let i = {};
          typeof e != "object" ? (i[this.optionValue] = e, i[this.optionLabel] = e) : i = JSON.parse(JSON.stringify(e)), t.push(i);
        }), t;
      },
      uniqueId() {
        return this.id ? this.id : vn("dps-form-checkbox-group-");
      }
    },
    created() {
      this.selected = this.modelValue;
    },
    methods: {
      handleChange(t) {
        this.selected = t, this.$emit("update:modelValue", t);
      },
      getLabelContent(t) {
        const e = t[this.optionLabel];
        return typeof e == "string" ? av(e) : e.toString();
      }
    }
  });
  const KX = je({
    name: "DpsFormGroup",
    props: {
      /**
       * Unique ID for the component (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Description text shown under the content.
       * @default undefined
       */
      description: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Label for the group.
       * @default undefined
       */
      label: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * ID of the element the label is for.
       * @default undefined
       */
      labelFor: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Whether the label should be visually hidden.
       * @default false
       */
      hideLabel: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Text shown on success.
       * @default undefined
       */
      successFeedback: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Text shown on error.
       * @default undefined
       */
      errorFeedback: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Whether the input is valid or not.
       * `undefined` if the state is neutral.
       * @default undefined
       */
      valid: {
        type: Boolean,
        required: !1,
        default: void 0
      },
      /**
       * Whether the group is disabled.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    computed: {
      uniqueId() {
        return this.id ? this.id : vn("dps-form-group-");
      },
      hasError() {
        return this.valid === !1;
      },
      hasSuccess() {
        return this.valid === !0;
      },
      ariaDescribedby() {
        const t = [];
        if (this.description && t.push(this.uniqueId + "__description"), this.successFeedback && this.hasSuccess && t.push(this.uniqueId + "__success-feedback"), this.errorFeedback && this.hasError && t.push(this.uniqueId + "__error-feedback"), t.length)
          return t.join(" ");
      }
    }
  }), XX = ["id", "aria-invalid"], ZX = ["id", "for"], qX = ["id"], $X = ["id"], eZ = ["id"];
  function tZ(t, e, i, r, n, s) {
    return G(), X("div", {
      id: t.uniqueId,
      class: he(["dps-form-group", {
        "dps-form-group--disabled": t.disabled
      }]),
      role: "group",
      "aria-invalid": t.hasError ? "true" : void 0
    }, [
      t.label ? (G(), X("label", {
        key: 0,
        id: t.uniqueId + "__label",
        for: t.labelFor,
        class: he(["dps-form-group__label", { "visually-hidden": t.hideLabel }])
      }, Pe(t.label), 11, ZX)) : de("", !0),
      be("div", null, [
        ge(t.$slots, "default", {
          slotProps: {
            success: t.hasSuccess,
            error: t.hasError,
            disabled: t.disabled,
            description: t.description,
            ariaDescribedby: t.ariaDescribedby
          }
        }),
        t.errorFeedback ? $t((G(), X("div", {
          key: 0,
          id: t.uniqueId + "__error-feedback",
          tabindex: "-1",
          "aria-live": "assertive",
          class: "dps-form-group__feedback dps-form-group__feedback--error"
        }, Pe(t.errorFeedback), 9, qX)), [
          [gi, t.hasError]
        ]) : de("", !0),
        t.successFeedback ? $t((G(), X("div", {
          key: 1,
          id: t.uniqueId + "__success-feedback",
          tabindex: "-1",
          "aria-live": "assertive",
          class: "dps-form-group__feedback dps-form-group__feedback--success"
        }, Pe(t.successFeedback), 9, $X)), [
          [gi, t.hasSuccess]
        ]) : de("", !0),
        t.description ? (G(), X("div", {
          key: 2,
          id: t.uniqueId + "__description",
          tabindex: "-1",
          class: "dps-form-group__description"
        }, Pe(t.description), 9, eZ)) : de("", !0)
      ])
    ], 10, XX);
  }
  const iZ = /* @__PURE__ */ Vn(KX, [["render", tZ]]);
  je({
    name: "DpsFormInput",
    props: {
      /**
       * Unique ID of the input field.
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * ModelValue of the input.
       * @default undefined
       */
      modelValue: {
        type: [String, Number],
        required: !1,
        default: void 0
      },
      /**
       * Icon displayed at the end of the input field.
       * @default undefined
       */
      icon: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Placeholder text.
       * @default undefined
       */
      placeholder: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Title attribute of the input.
       * @default undefined
       */
      title: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Makes the field readonly.
       * @default false
       */
      readonly: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Disables the field.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * The maximum string length that the user can enter.
       * @default -1
       */
      maxlength: {
        type: Number,
        required: !1,
        default: -1
      },
      /**
       * The type of the input field.
       * @default "text"
       */
      type: {
        type: String,
        required: !1,
        default: "text"
      },
      /**
       * The step attribute specifying the granularity number values have to
       * adhere to.
       * @default 1
       */
      step: {
        type: Number,
        required: !1,
        default: 1
      },
      /**
       * The minimum value to accept for this input.
       * @default undefined
       */
      min: {
        type: Number,
        required: !1,
        default: void 0
      },
      /**
       * The maximum value to accept for this input.
       * @default undefined
       */
      max: {
        type: Number,
        required: !1,
        default: void 0
      },
      /**
       * Pattern the value must match to be valid.
       * @default undefined
       */
      pattern: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Required field.
       * @default false
       */
      required: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Aria label for the input.
       * @default undefined
       */
      ariaLabel: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * ID of the element that labels the input.
       * @default undefined
       */
      ariaLabelledby: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * ID of the element that describes the input.
       * @default undefined
       */
      ariaDescribedby: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Vertical size of the input field.
       * @default undefined
       */
      size: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Displays the success state.
       * @default false
       */
      success: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Displays the error state.
       * @default false
       */
      error: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the value changes.
       * @event module:DpsFormInput#update:modelValue
       */
      "update:modelValue",
      /**
       * Emitted on keyup.
       * @event module:DpsFormInput#keyup
       */
      "keyup",
      /**
       * Emitted on keydown.
       * @event module:DpsFormInput#keydown
       */
      "keydown",
      /**
       * Emitted on blur.
       * @event module:DpsFormInput#blur
       */
      "blur",
      /**
       * Emitted on focus.
       * @event module:DpsFormInput#focus
       */
      "focus"
    ],
    computed: {
      iconName() {
        if (this.icon)
          return this.icon;
        if (this.error)
          return "warning";
        if (this.success)
          return "check";
      },
      showSearchCancelButton() {
        var t;
        return this.type === "search" && typeof this.modelValue == "string" && ((t = this.modelValue) == null ? void 0 : t.length) > 0;
      }
    },
    methods: {
      focus() {
        this.$refs.input.focus();
      },
      cancelSearch() {
        this.$emit("update:modelValue", ""), this.focus();
      },
      handleInput(t) {
        const e = t.target.value;
        this.$emit("update:modelValue", e);
      }
    }
  });
  const rZ = je({
    name: "DpsFormRadio",
    props: {
      /**
       * Unique ID for the radio (optional)
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * ModelValue of the radio.
       * @default undefined
       */
      modelValue: {
        type: [String, Boolean, Number],
        required: !1,
        default: void 0
      },
      /**
       * Name attribute of the radio input.
       */
      name: {
        type: String,
        required: !0
      },
      /**
       * Value of the radio input.
       */
      value: {
        type: [String, Boolean, Number],
        required: !0
      },
      /**
       * Disables the radio input.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      readonly: {
        type: Boolean,
        required: !1,
        default: !1
      },
      error: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Displays the component as a block.
       * @default false
       */
      block: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Truncates the label.
       * @default false
       */
      truncate: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Hides the label.
       * @default false
       */
      hideLabel: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the selected value changes.
       * @event module:DpsFormRadio#update:modelValue
       */
      "update:modelValue"
    ],
    computed: {
      uniqueId() {
        return this.id ? this.id : vn("dps-form-radio-");
      },
      isChecked() {
        return this.modelValue === this.value;
      }
    },
    methods: {
      handleChange(t) {
        const e = t.target.value;
        this.$emit("update:modelValue", e);
      }
    }
  }), nZ = ["id", "name", "value", "checked", "disabled", "readonly"], sZ = ["for"], oZ = {
    key: 0,
    class: "sr-only"
  };
  function aZ(t, e, i, r, n, s) {
    return G(), X("div", {
      class: he(["dps-form-radio dps-input-wrapper", { "dps-form-radio--block": t.block || t.truncate }])
    }, [
      be("input", {
        id: t.uniqueId,
        class: he(["dps-form-radio__input dps-radio", { "dps-radio--error": t.error }]),
        type: "radio",
        name: t.name,
        value: t.value,
        checked: t.isChecked,
        disabled: t.disabled || t.readonly,
        readonly: t.readonly,
        onChange: e[0] || (e[0] = (...o) => t.handleChange && t.handleChange(...o))
      }, null, 42, nZ),
      be("label", {
        for: t.uniqueId,
        class: he(["dps-form-radio__label dps-label", {
          "dps-form-radio__label--input-only": t.hideLabel,
          "dps-text--ellipse": t.truncate
        }])
      }, [
        t.hideLabel ? (G(), X("span", oZ, [
          ge(t.$slots, "default")
        ])) : ge(t.$slots, "default", { key: 1 })
      ], 10, sZ)
    ], 2);
  }
  const AZ = /* @__PURE__ */ Vn(rZ, [["render", aZ]]);
  je({
    name: "DpsFormRadioGroup",
    components: {
      DpsFormRadio: AZ
    },
    props: {
      /**
       * The unique identifier for the radio group (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * ModelValue of the radio group.
       * @default undefined
       */
      modelValue: {
        type: [String, Boolean, Number],
        required: !1,
        default: void 0
      },
      /**
       * Name of the radio inputs.
       */
      name: {
        type: String,
        required: !0
      },
      /**
       * Label for the radio group.
       * @default undefined
       */
      label: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Whether the label should be visually hidden.
       * @default false
       */
      hideLabel: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Array of options to be displayed.
       */
      options: {
        type: Array,
        required: !0
      },
      /**
       * Which key to use for the option value.
       * @default "value"
       */
      optionValue: {
        type: String,
        required: !1,
        default: "value"
      },
      /**
       * Which key to use for the option label.
       * @default "label"
       */
      optionLabel: {
        type: String,
        required: !1,
        default: "label"
      },
      /**
       * Whether the radio group should be disabled.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Whether the radio inputs should be displayed in line.
       * @default false
       */
      inline: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Whether the labels should be truncated.
       * @default false
       */
      truncate: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the selected value changes.
       * @event module:DpsFormRadioGroup#update:modelValue
       */
      "update:modelValue"
    ],
    data() {
      return {
        selected: void 0
      };
    },
    computed: {
      mappedOptions() {
        const t = [];
        return this.options.forEach((e) => {
          let i = {};
          typeof e != "object" ? (i[this.optionValue] = e, i[this.optionLabel] = e) : i = JSON.parse(JSON.stringify(e)), t.push(i);
        }), t;
      },
      uniqueId() {
        return this.id ? this.id : vn("dps-form-radio-group-");
      }
    },
    watch: {
      modelValue(t) {
        this.selected = t;
      }
    },
    created() {
      this.selected = this.modelValue;
    },
    methods: {
      handleChange(t) {
        this.$emit("update:modelValue", t);
      },
      getLabelContent(t) {
        const e = t[this.optionLabel];
        return typeof e == "string" ? av(e) : e.toString();
      }
    }
  });
  function f0(t) {
    return t === 0 ? !1 : Array.isArray(t) && t.length === 0 ? !0 : !t;
  }
  function lZ(t) {
    return (...e) => !t(...e);
  }
  function cZ(t, e) {
    return t === void 0 && (t = "undefined"), t === null && (t = "null"), t === !1 && (t = "false"), t.toString().toLowerCase().indexOf(e.trim()) !== -1;
  }
  function JN(t, e, i, r) {
    return e ? t.filter((n) => cZ(r(n, i), e)).sort((n, s) => r(n, i).length - r(s, i).length) : t;
  }
  function uZ(t) {
    return t.filter((e) => !e.$isLabel);
  }
  function p0(t, e) {
    return (i) => i.reduce((r, n) => n[t] && n[t].length ? (r.push({
      $groupLabel: n[e],
      $isLabel: !0
    }), r.concat(n[t])) : r, []);
  }
  function dZ(t, e, i, r, n) {
    return (s) => s.map((o) => {
      if (!o[i])
        return console.warn("Options passed to vue-multiselect do not contain groups, despite the config."), [];
      const a = JN(o[i], t, e, n);
      return a.length ? {
        [r]: o[r],
        [i]: a
      } : [];
    });
  }
  const eD = (...t) => (e) => t.reduce((i, r) => r(i), e);
  var hZ = {
    data() {
      return {
        search: "",
        isOpen: !1,
        preferredOpenDirection: "below",
        optimizedHeight: this.maxHeight
      };
    },
    props: {
      /**
       * Decide whether to filter the results based on search query.
       * Useful for async filtering, where we search through more complex data.
       * @type {Boolean}
       */
      internalSearch: {
        type: Boolean,
        default: !0
      },
      /**
       * Array of available options: Objects, Strings or Integers.
       * If array of objects, visible label will default to option.label.
       * If `labal` prop is passed, label will equal option['label']
       * @type {Array}
       */
      options: {
        type: Array,
        required: !0
      },
      /**
       * Equivalent to the `multiple` attribute on a `<select>` input.
       * @default false
       * @type {Boolean}
       */
      multiple: {
        type: Boolean,
        default: !1
      },
      /**
       * Key to compare objects
       * @default 'id'
       * @type {String}
       */
      trackBy: {
        type: String
      },
      /**
       * Label to look for in option Object
       * @default 'label'
       * @type {String}
       */
      label: {
        type: String
      },
      /**
       * Enable/disable search in options
       * @default true
       * @type {Boolean}
       */
      searchable: {
        type: Boolean,
        default: !0
      },
      /**
       * Clear the search input after `)
       * @default true
       * @type {Boolean}
       */
      clearOnSelect: {
        type: Boolean,
        default: !0
      },
      /**
       * Hide already selected options
       * @default false
       * @type {Boolean}
       */
      hideSelected: {
        type: Boolean,
        default: !1
      },
      /**
       * Equivalent to the `placeholder` attribute on a `<select>` input.
       * @default 'Select option'
       * @type {String}
       */
      placeholder: {
        type: String,
        default: "Select option"
      },
      /**
       * Allow to remove all selected values
       * @default true
       * @type {Boolean}
       */
      allowEmpty: {
        type: Boolean,
        default: !0
      },
      /**
       * Reset this.internalValue, this.search after this.internalValue changes.
       * Useful if want to create a stateless dropdown.
       * @default false
       * @type {Boolean}
       */
      resetAfter: {
        type: Boolean,
        default: !1
      },
      /**
       * Enable/disable closing after selecting an option
       * @default true
       * @type {Boolean}
       */
      closeOnSelect: {
        type: Boolean,
        default: !0
      },
      /**
       * Function to interpolate the custom label
       * @default false
       * @type {Function}
       */
      customLabel: {
        type: Function,
        default(t, e) {
          return f0(t) ? "" : e ? t[e] : t;
        }
      },
      /**
       * Disable / Enable tagging
       * @default false
       * @type {Boolean}
       */
      taggable: {
        type: Boolean,
        default: !1
      },
      /**
       * String to show when highlighting a potential tag
       * @default 'Press enter to create a tag'
       * @type {String}
      */
      tagPlaceholder: {
        type: String,
        default: "Press enter to create a tag"
      },
      /**
       * By default new tags will appear above the search results.
       * Changing to 'bottom' will revert this behaviour
       * and will proritize the search results
       * @default 'top'
       * @type {String}
      */
      tagPosition: {
        type: String,
        default: "top"
      },
      /**
       * Number of allowed selected options. No limit if 0.
       * @default 0
       * @type {Number}
      */
      max: {
        type: [Number, Boolean],
        default: !1
      },
      /**
       * Will be passed with all events as second param.
       * Useful for identifying events origin.
       * @default null
       * @type {String|Integer}
      */
      id: {
        default: null
      },
      /**
       * Limits the options displayed in the dropdown
       * to the first X options.
       * @default 1000
       * @type {Integer}
      */
      optionsLimit: {
        type: Number,
        default: 1e3
      },
      /**
       * Name of the property containing
       * the group values
       * @default 1000
       * @type {String}
      */
      groupValues: {
        type: String
      },
      /**
       * Name of the property containing
       * the group label
       * @default 1000
       * @type {String}
      */
      groupLabel: {
        type: String
      },
      /**
       * Allow to select all group values
       * by selecting the group label
       * @default false
       * @type {Boolean}
       */
      groupSelect: {
        type: Boolean,
        default: !1
      },
      /**
       * Array of keyboard keys to block
       * when selecting
       * @default 1000
       * @type {String}
      */
      blockKeys: {
        type: Array,
        default() {
          return [];
        }
      },
      /**
       * Prevent from wiping up the search value
       * @default false
       * @type {Boolean}
      */
      preserveSearch: {
        type: Boolean,
        default: !1
      },
      /**
       * Select 1st options if value is empty
       * @default false
       * @type {Boolean}
      */
      preselectFirst: {
        type: Boolean,
        default: !1
      },
      /**
       * Prevent autofocus
       * @default false
       * @type {Boolean}
      */
      preventAutofocus: {
        type: Boolean,
        default: !1
      }
    },
    mounted() {
      !this.multiple && this.max && console.warn("[Vue-Multiselect warn]: Max prop should not be used when prop Multiple equals false."), this.preselectFirst && !this.internalValue.length && this.options.length && this.select(this.filteredOptions[0]);
    },
    computed: {
      internalValue() {
        return this.modelValue || this.modelValue === 0 ? Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue] : [];
      },
      filteredOptions() {
        const t = this.search || "", e = t.toLowerCase().trim();
        let i = this.options.concat();
        return this.internalSearch ? i = this.groupValues ? this.filterAndFlat(i, e, this.label) : JN(i, e, this.label, this.customLabel) : i = this.groupValues ? p0(this.groupValues, this.groupLabel)(i) : i, i = this.hideSelected ? i.filter(lZ(this.isSelected)) : i, this.taggable && e.length && !this.isExistingOption(e) && (this.tagPosition === "bottom" ? i.push({ isTag: !0, label: t }) : i.unshift({ isTag: !0, label: t })), i.slice(0, this.optionsLimit);
      },
      valueKeys() {
        return this.trackBy ? this.internalValue.map((t) => t[this.trackBy]) : this.internalValue;
      },
      optionKeys() {
        return (this.groupValues ? this.flatAndStrip(this.options) : this.options).map((t) => this.customLabel(t, this.label).toString().toLowerCase());
      },
      currentOptionLabel() {
        return this.multiple ? this.searchable ? "" : this.placeholder : this.internalValue.length ? this.getOptionLabel(this.internalValue[0]) : this.searchable ? "" : this.placeholder;
      }
    },
    watch: {
      internalValue: {
        handler() {
          this.resetAfter && this.internalValue.length && (this.search = "", this.$emit("update:modelValue", this.multiple ? [] : null));
        },
        deep: !0
      },
      search() {
        this.$emit("search-change", this.search);
      }
    },
    emits: ["open", "search-change", "close", "select", "update:modelValue", "remove", "tag"],
    methods: {
      /**
       * Returns the internalValue in a way it can be emited to the parent
       * @returns {Object||Array||String||Integer}
       */
      getValue() {
        return this.multiple ? this.internalValue : this.internalValue.length === 0 ? null : this.internalValue[0];
      },
      /**
       * Filters and then flattens the options list
       * @param  {Array}
       * @return {Array} returns a filtered and flat options list
       */
      filterAndFlat(t, e, i) {
        return eD(
          dZ(e, i, this.groupValues, this.groupLabel, this.customLabel),
          p0(this.groupValues, this.groupLabel)
        )(t);
      },
      /**
       * Flattens and then strips the group labels from the options list
       * @param  {Array}
       * @return {Array} returns a flat options list without group labels
       */
      flatAndStrip(t) {
        return eD(
          p0(this.groupValues, this.groupLabel),
          uZ
        )(t);
      },
      /**
       * Updates the search value
       * @param  {String}
       */
      updateSearch(t) {
        this.search = t;
      },
      /**
       * Finds out if the given query is already present
       * in the available options
       * @param  {String}
       * @return {Boolean} returns true if element is available
       */
      isExistingOption(t) {
        return this.options ? this.optionKeys.indexOf(t) > -1 : !1;
      },
      /**
       * Finds out if the given element is already present
       * in the result value
       * @param  {Object||String||Integer} option passed element to check
       * @returns {Boolean} returns true if element is selected
       */
      isSelected(t) {
        const e = this.trackBy ? t[this.trackBy] : t;
        return this.valueKeys.indexOf(e) > -1;
      },
      /**
       * Finds out if the given option is disabled
       * @param  {Object||String||Integer} option passed element to check
       * @returns {Boolean} returns true if element is disabled
       */
      isOptionDisabled(t) {
        return !!t.$isDisabled;
      },
      /**
       * Returns empty string when options is null/undefined
       * Returns tag query if option is tag.
       * Returns the customLabel() results and casts it to string.
       *
       * @param  {Object||String||Integer} Passed option
       * @returns {Object||String}
       */
      getOptionLabel(t) {
        if (f0(t)) return "";
        if (t.isTag) return t.label;
        if (t.$isLabel) return t.$groupLabel;
        const e = this.customLabel(t, this.label);
        return f0(e) ? "" : e;
      },
      /**
       * Add the given option to the list of selected options
       * or sets the option as the selected option.
       * If option is already selected -> remove it from the results.
       *
       * @param  {Object||String||Integer} option to select/deselect
       * @param  {Boolean} block removing
       */
      select(t, e) {
        if (t.$isLabel && this.groupSelect) {
          this.selectGroup(t);
          return;
        }
        if (!(this.blockKeys.indexOf(e) !== -1 || this.disabled || t.$isDisabled || t.$isLabel) && !(this.max && this.multiple && this.internalValue.length === this.max) && !(e === "Tab" && !this.pointerDirty)) {
          if (t.isTag)
            this.$emit("tag", t.label, this.id), this.search = "", this.closeOnSelect && !this.multiple && this.deactivate();
          else {
            if (this.isSelected(t)) {
              e !== "Tab" && this.removeElement(t);
              return;
            }
            this.multiple ? this.$emit("update:modelValue", this.internalValue.concat([t])) : this.$emit("update:modelValue", t), this.$emit("select", t, this.id), this.clearOnSelect && (this.search = "");
          }
          this.closeOnSelect && this.deactivate();
        }
      },
      /**
       * Add the given group options to the list of selected options
       * If all group optiona are already selected -> remove it from the results.
       *
       * @param  {Object||String||Integer} group to select/deselect
       */
      selectGroup(t) {
        const e = this.options.find((i) => i[this.groupLabel] === t.$groupLabel);
        if (e) {
          if (this.wholeGroupSelected(e)) {
            this.$emit("remove", e[this.groupValues], this.id);
            const i = this.internalValue.filter(
              (r) => e[this.groupValues].indexOf(r) === -1
            );
            this.$emit("update:modelValue", i);
          } else {
            let i = e[this.groupValues].filter(
              (r) => !(this.isOptionDisabled(r) || this.isSelected(r))
            );
            this.max && i.splice(this.max - this.internalValue.length), this.$emit("select", i, this.id), this.$emit(
              "update:modelValue",
              this.internalValue.concat(i)
            );
          }
          this.closeOnSelect && this.deactivate();
        }
      },
      /**
       * Helper to identify if all values in a group are selected
       *
       * @param {Object} group to validated selected values against
       */
      wholeGroupSelected(t) {
        return t[this.groupValues].every(
          (e) => this.isSelected(e) || this.isOptionDisabled(e)
        );
      },
      /**
       * Helper to identify if all values in a group are disabled
       *
       * @param {Object} group to check for disabled values
       */
      wholeGroupDisabled(t) {
        return t[this.groupValues].every(this.isOptionDisabled);
      },
      /**
       * Removes the given option from the selected options.
       * Additionally checks this.allowEmpty prop if option can be removed when
       * it is the last selected option.
       *
       * @param  {type} option description
       * @return {type}        description
       */
      removeElement(t, e = !0) {
        if (this.disabled || t.$isDisabled) return;
        if (!this.allowEmpty && this.internalValue.length <= 1) {
          this.deactivate();
          return;
        }
        const i = typeof t == "object" ? this.valueKeys.indexOf(t[this.trackBy]) : this.valueKeys.indexOf(t);
        if (this.multiple) {
          const r = this.internalValue.slice(0, i).concat(this.internalValue.slice(i + 1));
          this.$emit("update:modelValue", r);
        } else
          this.$emit("update:modelValue", null);
        this.$emit("remove", t, this.id), this.closeOnSelect && e && this.deactivate();
      },
      /**
       * Calls this.removeElement() with the last element
       * from this.internalValue (selected element Array)
       *
       * @fires this#removeElement
       */
      removeLastElement() {
        this.blockKeys.indexOf("Delete") === -1 && this.search.length === 0 && Array.isArray(this.internalValue) && this.internalValue.length && this.removeElement(this.internalValue[this.internalValue.length - 1], !1);
      },
      /**
       * Opens the multiselect’s dropdown.
       * Sets this.isOpen to TRUE
       */
      activate() {
        this.isOpen || this.disabled || (this.adjustPosition(), this.groupValues && this.pointer === 0 && this.filteredOptions.length && (this.pointer = 1), this.isOpen = !0, this.searchable ? (this.preserveSearch || (this.search = ""), this.preventAutofocus || this.$nextTick(() => this.$refs.search && this.$refs.search.focus())) : this.preventAutofocus || typeof this.$el < "u" && this.$el.focus(), this.$emit("open", this.id));
      },
      /**
       * Closes the multiselect’s dropdown.
       * Sets this.isOpen to FALSE
       */
      deactivate() {
        this.isOpen && (this.isOpen = !1, this.searchable ? this.$refs.search !== null && typeof this.$refs.search < "u" && this.$refs.search.blur() : typeof this.$el < "u" && this.$el.blur(), this.preserveSearch || (this.search = ""), this.$emit("close", this.getValue(), this.id));
      },
      /**
       * Call this.activate() or this.deactivate()
       * depending on this.isOpen value.
       *
       * @fires this#activate || this#deactivate
       * @property {Boolean} isOpen indicates if dropdown is open
       */
      toggle() {
        this.isOpen ? this.deactivate() : this.activate();
      },
      /**
       * Updates the hasEnoughSpace variable used for
       * detecting where to expand the dropdown
       */
      adjustPosition() {
        if (typeof window > "u") return;
        const t = this.$el.getBoundingClientRect().top, e = window.innerHeight - this.$el.getBoundingClientRect().bottom;
        e > this.maxHeight || e > t || this.openDirection === "below" || this.openDirection === "bottom" ? (this.preferredOpenDirection = "below", this.optimizedHeight = Math.min(e - 40, this.maxHeight)) : (this.preferredOpenDirection = "above", this.optimizedHeight = Math.min(t - 40, this.maxHeight));
      }
    }
  }, gZ = {
    data() {
      return {
        pointer: 0,
        pointerDirty: !1
      };
    },
    props: {
      /**
       * Enable/disable highlighting of the pointed value.
       * @type {Boolean}
       * @default true
       */
      showPointer: {
        type: Boolean,
        default: !0
      },
      optionHeight: {
        type: Number,
        default: 40
      }
    },
    computed: {
      pointerPosition() {
        return this.pointer * this.optionHeight;
      },
      visibleElements() {
        return this.optimizedHeight / this.optionHeight;
      }
    },
    watch: {
      filteredOptions() {
        this.pointerAdjust();
      },
      isOpen() {
        this.pointerDirty = !1;
      },
      pointer() {
        this.$refs.search && this.$refs.search.setAttribute("aria-activedescendant", this.id + "-" + this.pointer.toString());
      }
    },
    methods: {
      optionHighlight(t, e) {
        return {
          "multiselect__option--highlight": t === this.pointer && this.showPointer,
          "multiselect__option--selected": this.isSelected(e)
        };
      },
      groupHighlight(t, e) {
        if (!this.groupSelect)
          return [
            "multiselect__option--disabled",
            { "multiselect__option--group": e.$isLabel }
          ];
        const i = this.options.find((r) => r[this.groupLabel] === e.$groupLabel);
        return i && !this.wholeGroupDisabled(i) ? [
          "multiselect__option--group",
          { "multiselect__option--highlight": t === this.pointer && this.showPointer },
          { "multiselect__option--group-selected": this.wholeGroupSelected(i) }
        ] : "multiselect__option--disabled";
      },
      addPointerElement({ key: t } = "Enter") {
        this.filteredOptions.length > 0 && this.select(this.filteredOptions[this.pointer], t), this.pointerReset();
      },
      pointerForward() {
        this.pointer < this.filteredOptions.length - 1 && (this.pointer++, this.$refs.list.scrollTop <= this.pointerPosition - (this.visibleElements - 1) * this.optionHeight && (this.$refs.list.scrollTop = this.pointerPosition - (this.visibleElements - 1) * this.optionHeight), this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect && this.pointerForward()), this.pointerDirty = !0;
      },
      pointerBackward() {
        this.pointer > 0 ? (this.pointer--, this.$refs.list.scrollTop >= this.pointerPosition && (this.$refs.list.scrollTop = this.pointerPosition), this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect && this.pointerBackward()) : this.filteredOptions[this.pointer] && this.filteredOptions[0].$isLabel && !this.groupSelect && this.pointerForward(), this.pointerDirty = !0;
      },
      pointerReset() {
        this.closeOnSelect && (this.pointer = 0, this.$refs.list && (this.$refs.list.scrollTop = 0));
      },
      pointerAdjust() {
        this.pointer >= this.filteredOptions.length - 1 && (this.pointer = this.filteredOptions.length ? this.filteredOptions.length - 1 : 0), this.filteredOptions.length > 0 && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect && this.pointerForward();
      },
      pointerSet(t) {
        this.pointer = t, this.pointerDirty = !0;
      }
    }
  }, VN = {
    name: "vue-multiselect",
    mixins: [hZ, gZ],
    compatConfig: {
      MODE: 3,
      ATTR_ENUMERATED_COERCION: !1
    },
    props: {
      /**
         * name attribute to match optional label element
         * @default ''
         * @type {String}
         */
      name: {
        type: String,
        default: ""
      },
      /**
         * Presets the selected options value.
         * @type {Object||Array||String||Integer}
         */
      modelValue: {
        type: null,
        default() {
          return [];
        }
      },
      /**
         * String to show when pointing to an option
         * @default 'Press enter to select'
         * @type {String}
         */
      selectLabel: {
        type: String,
        default: "Press enter to select"
      },
      /**
         * String to show when pointing to an option
         * @default 'Press enter to select'
         * @type {String}
         */
      selectGroupLabel: {
        type: String,
        default: "Press enter to select group"
      },
      /**
         * String to show next to selected option
         * @default 'Selected'
         * @type {String}
         */
      selectedLabel: {
        type: String,
        default: "Selected"
      },
      /**
         * String to show when pointing to an already selected option
         * @default 'Press enter to remove'
         * @type {String}
         */
      deselectLabel: {
        type: String,
        default: "Press enter to remove"
      },
      /**
         * String to show when pointing to an already selected option
         * @default 'Press enter to remove'
         * @type {String}
         */
      deselectGroupLabel: {
        type: String,
        default: "Press enter to deselect group"
      },
      /**
         * Decide whether to show pointer labels
         * @default true
         * @type {Boolean}
         */
      showLabels: {
        type: Boolean,
        default: !0
      },
      /**
         * Limit the display of selected options. The rest will be hidden within the limitText string.
         * @default 99999
         * @type {Integer}
         */
      limit: {
        type: Number,
        default: 99999
      },
      /**
         * Sets maxHeight style value of the dropdown
         * @default 300
         * @type {Integer}
         */
      maxHeight: {
        type: Number,
        default: 300
      },
      /**
         * Function that process the message shown when selected
         * elements pass the defined limit.
         * @default 'and * more'
         * @param {Int} count Number of elements more than limit
         * @type {Function}
         */
      limitText: {
        type: Function,
        default: (t) => `and ${t} more`
      },
      /**
         * Set true to trigger the loading spinner.
         * @default False
         * @type {Boolean}
         */
      loading: {
        type: Boolean,
        default: !1
      },
      /**
         * Disables the multiselect if true.
         * @default false
         * @type {Boolean}
         */
      disabled: {
        type: Boolean,
        default: !1
      },
      /**
         * Fixed opening direction
         * @default ''
         * @type {String}
         */
      openDirection: {
        type: String,
        default: ""
      },
      /**
         * Shows slot with message about empty options
         * @default true
         * @type {Boolean}
         */
      showNoOptions: {
        type: Boolean,
        default: !0
      },
      showNoResults: {
        type: Boolean,
        default: !0
      },
      tabindex: {
        type: Number,
        default: 0
      }
    },
    computed: {
      hasOptionGroup() {
        return this.groupValues && this.groupLabel && this.groupSelect;
      },
      isSingleLabelVisible() {
        return (this.singleValue || this.singleValue === 0) && (!this.isOpen || !this.searchable) && !this.visibleValues.length;
      },
      isPlaceholderVisible() {
        return !this.internalValue.length && (!this.searchable || !this.isOpen);
      },
      visibleValues() {
        return this.multiple ? this.internalValue.slice(0, this.limit) : [];
      },
      singleValue() {
        return this.internalValue[0];
      },
      deselectLabelText() {
        return this.showLabels ? this.deselectLabel : "";
      },
      deselectGroupLabelText() {
        return this.showLabels ? this.deselectGroupLabel : "";
      },
      selectLabelText() {
        return this.showLabels ? this.selectLabel : "";
      },
      selectGroupLabelText() {
        return this.showLabels ? this.selectGroupLabel : "";
      },
      selectedLabelText() {
        return this.showLabels ? this.selectedLabel : "";
      },
      inputStyle() {
        return this.searchable || this.multiple && this.modelValue && this.modelValue.length ? this.isOpen ? { width: "100%" } : { width: "0", position: "absolute", padding: "0" } : "";
      },
      contentStyle() {
        return this.options.length ? { display: "inline-block" } : { display: "block" };
      },
      isAbove() {
        return this.openDirection === "above" || this.openDirection === "top" ? !0 : this.openDirection === "below" || this.openDirection === "bottom" ? !1 : this.preferredOpenDirection === "above";
      },
      showSearchInput() {
        return this.searchable && (this.hasSingleSelectedSlot && (this.visibleSingleValue || this.visibleSingleValue === 0) ? this.isOpen : !0);
      }
    }
  };
  const fZ = {
    ref: "tags",
    class: "multiselect__tags"
  }, pZ = { class: "multiselect__tags-wrap" }, mZ = { class: "multiselect__spinner" }, EZ = { key: 0 }, yZ = { class: "multiselect__option" }, BZ = { class: "multiselect__option" }, wZ = /* @__PURE__ */ Ct("No elements found. Consider changing the search query."), CZ = { class: "multiselect__option" }, bZ = /* @__PURE__ */ Ct("List is empty.");
  function MZ(t, e, i, r, n, s) {
    return G(), De("div", {
      tabindex: t.searchable ? -1 : i.tabindex,
      class: [{ "multiselect--active": t.isOpen, "multiselect--disabled": i.disabled, "multiselect--above": s.isAbove, "multiselect--has-options-group": s.hasOptionGroup }, "multiselect"],
      onFocus: e[14] || (e[14] = (o) => t.activate()),
      onBlur: e[15] || (e[15] = (o) => t.searchable ? !1 : t.deactivate()),
      onKeydown: [
        e[16] || (e[16] = At(at((o) => t.pointerForward(), ["self", "prevent"]), ["down"])),
        e[17] || (e[17] = At(at((o) => t.pointerBackward(), ["self", "prevent"]), ["up"]))
      ],
      onKeypress: e[18] || (e[18] = At(at((o) => t.addPointerElement(o), ["stop", "self"]), ["enter", "tab"])),
      onKeyup: e[19] || (e[19] = At((o) => t.deactivate(), ["esc"])),
      role: "combobox",
      "aria-owns": "listbox-" + t.id
    }, [
      ge(t.$slots, "caret", { toggle: t.toggle }, () => [
        ee(
          "div",
          {
            onMousedown: e[1] || (e[1] = at((o) => t.toggle(), ["prevent", "stop"])),
            class: "multiselect__select"
          },
          null,
          32
          /* HYDRATE_EVENTS */
        )
      ]),
      ge(t.$slots, "clear", { search: t.search }),
      ee(
        "div",
        fZ,
        [
          ge(t.$slots, "selection", {
            search: t.search,
            remove: t.removeElement,
            values: s.visibleValues,
            isOpen: t.isOpen
          }, () => [
            $t(ee(
              "div",
              pZ,
              [
                (G(!0), De(
                  ht,
                  null,
                  xi(s.visibleValues, (o, a) => ge(t.$slots, "tag", {
                    option: o,
                    search: t.search,
                    remove: t.removeElement
                  }, () => [
                    (G(), De("span", {
                      class: "multiselect__tag",
                      key: a
                    }, [
                      ee("span", {
                        textContent: Pe(t.getOptionLabel(o))
                      }, null, 8, ["textContent"]),
                      ee("i", {
                        tabindex: "1",
                        onKeypress: At(at((A) => t.removeElement(o), ["prevent"]), ["enter"]),
                        onMousedown: at((A) => t.removeElement(o), ["prevent"]),
                        class: "multiselect__tag-icon"
                      }, null, 40, ["onKeypress", "onMousedown"])
                    ]))
                  ])),
                  256
                  /* UNKEYED_FRAGMENT */
                ))
              ],
              512
              /* NEED_PATCH */
            ), [
              [gi, s.visibleValues.length > 0]
            ]),
            t.internalValue && t.internalValue.length > i.limit ? ge(t.$slots, "limit", { key: 0 }, () => [
              ee("strong", {
                class: "multiselect__strong",
                textContent: Pe(i.limitText(t.internalValue.length - i.limit))
              }, null, 8, ["textContent"])
            ]) : de("v-if", !0)
          ]),
          ee(Ws, { name: "multiselect__loading" }, {
            default: Ye(() => [
              ge(t.$slots, "loading", {}, () => [
                $t(ee(
                  "div",
                  mZ,
                  null,
                  512
                  /* NEED_PATCH */
                ), [
                  [gi, i.loading]
                ])
              ])
            ]),
            _: 3
            /* FORWARDED */
          }),
          t.searchable ? (G(), De("input", {
            key: 0,
            ref: "search",
            name: i.name,
            id: t.id,
            type: "text",
            autocomplete: "off",
            spellcheck: !1,
            placeholder: t.placeholder,
            style: s.inputStyle,
            value: t.search,
            disabled: i.disabled,
            tabindex: i.tabindex,
            onInput: e[2] || (e[2] = (o) => t.updateSearch(o.target.value)),
            onFocus: e[3] || (e[3] = at((o) => t.activate(), ["prevent"])),
            onBlur: e[4] || (e[4] = at((o) => t.deactivate(), ["prevent"])),
            onKeyup: e[5] || (e[5] = At((o) => t.deactivate(), ["esc"])),
            onKeydown: [
              e[6] || (e[6] = At(at((o) => t.pointerForward(), ["prevent"]), ["down"])),
              e[7] || (e[7] = At(at((o) => t.pointerBackward(), ["prevent"]), ["up"])),
              e[9] || (e[9] = At(at((o) => t.removeLastElement(), ["stop"]), ["delete"]))
            ],
            onKeypress: e[8] || (e[8] = At(at((o) => t.addPointerElement(o), ["prevent", "stop", "self"]), ["enter"])),
            class: "multiselect__input",
            "aria-controls": "listbox-" + t.id
          }, null, 44, ["name", "id", "placeholder", "value", "disabled", "tabindex", "aria-controls"])) : de("v-if", !0),
          s.isSingleLabelVisible ? (G(), De(
            "span",
            {
              key: 1,
              class: "multiselect__single",
              onMousedown: e[10] || (e[10] = at((...o) => t.toggle && t.toggle(...o), ["prevent"]))
            },
            [
              ge(t.$slots, "singleLabel", { option: s.singleValue }, () => [
                Ct(
                  Pe(t.currentOptionLabel),
                  1
                  /* TEXT */
                )
              ])
            ],
            32
            /* HYDRATE_EVENTS */
          )) : de("v-if", !0),
          s.isPlaceholderVisible ? (G(), De(
            "span",
            {
              key: 2,
              class: "multiselect__placeholder",
              onMousedown: e[11] || (e[11] = at((...o) => t.toggle && t.toggle(...o), ["prevent"]))
            },
            [
              ge(t.$slots, "placeholder", {}, () => [
                Ct(
                  Pe(t.placeholder),
                  1
                  /* TEXT */
                )
              ])
            ],
            32
            /* HYDRATE_EVENTS */
          )) : de("v-if", !0)
        ],
        512
        /* NEED_PATCH */
      ),
      ee(Ws, { name: "multiselect" }, {
        default: Ye(() => [
          $t(ee(
            "div",
            {
              class: "multiselect__content-wrapper",
              onFocus: e[12] || (e[12] = (...o) => t.activate && t.activate(...o)),
              tabindex: "-1",
              onMousedown: e[13] || (e[13] = at(() => {
              }, ["prevent"])),
              style: { maxHeight: t.optimizedHeight + "px" },
              ref: "list"
            },
            [
              ee("ul", {
                class: "multiselect__content",
                style: s.contentStyle,
                role: "listbox",
                id: "listbox-" + t.id
              }, [
                ge(t.$slots, "beforeList"),
                t.multiple && t.max === t.internalValue.length ? (G(), De("li", EZ, [
                  ee("span", yZ, [
                    ge(t.$slots, "maxElements", {}, () => [
                      Ct(
                        "Maximum of " + Pe(t.max) + " options selected. First remove a selected option to select another.",
                        1
                        /* TEXT */
                      )
                    ])
                  ])
                ])) : de("v-if", !0),
                !t.max || t.internalValue.length < t.max ? (G(!0), De(
                  ht,
                  { key: 1 },
                  xi(t.filteredOptions, (o, a) => (G(), De("li", {
                    class: "multiselect__element",
                    key: a,
                    id: t.id + "-" + a,
                    role: o && (o.$isLabel || o.$isDisabled) ? null : "option"
                  }, [
                    o && (o.$isLabel || o.$isDisabled) ? de("v-if", !0) : (G(), De("span", {
                      key: 0,
                      class: [t.optionHighlight(a, o), "multiselect__option"],
                      onClick: at((A) => t.select(o), ["stop"]),
                      onMouseenter: at((A) => t.pointerSet(a), ["self"]),
                      "data-select": o && o.isTag ? t.tagPlaceholder : s.selectLabelText,
                      "data-selected": s.selectedLabelText,
                      "data-deselect": s.deselectLabelText
                    }, [
                      ge(t.$slots, "option", {
                        option: o,
                        search: t.search,
                        index: a
                      }, () => [
                        ee(
                          "span",
                          null,
                          Pe(t.getOptionLabel(o)),
                          1
                          /* TEXT */
                        )
                      ])
                    ], 42, ["onClick", "onMouseenter", "data-select", "data-selected", "data-deselect"])),
                    o && (o.$isLabel || o.$isDisabled) ? (G(), De("span", {
                      key: 1,
                      "data-select": t.groupSelect && s.selectGroupLabelText,
                      "data-deselect": t.groupSelect && s.deselectGroupLabelText,
                      class: [t.groupHighlight(a, o), "multiselect__option"],
                      onMouseenter: at((A) => t.groupSelect && t.pointerSet(a), ["self"]),
                      onMousedown: at((A) => t.selectGroup(o), ["prevent"])
                    }, [
                      ge(t.$slots, "option", {
                        option: o,
                        search: t.search,
                        index: a
                      }, () => [
                        ee(
                          "span",
                          null,
                          Pe(t.getOptionLabel(o)),
                          1
                          /* TEXT */
                        )
                      ])
                    ], 42, ["data-select", "data-deselect", "onMouseenter", "onMousedown"])) : de("v-if", !0)
                  ], 8, ["id", "role"]))),
                  128
                  /* KEYED_FRAGMENT */
                )) : de("v-if", !0),
                $t(ee(
                  "li",
                  null,
                  [
                    ee("span", BZ, [
                      ge(t.$slots, "noResult", { search: t.search }, () => [
                        wZ
                      ])
                    ])
                  ],
                  512
                  /* NEED_PATCH */
                ), [
                  [gi, i.showNoResults && t.filteredOptions.length === 0 && t.search && !i.loading]
                ]),
                $t(ee(
                  "li",
                  null,
                  [
                    ee("span", CZ, [
                      ge(t.$slots, "noOptions", {}, () => [
                        bZ
                      ])
                    ])
                  ],
                  512
                  /* NEED_PATCH */
                ), [
                  [gi, i.showNoOptions && (t.options.length === 0 || s.hasOptionGroup === !0 && t.filteredOptions.length === 0) && !t.search && !i.loading]
                ]),
                ge(t.$slots, "afterList")
              ], 12, ["id"])
            ],
            36
            /* STYLE, HYDRATE_EVENTS */
          ), [
            [gi, t.isOpen]
          ])
        ]),
        _: 3
        /* FORWARDED */
      })
    ], 42, ["tabindex", "aria-owns"]);
  }
  VN.render = MZ;
  const IZ = je({
    name: "DpsFormSelect",
    components: { DpsFilterButton: hX, Multiselect: VN },
    props: {
      /**
       * Unique ID of the select (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Size of the select.
       * @default undefined
       */
      size: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Style variant of the select.
       * @default undefined
       */
      variant: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Hides tags for selected elements (only for multiple).
       * @default false
       */
      hideTags: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * ModelValue for the select.
       * @default undefined
       */
      modelValue: {
        type: [String, Number, Array, Object],
        required: !1,
        default: void 0
      },
      /**
       * Key for the label text in the option object.
       * @default "label"
       */
      optionLabel: {
        type: String,
        required: !1,
        default: "label"
      },
      /**
       * Key for the value in the option object.
       * @default "value"
       */
      optionValue: {
        type: String,
        required: !1,
        default: "value"
      },
      /**
       * Makes the select readonly.
       * @default false
       */
      readonly: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Requires a value to be selected.
       * @default false
       */
      required: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Title attribute of the select.
       * @default props.placeholder
       */
      title: {
        type: String,
        required: !1,
        default(t) {
          return t.placeholder;
        }
      },
      /**
       * Label for the select.
       * @default undefined
       */
      label: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Icon placed before the select in the simple variant.
       * @default undefined
       */
      icon: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Success state of the select.
       * @default false
       */
      success: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Error state of the select.
       * @default false
       */
      error: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Aligns the dropdown left or right.
       * @default "start"
       */
      align: {
        type: String,
        required: !1,
        default: "start"
      },
      // -----------------------
      // Vue-Multiselect
      // -----------------------
      /**
       * Array of available options: Objects, Strings or Integers. If array of objects, visible label will default to option.label.
       */
      options: {
        type: Array,
        required: !0
      },
      /**
       * Clear the search input after `select()`. Use only when multiple is true.
       * @default true
       */
      clearOnSelect: {
        type: Boolean,
        required: !1,
        default: !0
      },
      /**
       * Enable/disable closing after selecting an option
       * @default true
       */
      closeOnSelect: {
        type: Boolean,
        required: !1,
        default: !0
      },
      /**
       * Enable/disable the multiselect.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Number of allowed selected options.
       * @default undefined
       */
      max: {
        type: Number,
        required: !1,
        default: void 0
      },
      /**
       * Equivalent to the multiple attribute on a `<select>` input.
       * @default false
       */
      multiple: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Fixed opening direction (instead of auto). Options are "above"/"top" or "below"/"bottom"
       * @default ""
       */
      openDirection: {
        type: String,
        required: !1,
        default: ""
      },
      /**
       * Equivalent to the placeholder attribute on a `<select>` input.
       * @default "Bitte wählen"
       */
      placeholder: {
        type: String,
        required: !1,
        default: "Bitte wählen"
      },
      /**
       * Selects the first option if initial value is empty
       * @default false
       */
      preselectFirst: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * If set to true, will preserve the search query when opening/closing the component.
       * @default false
       */
      preserveSearch: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Add / removes search input.
       * @default false
       */
      searchable: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when a value gets selected.
       */
      "select",
      /**
       * Emitted after removing an option.
       */
      "remove",
      /**
       * Emitted after the search query changes.
       */
      "search-change",
      /**
       * Emitted after user attempts to add a tag.
       */
      "tag",
      /**
       * Emitted when the dropdown opens. Useful for detecting when touched.
       */
      "open",
      /**
       * Emitted when the dropdown closes.
       */
      "close",
      /**
       * Emitted after this.modelValue changes.
       */
      "update:modelValue"
    ],
    data() {
      return {
        selected: void 0,
        multiselectEl: null
      };
    },
    computed: {
      uniqueId() {
        return this.id ? this.id : vn("dps-form-select-");
      },
      multiselectOptions() {
        const t = [];
        for (const e of this.options)
          if (typeof e != "object") {
            const i = {};
            i[this.optionValue] = e, i[this.optionLabel] = e, t.push(i);
          } else
            t.push(e);
        return t;
      }
    },
    watch: {
      modelValue(t) {
        this.selected = t;
      },
      selected(t, e) {
        JSON.stringify(t) !== JSON.stringify(e) && this.$emit("update:modelValue", t);
      }
    },
    mounted() {
      const t = this.$refs.multiselect;
      this.multiselectEl = t == null ? void 0 : t.$el, this.improveMultiselectAccessibility(), this.improveElementAccessibility(), this.improveContentAccessibility();
    },
    created() {
      this.selected = this.modelValue;
    },
    methods: {
      improveMultiselectAccessibility() {
        var t, e;
        (t = this.multiselectEl) == null || t.setAttribute("aria-expanded", "false"), (e = this.multiselectEl) == null || e.setAttribute("aria-controls", "listbox-" + this.uniqueId);
      },
      improveContentAccessibility() {
        var t;
        const e = (t = this.multiselectEl) == null ? void 0 : t.querySelector(".multiselect__content");
        e && (e.ariaLabel = "Auswahlliste");
      },
      improveElementAccessibility() {
        var t, e, i;
        const r = (t = this.multiselectEl) == null ? void 0 : t.querySelectorAll(".multiselect__option");
        if (r)
          for (const o of Array.from(r)) {
            const a = o.parentElement;
            a != null && a.classList.contains("multiselect__element") && (o.classList.contains("multiselect__option--selected") ? a.ariaSelected = "true" : a.ariaSelected = "false");
          }
        const n = (e = this.multiselectEl) == null ? void 0 : e.querySelectorAll(
          ".multiselect__content > li:not(.multiselect__element)"
        );
        if (n)
          for (const o of Array.from(n))
            o.role = "option";
        const s = (i = this.multiselectEl) == null ? void 0 : i.querySelector(
          ".multiselect__input"
        );
        s && (s.placeholder = "Suchbegriff ...");
      },
      handleSelect(t) {
        this.$emit("select", t), this.$nextTick(() => {
          this.improveElementAccessibility();
        });
      },
      handleRemove(t) {
        this.$emit("remove", t), this.$nextTick(() => {
          this.improveElementAccessibility();
        });
      },
      handleOpen(t) {
        var e;
        this.$emit("open", t), (e = this.multiselectEl) == null || e.setAttribute("aria-expanded", "true"), this.$nextTick(() => {
          this.setSearchInputWidth();
        });
      },
      handleClose(t) {
        var e;
        this.$emit("close", t), (e = this.multiselectEl) == null || e.setAttribute("aria-expanded", "false");
      },
      handleTag(t) {
        this.$emit("tag", t);
      },
      handleSearchChange(t) {
        this.$emit("search-change", t);
      },
      setSearchInputWidth() {
        var t, e;
        const i = (t = this.multiselectEl) == null ? void 0 : t.querySelector(
          ".multiselect__input"
        ), r = (e = this.multiselectEl) == null ? void 0 : e.querySelector(
          ".multiselect__content"
        );
        if (i && r) {
          const n = r.offsetWidth;
          i.style.setProperty("--width", n - 12 + "px");
        }
      }
    }
  }), vZ = {
    key: 0,
    class: "multiselect__option-checkbox"
  }, xZ = /* @__PURE__ */ be("span", { class: "dps-icon dps-icon--check" }, null, -1), QZ = [
    xZ
  ], FZ = { class: "multiselect__option-label" }, SZ = {
    key: 2,
    class: "multiselect__option-checkbox"
  }, DZ = /* @__PURE__ */ be("span", { class: "dps-icon dps-icon--check" }, null, -1), TZ = [
    DZ
  ], RZ = {
    key: 0,
    class: "multiselect__single multiselect__single--label"
  }, _Z = {
    key: 1,
    class: "multiselect__placeholder multiselect__placeholder--label"
  }, kZ = {
    key: 1,
    class: "multiselect__tags-wrap"
  }, YZ = { class: "multiselect__option-results" }, NZ = { class: "multiselect__option-results" }, UZ = { class: "multiselect__option-results" };
  function LZ(t, e, i, r, n, s) {
    const o = Os("DpsFilterButton"), a = Os("Multiselect");
    return G(), De(a, {
      id: t.uniqueId,
      ref: "multiselect",
      modelValue: t.selected,
      "onUpdate:modelValue": e[0] || (e[0] = (A) => t.selected = A),
      class: he(["dps-form-select", {
        "dps-form-select--readonly": t.readonly,
        "dps-form-select--multiple": t.multiple,
        "dps-form-select--searchable": t.searchable,
        "dps-form-select--labelled": t.label,
        "dps-form-select--filter": t.variant === "filter",
        "dps-form-select--simple": t.variant === "simple",
        "dps-form-select--size-sm": t.size === "sm",
        "dps-form-select--success": t.success,
        "dps-form-select--error": t.error,
        "dps-form-select--align-end": t.align === "end"
      }]),
      options: t.multiselectOptions,
      "allow-empty": !t.required,
      "clear-on-select": t.clearOnSelect,
      "close-on-select": t.closeOnSelect,
      disabled: t.disabled || t.readonly,
      label: t.optionLabel,
      max: t.max,
      multiple: t.multiple,
      "open-direction": t.openDirection,
      placeholder: t.placeholder,
      "preselect-first": t.preselectFirst,
      "preserve-search": t.preserveSearch,
      searchable: t.searchable,
      "track-by": t.optionValue,
      title: t.title,
      onClose: t.handleClose,
      onOpen: t.handleOpen,
      onRemove: t.handleRemove,
      onSearchChange: t.handleSearchChange,
      onSelect: t.handleSelect,
      onTag: t.handleTag
    }, ok({
      option: Ye((A) => [
        t.multiple ? (G(), X("span", vZ, QZ)) : de("", !0),
        A.option.icon ? (G(), X("span", {
          key: 1,
          class: he(["multiselect__option-icon dps-icon", "dps-icon--" + A.option.icon])
        }, null, 2)) : de("", !0),
        be("span", FZ, [
          ge(t.$slots, "option", ia(ra(A)), () => [
            Ct(Pe(A.option[t.optionLabel]), 1)
          ])
        ]),
        t.multiple ? de("", !0) : (G(), X("span", SZ, TZ))
      ]),
      tag: Ye((A) => [
        ee(o, {
          disabled: t.disabled,
          readonly: t.readonly,
          onClick: (l) => A.remove(A.option)
        }, {
          default: Ye(() => [
            ge(t.$slots, "tag", ia(ra(A)), () => [
              Ct(Pe(A.option[t.optionLabel]), 1)
            ])
          ]),
          _: 2
        }, 1032, ["disabled", "readonly", "onClick"])
      ]),
      noOptions: Ye(() => [
        be("span", YZ, [
          ge(t.$slots, "noOptions", {}, () => [
            Ct("Keine Elemente")
          ])
        ])
      ]),
      noResult: Ye(() => [
        be("span", NZ, [
          ge(t.$slots, "noResult", {}, () => [
            Ct(" Es wurden keine Elemente gefunden. ")
          ])
        ])
      ]),
      maxElements: Ye(() => [
        be("span", UZ, [
          ge(t.$slots, "maxElements", {}, () => [
            Ct(" Maximale Anzahl von Elementen erreicht. Bitte zuerst ein Element abwählen bevor Sie eine erneute Auswahl treffen. ")
          ])
        ])
      ]),
      _: 2
    }, [
      t.multiple ? {
        name: "selection",
        fn: Ye((A) => [
          A.values.length === 0 || t.hideTags ? (G(), X(ht, { key: 0 }, [
            t.label ? (G(), X("div", RZ, Pe(t.label), 1)) : (G(), X("div", _Z, [
              ge(t.$slots, "selection", ia(ra(A)), () => [
                Ct(Pe(t.placeholder), 1)
              ])
            ]))
          ], 64)) : (G(), X("div", kZ, [
            (G(!0), X(ht, null, xi(A.values, (l, c) => (G(), De(o, {
              key: "option-" + c,
              disabled: t.disabled,
              readonly: t.readonly,
              onClick: (u) => A.remove(l)
            }, {
              default: Ye(() => [
                ge(t.$slots, "selection", Tt({ ref_for: !0 }, A, { option: l }), () => [
                  Ct(Pe(l[t.optionLabel]), 1)
                ])
              ]),
              _: 2
            }, 1032, ["disabled", "readonly", "onClick"]))), 128))
          ]))
        ]),
        key: "0"
      } : {
        name: "selection",
        fn: Ye((A) => [
          t.variant === "simple" && t.icon ? (G(), X("span", {
            key: 0,
            class: he(["dps-icon dps-icon--" + t.icon])
          }, null, 2)) : de("", !0),
          t.label ? (G(), X("div", {
            key: 1,
            class: "multiselect__single multiselect__single--label"
          }, Pe(t.label), 1)) : de("", !0),
          t.modelValue && t.modelValue[t.optionLabel] ? (G(), X("div", {
            key: 2,
            class: "multiselect__placeholder multiselect__placeholder--label"
          }, [
            ge(t.$slots, "selection", ia(ra(A)), () => [
              Ct(Pe(t.modelValue[t.optionLabel]), 1)
            ])
          ])) : (G(), X("div", {
            key: 3,
            class: "multiselect__placeholder multiselect__placeholder--label"
          }, [
            ge(t.$slots, "selection", ia(ra(A)), () => [
              Ct(Pe(t.placeholder), 1)
            ])
          ]))
        ]),
        key: "1"
      },
      t.$slots.beforeList ? {
        name: "beforeList",
        fn: Ye(() => [
          ge(t.$slots, "beforeList")
        ]),
        key: "2"
      } : void 0,
      t.$slots.afterList ? {
        name: "afterList",
        fn: Ye(() => [
          ge(t.$slots, "afterList")
        ]),
        key: "3"
      } : void 0
    ]), 1032, ["id", "modelValue", "class", "options", "allow-empty", "clear-on-select", "close-on-select", "disabled", "label", "max", "multiple", "open-direction", "placeholder", "preselect-first", "preserve-search", "searchable", "track-by", "title", "onClose", "onOpen", "onRemove", "onSearchChange", "onSelect", "onTag"]);
  }
  const zZ = /* @__PURE__ */ Vn(IZ, [["render", LZ]]);
  je({
    name: "DpsFormTextarea",
    props: {
      /**
       * ModelValue of the textarea.
       * @default undefined
       */
      modelValue: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Sets whether the textarea is resizable, and if so, in which directions.
       * @default false
       */
      resizable: {
        type: [Boolean, String],
        required: !1,
        default: !1
      },
      /**
       * Success state of the textarea.
       * @default false
       */
      success: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Error state of the textarea.
       * @default false
       */
      error: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * The number of visible text lines.
       * @default 3
       */
      rows: {
        type: Number,
        required: !1,
        default: 3
      },
      /**
       * Makes the textarea readonly.
       * @default false
       */
      readonly: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Disables the textarea.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the value changes.
       */
      "update:modelValue"
    ],
    methods: {
      handleInput(t) {
        const e = t.target.value;
        this.$emit("update:modelValue", e);
      }
    }
  });
  je({
    name: "DpsLink",
    props: {
      /**
       * The URL that the hyperlink points to.
       */
      href: {
        type: String,
        required: !0
      },
      /**
       * Icon to be displayed in front of the link text.
       * Can be set to 'false' when using external links to
       * hide the icon.
       * @default undefined
       */
      icon: {
        type: [String, Boolean],
        required: !1,
        default: void 0
      },
      /**
       * The relationship of the linked URL as space-separated
       * link types. "noopener noreferrer" gets set automatically
       * when "external" is true.
       * @default undefined
       */
      rel: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Where to display the linked URL,
       * as the name for a browsing context.
       * Gets set to "_blank" automatically when "external" is true.
       * @default undefined
       */
      target: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Whether the link is an external link.
       * @default false
       */
      external: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * How to format the link (telephone or email formatting).
       * @default undefined
       */
      format: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Whether the link should be a slightly darker blue.
       * @default false
       */
      darker: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the link is clicked.
       */
      "click"
    ],
    computed: {
      hrefAttribute() {
        return this.format === "telephone" ? "tel:" + this.href.replaceAll(" ", "").replaceAll("-", "").replaceAll("/", "").replaceAll("(", "").replaceAll(")", "") : this.format === "email" ? "mailto:" + this.href.replaceAll(" ", "") : this.href;
      },
      relAttribute() {
        if (this.rel)
          return this.rel;
        if (this.external)
          return "noopener noreferrer";
      },
      targetAttribute() {
        if (this.target)
          return this.target;
        if (this.external)
          return "_blank";
      },
      iconName() {
        if (this.icon !== !1) {
          if (this.icon && typeof this.icon == "string")
            return this.icon;
          if (this.external)
            return "external-link";
        }
      }
    },
    methods: {
      handleClick(t) {
        !this.external && !this.format && (t.preventDefault(), this.$router && this.$router.push(this.hrefAttribute)), this.$emit("click", t);
      }
    }
  });
  je({
    name: "DpsSortSelect",
    components: { DpsFormSelect: zZ },
    props: {
      /**
       * Unique ID of the select (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Array of options to be displayed.
       */
      options: {
        type: Array,
        required: !0
      },
      /**
       * ModelValue of the select.
       */
      modelValue: {
        type: String,
        required: !0
      },
      /**
       * Title attribute of the select.
       * @default "Sortierung anpassen"
       */
      title: {
        type: String,
        default: "Sortierung anpassen",
        required: !1
      },
      /**
       * Disables the select.
       * @default false
       */
      disabled: {
        type: Boolean,
        default: !1,
        required: !1
      }
    },
    emits: [
      /**
       * Emitted when the selected value changes.
       */
      "update:modelValue"
    ],
    data() {
      return {
        selected: void 0
      };
    },
    computed: {
      uniqueId() {
        return this.id ? this.id : vn("dps-sort-select-");
      }
    },
    watch: {
      modelValue() {
        this.setSelectedOption();
      }
    },
    created() {
      this.setSelectedOption();
    },
    methods: {
      setSelectedOption() {
        let t = this.options[0];
        for (const e of this.options)
          e.value === this.modelValue && (t = e);
        this.selected = t;
      },
      handleChange(t) {
        this.$emit("update:modelValue", t.value);
      }
    }
  });
  const PZ = je({
    name: "DpsAlert",
    props: {
      /**
       * The variant determines the color and icon of the alert.
       * @default undefined
       */
      variant: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * Headline of the alert.
       * @default undefined
       */
      heading: {
        type: String,
        default: void 0,
        required: !1
      },
      /**
       * Hides the icon.
       * @default false
       */
      hideIcon: {
        type: Boolean,
        default: !1,
        required: !1
      }
    },
    computed: {
      variantIcon() {
        return {
          info: "information",
          warning: "warning",
          success: "success",
          error: "warning"
        }[this.variant ?? "info"];
      }
    },
    methods: {
      sanitizeHtml: av
    }
  }), OZ = {
    key: 0,
    class: "dps-alert__icon-wrapper"
  }, GZ = { class: "dps-alert__content-wrapper" }, jZ = ["innerHTML"];
  function HZ(t, e, i, r, n, s) {
    return G(), X("div", {
      class: he(["dps-alert", { ["dps-alert--" + t.variant]: t.variant }])
    }, [
      t.hideIcon ? de("", !0) : (G(), X("div", OZ, [
        be("span", {
          class: he(["dps-icon", "dps-icon--" + t.variantIcon])
        }, null, 2)
      ])),
      be("div", GZ, [
        t.heading ? (G(), X("header", {
          key: 0,
          class: "dps-alert__content-header",
          innerHTML: t.sanitizeHtml(t.heading)
        }, null, 8, jZ)) : de("", !0),
        ge(t.$slots, "default")
      ])
    ], 2);
  }
  const JZ = /* @__PURE__ */ Vn(PZ, [["render", HZ]]), VZ = je({
    name: "DpsInputGroup",
    props: {
      /**
       * Whether there should be no gap between the
       * elements.
       */
      collapsed: {
        type: Boolean,
        required: !1,
        default: !1
      }
    }
  }), WZ = {
    key: 0,
    class: "dps-input-group__content dps-input-group__content--prepend"
  }, KZ = { class: "dps-input-group__content dps-input-group__content--default" }, XZ = {
    key: 1,
    class: "dps-input-group__content dps-input-group__content--append"
  };
  function ZZ(t, e, i, r, n, s) {
    return G(), X("div", {
      role: "group",
      class: he(["dps-input-group", { "dps-input-group--collapsed": t.collapsed }])
    }, [
      t.$slots.prepend ? (G(), X("div", WZ, [
        ge(t.$slots, "prepend")
      ])) : de("", !0),
      be("div", KZ, [
        ge(t.$slots, "default")
      ]),
      t.$slots.append ? (G(), X("div", XZ, [
        ge(t.$slots, "append")
      ])) : de("", !0)
    ], 2);
  }
  const qZ = /* @__PURE__ */ Vn(VZ, [["render", ZZ]]), $Z = je({
    name: "DpsFormFile",
    props: {
      /**
       * The unique identifier for the input (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * ModelValue of the input.
       * With inputs of type file, normally this is uni-directional.
       * However, you can clear the file input's selected files by setting the modelValue to either null
       * (for single mode) or an empty array [] (for multiple mode).
       * @default null
       */
      modelValue: {
        type: [File, Array, null],
        required: !1,
        default: null
      },
      /**
       * Which file formats to accept.
       * Can be either file extension or mime-type or mixed
       * e.g. '.pdf', 'application/pdf' or '.pdf, application/pdf'
       * @default ""
       */
      accept: {
        type: String,
        required: !1,
        default: ""
      },
      /**
       * Allows selecting multiple files at once.
       * @default false
       */
      multiple: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Disables the component.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Title for the search button.
       * Defaults to "Datei auswählen" if no title is set.
       * @default undefined
       */
      title: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Changes the state to error.
       * @default false
       */
      error: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Required attribute of the input.
       * @default false
       */
      required: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the file selection changes.
       * @event module:DpsFormFile#update:modelValue
       */
      "update:modelValue"
    ],
    data() {
      return {
        uniqID: this.id ?? vn("dps-form-file-")
      };
    },
    computed: {
      fileSearchTitle() {
        return this.title ?? `Datei${this.multiple ? "en" : ""} auswählen`;
      }
    },
    watch: {
      modelValue: {
        handler(t) {
          (!t || this.multiple && !t.length) && (this.$refs.fileInput.value = "");
        }
      }
    },
    methods: {
      getUniqueId: vn,
      handleSelectionChange() {
        const t = this.$refs.fileInput.files;
        t.length === 0 ? this.$emit("update:modelValue", this.multiple ? [] : null) : this.$emit("update:modelValue", this.multiple ? Array.from(t) : t[0]);
      },
      resetSelection() {
        this.$refs.fileInput.value = "", this.$emit("update:modelValue", this.multiple ? [] : null);
      }
    }
  }), eq = ["for", "title"], tq = /* @__PURE__ */ be("span", {
    class: "dps-icon dps-icon--search",
    "aria-hidden": "true"
  }, null, -1), iq = { class: "sr-only" }, rq = ["id", "accept", "required", "multiple", "disabled"];
  function nq(t, e, i, r, n, s) {
    return G(), X("div", {
      class: he(["dps-form-file", {
        "dps-form-file--selected": t.multiple && Array.isArray(t.modelValue) ? t.modelValue.length : t.modelValue,
        "dps-form-file--disabled": t.disabled,
        "dps-form-file--error": t.error
      }])
    }, [
      be("label", {
        for: t.uniqID,
        title: t.fileSearchTitle
      }, [
        tq,
        be("span", iq, Pe(t.fileSearchTitle), 1)
      ], 8, eq),
      be("input", {
        id: t.uniqID,
        ref: "fileInput",
        type: "file",
        class: "dps-form-file__input",
        accept: t.accept,
        required: t.required,
        multiple: t.multiple ? !0 : void 0,
        disabled: t.disabled,
        onChange: e[0] || (e[0] = (...o) => t.handleSelectionChange && t.handleSelectionChange(...o)),
        onCancel: e[1] || (e[1] = (...o) => t.resetSelection && t.resetSelection(...o)),
        onClick: e[2] || (e[2] = (o) => o.target.value = "")
      }, null, 40, rq)
    ], 2);
  }
  const sq = /* @__PURE__ */ Vn($Z, [["render", nq]]);
  je({
    name: "DpsLogoutAlert",
    components: { DpsButton: vl, DpsAlert: JZ },
    props: {
      /**
       * Defines when the current session expires (UNIX timestamp in seconds)
       */
      expirationTime: {
        type: Number,
        required: !0
      },
      /**
       * Defines how many minutes before the logout the alert should be visible
       * @default 3
       */
      threshold: {
        type: Number,
        default: 3,
        required: !1
      }
    },
    emits: [
      /**
       * Emitted when the user clicks the "Neu anmelden" button
       */
      "click"
    ],
    data() {
      return {
        interval: null,
        minutesToLogout: null
      };
    },
    computed: {
      showLogoutAlert() {
        return this.minutesToLogout <= this.threshold;
      }
    },
    watch: {
      expirationTime() {
        this.startInterval();
      }
    },
    created() {
      this.startInterval();
    },
    beforeUnmount() {
      clearInterval(this.interval);
    },
    methods: {
      startInterval() {
        this.setMinutesToLogout(), clearInterval(this.interval), this.minutesToLogout > 0 && (this.interval = setInterval(this.setMinutesToLogout, 1e3));
      },
      setMinutesToLogout() {
        const t = this.expirationTime * 1e3, e = Date.now(), i = t - e;
        this.minutesToLogout = Math.ceil(i / 1e3 / 60), this.minutesToLogout <= 0 && clearInterval(this.interval);
      },
      handleClick() {
        this.$emit("click");
      }
    }
  });
  var oq = {
    months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
    monthsShort: ["Jan", "Feb", "März", "Apr", "Mai", "Juni", "Juli", "Aug", "Sep", "Okt", "Nov", "Dez"],
    weekdays: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
    weekdaysShort: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
    weekdaysMin: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    firstDayOfWeek: 1,
    firstWeekContainsDate: 4
  };
  const aq = {
    formatLocale: oq,
    yearFormat: "YYYY",
    monthFormat: "MMM",
    monthBeforeYear: !0
  };
  KW.locale("de", aq);
  je({
    name: "DpsUploadFormGroup",
    components: { DpsFormFile: sq, DpsFormGroup: iZ, DpsButton: vl, DpsInputGroup: qZ },
    props: {
      /**
       * The unique identifier for the input (optional).
       * @default undefined
       */
      id: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * The label for the component.
       * @default ""
       */
      label: {
        type: String,
        required: !1,
        default: ""
      },
      /**
       * Hides the label.
       * @default false
       */
      hideLabel: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * The label for the upload button.
       * @default "Hochladen"
       */
      uploadButtonLabel: {
        type: String,
        required: !1,
        default: "Hochladen"
      },
      /**
       * The title for the upload button.
       * Defaults to the button label if no title is set.
       * @default undefined
       */
      uploadButtonTitle: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Which file formats to accept.
       * Can be either file extension or mime-type or mixed
       * e.g. ['.pdf'], ['application/pdf'] or ['.pdf', 'application/pdf']
       * @default []
       */
      fileAccept: {
        type: Array,
        required: !1,
        default() {
          return [];
        }
      },
      /**
       * Allows selecting multiple files at once.
       * @default false
       */
      fileMultiple: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Disables the component.
       * @default false
       */
      disabled: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Title for the search button.
       * Defaults to the label if no title is set.
       * @default undefined
       */
      title: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Disables the upload button.
       * @default false
       */
      disableUploadButton: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Displays the component without the upload button.
       * @default false
       */
      hideUploadButton: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * Changes the state to error and displays the provided error message.
       * @default ""
       */
      uploadErrorMessage: {
        type: String,
        required: !1,
        default: ""
      },
      /**
       * Required attribute of the input.
       * @default false
       */
      fileRequired: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * Emitted when the file selection changes.
       * @event module:DpsFormFile#input
       */
      "input",
      /**
       * Emitted when the upload button gets clicked.
       * @event module:DpsFormFile#upload
       */
      "upload"
    ],
    data() {
      return {
        hasError: !1,
        filesSelected: null,
        uniqID: this.id ?? vn("dps-upload-form-group-"),
        rerenderCounter: 0
      };
    },
    computed: {
      fileSearchTitle() {
        return this.title ?? this.label;
      },
      acceptedFilesAsString() {
        if (Array.isArray(this.fileAccept))
          return this.fileAccept.join(", ");
      },
      acceptedFilesDescription() {
        var t;
        return this.acceptedFilesAsString ? `${((t = this.fileAccept) == null ? void 0 : t.length) > 1 ? "Erlaubte Dateiformate" : "Erlaubtes Dateiformat"}: ${this.acceptedFilesAsString}` : void 0;
      },
      acceptedFilesErrorMessage() {
        var t;
        return this.acceptedFilesAsString ? `Die ${this.fileMultiple ? "gewählten Dateien entsprechen" : "gewählte Datei entspricht"} nicht ${((t = this.fileAccept) == null ? void 0 : t.length) > 1 ? "den erlaubten Dateiformaten" : "dem erlaubten Dateiformat"}` : "";
      },
      errorMessage() {
        return this.uploadErrorMessage ? this.uploadErrorMessage : this.acceptedFilesErrorMessage;
      },
      isUploadButtonDisabled() {
        var t;
        return !(Array.isArray(this.filesSelected) ? (t = this.filesSelected) != null && t.length : this.filesSelected) || this.disabled || this.disableUploadButton;
      }
    },
    watch: {
      uploadErrorMessage(t) {
        t && (this.hasError = !0);
      }
    },
    mounted() {
      this.hasError = !!this.uploadErrorMessage;
    },
    methods: {
      validateFileType(t) {
        const e = "." + t.name.split(".").pop();
        return this.fileAccept.includes(t.type) || this.fileAccept.includes(e);
      },
      handleSelectionChange(t) {
        if (!t)
          return this.filesSelected = null, this.$emit("input", this.filesSelected), !1;
        if (this.filesSelected = Array.isArray(t) ? t : [t], this.acceptedFilesAsString && !Array.from(this.filesSelected).reduce(
          (e, i) => e && i && this.validateFileType(i),
          !0
        ))
          return this.resetSelection(!0), !1;
        this.hasError = !1, this.$emit("input", this.filesSelected);
      },
      // May be called as an API method from outside - do not remove!
      resetSelection(t = !1) {
        this.filesSelected = this.fileMultiple ? [] : null, this.rerenderCounter++, this.$emit("input", this.filesSelected), this.hasError = t;
      }
    },
    expose: ["resetSelection"]
  });
  je({
    name: "DpsListGroupItem",
    components: { DpsBadge: iX, DpsIconButton: RN },
    props: {
      /**
       * The unique identifier for the collapsible element. This identifier is used to associate the
       * collapsible content with its corresponding trigger for accessibility and Bootstrap's collapse functionality.
       *
       * @default undefined
       */
      collapseId: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Specifies the HTML tag to use for the root element.
       * @default "div"
       */
      tag: {
        type: String,
        required: !1,
        default: "div"
      },
      /**
       * The URL that the hyperlink points to.
       * @default undefined
       */
      href: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Indicates whether the collapsible row content is initially expanded.
       * When set to true, the collapsible content will be visible by default.
       *
       * @default false
       */
      expanded: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * This event is fired immediately when the show method has been called.
       */
      "show",
      /**
       * This event is fired immediately when the hide method has been called.
       */
      "hide"
    ],
    data() {
      return {
        isExpanded: !1
      };
    },
    computed: {
      uniqueId() {
        return this.collapseId ? this.collapseId : vn("dps-list-group-item-");
      },
      computedTag() {
        return this.href ? "a" : this.tag;
      },
      isCollapsible() {
        return !!this.$slots["collapsible-content"];
      }
    },
    watch: {
      expanded(t) {
        this.isExpanded = t;
      }
    },
    mounted() {
      const t = this.$refs.collapsible;
      this.isExpanded = this.expanded, t && (t.addEventListener("hide.bs.collapse", () => {
        this.isExpanded = !1, this.$emit("hide");
      }), t.addEventListener("show.bs.collapse", () => {
        this.isExpanded = !0, this.$emit("show");
      }));
    },
    methods: {
      handleEnter() {
        this.isCollapsible && this.$refs.trigger.click();
      }
    }
  });
  const Aq = je({
    name: "DpsTableRow",
    props: {
      /**
       * The unique identifier for the collapsible element. This identifier is used to associate the
       * collapsible content with its corresponding trigger for accessibility and Bootstrap's collapse functionality.
       * @default undefined
       */
      collapseId: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * The number of columns the collapsible content should span when expanded.
       * This controls the width of the collapsible content.
       *
       * @default undefined
       */
      collapseColspan: {
        type: Number,
        required: !1,
        default: void 0
      },
      /**
       * The starting position (column index) where the collapsible content should be displayed.
       * This can be used to create an offset within the row.
       *
       * @default 0
       */
      collapseColstart: {
        type: Number,
        required: !1,
        default: 0
      },
      /**
       * Indicates whether the collapsible row content is initially expanded.
       * When set to true, the collapsible content will be visible by default.
       *
       * @default false
       */
      expanded: {
        type: Boolean,
        required: !1,
        default: !1
      }
    },
    emits: [
      /**
       * This event is fired immediately when the show method has been called.
       */
      "show",
      /**
       * This event is fired immediately when the hide method has been called.
       */
      "hide"
    ],
    data() {
      return {
        isExpanded: !1
      };
    },
    computed: {
      uniqueId() {
        return this.collapseId ? this.collapseId : vn("dps-table-row-");
      },
      isCollapsible() {
        return !!this.$slots["collapsible-content"];
      }
    },
    watch: {
      expanded(t) {
        this.isExpanded = t;
      }
    },
    mounted() {
      const t = this.$refs.collapsible;
      this.isExpanded = this.expanded, t && (t.addEventListener("hide.bs.collapse", () => {
        this.isExpanded = !1, this.$emit("hide");
      }), t.addEventListener("show.bs.collapse", () => {
        this.isExpanded = !0, this.$emit("show");
      }));
    },
    methods: {
      handleEnter() {
        this.isCollapsible && this.$refs.mainElement.click();
      }
    }
  }), lq = ["data-bs-toggle", "data-bs-target", "aria-expanded", "aria-controls", "tabindex", "role"], cq = {
    key: 0,
    class: "dps-table-row dps-table-row--collapse"
  }, uq = ["colspan"], dq = ["colspan"], hq = ["id"], gq = { class: "dps-table-row__collapsible-content" };
  function fq(t, e, i, r, n, s) {
    return G(), X(ht, null, [
      be("tr", {
        ref: "mainElement",
        class: he(["dps-table-row", {
          "dps-table-row--collapsible": t.isCollapsible,
          "dps-table-row--expanded": t.isCollapsible && t.isExpanded
        }]),
        "data-bs-toggle": t.isCollapsible ? "collapse" : void 0,
        "data-bs-target": t.isCollapsible ? "#" + t.uniqueId : void 0,
        "aria-expanded": t.isCollapsible ? t.expanded : void 0,
        "aria-controls": t.isCollapsible ? t.uniqueId : void 0,
        tabindex: t.isCollapsible ? "0" : void 0,
        role: t.isCollapsible ? "button" : void 0,
        onKeydown: e[0] || (e[0] = At((...o) => t.handleEnter && t.handleEnter(...o), ["enter"]))
      }, [
        ge(t.$slots, "default")
      ], 42, lq),
      t.isCollapsible ? (G(), X("tr", cq, [
        t.collapseColstart > 0 ? (G(), X("td", {
          key: 0,
          colspan: t.collapseColstart
        }, null, 8, uq)) : de("", !0),
        be("td", { colspan: t.collapseColspan }, [
          be("div", {
            id: t.uniqueId,
            ref: "collapsible",
            class: he(["collapse", { show: t.expanded }])
          }, [
            be("div", gq, [
              ge(t.$slots, "collapsible-content")
            ])
          ], 10, hq)
        ], 8, dq)
      ])) : de("", !0)
    ], 64);
  }
  const pq = /* @__PURE__ */ Vn(Aq, [["render", fq]]);
  je({
    name: "DpsTable",
    components: { DpsTableRow: pq, DpsFormCheckbox: _N },
    props: {
      /**
       * An array of field definition objects, each defining the properties of a table column.
       *
       * @default []
       */
      fields: {
        type: Array,
        default() {
          return [];
        }
      },
      /**
       * An array of data objects to be displayed in the table rows.
       * Each object should match the structure defined by the `fields` array.
       *
       * @default []
       */
      items: {
        type: Array,
        default() {
          return [];
        }
      },
      /**
       * Whether to hide the table header while keeping it accessible for screen readers.
       * This is useful for visually minimalist tables while maintaining accessibility.
       *
       * @default false
       */
      hideHeader: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * The key  of the field currently being used for sorting the table.
       * Should correspond to one of the `key` values defined in the `fields` array.
       *
       * @default undefined
       */
      sortBy: {
        type: String,
        required: !1,
        default: void 0
      },
      /**
       * Indicates whether the sorting is in descending order.
       * When set to `true`, the table will be sorted in descending order; otherwise, it will be in ascending order.
       *
       * @default false
       */
      sortDesc: {
        type: Boolean,
        required: !1,
        default: !1
      },
      /**
       * The starting column index where the collapsible content should be displayed.
       * This can create an offset within the table row for the collapsible section.
       *
       * @default undefined
       */
      collapseColstart: {
        type: Number,
        required: !1,
        default: void 0
      },
      /**
       * The number of columns the collapsible content should span when expanded.
       * Determines the width of the collapsible content section.
       *
       * @default undefined
       */
      collapseColspan: {
        type: Number,
        required: !1,
        default: void 0
      }
    },
    emits: [
      /**
       * Emitted when the sortBy property changes.
       *
       * @event update:sort-by
       * @property {string} - The key of the field being sorted. Corresponds to the `key` property in the `fields` array.
       */
      "update:sort-by",
      /**
       * Emitted when the sortDesc property changes.
       *
       * @event update:sort-desc
       * @property {boolean} - Indicates the sort direction. `true` for descending order, `false` for ascending order.
       */
      "update:sort-desc",
      /**
       * Emitted when the status of a header checkbox changes.
       *
       * @event change-checked
       * @property {number} - The key of the field whose checkbox status was changed.
       */
      "change-checked"
    ],
    data() {
      return {
        isScrollable: !1,
        isScrolledToRight: !1,
        isScrolledToLeft: !0
      };
    },
    computed: {
      hasCustomTemplate() {
        return !!this.$slots["table-row"];
      },
      stickyColumns() {
        return this.fields.reduce((t, e, i) => (e.sticky && t.push(i), t), []);
      },
      sortedItems() {
        const t = this.fields.map((i) => i.key);
        if (this.sortBy === void 0 || !t.includes(this.sortBy))
          return this.items;
        const e = (i) => {
          const r = new Date(i);
          return !isNaN(r.getTime());
        };
        return this.items.slice().sort((i, r) => {
          const n = this.sortBy, s = i[n], o = r[n];
          if (e(s) && e(o)) {
            const l = String(s), c = String(o);
            return this.sortDesc ? new Date(c).getTime() - new Date(l).getTime() : new Date(l).getTime() - new Date(c).getTime();
          }
          const a = (s || "").toString().toLowerCase(), A = (o || "").toString().toLowerCase();
          return this.sortDesc ? A.localeCompare(a) : a.localeCompare(A);
        });
      },
      ariaSort() {
        return this.fields.reduce(
          (t, e) => (t[e.key] = e.sortable ? this.sortBy === e.key ? this.sortDesc ? "descending" : "ascending" : "none" : void 0, t),
          {}
        );
      }
    },
    watch: {
      items: {
        handler() {
          ji(this.setStickyStyles);
        },
        deep: !0
      },
      isScrollable() {
        this.setStickyStyles();
      }
    },
    mounted() {
      this.observeTableWidth(), this.observeScrollPos();
    },
    methods: {
      updateSorting(t) {
        t.sortable && (t.key !== this.sortBy ? (this.$emit("update:sort-by", t.key), this.$emit("update:sort-desc", !1)) : this.$emit("update:sort-desc", !this.sortDesc));
      },
      observeTableWidth() {
        const t = this.$refs.table, e = this.$refs.tableWrapper, i = new ResizeObserver(() => {
          t.clientWidth && e.clientWidth && (this.isScrollable = t.clientWidth > e.clientWidth);
        });
        i.observe(e), i.observe(t);
      },
      observeScrollPos() {
        const t = this.$refs.tableWrapper;
        t.addEventListener("scroll", () => {
          this.isScrolledToRight = t.scrollWidth - t.scrollLeft - t.clientWidth < 2, this.isScrolledToLeft = t.scrollLeft < 2;
        });
      },
      setStickyStyles() {
        const t = this.$refs.table, e = this.$refs.tableWrapper;
        if (this.stickyColumns.length === 0)
          return;
        e.scrollLeft = 0;
        const i = t.querySelectorAll("tr");
        for (const r of Array.from(i)) {
          const n = r.querySelectorAll("th, td");
          for (const [s, o] of Array.from(n).entries())
            o.style.removeProperty("left"), o.removeAttribute("data-sticky"), this.stickyColumns.includes(+s) && (o.setAttribute("data-sticky", ""), o.style.left = +s !== this.stickyColumns[0] ? `${n[s - 1].getBoundingClientRect().width + 1}px` : `${o.offsetLeft}px`);
        }
      }
    }
  });
  const mq = je({
    name: "DpsLoadingSpinner",
    props: {
      /**
       * Aria label for the spinner.
       * @default undefined
       */
      ariaLabel: {
        type: String,
        required: !1,
        default: "Laden"
      }
    }
  }), Eq = ["aria-label"], yq = /* @__PURE__ */ be("span", { class: "dps-icon dps-icon--ladeanimation" }, null, -1);
  function Bq(t, e, i, r, n, s) {
    return G(), X("div", {
      class: "dps-loading-spinner align-content-center d-flex gap-2",
      "aria-busy": "true",
      "aria-label": t.ariaLabel
    }, [
      ge(t.$slots, "default"),
      yq
    ], 8, Eq);
  }
  const wq = /* @__PURE__ */ Vn(mq, [["render", Bq]]);
  window.Bootstrap = mV;
  const Cq = {
    class: "ol-control control-layer-selection d-print-none",
    style: { visibility: "hidden" }
  }, bq = { class: "accordion-header" }, Mq = { class: "accordion-header-icon" }, Iq = { class: "accordion-header-title" }, vq = {
    key: 0,
    class: "accordion-content"
  }, xq = {
    key: 1,
    class: "accordion-content"
  }, Qq = {
    key: 2,
    class: "accordion-content"
  }, Fq = {
    key: 3,
    class: "accordion-content"
  }, Sq = /* @__PURE__ */ je({
    __name: "LayerSelectControl",
    props: {
      applicationData: { type: Boolean, default: !1 },
      baseLayer: { type: Number, required: !0 },
      backgroundLayers: { type: Array, required: !0 },
      dataLayers: { type: Array, required: !0 },
      xplanLayers: { type: Array, default: () => [] }
    },
    emits: ["backgroundChange", "dataChange", "toggle"],
    setup(t, { emit: e }) {
      var M, I;
      const i = t, r = e, n = i.backgroundLayers.map((b) => ({
        value: { value: b.Layer, label: b.Titel },
        label: b.Titel
      })), s = ue(
        ((M = n[i.baseLayer]) == null ? void 0 : M.value) || null
      );
      function o(b) {
        b || (b = n[i.baseLayer].value, s.value = b);
        const B = {
          Titel: b.label,
          Layer: b.value
        };
        r("backgroundChange", B);
      }
      const a = i.dataLayers.map((b) => ({
        value: { value: b.Layer, label: b.Titel, ordinal: b.Ordinal },
        label: b.Titel
      })), A = i.xplanLayers.map((b) => ({
        value: { value: b.Layer, label: b.Titel, ordinal: b.Ordinal },
        label: b.Titel
      })), l = ue([]), c = ue([]), u = ue([]), d = ue([]);
      function h(b) {
        return (b || []).map((B) => ({
          Titel: B.label,
          Layer: B.value,
          Ordinal: B.ordinal
        })).sort(
          (B, x) => B.Ordinal && x.Ordinal ? B.Ordinal - x.Ordinal : 0
        );
      }
      function g(b) {
        const B = h(b);
        d.value = B, r("dataChange", [...u.value, ...B]);
      }
      function f(b) {
        const B = h(b);
        u.value = B, r("dataChange", [...d.value, ...B]);
      }
      const p = [
        {
          label: "Potenzialflächen",
          value: Kp.NEIGBHBOURS,
          active: !1
        },
        {
          label: "Konversionsflächen",
          value: Kp.CONVERSIONS,
          active: !1
        },
        {
          label: "Gewerbliche Standorte",
          value: Kp.COMMERCIALS,
          active: !1
        }
      ], m = ue([]);
      function E(b) {
        p.forEach((B) => {
          const x = (b == null ? void 0 : b.includes(B.value)) || !1;
          x !== B.active && (B.active = x, r("toggle", B.value, x));
        });
      }
      const y = {
        legendClass: {
          "fs-6": !1,
          "layer-select-legend": !0,
          uppercase: !0
        },
        labelClass: {
          "fw-semibold": !1,
          "fw-normal": !0,
          "form-label": !1
        },
        outerClass: {
          "formkit-outer": !1,
          "mb-0": !0
        },
        fieldsetClass: {
          "input-field": !1
        },
        optionsClass: {
          "input-field": !1,
          "mb-0": !0
        }
      }, C = ue(0), w = ue([
        ...(I = i.xplanLayers) != null && I.length ? [
          {
            title: "XPlan GML",
            kind: "isXPlanLayers"
          }
        ] : [],
        {
          title: "Fachdaten",
          kind: "isDataLayers"
        },
        {
          title: "Hintergrundkarte",
          kind: "isBackgroundLayers"
        },
        ...i.applicationData ? [
          {
            title: "Anwendungsdaten",
            kind: "isAppLayers"
          }
        ] : []
      ]);
      return (b, B) => {
        const x = Os("o-icon"), Q = Os("FormKit"), v = Os("o-collapse");
        return G(), X("div", Cq, [
          (G(!0), X(ht, null, xi(w.value, (T, S) => (G(), De(v, {
            key: S,
            class: "show",
            animation: "slide",
            expanded: "",
            open: C.value == S,
            "onUpdate:open": (D) => C.value = S
          }, {
            trigger: Ye((D) => [
              be("div", bq, [
                be("span", Mq, [
                  ee(x, {
                    icon: D.open ? "minus" : "plus"
                  }, null, 8, ["icon"])
                ]),
                be("span", Iq, Pe(T.title), 1)
              ])
            ]),
            default: Ye(() => [
              T.kind === "isXPlanLayers" ? (G(), X("div", vq, [
                t.xplanLayers && t.xplanLayers.length > 0 ? (G(), De(Q, Tt({
                  key: 0,
                  ref_for: !0
                }, y, {
                  modelValue: c.value,
                  "onUpdate:modelValue": B[0] || (B[0] = (D) => c.value = D),
                  type: "checkbox",
                  ignore: "",
                  options: j(A),
                  onInput: g
                }), null, 16, ["modelValue", "options"])) : (G(), De(j(wq), { key: 1 }))
              ])) : de("", !0),
              T.kind === "isDataLayers" ? (G(), X("div", xq, [
                ee(Q, Tt({ ref_for: !0 }, y, {
                  modelValue: l.value,
                  "onUpdate:modelValue": B[1] || (B[1] = (D) => l.value = D),
                  type: "checkbox",
                  ignore: "",
                  options: j(a),
                  onInput: f
                }), null, 16, ["modelValue", "options"])
              ])) : de("", !0),
              T.kind === "isBackgroundLayers" ? (G(), X("div", Qq, [
                ee(Q, Tt({ ref_for: !0 }, y, {
                  modelValue: s.value,
                  "onUpdate:modelValue": B[2] || (B[2] = (D) => s.value = D),
                  type: "radio",
                  ignore: "",
                  options: j(n),
                  onInput: o
                }), null, 16, ["modelValue", "options"])
              ])) : de("", !0),
              T.kind === "isAppLayers" ? (G(), X("div", Fq, [
                t.applicationData ? (G(), De(Q, Tt({
                  key: 0,
                  ref_for: !0
                }, y, {
                  modelValue: m.value,
                  "onUpdate:modelValue": B[3] || (B[3] = (D) => m.value = D),
                  type: "checkbox",
                  ignore: "",
                  options: p,
                  onInput: E
                }), null, 16, ["modelValue"])) : de("", !0)
              ])) : de("", !0)
            ]),
            _: 2
          }, 1032, ["open", "onUpdate:open"]))), 128))
        ]);
      };
    }
  }), Dq = ".dps-loading-spinner .dps-icon[data-v-13ae5a84]{display:inline-block;color:var(--dps-color-primary);font-size:24px;animation:spin-13ae5a84 2s linear infinite}@keyframes spin-13ae5a84{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.control-layer-selection[data-v-13ae5a84]{background-color:#fff;display:none;visibility:hidden;width:300px;margin-right:.5rem}[data-v-13ae5a84] .collapse,[data-v-13ae5a84] .collapse-trigger[aria-expanded=true]{border-bottom:1px #c8cacc solid}[data-v-13ae5a84] .input-group{flex-direction:column;list-style:none;padding:0;margin:0}[data-v-13ae5a84] .formkit-fieldset{padding:0}[data-v-13ae5a84] .input-option{display:flex;min-height:3rem;padding:1rem;justify-content:space-between;align-items:center;align-self:stretch;border-bottom:1px #c8cacc solid}[data-v-13ae5a84] .input-option:last-child{border-bottom:none}[data-v-13ae5a84] .form-check-input[type=radio]{border-radius:50%!important}[data-v-13ae5a84] .formkit-wrapper{display:flex;align-items:center}.accordion-header[data-v-13ae5a84]{display:flex;height:3rem;align-items:center;gap:.5rem;align-self:stretch;padding-left:.75rem;padding-right:1rem;background-color:#f7f8fa;color:#04071a}.accordion-header-title[data-v-13ae5a84]{font-weight:600}[aria-expanded=true] .accordion-header-title[data-v-13ae5a84]{color:#3375d4}.accordion-header-icon[data-v-13ae5a84]{cursor:pointer;padding:4px 2px 2px}.accordion-header-icon .icon[data-v-13ae5a84]{border:1px solid #c8cacc;border-radius:50%;font-size:1.25rem;height:1.5rem;width:1.5rem}.accordion-content[data-v-13ae5a84]{max-height:300px;overflow:auto}", Tq = /* @__PURE__ */ Zl(Sq, [["styles", [Dq]], ["__scopeId", "data-v-13ae5a84"]]);
  class on {
    /**
     * @param {string} type Type.
     */
    constructor(e) {
      this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
    }
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */
    preventDefault() {
      this.defaultPrevented = !0;
    }
    /**
     * Stop event propagation.
     * @api
     */
    stopPropagation() {
      this.propagationStopped = !0;
    }
  }
  const qu = {
    /**
     * Triggered when a property is changed.
     * @event module:ol/Object.ObjectEvent#propertychange
     * @api
     */
    PROPERTYCHANGE: "propertychange"
  };
  class Td {
    constructor() {
      this.disposed = !1;
    }
    /**
     * Clean up.
     */
    dispose() {
      this.disposed || (this.disposed = !0, this.disposeInternal());
    }
    /**
     * Extension point for disposable objects.
     * @protected
     */
    disposeInternal() {
    }
  }
  function Rq(t, e, i) {
    let r, n;
    i = i || Qo;
    let s = 0, o = t.length, a = !1;
    for (; s < o; )
      r = s + (o - s >> 1), n = +i(t[r], e), n < 0 ? s = r + 1 : (o = r, a = !n);
    return a ? s : ~s;
  }
  function Qo(t, e) {
    return t > e ? 1 : t < e ? -1 : 0;
  }
  function WN(t, e) {
    return t < e ? 1 : t > e ? -1 : 0;
  }
  function nB(t, e, i) {
    if (t[0] <= e)
      return 0;
    const r = t.length;
    if (e <= t[r - 1])
      return r - 1;
    if (typeof i == "function") {
      for (let n = 1; n < r; ++n) {
        const s = t[n];
        if (s === e)
          return n;
        if (s < e)
          return i(e, t[n - 1], s) > 0 ? n - 1 : n;
      }
      return r - 1;
    }
    if (i > 0) {
      for (let n = 1; n < r; ++n)
        if (t[n] < e)
          return n - 1;
      return r - 1;
    }
    if (i < 0) {
      for (let n = 1; n < r; ++n)
        if (t[n] <= e)
          return n;
      return r - 1;
    }
    for (let n = 1; n < r; ++n) {
      if (t[n] == e)
        return n;
      if (t[n] < e)
        return t[n - 1] - e < e - t[n] ? n - 1 : n;
    }
    return r - 1;
  }
  function _q(t, e, i) {
    for (; e < i; ) {
      const r = t[e];
      t[e] = t[i], t[i] = r, ++e, --i;
    }
  }
  function xr(t, e) {
    const i = Array.isArray(e) ? e : [e], r = i.length;
    for (let n = 0; n < r; n++)
      t[t.length] = i[n];
  }
  function jo(t, e) {
    const i = t.length;
    if (i !== e.length)
      return !1;
    for (let r = 0; r < i; r++)
      if (t[r] !== e[r])
        return !1;
    return !0;
  }
  function kq(t, e, i) {
    const r = e || Qo;
    return t.every(function(n, s) {
      if (s === 0)
        return !0;
      const o = r(t[s - 1], n);
      return !(o > 0 || o === 0);
    });
  }
  function Qa() {
    return !0;
  }
  function rc() {
    return !1;
  }
  function $u() {
  }
  function KN(t) {
    let e, i, r;
    return function() {
      const n = Array.prototype.slice.call(arguments);
      return (!i || this !== r || !jo(n, i)) && (r = this, i = n, e = t.apply(this, arguments)), e;
    };
  }
  function ed(t) {
    function e() {
      let i;
      try {
        i = t();
      } catch (r) {
        return Promise.reject(r);
      }
      return i instanceof Promise ? i : Promise.resolve(i);
    }
    return e();
  }
  function nc(t) {
    for (const e in t)
      delete t[e];
  }
  function vA(t) {
    let e;
    for (e in t)
      return !1;
    return !e;
  }
  class Rd extends Td {
    /**
     * @param {*} [target] Default event target for dispatched events.
     */
    constructor(e) {
      super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    addEventListener(e, i) {
      if (!e || !i)
        return;
      const r = this.listeners_ || (this.listeners_ = {}), n = r[e] || (r[e] = []);
      n.includes(i) || n.push(i);
    }
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */
    dispatchEvent(e) {
      const i = typeof e == "string", r = i ? e : e.type, n = this.listeners_ && this.listeners_[r];
      if (!n)
        return;
      const s = i ? new on(e) : (
        /** @type {Event} */
        e
      );
      s.target || (s.target = this.eventTarget_ || this);
      const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
      r in o || (o[r] = 0, a[r] = 0), ++o[r];
      let A;
      for (let l = 0, c = n.length; l < c; ++l)
        if ("handleEvent" in n[l] ? A = /** @type {import("../events.js").ListenerObject} */
        n[l].handleEvent(s) : A = /** @type {import("../events.js").ListenerFunction} */
        n[l].call(this, s), A === !1 || s.propagationStopped) {
          A = !1;
          break;
        }
      if (--o[r] === 0) {
        let l = a[r];
        for (delete a[r]; l--; )
          this.removeEventListener(r, $u);
        delete o[r];
      }
      return A;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.listeners_ && nc(this.listeners_);
    }
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */
    getListeners(e) {
      return this.listeners_ && this.listeners_[e] || void 0;
    }
    /**
     * @param {string} [type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */
    hasListener(e) {
      return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    removeEventListener(e, i) {
      if (!this.listeners_)
        return;
      const r = this.listeners_[e];
      if (!r)
        return;
      const n = r.indexOf(i);
      n !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (r[n] = $u, ++this.pendingRemovals_[e]) : (r.splice(n, 1), r.length === 0 && delete this.listeners_[e]));
    }
  }
  const Ge = {
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */
    CHANGE: "change",
    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */
    ERROR: "error",
    CONTEXTMENU: "contextmenu",
    CLICK: "click",
    DBLCLICK: "dblclick",
    KEYDOWN: "keydown",
    KEYPRESS: "keypress",
    LOAD: "load",
    TOUCHMOVE: "touchmove",
    WHEEL: "wheel"
  };
  function nt(t, e, i, r, n) {
    if (n) {
      const o = i;
      i = function() {
        t.removeEventListener(e, i), o.apply(r ?? this, arguments);
      };
    } else r && r !== t && (i = i.bind(r));
    const s = {
      target: t,
      type: e,
      listener: i
    };
    return t.addEventListener(e, i), s;
  }
  function gE(t, e, i, r) {
    return nt(t, e, i, r, !0);
  }
  function Pt(t) {
    t && t.target && (t.target.removeEventListener(t.type, t.listener), nc(t));
  }
  class rf extends Rd {
    constructor() {
      super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
      this.unInternal, this.revision_ = 0;
    }
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */
    changed() {
      ++this.revision_, this.dispatchEvent(Ge.CHANGE);
    }
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */
    getRevision() {
      return this.revision_;
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onInternal(e, i) {
      if (Array.isArray(e)) {
        const r = e.length, n = new Array(r);
        for (let s = 0; s < r; ++s)
          n[s] = nt(this, e[s], i);
        return n;
      }
      return nt(
        this,
        /** @type {string} */
        e,
        i
      );
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onceInternal(e, i) {
      let r;
      if (Array.isArray(e)) {
        const n = e.length;
        r = new Array(n);
        for (let s = 0; s < n; ++s)
          r[s] = gE(this, e[s], i);
      } else
        r = gE(
          this,
          /** @type {string} */
          e,
          i
        );
      return i.ol_key = r, r;
    }
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */
    unInternal(e, i) {
      const r = (
        /** @type {Object} */
        i.ol_key
      );
      if (r)
        Yq(r);
      else if (Array.isArray(e))
        for (let n = 0, s = e.length; n < s; ++n)
          this.removeEventListener(e[n], i);
      else
        this.removeEventListener(e, i);
    }
  }
  rf.prototype.on;
  rf.prototype.once;
  rf.prototype.un;
  function Yq(t) {
    if (Array.isArray(t))
      for (let e = 0, i = t.length; e < i; ++e)
        Pt(t[e]);
    else
      Pt(
        /** @type {import("./events.js").EventsKey} */
        t
      );
  }
  function it() {
    throw new Error("Unimplemented abstract method.");
  }
  let Nq = 0;
  function ve(t) {
    return t.ol_uid || (t.ol_uid = String(++Nq));
  }
  class tD extends on {
    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */
    constructor(e, i, r) {
      super(e), this.key = i, this.oldValue = r;
    }
  }
  class no extends rf {
    /**
     * @param {Object<string, *>} [values] An object with key-value pairs.
     */
    constructor(e) {
      super(), this.on, this.once, this.un, ve(this), this.values_ = null, e !== void 0 && this.setProperties(e);
    }
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */
    get(e) {
      let i;
      return this.values_ && this.values_.hasOwnProperty(e) && (i = this.values_[e]), i;
    }
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */
    getKeys() {
      return this.values_ && Object.keys(this.values_) || [];
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */
    getProperties() {
      return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal() {
      return this.values_;
    }
    /**
     * @return {boolean} The object has properties.
     */
    hasProperties() {
      return !!this.values_;
    }
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */
    notify(e, i) {
      let r;
      r = `change:${e}`, this.hasListener(r) && this.dispatchEvent(new tD(r, e, i)), r = qu.PROPERTYCHANGE, this.hasListener(r) && this.dispatchEvent(new tD(r, e, i));
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    addChangeListener(e, i) {
      this.addEventListener(`change:${e}`, i);
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    removeChangeListener(e, i) {
      this.removeEventListener(`change:${e}`, i);
    }
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    set(e, i, r) {
      const n = this.values_ || (this.values_ = {});
      if (r)
        n[e] = i;
      else {
        const s = n[e];
        n[e] = i, s !== i && this.notify(e, s);
      }
    }
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    setProperties(e, i) {
      for (const r in e)
        this.set(r, e[r], i);
    }
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */
    applyProperties(e) {
      e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
    }
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [silent] Unset without triggering an event.
     * @api
     */
    unset(e, i) {
      if (this.values_ && e in this.values_) {
        const r = this.values_[e];
        delete this.values_[e], vA(this.values_) && (this.values_ = null), i || this.notify(e, r);
      }
    }
  }
  const Ui = {
    /**
     * Triggered when an item is added to the collection.
     * @event module:ol/Collection.CollectionEvent#add
     * @api
     */
    ADD: "add",
    /**
     * Triggered when an item is removed from the collection.
     * @event module:ol/Collection.CollectionEvent#remove
     * @api
     */
    REMOVE: "remove"
  }, iD = {
    LENGTH: "length"
  };
  class ip extends on {
    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {T} element Element.
     * @param {number} index The index of the added or removed element.
     */
    constructor(e, i, r) {
      super(e), this.element = i, this.index = r;
    }
  }
  class Bn extends no {
    /**
     * @param {Array<T>} [array] Array.
     * @param {Options} [options] Collection options.
     */
    constructor(e, i) {
      if (super(), this.on, this.once, this.un, i = i || {}, this.unique_ = !!i.unique, this.array_ = e || [], this.unique_)
        for (let r = 0, n = this.array_.length; r < n; ++r)
          this.assertUnique_(this.array_[r], r);
      this.updateLength_();
    }
    /**
     * Remove all elements from the collection.
     * @api
     */
    clear() {
      for (; this.getLength() > 0; )
        this.pop();
    }
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */
    extend(e) {
      for (let i = 0, r = e.length; i < r; ++i)
        this.push(e[i]);
      return this;
    }
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */
    forEach(e) {
      const i = this.array_;
      for (let r = 0, n = i.length; r < n; ++r)
        e(i[r], r, i);
    }
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */
    getArray() {
      return this.array_;
    }
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */
    item(e) {
      return this.array_[e];
    }
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */
    getLength() {
      return this.get(iD.LENGTH);
    }
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    insertAt(e, i) {
      if (e < 0 || e > this.getLength())
        throw new Error("Index out of bounds: " + e);
      this.unique_ && this.assertUnique_(i), this.array_.splice(e, 0, i), this.updateLength_(), this.dispatchEvent(
        new ip(Ui.ADD, i, e)
      );
    }
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */
    pop() {
      return this.removeAt(this.getLength() - 1);
    }
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */
    push(e) {
      this.unique_ && this.assertUnique_(e);
      const i = this.getLength();
      return this.insertAt(i, e), this.getLength();
    }
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */
    remove(e) {
      const i = this.array_;
      for (let r = 0, n = i.length; r < n; ++r)
        if (i[r] === e)
          return this.removeAt(r);
    }
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */
    removeAt(e) {
      if (e < 0 || e >= this.getLength())
        return;
      const i = this.array_[e];
      return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new ip(Ui.REMOVE, i, e)
      ), i;
    }
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    setAt(e, i) {
      const r = this.getLength();
      if (e >= r) {
        this.insertAt(e, i);
        return;
      }
      if (e < 0)
        throw new Error("Index out of bounds: " + e);
      this.unique_ && this.assertUnique_(i, e);
      const n = this.array_[e];
      this.array_[e] = i, this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new ip(Ui.REMOVE, n, e)
      ), this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new ip(Ui.ADD, i, e)
      );
    }
    /**
     * @private
     */
    updateLength_() {
      this.set(iD.LENGTH, this.array_.length);
    }
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [except] Optional index to ignore.
     */
    assertUnique_(e, i) {
      for (let r = 0, n = this.array_.length; r < n; ++r)
        if (this.array_[r] === e && r !== i)
          throw new Error("Duplicate item added to a unique collection");
    }
  }
  function Mt(t, e) {
    if (!t)
      throw new Error(e);
  }
  class hr extends no {
    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */
    constructor(e) {
      if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
        if (typeof /** @type {?} */
        e.getSimplifiedGeometry == "function") {
          const i = (
            /** @type {Geometry} */
            e
          );
          this.setGeometry(i);
        } else {
          const i = e;
          this.setProperties(i);
        }
    }
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */
    clone() {
      const e = (
        /** @type {Feature<Geometry>} */
        new hr(this.hasProperties() ? this.getProperties() : null)
      );
      e.setGeometryName(this.getGeometryName());
      const i = this.getGeometry();
      i && e.setGeometry(
        /** @type {Geometry} */
        i.clone()
      );
      const r = this.getStyle();
      return r && e.setStyle(r), e;
    }
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */
    getGeometry() {
      return (
        /** @type {Geometry|undefined} */
        this.get(this.geometryName_)
      );
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id_;
    }
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */
    getGeometryName() {
      return this.geometryName_;
    }
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @private
     */
    handleGeometryChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleGeometryChanged_() {
      this.geometryChangeKey_ && (Pt(this.geometryChangeKey_), this.geometryChangeKey_ = null);
      const e = this.getGeometry();
      e && (this.geometryChangeKey_ = nt(
        e,
        Ge.CHANGE,
        this.handleGeometryChange_,
        this
      )), this.changed();
    }
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */
    setGeometry(e) {
      this.set(this.geometryName_, e);
    }
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setStyle(e) {
      this.style_ = e, this.styleFunction_ = e ? Uq(e) : void 0, this.changed();
    }
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setId(e) {
      this.id_ = e, this.changed();
    }
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */
    setGeometryName(e) {
      this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
    }
  }
  function Uq(t) {
    if (typeof t == "function")
      return t;
    let e;
    return Array.isArray(t) ? e = t : (Mt(
      typeof /** @type {?} */
      t.getZIndex == "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    ), e = [
      /** @type {import("./style/Style.js").default} */
      t
    ]), function() {
      return e;
    };
  }
  const Av = new Array(6);
  function ri() {
    return [1, 0, 0, 1, 0, 0];
  }
  function ab(t) {
    return sB(t, 1, 0, 0, 1, 0, 0);
  }
  function sc(t, e) {
    const i = t[0], r = t[1], n = t[2], s = t[3], o = t[4], a = t[5], A = e[0], l = e[1], c = e[2], u = e[3], d = e[4], h = e[5];
    return t[0] = i * A + n * l, t[1] = r * A + s * l, t[2] = i * c + n * u, t[3] = r * c + s * u, t[4] = i * d + n * h + o, t[5] = r * d + s * h + a, t;
  }
  function sB(t, e, i, r, n, s, o) {
    return t[0] = e, t[1] = i, t[2] = r, t[3] = n, t[4] = s, t[5] = o, t;
  }
  function fE(t, e) {
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
  }
  function Ei(t, e) {
    const i = e[0], r = e[1];
    return e[0] = t[0] * i + t[2] * r + t[4], e[1] = t[1] * i + t[3] * r + t[5], e;
  }
  function Lq(t, e) {
    const i = Math.cos(e), r = Math.sin(e);
    return sc(t, sB(Av, i, r, -r, i, 0, 0));
  }
  function Nh(t, e, i) {
    return sc(t, sB(Av, e, 0, 0, i, 0, 0));
  }
  function nf(t, e, i) {
    return sc(t, sB(Av, 1, 0, 0, 1, e, i));
  }
  function gs(t, e, i, r, n, s, o, a) {
    const A = Math.sin(s), l = Math.cos(s);
    return t[0] = r * l, t[1] = n * A, t[2] = -r * A, t[3] = n * l, t[4] = o * r * l - a * r * A + e, t[5] = o * n * A + a * n * l + i, t;
  }
  function xA(t, e) {
    const i = zq(e);
    Mt(i !== 0, "Transformation matrix cannot be inverted");
    const r = e[0], n = e[1], s = e[2], o = e[3], a = e[4], A = e[5];
    return t[0] = o / i, t[1] = -n / i, t[2] = -s / i, t[3] = r / i, t[4] = (s * A - o * a) / i, t[5] = -(r * A - n * a) / i, t;
  }
  function zq(t) {
    return t[0] * t[3] - t[1] * t[2];
  }
  const rD = [1e6, 1e6, 1e6, 1e6, 2, 2];
  function Pq(t) {
    return "matrix(" + t.map(
      (i, r) => Math.round(i * rD[r]) / rD[r]
    ).join(", ") + ")";
  }
  const cr = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
  };
  function $i(t) {
    const e = yr();
    for (let i = 0, r = t.length; i < r; ++i)
      Uh(e, t[i]);
    return e;
  }
  function Oq(t, e, i) {
    const r = Math.min.apply(null, t), n = Math.min.apply(null, e), s = Math.max.apply(null, t), o = Math.max.apply(null, e);
    return fs(r, n, s, o, i);
  }
  function $r(t, e, i) {
    return i ? (i[0] = t[0] - e, i[1] = t[1] - e, i[2] = t[2] + e, i[3] = t[3] + e, i) : [
      t[0] - e,
      t[1] - e,
      t[2] + e,
      t[3] + e
    ];
  }
  function XN(t, e) {
    return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t.slice();
  }
  function oc(t, e, i) {
    let r, n;
    return e < t[0] ? r = t[0] - e : t[2] < e ? r = e - t[2] : r = 0, i < t[1] ? n = t[1] - i : t[3] < i ? n = i - t[3] : n = 0, r * r + n * n;
  }
  function zl(t, e) {
    return lv(t, e[0], e[1]);
  }
  function ts(t, e) {
    return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3];
  }
  function lv(t, e, i) {
    return t[0] <= e && e <= t[2] && t[1] <= i && i <= t[3];
  }
  function Ab(t, e) {
    const i = t[0], r = t[1], n = t[2], s = t[3], o = e[0], a = e[1];
    let A = cr.UNKNOWN;
    return o < i ? A = A | cr.LEFT : o > n && (A = A | cr.RIGHT), a < r ? A = A | cr.BELOW : a > s && (A = A | cr.ABOVE), A === cr.UNKNOWN && (A = cr.INTERSECTING), A;
  }
  function yr() {
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  }
  function fs(t, e, i, r, n) {
    return n ? (n[0] = t, n[1] = e, n[2] = i, n[3] = r, n) : [t, e, i, r];
  }
  function _d(t) {
    return fs(1 / 0, 1 / 0, -1 / 0, -1 / 0, t);
  }
  function Qu(t, e) {
    const i = t[0], r = t[1];
    return fs(i, r, i, r, e);
  }
  function cv(t, e, i, r, n) {
    const s = _d(n);
    return ZN(s, t, e, i, r);
  }
  function Zs(t, e) {
    return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3];
  }
  function uv(t, e) {
    return e[0] < t[0] && (t[0] = e[0]), e[2] > t[2] && (t[2] = e[2]), e[1] < t[1] && (t[1] = e[1]), e[3] > t[3] && (t[3] = e[3]), t;
  }
  function Uh(t, e) {
    e[0] < t[0] && (t[0] = e[0]), e[0] > t[2] && (t[2] = e[0]), e[1] < t[1] && (t[1] = e[1]), e[1] > t[3] && (t[3] = e[1]);
  }
  function ZN(t, e, i, r, n) {
    for (; i < r; i += n)
      Gq(t, e[i], e[i + 1]);
    return t;
  }
  function Gq(t, e, i) {
    t[0] = Math.min(t[0], e), t[1] = Math.min(t[1], i), t[2] = Math.max(t[2], e), t[3] = Math.max(t[3], i);
  }
  function dv(t, e) {
    let i;
    return i = e(oB(t)), i || (i = e(aB(t)), i) || (i = e(AB(t)), i) || (i = e(qs(t)), i) ? i : !1;
  }
  function og(t) {
    let e = 0;
    return GA(t) || (e = mt(t) * Fi(t)), e;
  }
  function oB(t) {
    return [t[0], t[1]];
  }
  function aB(t) {
    return [t[2], t[1]];
  }
  function xn(t) {
    return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2];
  }
  function jq(t, e) {
    let i;
    if (e === "bottom-left")
      i = oB(t);
    else if (e === "bottom-right")
      i = aB(t);
    else if (e === "top-left")
      i = qs(t);
    else if (e === "top-right")
      i = AB(t);
    else
      throw new Error("Invalid corner");
    return i;
  }
  function ag(t, e, i, r, n) {
    const [s, o, a, A, l, c, u, d] = Hq(
      t,
      e,
      i,
      r
    );
    return fs(
      Math.min(s, a, l, u),
      Math.min(o, A, c, d),
      Math.max(s, a, l, u),
      Math.max(o, A, c, d),
      n
    );
  }
  function Hq(t, e, i, r) {
    const n = e * r[0] / 2, s = e * r[1] / 2, o = Math.cos(i), a = Math.sin(i), A = n * o, l = n * a, c = s * o, u = s * a, d = t[0], h = t[1];
    return [
      d - A + u,
      h - l - c,
      d - A - u,
      h - l + c,
      d + A - u,
      h + l + c,
      d + A + u,
      h + l - c,
      d - A + u,
      h - l - c
    ];
  }
  function Fi(t) {
    return t[3] - t[1];
  }
  function fr(t, e, i) {
    const r = i || yr();
    return Yi(t, e) ? (t[0] > e[0] ? r[0] = t[0] : r[0] = e[0], t[1] > e[1] ? r[1] = t[1] : r[1] = e[1], t[2] < e[2] ? r[2] = t[2] : r[2] = e[2], t[3] < e[3] ? r[3] = t[3] : r[3] = e[3]) : _d(r), r;
  }
  function qs(t) {
    return [t[0], t[3]];
  }
  function AB(t) {
    return [t[2], t[3]];
  }
  function mt(t) {
    return t[2] - t[0];
  }
  function Yi(t, e) {
    return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1];
  }
  function GA(t) {
    return t[2] < t[0] || t[3] < t[1];
  }
  function Jq(t, e) {
    return e ? (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e) : t;
  }
  function Vq(t, e, i) {
    let r = !1;
    const n = Ab(t, e), s = Ab(t, i);
    if (n === cr.INTERSECTING || s === cr.INTERSECTING)
      r = !0;
    else {
      const o = t[0], a = t[1], A = t[2], l = t[3], c = e[0], u = e[1], d = i[0], h = i[1], g = (h - u) / (d - c);
      let f, p;
      s & cr.ABOVE && !(n & cr.ABOVE) && (f = d - (h - l) / g, r = f >= o && f <= A), !r && s & cr.RIGHT && !(n & cr.RIGHT) && (p = h - (d - A) * g, r = p >= a && p <= l), !r && s & cr.BELOW && !(n & cr.BELOW) && (f = d - (h - a) / g, r = f >= o && f <= A), !r && s & cr.LEFT && !(n & cr.LEFT) && (p = h - (d - o) * g, r = p >= a && p <= l);
    }
    return r;
  }
  function qN(t, e, i, r) {
    if (GA(t))
      return _d(i);
    let n = [];
    n = [
      t[0],
      t[1],
      t[2],
      t[1],
      t[2],
      t[3],
      t[0],
      t[3]
    ], e(n, n, 2);
    const s = [], o = [];
    for (let a = 0, A = n.length; a < A; a += 2)
      s.push(n[a]), o.push(n[a + 1]);
    return Oq(s, o, i);
  }
  function $N(t, e) {
    const i = e.getExtent(), r = xn(t);
    if (e.canWrapX() && (r[0] < i[0] || r[0] >= i[2])) {
      const n = mt(i), o = Math.floor(
        (r[0] - i[0]) / n
      ) * n;
      t[0] -= o, t[2] -= o;
    }
    return t;
  }
  function hv(t, e, i) {
    if (e.canWrapX()) {
      const r = e.getExtent();
      if (!isFinite(t[0]) || !isFinite(t[2]))
        return [[r[0], t[1], r[2], t[3]]];
      $N(t, e);
      const n = mt(r);
      if (mt(t) > n && !i)
        return [[r[0], t[1], r[2], t[3]]];
      if (t[0] < r[0])
        return [
          [t[0] + n, t[1], r[2], t[3]],
          [r[0], t[1], t[2], t[3]]
        ];
      if (t[2] > r[2])
        return [
          [t[0], t[1], r[2], t[3]],
          [r[0], t[1], t[2] - n, t[3]]
        ];
    }
    return [t];
  }
  const Fa = {
    // use the radius of the Normal sphere
    radians: 6370997 / (2 * Math.PI),
    degrees: 2 * Math.PI * 6370997 / 360,
    ft: 0.3048,
    m: 1,
    "us-ft": 1200 / 3937
  };
  let sf = class {
    /**
     * @param {Options} options Projection options.
     */
    constructor(e) {
      this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
      e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    canWrapX() {
      return this.canWrapX_;
    }
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    getCode() {
      return this.code_;
    }
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_;
    }
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").Units} Units.
     * @api
     */
    getUnits() {
      return this.units_;
    }
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    getMetersPerUnit() {
      return this.metersPerUnit_ || Fa[this.units_];
    }
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getWorldExtent() {
      return this.worldExtent_;
    }
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    getAxisOrientation() {
      return this.axisOrientation_;
    }
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    isGlobal() {
      return this.global_;
    }
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    setGlobal(e) {
      this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
    }
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
    getDefaultTileGrid() {
      return this.defaultTileGrid_;
    }
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
    setDefaultTileGrid(e) {
      this.defaultTileGrid_ = e;
    }
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    setExtent(e) {
      this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
    }
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
    setWorldExtent(e) {
      this.worldExtent_ = e;
    }
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
    setGetPointResolution(e) {
      this.getPointResolutionFunc_ = e;
    }
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
    getPointResolutionFunc() {
      return this.getPointResolutionFunc_;
    }
  };
  const of = 6378137, lu = Math.PI * of, Wq = [-lu, -lu, lu, lu], Kq = [-180, -85, 180, 85], rp = of * Math.log(Math.tan(Math.PI / 2));
  class bc extends sf {
    /**
     * @param {string} code Code.
     */
    constructor(e) {
      super({
        code: e,
        units: "m",
        extent: Wq,
        global: !0,
        worldExtent: Kq,
        getPointResolution: function(i, r) {
          return i / Math.cosh(r[1] / of);
        }
      });
    }
  }
  const nD = [
    new bc("EPSG:3857"),
    new bc("EPSG:102100"),
    new bc("EPSG:102113"),
    new bc("EPSG:900913"),
    new bc("http://www.opengis.net/def/crs/EPSG/0/3857"),
    new bc("http://www.opengis.net/gml/srs/epsg.xml#3857")
  ];
  function Xq(t, e, i, r) {
    const n = t.length;
    i = i > 1 ? i : 2, r = r ?? i, e === void 0 && (i > 2 ? e = t.slice() : e = new Array(n));
    for (let s = 0; s < n; s += r) {
      e[s] = lu * t[s] / 180;
      let o = of * Math.log(Math.tan(Math.PI * (+t[s + 1] + 90) / 360));
      o > rp ? o = rp : o < -rp && (o = -rp), e[s + 1] = o;
    }
    return e;
  }
  function Zq(t, e, i, r) {
    const n = t.length;
    i = i > 1 ? i : 2, r = r ?? i, e === void 0 && (i > 2 ? e = t.slice() : e = new Array(n));
    for (let s = 0; s < n; s += r)
      e[s] = 180 * t[s] / lu, e[s + 1] = 360 * Math.atan(Math.exp(t[s + 1] / of)) / Math.PI - 90;
    return e;
  }
  const qq = 6378137, sD = [-180, -90, 180, 90], $q = Math.PI * qq / 180;
  class el extends sf {
    /**
     * @param {string} code Code.
     * @param {string} [axisOrientation] Axis orientation.
     */
    constructor(e, i) {
      super({
        code: e,
        units: "degrees",
        extent: sD,
        axisOrientation: i,
        global: !0,
        metersPerUnit: $q,
        worldExtent: sD
      });
    }
  }
  const oD = [
    new el("CRS:84"),
    new el("EPSG:4326", "neu"),
    new el("urn:ogc:def:crs:OGC:1.3:CRS84"),
    new el("urn:ogc:def:crs:OGC:2:84"),
    new el("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
    new el("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
    new el("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
  ];
  let lb = {};
  function im(t) {
    return lb[t] || lb[t.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
  }
  function e$(t, e) {
    lb[t] = e;
  }
  let Fu = {};
  function Pl(t, e, i) {
    const r = t.getCode(), n = e.getCode();
    r in Fu || (Fu[r] = {}), Fu[r][n] = i;
  }
  function rm(t, e) {
    return t in Fu && e in Fu[t] ? Fu[t][e] : null;
  }
  function yi(t, e, i) {
    return Math.min(Math.max(t, e), i);
  }
  function t$(t, e, i, r, n, s) {
    const o = n - i, a = s - r;
    if (o !== 0 || a !== 0) {
      const A = ((t - i) * o + (e - r) * a) / (o * o + a * a);
      A > 1 ? (i = n, r = s) : A > 0 && (i += o * A, r += a * A);
    }
    return fa(t, e, i, r);
  }
  function fa(t, e, i, r) {
    const n = i - t, s = r - e;
    return n * n + s * s;
  }
  function i$(t) {
    const e = t.length;
    for (let r = 0; r < e; r++) {
      let n = r, s = Math.abs(t[r][r]);
      for (let a = r + 1; a < e; a++) {
        const A = Math.abs(t[a][r]);
        A > s && (s = A, n = a);
      }
      if (s === 0)
        return null;
      const o = t[n];
      t[n] = t[r], t[r] = o;
      for (let a = r + 1; a < e; a++) {
        const A = -t[a][r] / t[r][r];
        for (let l = r; l < e + 1; l++)
          r == l ? t[a][l] = 0 : t[a][l] += A * t[r][l];
      }
    }
    const i = new Array(e);
    for (let r = e - 1; r >= 0; r--) {
      i[r] = t[r][e] / t[r][r];
      for (let n = r - 1; n >= 0; n--)
        t[n][e] -= t[n][r] * i[r];
    }
    return i;
  }
  function aD(t) {
    return t * 180 / Math.PI;
  }
  function BA(t) {
    return t * Math.PI / 180;
  }
  function pa(t, e) {
    const i = t % e;
    return i * e < 0 ? i + e : i;
  }
  function _n(t, e, i) {
    return t + i * (e - t);
  }
  function af(t, e) {
    const i = Math.pow(10, e);
    return Math.round(t * i) / i;
  }
  function AD(t, e) {
    return Math.round(af(t, e));
  }
  function cu(t, e) {
    return Math.floor(af(t, e));
  }
  function dA(t, e) {
    return Math.ceil(af(t, e));
  }
  function cb(t, e, i) {
    if (t >= e && t < i)
      return t;
    const r = i - e;
    return ((t - e) % r + r) % r + e;
  }
  function gv(t, e) {
    const i = ("" + t).split("."), r = ("" + e).split(".");
    for (let n = 0; n < Math.max(i.length, r.length); n++) {
      const s = parseInt(i[n] || "0", 10), o = parseInt(r[n] || "0", 10);
      if (s > o)
        return 1;
      if (o > s)
        return -1;
    }
    return 0;
  }
  function eU(t, e) {
    return t[0] += +e[0], t[1] += +e[1], t;
  }
  function r$(t, e) {
    const i = e.getRadius(), r = e.getCenter(), n = r[0], s = r[1], o = t[0], a = t[1];
    let A = o - n;
    const l = a - s;
    A === 0 && l === 0 && (A = 1);
    const c = Math.sqrt(A * A + l * l), u = n + i * A / c, d = s + i * l / c;
    return [u, d];
  }
  function fv(t, e) {
    const i = t[0], r = t[1], n = e[0], s = e[1], o = n[0], a = n[1], A = s[0], l = s[1], c = A - o, u = l - a, d = c === 0 && u === 0 ? 0 : (c * (i - o) + u * (r - a)) / (c * c + u * u || 0);
    let h, g;
    return d <= 0 ? (h = o, g = a) : d >= 1 ? (h = A, g = l) : (h = o + d * c, g = a + d * u), [h, g];
  }
  function Hr(t, e) {
    let i = !0;
    for (let r = t.length - 1; r >= 0; --r)
      if (t[r] != e[r]) {
        i = !1;
        break;
      }
    return i;
  }
  function pv(t, e) {
    const i = Math.cos(e), r = Math.sin(e), n = t[0] * i - t[1] * r, s = t[1] * i + t[0] * r;
    return t[0] = n, t[1] = s, t;
  }
  function tU(t, e) {
    return t[0] *= e, t[1] *= e, t;
  }
  function ma(t, e) {
    const i = t[0] - e[0], r = t[1] - e[1];
    return i * i + r * r;
  }
  function pE(t, e) {
    return Math.sqrt(ma(t, e));
  }
  function n$(t, e) {
    return ma(t, fv(t, e));
  }
  function mv(t, e) {
    if (e.canWrapX()) {
      const i = mt(e.getExtent()), r = iU(t, e, i);
      r && (t[0] -= r * i);
    }
    return t;
  }
  function iU(t, e, i) {
    const r = e.getExtent();
    let n = 0;
    return e.canWrapX() && (t[0] < r[0] || t[0] > r[2]) && (i = i || mt(r), n = Math.floor(
      (t[0] - r[0]) / i
    )), n;
  }
  const s$ = 63710088e-1;
  function lD(t, e, i) {
    i = i || s$;
    const r = BA(t[1]), n = BA(e[1]), s = (n - r) / 2, o = BA(e[0] - t[0]) / 2, a = Math.sin(s) * Math.sin(s) + Math.sin(o) * Math.sin(o) * Math.cos(r) * Math.cos(n);
    return 2 * i * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }
  const mE = 0.9996, as = 669438e-8, lB = as * as, cB = lB * as, fl = as / (1 - as), cD = Math.sqrt(1 - as), td = (1 - cD) / (1 + cD), rU = td * td, Ev = rU * td, yv = Ev * td, nU = yv * td, sU = 1 - as / 4 - 3 * lB / 64 - 5 * cB / 256, o$ = 3 * as / 8 + 3 * lB / 32 + 45 * cB / 1024, a$ = 15 * lB / 256 + 45 * cB / 1024, A$ = 35 * cB / 3072, l$ = 3 / 2 * td - 27 / 32 * Ev + 269 / 512 * nU, c$ = 21 / 16 * rU - 55 / 32 * yv, u$ = 151 / 96 * Ev - 417 / 128 * nU, d$ = 1097 / 512 * yv, EE = 6378137;
  function h$(t, e, i) {
    const r = t - 5e5, o = (i.north ? e : e - 1e7) / mE / (EE * sU), a = o + l$ * Math.sin(2 * o) + c$ * Math.sin(4 * o) + u$ * Math.sin(6 * o) + d$ * Math.sin(8 * o), A = Math.sin(a), l = A * A, c = Math.cos(a), u = A / c, d = u * u, h = d * d, g = 1 - as * l, f = Math.sqrt(1 - as * l), p = EE / f, m = (1 - as) / g, E = fl * c ** 2, y = E * E, C = r / (p * mE), w = C * C, M = w * C, I = M * C, b = I * C, B = b * C, x = a - u / m * (w / 2 - I / 24 * (5 + 3 * d + 10 * E - 4 * y - 9 * fl)) + B / 720 * (61 + 90 * d + 298 * E + 45 * h - 252 * fl - 3 * y);
    let Q = (C - M / 6 * (1 + 2 * d + E) + b / 120 * (5 - 2 * E + 28 * d - 3 * y + 8 * fl + 24 * h)) / c;
    return Q = cb(
      Q + BA(oU(i.number)),
      -Math.PI,
      Math.PI
    ), [aD(Q), aD(x)];
  }
  const uD = -80, dD = 84, g$ = -180, f$ = 180;
  function p$(t, e, i) {
    t = cb(t, g$, f$), e < uD ? e = uD : e > dD && (e = dD);
    const r = BA(e), n = Math.sin(r), s = Math.cos(r), o = n / s, a = o * o, A = a * a, l = BA(t), c = oU(i.number), u = BA(c), d = EE / Math.sqrt(1 - as * n ** 2), h = fl * s ** 2, g = s * cb(l - u, -Math.PI, Math.PI), f = g * g, p = f * g, m = p * g, E = m * g, y = E * g, C = EE * (sU * r - o$ * Math.sin(2 * r) + a$ * Math.sin(4 * r) - A$ * Math.sin(6 * r)), w = mE * d * (g + p / 6 * (1 - a + h) + E / 120 * (5 - 18 * a + A + 72 * h - 58 * fl)) + 5e5;
    let M = mE * (C + d * o * (f / 2 + m / 24 * (5 - a + 9 * h + 4 * h ** 2) + y / 720 * (61 - 58 * a + A + 600 * h - 330 * fl)));
    return i.north || (M += 1e7), [w, M];
  }
  function oU(t) {
    return (t - 1) * 6 - 180 + 3;
  }
  const m$ = [
    /^EPSG:(\d+)$/,
    /^urn:ogc:def:crs:EPSG::(\d+)$/,
    /^http:\/\/www\.opengis\.net\/def\/crs\/EPSG\/0\/(\d+)$/
  ];
  function aU(t) {
    let e = 0;
    for (const n of m$) {
      const s = t.match(n);
      if (s) {
        e = parseInt(s[1]);
        break;
      }
    }
    if (!e)
      return null;
    let i = 0, r = !1;
    return e > 32700 && e < 32761 ? i = e - 32700 : e > 32600 && e < 32661 && (r = !0, i = e - 32600), i ? { number: i, north: r } : null;
  }
  function hD(t, e) {
    return function(i, r, n, s) {
      const o = i.length;
      n = n > 1 ? n : 2, s = s ?? n, r || (n > 2 ? r = i.slice() : r = new Array(o));
      for (let a = 0; a < o; a += s) {
        const A = i[a], l = i[a + 1], c = t(A, l, e);
        r[a] = c[0], r[a + 1] = c[1];
      }
      return r;
    };
  }
  function E$(t) {
    return aU(t) ? new sf({ code: t, units: "m" }) : null;
  }
  function y$(t) {
    const e = aU(t.getCode());
    return e ? {
      forward: hD(p$, e),
      inverse: hD(h$, e)
    } : null;
  }
  function AU(...t) {
    console.warn(...t);
  }
  const B$ = [y$], w$ = [E$];
  let ub = !0;
  function lU(t) {
    ub = !1;
  }
  function Bv(t, e) {
    if (e !== void 0) {
      for (let i = 0, r = t.length; i < r; ++i)
        e[i] = t[i];
      e = e;
    } else
      e = t.slice();
    return e;
  }
  function Ag(t) {
    e$(t.getCode(), t), Pl(t, t, Bv);
  }
  function C$(t) {
    t.forEach(Ag);
  }
  function Xe(t) {
    if (typeof t != "string")
      return t;
    const e = im(t);
    if (e)
      return e;
    for (const i of w$) {
      const r = i(t);
      if (r)
        return r;
    }
    return null;
  }
  function lg(t, e, i, r) {
    t = Xe(t);
    let n;
    const s = t.getPointResolutionFunc();
    if (s) {
      if (n = s(e, i), r && r !== t.getUnits()) {
        const o = t.getMetersPerUnit();
        o && (n = n * o / Fa[r]);
      }
    } else {
      const o = t.getUnits();
      if (o == "degrees" && !r || r == "degrees")
        n = e;
      else {
        const a = Af(
          t,
          Xe("EPSG:4326")
        );
        if (!a && o !== "degrees")
          n = e * t.getMetersPerUnit();
        else {
          let l = [
            i[0] - e / 2,
            i[1],
            i[0] + e / 2,
            i[1],
            i[0],
            i[1] - e / 2,
            i[0],
            i[1] + e / 2
          ];
          l = a(l, l, 2);
          const c = lD(l.slice(0, 2), l.slice(2, 4)), u = lD(l.slice(4, 6), l.slice(6, 8));
          n = (c + u) / 2;
        }
        const A = r ? Fa[r] : t.getMetersPerUnit();
        A !== void 0 && (n /= A);
      }
    }
    return n;
  }
  function db(t) {
    C$(t), t.forEach(function(e) {
      t.forEach(function(i) {
        e !== i && Pl(e, i, Bv);
      });
    });
  }
  function b$(t, e, i, r) {
    t.forEach(function(n) {
      e.forEach(function(s) {
        Pl(n, s, i), Pl(s, n, r);
      });
    });
  }
  function wv(t, e) {
    return t ? typeof t == "string" ? Xe(t) : (
      /** @type {Projection} */
      t
    ) : Xe(e);
  }
  function hb(t) {
    return (
      /**
       * @param {Array<number>} input Input.
       * @param {Array<number>} [output] Output.
       * @param {number} [dimension] Dimensions that should be transformed.
       * @param {number} [stride] Stride.
       * @return {Array<number>} Output.
       */
      function(e, i, r, n) {
        const s = e.length;
        r = r !== void 0 ? r : 2, n = n ?? r, i = i !== void 0 ? i : new Array(s);
        for (let o = 0; o < s; o += n) {
          const a = t(e.slice(o, o + r)), A = a.length;
          for (let l = 0, c = n; l < c; ++l)
            i[o + l] = l >= A ? e[o + l] : a[l];
        }
        return i;
      }
    );
  }
  function M$(t, e, i, r) {
    const n = Xe(t), s = Xe(e);
    Pl(
      n,
      s,
      hb(i)
    ), Pl(
      s,
      n,
      hb(r)
    );
  }
  function yE(t, e) {
    return lU(), kd(
      t,
      "EPSG:4326",
      e !== void 0 ? e : "EPSG:3857"
    );
  }
  function I$(t, e) {
    const i = kd(
      t,
      e,
      "EPSG:4326"
    ), r = i[0];
    return (r < -180 || r > 180) && (i[0] = pa(r + 180, 360) - 180), i;
  }
  function Fo(t, e) {
    if (t === e)
      return !0;
    const i = t.getUnits() === e.getUnits();
    return (t.getCode() === e.getCode() || Af(t, e) === Bv) && i;
  }
  function Af(t, e) {
    const i = t.getCode(), r = e.getCode();
    let n = rm(i, r);
    if (n)
      return n;
    let s = null, o = null;
    for (const A of B$)
      s || (s = A(t)), o || (o = A(e));
    if (!s && !o)
      return null;
    const a = "EPSG:4326";
    if (o)
      if (s)
        n = m0(
          s.inverse,
          o.forward
        );
      else {
        const A = rm(i, a);
        A && (n = m0(
          A,
          o.forward
        ));
      }
    else {
      const A = rm(a, r);
      A && (n = m0(
        s.inverse,
        A
      ));
    }
    return n && (Ag(t), Ag(e), Pl(t, e, n)), n;
  }
  function m0(t, e) {
    return function(i, r, n, s) {
      return r = t(i, r, n, s), e(r, r, n, s);
    };
  }
  function id(t, e) {
    const i = Xe(t), r = Xe(e);
    return Af(i, r);
  }
  function kd(t, e, i) {
    const r = id(e, i);
    if (!r) {
      const n = Xe(e).getCode(), s = Xe(i).getCode();
      throw new Error(
        `No transform available between ${n} and ${s}`
      );
    }
    return r(t, void 0, t.length);
  }
  function cU(t, e, i, r) {
    const n = id(e, i);
    return qN(t, n, void 0);
  }
  let v$ = null;
  function x$() {
    return v$;
  }
  function QA(t, e) {
    return t;
  }
  function di(t, e) {
    return ub && !Hr(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 && (ub = !1, AU(
      "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
    )), t;
  }
  function lf(t, e) {
    return t;
  }
  function is(t, e) {
    return t;
  }
  function gD(t, e, i) {
    return function(r) {
      let n, s;
      if (t.canWrapX()) {
        const o = t.getExtent(), a = mt(o);
        r = r.slice(0), s = iU(r, t, a), s && (r[0] = r[0] - s * a), r[0] = yi(r[0], o[0], o[2]), r[1] = yi(r[1], o[1], o[3]), n = i(r);
      } else
        n = i(r);
      return s && e.canWrapX() && (n[0] += s * mt(e.getExtent())), n;
    };
  }
  function Q$() {
    db(nD), db(oD), b$(
      oD,
      nD,
      Xq,
      Zq
    );
  }
  Q$();
  function So(t, e, i, r, n, s, o) {
    s = s || [], o = o || 2;
    let a = 0;
    for (let A = e; A < i; A += r) {
      const l = t[A], c = t[A + 1];
      s[a++] = n[0] * l + n[2] * c + n[4], s[a++] = n[1] * l + n[3] * c + n[5];
      for (let u = 2; u < o; u++)
        s[a++] = t[A + u];
    }
    return s && s.length != a && (s.length = a), s;
  }
  function Cv(t, e, i, r, n, s, o) {
    o = o || [];
    const a = Math.cos(n), A = Math.sin(n), l = s[0], c = s[1];
    let u = 0;
    for (let d = e; d < i; d += r) {
      const h = t[d] - l, g = t[d + 1] - c;
      o[u++] = l + h * a - g * A, o[u++] = c + h * A + g * a;
      for (let f = d + 2; f < d + r; ++f)
        o[u++] = t[f];
    }
    return o && o.length != u && (o.length = u), o;
  }
  function F$(t, e, i, r, n, s, o, a) {
    a = a || [];
    const A = o[0], l = o[1];
    let c = 0;
    for (let u = e; u < i; u += r) {
      const d = t[u] - A, h = t[u + 1] - l;
      a[c++] = A + n * d, a[c++] = l + s * h;
      for (let g = u + 2; g < u + r; ++g)
        a[c++] = t[g];
    }
    return a && a.length != c && (a.length = c), a;
  }
  function S$(t, e, i, r, n, s, o) {
    o = o || [];
    let a = 0;
    for (let A = e; A < i; A += r) {
      o[a++] = t[A] + n, o[a++] = t[A + 1] + s;
      for (let l = A + 2; l < A + r; ++l)
        o[a++] = t[l];
    }
    return o && o.length != a && (o.length = a), o;
  }
  const fD = ri();
  class bv extends no {
    constructor() {
      super(), this.extent_ = yr(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = KN(
        (e, i, r) => {
          if (!r)
            return this.getSimplifiedGeometry(i);
          const n = this.clone();
          return n.applyTransform(r), n.getSimplifiedGeometry(i);
        }
      );
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    simplifyTransformed(e, i) {
      return this.simplifyTransformedInternal(
        this.getRevision(),
        e,
        i
      );
    }
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */
    clone() {
      return it();
    }
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(e, i, r, n) {
      return it();
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(e, i) {
      const r = this.getClosestPoint([e, i]);
      return r[0] === e && r[1] === i;
    }
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */
    getClosestPoint(e, i) {
      return i = i || [NaN, NaN], this.closestPointXY(e[0], e[1], i, 1 / 0), i;
    }
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */
    intersectsCoordinate(e) {
      return this.containsXY(e[0], e[1]);
    }
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    computeExtent(e) {
      return it();
    }
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */
    getExtent(e) {
      if (this.extentRevision_ != this.getRevision()) {
        const i = this.computeExtent(this.extent_);
        (isNaN(i[0]) || isNaN(i[1])) && _d(i), this.extentRevision_ = this.getRevision();
      }
      return Jq(this.extent_, e);
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    rotate(e, i) {
      it();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    scale(e, i, r) {
      it();
    }
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */
    simplify(e) {
      return this.getSimplifiedGeometry(e * e);
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */
    getSimplifiedGeometry(e) {
      return it();
    }
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {Type} Geometry type.
     */
    getType() {
      return it();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */
    applyTransform(e) {
      it();
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */
    intersectsExtent(e) {
      return it();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    translate(e, i) {
      it();
    }
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {this} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */
    transform(e, i) {
      const r = Xe(e), n = r.getUnits() == "tile-pixels" ? function(s, o, a) {
        const A = r.getExtent(), l = r.getWorldExtent(), c = Fi(l) / Fi(A);
        gs(
          fD,
          l[0],
          l[3],
          c,
          -c,
          0,
          0,
          0
        );
        const u = So(
          s,
          0,
          s.length,
          a,
          fD,
          o
        ), d = id(r, i);
        return d ? d(u, u, a) : u;
      } : id(r, i);
      return this.applyTransform(n), this;
    }
  }
  class jA extends bv {
    constructor() {
      super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(e) {
      return cv(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        e
      );
    }
    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */
    getCoordinates() {
      return it();
    }
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */
    getFirstCoordinate() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getFlatCoordinates() {
      return this.flatCoordinates;
    }
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */
    getLastCoordinate() {
      return this.flatCoordinates.slice(
        this.flatCoordinates.length - this.stride
      );
    }
    /**
     * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
     * @return {import("./Geometry.js").GeometryLayout} Layout.
     * @api
     */
    getLayout() {
      return this.layout;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @override
     */
    getSimplifiedGeometry(e) {
      if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
        return this;
      const i = this.getSimplifiedGeometryInternal(e);
      return i.getFlatCoordinates().length < this.flatCoordinates.length ? i : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */
    getSimplifiedGeometryInternal(e) {
      return this;
    }
    /**
     * @return {number} Stride.
     */
    getStride() {
      return this.stride;
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */
    setFlatCoordinates(e, i) {
      this.stride = BE(e), this.layout = e, this.flatCoordinates = i;
    }
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    setCoordinates(e, i) {
      it();
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */
    setLayout(e, i, r) {
      let n;
      if (e)
        n = BE(e);
      else {
        for (let s = 0; s < r; ++s) {
          if (i.length === 0) {
            this.layout = "XY", this.stride = 2;
            return;
          }
          i = /** @type {Array<unknown>} */
          i[0];
        }
        n = i.length, e = ac(n);
      }
      this.layout = e, this.stride = n;
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     * @override
     */
    applyTransform(e) {
      this.flatCoordinates && (e(
        this.flatCoordinates,
        this.flatCoordinates,
        this.layout.startsWith("XYZ") ? 3 : 2,
        this.stride
      ), this.changed());
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(e, i) {
      const r = this.getFlatCoordinates();
      if (r) {
        const n = this.getStride();
        Cv(
          r,
          0,
          r.length,
          n,
          e,
          i,
          r
        ), this.changed();
      }
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     * @override
     */
    scale(e, i, r) {
      i === void 0 && (i = e), r || (r = xn(this.getExtent()));
      const n = this.getFlatCoordinates();
      if (n) {
        const s = this.getStride();
        F$(
          n,
          0,
          n.length,
          s,
          e,
          i,
          r,
          n
        ), this.changed();
      }
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     * @override
     */
    translate(e, i) {
      const r = this.getFlatCoordinates();
      if (r) {
        const n = this.getStride();
        S$(
          r,
          0,
          r.length,
          n,
          e,
          i,
          r
        ), this.changed();
      }
    }
  }
  function ac(t) {
    let e;
    return t == 2 ? e = "XY" : t == 3 ? e = "XYZ" : t == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
    e;
  }
  function BE(t) {
    let e;
    return t == "XY" ? e = 2 : t == "XYZ" || t == "XYM" ? e = 3 : t == "XYZM" && (e = 4), /** @type {number} */
    e;
  }
  function D$(t, e, i) {
    const r = t.getFlatCoordinates();
    if (!r)
      return null;
    const n = t.getStride();
    return So(
      r,
      0,
      r.length,
      n,
      e,
      i
    );
  }
  function pD(t, e, i, r, n, s, o) {
    const a = t[e], A = t[e + 1], l = t[i] - a, c = t[i + 1] - A;
    let u;
    if (l === 0 && c === 0)
      u = e;
    else {
      const d = ((n - a) * l + (s - A) * c) / (l * l + c * c);
      if (d > 1)
        u = i;
      else if (d > 0) {
        for (let h = 0; h < r; ++h)
          o[h] = _n(
            t[e + h],
            t[i + h],
            d
          );
        o.length = r;
        return;
      } else
        u = e;
    }
    for (let d = 0; d < r; ++d)
      o[d] = t[u + d];
    o.length = r;
  }
  function Mv(t, e, i, r, n) {
    let s = t[e], o = t[e + 1];
    for (e += r; e < i; e += r) {
      const a = t[e], A = t[e + 1], l = fa(s, o, a, A);
      l > n && (n = l), s = a, o = A;
    }
    return n;
  }
  function Iv(t, e, i, r, n) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s];
      n = Mv(t, e, a, r, n), e = a;
    }
    return n;
  }
  function T$(t, e, i, r, n) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s];
      n = Iv(t, e, a, r, n), e = a[a.length - 1];
    }
    return n;
  }
  function vv(t, e, i, r, n, s, o, a, A, l, c) {
    if (e == i)
      return l;
    let u, d;
    if (n === 0) {
      if (d = fa(
        o,
        a,
        t[e],
        t[e + 1]
      ), d < l) {
        for (u = 0; u < r; ++u)
          A[u] = t[e + u];
        return A.length = r, d;
      }
      return l;
    }
    c = c || [NaN, NaN];
    let h = e + r;
    for (; h < i; )
      if (pD(
        t,
        h - r,
        h,
        r,
        o,
        a,
        c
      ), d = fa(o, a, c[0], c[1]), d < l) {
        for (l = d, u = 0; u < r; ++u)
          A[u] = c[u];
        A.length = r, h += r;
      } else
        h += r * Math.max(
          (Math.sqrt(d) - Math.sqrt(l)) / n | 0,
          1
        );
    if (s && (pD(
      t,
      i - r,
      e,
      r,
      o,
      a,
      c
    ), d = fa(o, a, c[0], c[1]), d < l)) {
      for (l = d, u = 0; u < r; ++u)
        A[u] = c[u];
      A.length = r;
    }
    return l;
  }
  function xv(t, e, i, r, n, s, o, a, A, l, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = i.length; u < d; ++u) {
      const h = i[u];
      l = vv(
        t,
        e,
        h,
        r,
        n,
        s,
        o,
        a,
        A,
        l,
        c
      ), e = h;
    }
    return l;
  }
  function R$(t, e, i, r, n, s, o, a, A, l, c) {
    c = c || [NaN, NaN];
    for (let u = 0, d = i.length; u < d; ++u) {
      const h = i[u];
      l = xv(
        t,
        e,
        h,
        r,
        n,
        s,
        o,
        a,
        A,
        l,
        c
      ), e = h[h.length - 1];
    }
    return l;
  }
  function uU(t, e, i, r) {
    for (let n = 0, s = i.length; n < s; ++n)
      t[e++] = i[n];
    return e;
  }
  function uB(t, e, i, r) {
    for (let n = 0, s = i.length; n < s; ++n) {
      const o = i[n];
      for (let a = 0; a < r; ++a)
        t[e++] = o[a];
    }
    return e;
  }
  function cf(t, e, i, r, n) {
    n = n || [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const A = uB(
        t,
        e,
        i[o],
        r
      );
      n[s++] = A, e = A;
    }
    return n.length = s, n;
  }
  function dU(t, e, i, r, n) {
    n = n || [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const A = cf(
        t,
        e,
        i[o],
        r,
        n[s]
      );
      A.length === 0 && (A[0] = e), n[s++] = A, e = A[A.length - 1];
    }
    return n.length = s, n;
  }
  function dB(t, e, i, r, n, s, o) {
    const a = (i - e) / r;
    if (a < 3) {
      for (; e < i; e += r)
        s[o++] = t[e], s[o++] = t[e + 1];
      return o;
    }
    const A = new Array(a);
    A[0] = 1, A[a - 1] = 1;
    const l = [e, i - r];
    let c = 0;
    for (; l.length > 0; ) {
      const u = l.pop(), d = l.pop();
      let h = 0;
      const g = t[d], f = t[d + 1], p = t[u], m = t[u + 1];
      for (let E = d + r; E < u; E += r) {
        const y = t[E], C = t[E + 1], w = t$(y, C, g, f, p, m);
        w > h && (c = E, h = w);
      }
      h > n && (A[(c - e) / r] = 1, d + r < c && l.push(d, c), c + r < u && l.push(c, u));
    }
    for (let u = 0; u < a; ++u)
      A[u] && (s[o++] = t[e + u * r], s[o++] = t[e + u * r + 1]);
    return o;
  }
  function hU(t, e, i, r, n, s, o, a) {
    for (let A = 0, l = i.length; A < l; ++A) {
      const c = i[A];
      o = dB(
        t,
        e,
        c,
        r,
        n,
        s,
        o
      ), a.push(o), e = c;
    }
    return o;
  }
  function al(t, e) {
    return e * Math.round(t / e);
  }
  function _$(t, e, i, r, n, s, o) {
    if (e == i)
      return o;
    let a = al(t[e], n), A = al(t[e + 1], n);
    e += r, s[o++] = a, s[o++] = A;
    let l, c;
    do
      if (l = al(t[e], n), c = al(t[e + 1], n), e += r, e == i)
        return s[o++] = l, s[o++] = c, o;
    while (l == a && c == A);
    for (; e < i; ) {
      const u = al(t[e], n), d = al(t[e + 1], n);
      if (e += r, u == l && d == c)
        continue;
      const h = l - a, g = c - A, f = u - a, p = d - A;
      if (h * p == g * f && (h < 0 && f < h || h == f || h > 0 && f > h) && (g < 0 && p < g || g == p || g > 0 && p > g)) {
        l = u, c = d;
        continue;
      }
      s[o++] = l, s[o++] = c, a = l, A = c, l = u, c = d;
    }
    return s[o++] = l, s[o++] = c, o;
  }
  function Qv(t, e, i, r, n, s, o, a) {
    for (let A = 0, l = i.length; A < l; ++A) {
      const c = i[A];
      o = _$(
        t,
        e,
        c,
        r,
        n,
        s,
        o
      ), a.push(o), e = c;
    }
    return o;
  }
  function k$(t, e, i, r, n, s, o, a) {
    for (let A = 0, l = i.length; A < l; ++A) {
      const c = i[A], u = [];
      o = Qv(
        t,
        e,
        c,
        r,
        n,
        s,
        o,
        u
      ), a.push(u), e = c[c.length - 1];
    }
    return o;
  }
  function hA(t, e, i, r, n) {
    n = n !== void 0 ? n : [];
    let s = 0;
    for (let o = e; o < i; o += r)
      n[s++] = t.slice(o, o + r);
    return n.length = s, n;
  }
  function cg(t, e, i, r, n) {
    n = n !== void 0 ? n : [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const A = i[o];
      n[s++] = hA(
        t,
        e,
        A,
        r,
        n[s]
      ), e = A;
    }
    return n.length = s, n;
  }
  function gb(t, e, i, r, n) {
    n = n !== void 0 ? n : [];
    let s = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const A = i[o];
      n[s++] = A.length === 1 && A[0] === e ? [] : cg(
        t,
        e,
        A,
        r,
        n[s]
      ), e = A[A.length - 1];
    }
    return n.length = s, n;
  }
  function gU(t, e, i, r) {
    let n = 0;
    const s = t[i - r], o = t[i - r + 1];
    let a = 0, A = 0;
    for (; e < i; e += r) {
      const l = t[e] - s, c = t[e + 1] - o;
      n += A * l - a * c, a = l, A = c;
    }
    return n / 2;
  }
  function fU(t, e, i, r) {
    let n = 0;
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s];
      n += gU(t, e, a, r), e = a;
    }
    return n;
  }
  function Y$(t, e, i, r) {
    let n = 0;
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s];
      n += fU(t, e, a, r), e = a[a.length - 1];
    }
    return n;
  }
  class rd extends jA {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(e, i) {
      super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, i !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
        i,
        /** @type {Array<number>} */
        e
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        e,
        i
      );
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     * @override
     */
    clone() {
      return new rd(this.flatCoordinates.slice(), this.layout);
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      return n < oc(this.getExtent(), e, i) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Mv(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), vv(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        !0,
        e,
        i,
        r,
        n
      ));
    }
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return gU(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return hA(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(e) {
      const i = [];
      return i.length = dB(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        e,
        i,
        0
      ), new rd(i, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "LinearRing";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      return !1;
    }
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(e, i) {
      this.setLayout(i, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = uB(
        this.flatCoordinates,
        0,
        e,
        this.stride
      ), this.changed();
    }
  }
  let Cn = class pU extends jA {
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(e, i) {
      super(), this.setCoordinates(e, i);
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     * @override
     */
    clone() {
      const e = new pU(this.flatCoordinates.slice(), this.layout);
      return e.applyProperties(this), e;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      const s = this.flatCoordinates, o = fa(
        e,
        i,
        s[0],
        s[1]
      );
      if (o < n) {
        const a = this.stride;
        for (let A = 0; A < a; ++A)
          r[A] = s[A];
        return r.length = a, o;
      }
      return n;
    }
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return this.flatCoordinates.slice();
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(e) {
      return Qu(this.flatCoordinates, e);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Point";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      return lv(e, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(e, i) {
      this.setLayout(i, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = uU(
        this.flatCoordinates,
        0,
        e,
        this.stride
      ), this.changed();
    }
  };
  function N$(t, e, i, r, n) {
    return !dv(
      n,
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */
      function(o) {
        return !pl(
          t,
          e,
          i,
          r,
          o[0],
          o[1]
        );
      }
    );
  }
  function pl(t, e, i, r, n, s) {
    let o = 0, a = t[i - r], A = t[i - r + 1];
    for (; e < i; e += r) {
      const l = t[e], c = t[e + 1];
      A <= s ? c > s && (l - a) * (s - A) - (n - a) * (c - A) > 0 && o++ : c <= s && (l - a) * (s - A) - (n - a) * (c - A) < 0 && o--, a = l, A = c;
    }
    return o !== 0;
  }
  function Fv(t, e, i, r, n, s) {
    if (i.length === 0 || !pl(t, e, i[0], r, n, s))
      return !1;
    for (let o = 1, a = i.length; o < a; ++o)
      if (pl(t, i[o - 1], i[o], r, n, s))
        return !1;
    return !0;
  }
  function U$(t, e, i, r, n, s) {
    if (i.length === 0)
      return !1;
    for (let o = 0, a = i.length; o < a; ++o) {
      const A = i[o];
      if (Fv(t, e, A, r, n, s))
        return !0;
      e = A[A.length - 1];
    }
    return !1;
  }
  function Sv(t, e, i, r, n, s, o) {
    let a, A, l, c, u, d, h;
    const g = n[s + 1], f = [];
    for (let E = 0, y = i.length; E < y; ++E) {
      const C = i[E];
      for (c = t[C - r], d = t[C - r + 1], a = e; a < C; a += r)
        u = t[a], h = t[a + 1], (g <= d && h <= g || d <= g && g <= h) && (l = (g - d) / (h - d) * (u - c) + c, f.push(l)), c = u, d = h;
    }
    let p = NaN, m = -1 / 0;
    for (f.sort(Qo), c = f[0], a = 1, A = f.length; a < A; ++a) {
      u = f[a];
      const E = Math.abs(u - c);
      E > m && (l = (c + u) / 2, Fv(t, e, i, r, l, g) && (p = l, m = E)), c = u;
    }
    return isNaN(p) && (p = n[s]), o ? (o.push(p, g, m), o) : [p, g, m];
  }
  function mU(t, e, i, r, n) {
    let s = [];
    for (let o = 0, a = i.length; o < a; ++o) {
      const A = i[o];
      s = Sv(
        t,
        e,
        A,
        r,
        n,
        2 * o,
        s
      ), e = A[A.length - 1];
    }
    return s;
  }
  function EU(t, e, i, r, n) {
    let s;
    for (e += r; e < i; e += r)
      if (s = n(
        t.slice(e - r, e),
        t.slice(e, e + r)
      ), s)
        return s;
    return !1;
  }
  function hB(t, e, i, r, n) {
    const s = ZN(
      yr(),
      t,
      e,
      i,
      r
    );
    return Yi(n, s) ? ts(n, s) || s[0] >= n[0] && s[2] <= n[2] || s[1] >= n[1] && s[3] <= n[3] ? !0 : EU(
      t,
      e,
      i,
      r,
      /**
       * @param {import("../../coordinate.js").Coordinate} point1 Start point.
       * @param {import("../../coordinate.js").Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */
      function(o, a) {
        return Vq(n, o, a);
      }
    ) : !1;
  }
  function L$(t, e, i, r, n) {
    for (let s = 0, o = i.length; s < o; ++s) {
      if (hB(t, e, i[s], r, n))
        return !0;
      e = i[s];
    }
    return !1;
  }
  function yU(t, e, i, r, n) {
    return !!(hB(t, e, i, r, n) || pl(
      t,
      e,
      i,
      r,
      n[0],
      n[1]
    ) || pl(
      t,
      e,
      i,
      r,
      n[0],
      n[3]
    ) || pl(
      t,
      e,
      i,
      r,
      n[2],
      n[1]
    ) || pl(
      t,
      e,
      i,
      r,
      n[2],
      n[3]
    ));
  }
  function BU(t, e, i, r, n) {
    if (!yU(t, e, i[0], r, n))
      return !1;
    if (i.length === 1)
      return !0;
    for (let s = 1, o = i.length; s < o; ++s)
      if (N$(
        t,
        i[s - 1],
        i[s],
        r,
        n
      ) && !hB(
        t,
        i[s - 1],
        i[s],
        r,
        n
      ))
        return !1;
    return !0;
  }
  function z$(t, e, i, r, n) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s];
      if (BU(t, e, a, r, n))
        return !0;
      e = a[a.length - 1];
    }
    return !1;
  }
  function P$(t, e, i, r) {
    for (; e < i - r; ) {
      for (let n = 0; n < r; ++n) {
        const s = t[e + n];
        t[e + n] = t[i - r + n], t[i - r + n] = s;
      }
      e += r, i -= r;
    }
  }
  function Dv(t, e, i, r) {
    let n = 0, s = t[i - r], o = t[i - r + 1];
    for (; e < i; e += r) {
      const a = t[e], A = t[e + 1];
      n += (a - s) * (A + o), s = a, o = A;
    }
    return n === 0 ? void 0 : n > 0;
  }
  function Tv(t, e, i, r, n) {
    n = n !== void 0 ? n : !1;
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s], A = Dv(
        t,
        e,
        a,
        r
      );
      if (s === 0) {
        if (n && A || !n && !A)
          return !1;
      } else if (n && !A || !n && A)
        return !1;
      e = a;
    }
    return !0;
  }
  function wU(t, e, i, r, n) {
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s];
      if (!Tv(t, e, a, r, n))
        return !1;
      a.length && (e = a[a.length - 1]);
    }
    return !0;
  }
  function wE(t, e, i, r, n) {
    n = n !== void 0 ? n : !1;
    for (let s = 0, o = i.length; s < o; ++s) {
      const a = i[s], A = Dv(
        t,
        e,
        a,
        r
      );
      (s === 0 ? n && A || !n && !A : n && !A || !n && A) && P$(t, e, a, r), e = a;
    }
    return e;
  }
  function fb(t, e, i, r, n) {
    for (let s = 0, o = i.length; s < o; ++s)
      e = wE(
        t,
        e,
        i[s],
        r,
        n
      );
    return e;
  }
  function Rv(t, e) {
    const i = [];
    let r = 0, n = 0, s;
    for (let o = 0, a = e.length; o < a; ++o) {
      const A = e[o], l = Dv(t, r, A, 2);
      if (s === void 0 && (s = l), l === s)
        i.push(e.slice(n, o + 1));
      else {
        if (i.length === 0)
          continue;
        i[i.length - 1].push(e[n]);
      }
      n = o + 1, r = A;
    }
    return i;
  }
  class en extends jA {
    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
     */
    constructor(e, i, r) {
      super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, i !== void 0 && r ? (this.setFlatCoordinates(
        i,
        /** @type {Array<number>} */
        e
      ), this.ends_ = r) : this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        i
      );
    }
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */
    appendLinearRing(e) {
      this.flatCoordinates ? xr(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     * @override
     */
    clone() {
      const e = new en(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return e.applyProperties(this), e;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      return n < oc(this.getExtent(), e, i) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Iv(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), xv(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        !0,
        e,
        i,
        r,
        n
      ));
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(e, i) {
      return Fv(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        i
      );
    }
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return fU(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates(e) {
      let i;
      return e !== void 0 ? (i = this.getOrientedFlatCoordinates().slice(), wE(i, 0, this.ends_, this.stride, e)) : i = this.flatCoordinates, cg(i, 0, this.ends_, this.stride);
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * @return {Array<number>} Interior point.
     */
    getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        const e = xn(this.getExtent());
        this.flatInteriorPoint_ = Sv(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          e,
          0
        ), this.flatInteriorPointRevision_ = this.getRevision();
      }
      return (
        /** @type {import("../coordinate.js").Coordinate} */
        this.flatInteriorPoint_
      );
    }
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoint() {
      return new Cn(this.getFlatInteriorPoint(), "XYM");
    }
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */
    getLinearRingCount() {
      return this.ends_.length;
    }
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */
    getLinearRing(e) {
      return e < 0 || this.ends_.length <= e ? null : new rd(
        this.flatCoordinates.slice(
          e === 0 ? 0 : this.ends_[e - 1],
          this.ends_[e]
        ),
        this.layout
      );
    }
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */
    getLinearRings() {
      const e = this.layout, i = this.flatCoordinates, r = this.ends_, n = [];
      let s = 0;
      for (let o = 0, a = r.length; o < a; ++o) {
        const A = r[o], l = new rd(
          i.slice(s, A),
          e
        );
        n.push(l), s = A;
      }
      return n;
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const e = this.flatCoordinates;
        Tv(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = wE(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        )), this.orientedRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.orientedFlatCoordinates_
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(e) {
      const i = [], r = [];
      return i.length = Qv(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        Math.sqrt(e),
        i,
        0,
        r
      ), new en(i, "XY", r);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Polygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      return BU(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e
      );
    }
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(e, i) {
      this.setLayout(i, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
      const r = cf(
        this.flatCoordinates,
        0,
        e,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1], this.changed();
    }
  }
  function mD(t) {
    if (GA(t))
      throw new Error("Cannot create polygon from empty extent");
    const e = t[0], i = t[1], r = t[2], n = t[3], s = [
      e,
      i,
      e,
      n,
      r,
      n,
      r,
      i,
      e,
      i
    ];
    return new en(s, "XY", [s.length]);
  }
  function nm(t, e, i) {
    e = e || 32;
    const r = t.getStride(), n = t.getLayout(), s = t.getCenter(), o = r * (e + 1), a = new Array(o);
    for (let c = 0; c < o; c += r) {
      a[c] = 0, a[c + 1] = 0;
      for (let u = 2; u < r; u++)
        a[c + u] = s[u];
    }
    const A = [a.length], l = new en(a, n, A);
    return O$(l, s, t.getRadius(), i), l;
  }
  function O$(t, e, i, r) {
    const n = t.getFlatCoordinates(), s = t.getStride(), o = n.length / s - 1, a = r || 0;
    for (let A = 0; A <= o; ++A) {
      const l = A * s, c = a + pa(A, o) * 2 * Math.PI / o;
      n[l] = e[0] + i * Math.cos(c), n[l + 1] = e[1] + i * Math.sin(c);
    }
    t.changed();
  }
  const dr = {
    /**
     * Triggered before a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#prerender
     * @api
     */
    PRERENDER: "prerender",
    /**
     * Triggered after a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered before layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    PRECOMPOSE: "precompose",
    /**
     * Triggered after layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#postcompose
     * @api
     */
    POSTCOMPOSE: "postcompose",
    /**
     * Triggered when rendering is complete, i.e. all sources and tiles have
     * finished loading for the current viewport, and all tiles are faded in.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#rendercomplete
     * @api
     */
    RENDERCOMPLETE: "rendercomplete"
  }, ze = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
  }, ug = {
    name: "rgb",
    min: [0, 0, 0],
    max: [255, 255, 255],
    channel: ["red", "green", "blue"],
    alias: ["RGB"]
  }, Yr = {
    name: "xyz",
    min: [0, 0, 0],
    channel: ["X", "Y", "Z"],
    alias: ["XYZ", "ciexyz", "cie1931"],
    // Whitepoint reference values with observer/illuminant
    // http://en.wikipedia.org/wiki/Standard_illuminant
    whitepoint: {
      //1931 2°
      2: {
        //incadescent
        A: [109.85, 100, 35.585],
        // B:[],
        C: [98.074, 100, 118.232],
        D50: [96.422, 100, 82.521],
        D55: [95.682, 100, 92.149],
        //daylight
        D65: [95.045592705167, 100, 108.9057750759878],
        D75: [94.972, 100, 122.638],
        //flourescent
        // F1: [],
        F2: [99.187, 100, 67.395],
        // F3: [],
        // F4: [],
        // F5: [],
        // F6:[],
        F7: [95.044, 100, 108.755],
        // F8: [],
        // F9: [],
        // F10: [],
        F11: [100.966, 100, 64.37],
        // F12: [],
        E: [100, 100, 100]
      },
      //1964  10°
      10: {
        //incadescent
        A: [111.144, 100, 35.2],
        C: [97.285, 100, 116.145],
        D50: [96.72, 100, 81.427],
        D55: [95.799, 100, 90.926],
        //daylight
        D65: [94.811, 100, 107.304],
        D75: [94.416, 100, 120.641],
        //flourescent
        F2: [103.28, 100, 69.026],
        F7: [95.792, 100, 107.687],
        F11: [103.866, 100, 65.627],
        E: [100, 100, 100]
      }
    }
  };
  Yr.max = Yr.whitepoint[2].D65;
  Yr.rgb = function(t, e) {
    e = e || Yr.whitepoint[2].E;
    var i = t[0] / e[0], r = t[1] / e[1], n = t[2] / e[2], s, o, a;
    return s = i * 3.240969941904521 + r * -1.537383177570093 + n * -0.498610760293, o = i * -0.96924363628087 + r * 1.87596750150772 + n * 0.041555057407175, a = i * 0.055630079696993 + r * -0.20397695888897 + n * 1.056971514242878, s = s > 31308e-7 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s = s * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, s = Math.min(Math.max(0, s), 1), o = Math.min(Math.max(0, o), 1), a = Math.min(Math.max(0, a), 1), [s * 255, o * 255, a * 255];
  };
  ug.xyz = function(t, e) {
    var i = t[0] / 255, r = t[1] / 255, n = t[2] / 255;
    i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
    var s = i * 0.41239079926595 + r * 0.35758433938387 + n * 0.18048078840183, o = i * 0.21263900587151 + r * 0.71516867876775 + n * 0.072192315360733, a = i * 0.019330818715591 + r * 0.11919477979462 + n * 0.95053215224966;
    return e = e || Yr.whitepoint[2].E, [s * e[0], o * e[1], a * e[2]];
  };
  var _v = {
    name: "luv",
    //NOTE: luv has no rigidly defined limits
    //easyrgb fails to get proper coords
    //boronine states no rigid limits
    //colorMine refers this ones:
    min: [0, -134, -140],
    max: [100, 224, 122],
    channel: ["lightness", "u", "v"],
    alias: ["LUV", "cieluv", "cie1976"],
    xyz: function(t, e, i) {
      var r, n, s, o, a, A, l, c, u, d, h, g, f;
      if (s = t[0], o = t[1], a = t[2], s === 0) return [0, 0, 0];
      var p = 0.0011070564598794539;
      return e = e || "D65", i = i || 2, u = Yr.whitepoint[i][e][0], d = Yr.whitepoint[i][e][1], h = Yr.whitepoint[i][e][2], g = 4 * u / (u + 15 * d + 3 * h), f = 9 * d / (u + 15 * d + 3 * h), r = o / (13 * s) + g || 0, n = a / (13 * s) + f || 0, l = s > 8 ? d * Math.pow((s + 16) / 116, 3) : d * s * p, A = l * 9 * r / (4 * n) || 0, c = l * (12 - 3 * r - 20 * n) / (4 * n) || 0, [A, l, c];
    }
  };
  Yr.luv = function(t, e, i) {
    var r, n, s, o, a, A, l, c, u, d, h, g, f, p = 0.008856451679035631, m = 903.2962962962961;
    e = e || "D65", i = i || 2, u = Yr.whitepoint[i][e][0], d = Yr.whitepoint[i][e][1], h = Yr.whitepoint[i][e][2], g = 4 * u / (u + 15 * d + 3 * h), f = 9 * d / (u + 15 * d + 3 * h), A = t[0], l = t[1], c = t[2], r = 4 * A / (A + 15 * l + 3 * c) || 0, n = 9 * l / (A + 15 * l + 3 * c) || 0;
    var E = l / d;
    return s = E <= p ? m * E : 116 * Math.pow(E, 1 / 3) - 16, o = 13 * s * (r - g), a = 13 * s * (n - f), [s, o, a];
  };
  var CU = {
    name: "lchuv",
    channel: ["lightness", "chroma", "hue"],
    alias: ["LCHuv", "cielchuv"],
    min: [0, 0, 0],
    max: [100, 100, 360],
    luv: function(t) {
      var e = t[0], i = t[1], r = t[2], n, s, o;
      return o = r / 360 * 2 * Math.PI, n = i * Math.cos(o), s = i * Math.sin(o), [e, n, s];
    },
    xyz: function(t) {
      return _v.xyz(CU.luv(t));
    }
  };
  _v.lchuv = function(t) {
    var e = t[0], i = t[1], r = t[2], n = Math.sqrt(i * i + r * r), s = Math.atan2(r, i), o = s * 360 / 2 / Math.PI;
    return o < 0 && (o += 360), [e, n, o];
  };
  Yr.lchuv = function(t) {
    return _v.lchuv(Yr.luv(t));
  };
  const ED = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var yD = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
  };
  function G$(t) {
    var c, u;
    var e, i = [], r = 1, n;
    if (typeof t == "number")
      return { space: "rgb", values: [t >>> 16, (t & 65280) >>> 8, t & 255], alpha: 1 };
    if (typeof t == "number") return { space: "rgb", values: [t >>> 16, (t & 65280) >>> 8, t & 255], alpha: 1 };
    if (t = String(t).toLowerCase(), ED[t])
      i = ED[t].slice(), n = "rgb";
    else if (t === "transparent")
      r = 0, n = "rgb", i = [0, 0, 0];
    else if (t[0] === "#") {
      var s = t.slice(1), o = s.length, a = o <= 4;
      r = 1, a ? (i = [
        parseInt(s[0] + s[0], 16),
        parseInt(s[1] + s[1], 16),
        parseInt(s[2] + s[2], 16)
      ], o === 4 && (r = parseInt(s[3] + s[3], 16) / 255)) : (i = [
        parseInt(s[0] + s[1], 16),
        parseInt(s[2] + s[3], 16),
        parseInt(s[4] + s[5], 16)
      ], o === 8 && (r = parseInt(s[6] + s[7], 16) / 255)), i[0] || (i[0] = 0), i[1] || (i[1] = 0), i[2] || (i[2] = 0), n = "rgb";
    } else if (e = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(t)) {
      var A = e[1];
      n = A.replace(/a$/, "");
      var l = n === "cmyk" ? 4 : n === "gray" ? 1 : 3;
      i = e[2].trim().split(/\s*[,\/]\s*|\s+/), n === "color" && (n = i.shift()), i = i.map(function(d, h) {
        if (d[d.length - 1] === "%")
          return d = parseFloat(d) / 100, h === 3 ? d : n === "rgb" ? d * 255 : n[0] === "h" || n[0] === "l" && !h ? d * 100 : n === "lab" ? d * 125 : n === "lch" ? h < 2 ? d * 150 : d * 360 : n[0] === "o" && !h ? d : n === "oklab" ? d * 0.4 : n === "oklch" ? h < 2 ? d * 0.4 : d * 360 : d;
        if (n[h] === "h" || h === 2 && n[n.length - 1] === "h") {
          if (yD[d] !== void 0) return yD[d];
          if (d.endsWith("deg")) return parseFloat(d);
          if (d.endsWith("turn")) return parseFloat(d) * 360;
          if (d.endsWith("grad")) return parseFloat(d) * 360 / 400;
          if (d.endsWith("rad")) return parseFloat(d) * 180 / Math.PI;
        }
        return d === "none" ? 0 : parseFloat(d);
      }), r = i.length > l ? i.pop() : 1;
    } else /[0-9](?:\s|\/|,)/.test(t) && (i = t.match(/([0-9]+)/g).map(function(d) {
      return parseFloat(d);
    }), n = ((u = (c = t.match(/([a-z])/ig)) == null ? void 0 : c.join("")) == null ? void 0 : u.toLowerCase()) || "rgb");
    return {
      space: n,
      values: i,
      alpha: r
    };
  }
  var E0 = {
    name: "hsl",
    min: [0, 0, 0],
    max: [360, 100, 100],
    channel: ["hue", "saturation", "lightness"],
    alias: ["HSL"],
    rgb: function(t) {
      var e = t[0] / 360, i = t[1] / 100, r = t[2] / 100, n, s, o, a, A, l = 0;
      if (i === 0) return A = r * 255, [A, A, A];
      for (s = r < 0.5 ? r * (1 + i) : r + i - r * i, n = 2 * r - s, a = [0, 0, 0]; l < 3; )
        o = e + 1 / 3 * -(l - 1), o < 0 ? o++ : o > 1 && o--, A = 6 * o < 1 ? n + (s - n) * 6 * o : 2 * o < 1 ? s : 3 * o < 2 ? n + (s - n) * (2 / 3 - o) * 6 : n, a[l++] = A * 255;
      return a;
    }
  };
  ug.hsl = function(t) {
    var e = t[0] / 255, i = t[1] / 255, r = t[2] / 255, n = Math.min(e, i, r), s = Math.max(e, i, r), o = s - n, a, A, l;
    return s === n ? a = 0 : e === s ? a = (i - r) / o : i === s ? a = 2 + (r - e) / o : r === s && (a = 4 + (e - i) / o), a = Math.min(a * 60, 360), a < 0 && (a += 360), l = (n + s) / 2, s === n ? A = 0 : l <= 0.5 ? A = o / (s + n) : A = o / (2 - s - n), [a, A * 100, l * 100];
  };
  function j$(t) {
    Array.isArray(t) && t.raw && (t = String.raw(...arguments)), t instanceof Number && (t = +t);
    var e, i = G$(t);
    if (!i.space) return [];
    const r = i.space[0] === "h" ? E0.min : ug.min, n = i.space[0] === "h" ? E0.max : ug.max;
    return e = Array(3), e[0] = Math.min(Math.max(i.values[0], r[0]), n[0]), e[1] = Math.min(Math.max(i.values[1], r[1]), n[1]), e[2] = Math.min(Math.max(i.values[2], r[2]), n[2]), i.space[0] === "h" && (e = E0.rgb(e)), e.push(Math.min(Math.max(i.alpha, 0), 1)), e;
  }
  const kv = [NaN, NaN, NaN, 0];
  function H$(t) {
    return typeof t == "string" ? t : Nv(t);
  }
  const J$ = 1024, th = {};
  let y0 = 0;
  function V$(t) {
    if (t.length === 4)
      return t;
    const e = t.slice();
    return e[3] = 1, e;
  }
  function BD(t) {
    const e = Yr.lchuv(ug.xyz(t));
    return e[3] = t[3], e;
  }
  function W$(t) {
    const e = Yr.rgb(CU.xyz(t));
    return e[3] = t[3], e;
  }
  function Yv(t) {
    if (t === "none")
      return kv;
    if (th.hasOwnProperty(t))
      return th[t];
    if (y0 >= J$) {
      let i = 0;
      for (const r in th)
        (i++ & 3) === 0 && (delete th[r], --y0);
    }
    const e = j$(t);
    if (e.length !== 4)
      throw new Error('failed to parse "' + t + '" as color');
    for (const i of e)
      if (isNaN(i))
        throw new Error('failed to parse "' + t + '" as color');
    return bU(e), th[t] = e, ++y0, e;
  }
  function Hn(t) {
    return Array.isArray(t) ? t : Yv(t);
  }
  function bU(t) {
    return t[0] = yi(t[0] + 0.5 | 0, 0, 255), t[1] = yi(t[1] + 0.5 | 0, 0, 255), t[2] = yi(t[2] + 0.5 | 0, 0, 255), t[3] = yi(t[3], 0, 1), t;
  }
  function Nv(t) {
    let e = t[0];
    e != (e | 0) && (e = e + 0.5 | 0);
    let i = t[1];
    i != (i | 0) && (i = i + 0.5 | 0);
    let r = t[2];
    r != (r | 0) && (r = r + 0.5 | 0);
    const n = t[3] === void 0 ? 1 : Math.round(t[3] * 1e3) / 1e3;
    return "rgba(" + e + "," + i + "," + r + "," + n + ")";
  }
  const FA = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", K$ = FA.includes("firefox"), X$ = FA.includes("safari") && !FA.includes("chrom"), Z$ = X$ && (FA.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(FA)), q$ = FA.includes("webkit") && !FA.includes("edge"), MU = FA.includes("macintosh"), Uv = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, Lv = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, zv = typeof Image < "u" && Image.prototype.decode, $$ = typeof createImageBitmap == "function", IU = function() {
    let t = !1;
    try {
      const e = Object.defineProperty({}, "passive", {
        get: function() {
          t = !0;
        }
      });
      window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
    } catch {
    }
    return t;
  }();
  function Di(t, e, i, r) {
    let n;
    return i && i.length ? n = /** @type {HTMLCanvasElement} */
    i.shift() : Lv ? n = new OffscreenCanvas(t || 300, e || 300) : n = document.createElement("canvas"), t && (n.width = t), e && (n.height = e), /** @type {CanvasRenderingContext2D} */
    n.getContext("2d", r);
  }
  let B0;
  function CE() {
    return B0 || (B0 = Di(1, 1)), B0;
  }
  function uf(t) {
    const e = t.canvas;
    e.width = 1, e.height = 1, t.clearRect(0, 0, 1, 1);
  }
  function eee(t) {
    let e = t.offsetWidth;
    const i = getComputedStyle(t);
    return e += parseInt(i.marginLeft, 10) + parseInt(i.marginRight, 10), e;
  }
  function tee(t) {
    let e = t.offsetHeight;
    const i = getComputedStyle(t);
    return e += parseInt(i.marginTop, 10) + parseInt(i.marginBottom, 10), e;
  }
  function wD(t, e) {
    const i = e.parentNode;
    i && i.replaceChild(t, e);
  }
  function vU(t) {
    for (; t.lastChild; )
      t.lastChild.remove();
  }
  function iee(t, e) {
    const i = t.childNodes;
    for (let r = 0; ; ++r) {
      const n = i[r], s = e[r];
      if (!n && !s)
        break;
      if (n !== s) {
        if (!n) {
          t.appendChild(s);
          continue;
        }
        if (!s) {
          t.removeChild(n), --r;
          continue;
        }
        t.insertBefore(s, n);
      }
    }
  }
  class Pv extends Rd {
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
     * resolution will be assumed.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
     */
    constructor(e, i, r, n) {
      super(), this.extent = e, this.pixelRatio_ = r, this.resolution = i, this.state = typeof n == "function" ? ze.IDLE : n, this.image_ = null, this.loader = typeof n == "function" ? n : null;
    }
    /**
     * @protected
     */
    changed() {
      this.dispatchEvent(Ge.CHANGE);
    }
    /**
     * @return {import("./extent.js").Extent} Extent.
     */
    getExtent() {
      return this.extent;
    }
    /**
     * @return {import('./DataTile.js').ImageLike} Image.
     */
    getImage() {
      return this.image_;
    }
    /**
     * @return {number} PixelRatio.
     */
    getPixelRatio() {
      return this.pixelRatio_;
    }
    /**
     * @return {number|Array<number>} Resolution.
     */
    getResolution() {
      return (
        /** @type {number} */
        this.resolution
      );
    }
    /**
     * @return {import("./ImageState.js").default} State.
     */
    getState() {
      return this.state;
    }
    /**
     * Load not yet loaded URI.
     */
    load() {
      if (this.state == ze.IDLE && this.loader) {
        this.state = ze.LOADING, this.changed();
        const e = this.getResolution(), i = Array.isArray(e) ? e[0] : e;
        ed(
          () => this.loader(
            this.getExtent(),
            i,
            this.getPixelRatio()
          )
        ).then((r) => {
          "image" in r && (this.image_ = r.image), "extent" in r && (this.extent = r.extent), "resolution" in r && (this.resolution = r.resolution), "pixelRatio" in r && (this.pixelRatio_ = r.pixelRatio), (r instanceof HTMLImageElement || r instanceof ImageBitmap || r instanceof HTMLCanvasElement || r instanceof HTMLVideoElement) && (this.image_ = r), this.state = ze.LOADED;
        }).catch((r) => {
          this.state = ze.ERROR, console.error(r);
        }).finally(() => this.changed());
      }
    }
    /**
     * @param {import('./DataTile.js').ImageLike} image The image.
     */
    setImage(e) {
      this.image_ = e;
    }
    /**
     * @param {number|Array<number>} resolution Resolution.
     */
    setResolution(e) {
      this.resolution = e;
    }
  }
  function ree(t, e, i) {
    const r = (
      /** @type {HTMLImageElement} */
      t
    );
    let n = !0, s = !1, o = !1;
    const a = [
      gE(r, Ge.LOAD, function() {
        o = !0, s || e();
      })
    ];
    return r.src && zv ? (s = !0, r.decode().then(function() {
      n && e();
    }).catch(function(A) {
      n && (o ? e() : i());
    })) : a.push(gE(r, Ge.ERROR, i)), function() {
      n = !1, a.forEach(Pt);
    };
  }
  function nee(t, e) {
    return new Promise((i, r) => {
      function n() {
        o(), i(t);
      }
      function s() {
        o(), r(new Error("Image load error"));
      }
      function o() {
        t.removeEventListener("load", n), t.removeEventListener("error", s);
      }
      t.addEventListener("load", n), t.addEventListener("error", s);
    });
  }
  function xU(t, e) {
    return e && (t.src = e), t.src && zv ? new Promise(
      (i, r) => t.decode().then(() => i(t)).catch(
        (n) => t.complete && t.width ? i(t) : r(n)
      )
    ) : nee(t);
  }
  function QU(t, e) {
    return e && (t.src = e), t.src && zv && $$ ? t.decode().then(() => createImageBitmap(t)).catch((i) => {
      if (t.complete && t.width)
        return t;
      throw i;
    }) : xU(t);
  }
  class see {
    constructor() {
      this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 1024;
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
    }
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache() {
      return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
     * FIXME empty description for jsdoc
     */
    expire() {
      if (this.canExpireCache()) {
        let e = 0;
        for (const i in this.cache_) {
          const r = this.cache_[i];
          (e++ & 3) === 0 && !r.hasListener() && (delete this.cache_[i], delete this.patternCache_[i], --this.cacheSize_);
        }
      }
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */
    get(e, i, r) {
      const n = w0(e, i, r);
      return n in this.cache_ ? this.cache_[n] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @return {CanvasPattern} Icon image.
     */
    getPattern(e, i, r) {
      const n = w0(e, i, r);
      return n in this.patternCache_ ? this.patternCache_[n] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color|string|null} color Color.
     * @param {import("./IconImage.js").default|null} iconImage Icon image.
     * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
     */
    set(e, i, r, n, s) {
      const o = w0(e, i, r), a = o in this.cache_;
      this.cache_[o] = n, s && (n.getImageState() === ze.IDLE && n.load(), n.getImageState() === ze.LOADING ? n.ready().then(() => {
        this.patternCache_[o] = CE().createPattern(
          n.getImage(1),
          "repeat"
        );
      }) : this.patternCache_[o] = CE().createPattern(
        n.getImage(1),
        "repeat"
      )), a || ++this.cacheSize_;
    }
    /**
     * Set the cache size of the icon cache. Default is `1024`. Change this value when
     * your map uses more than 1024 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */
    setSize(e) {
      this.maxCacheSize_ = e, this.expire();
    }
  }
  function w0(t, e, i) {
    const r = i ? Hn(i) : "null";
    return e + ":" + t + ":" + r;
  }
  const rs = new see();
  let ih = null;
  class FU extends Rd {
    /**
     * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
     * @param {string|undefined} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default|undefined} imageState Image state.
     * @param {import("../color.js").Color|string|null} color Color.
     */
    constructor(e, i, r, n, s) {
      super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = r, this.canvas_ = {}, this.color_ = s, this.imageState_ = n === void 0 ? ze.IDLE : n, this.size_ = e && e.width && e.height ? [e.width, e.height] : null, this.src_ = i, this.tainted_, this.ready_ = null;
    }
    /**
     * @private
     */
    initializeImage_() {
      this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
    }
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */
    isTainted_() {
      if (this.tainted_ === void 0 && this.imageState_ === ze.LOADED) {
        ih || (ih = Di(1, 1, void 0, {
          willReadFrequently: !0
        })), ih.drawImage(this.image_, 0, 0);
        try {
          ih.getImageData(0, 0, 1, 1), this.tainted_ = !1;
        } catch {
          ih = null, this.tainted_ = !0;
        }
      }
      return this.tainted_ === !0;
    }
    /**
     * @private
     */
    dispatchChangeEvent_() {
      this.dispatchEvent(Ge.CHANGE);
    }
    /**
     * @private
     */
    handleImageError_() {
      this.imageState_ = ze.ERROR, this.dispatchChangeEvent_();
    }
    /**
     * @private
     */
    handleImageLoad_() {
      this.imageState_ = ze.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
     */
    getImage(e) {
      return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */
    getPixelRatio(e) {
      return this.replaceColor_(e), this.canvas_[e] ? e : 1;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return this.imageState_;
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
    getHitDetectionImage() {
      if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
        if (this.isTainted_()) {
          const e = this.size_[0], i = this.size_[1], r = Di(e, i);
          r.fillRect(0, 0, e, i), this.hitDetectionImage_ = r.canvas;
        } else
          this.hitDetectionImage_ = this.image_;
      return this.hitDetectionImage_;
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */
    getSize() {
      return this.size_;
    }
    /**
     * @return {string|undefined} Image src.
     */
    getSrc() {
      return this.src_;
    }
    /**
     * Load not yet loaded URI.
     */
    load() {
      if (this.imageState_ === ze.IDLE) {
        this.image_ || this.initializeImage_(), this.imageState_ = ze.LOADING;
        try {
          this.src_ !== void 0 && (this.image_.src = this.src_);
        } catch {
          this.handleImageError_();
        }
        this.image_ instanceof HTMLImageElement && xU(this.image_, this.src_).then((e) => {
          this.image_ = e, this.handleImageLoad_();
        }).catch(this.handleImageError_.bind(this));
      }
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */
    replaceColor_(e) {
      if (!this.color_ || this.canvas_[e] || this.imageState_ !== ze.LOADED)
        return;
      const i = this.image_, r = Di(
        Math.ceil(i.width * e),
        Math.ceil(i.height * e)
      ), n = r.canvas;
      r.scale(e, e), r.drawImage(i, 0, 0), r.globalCompositeOperation = "multiply", r.fillStyle = H$(this.color_), r.fillRect(0, 0, n.width / e, n.height / e), r.globalCompositeOperation = "destination-in", r.drawImage(i, 0, 0), this.canvas_[e] = n;
    }
    /**
     * @return {Promise<void>} Promise that resolves when the image is loaded.
     */
    ready() {
      return this.ready_ || (this.ready_ = new Promise((e) => {
        if (this.imageState_ === ze.LOADED || this.imageState_ === ze.ERROR)
          e();
        else {
          const i = () => {
            (this.imageState_ === ze.LOADED || this.imageState_ === ze.ERROR) && (this.removeEventListener(Ge.CHANGE, i), e());
          };
          this.addEventListener(Ge.CHANGE, i);
        }
      })), this.ready_;
    }
  }
  function Ov(t, e, i, r, n, s) {
    let o = e === void 0 ? void 0 : rs.get(e, i, n);
    return o || (o = new FU(
      t,
      t && "src" in t ? t.src || void 0 : e,
      i,
      r,
      n
    ), rs.set(e, i, n, o, s)), s && o && !rs.getPattern(e, i, n) && rs.set(e, i, n, o, s), o;
  }
  class vr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {}, this.patternImage_ = null, this.color_ = null, e.color !== void 0 && this.setColor(e.color);
    }
    /**
     * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
     * @return {Fill} The cloned style.
     * @api
     */
    clone() {
      const e = this.getColor();
      return new vr({
        color: Array.isArray(e) ? e.slice() : e || void 0
      });
    }
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
     * @api
     */
    setColor(e) {
      if (e !== null && typeof e == "object" && "src" in e) {
        const i = Ov(
          null,
          e.src,
          "anonymous",
          void 0,
          e.offset ? null : e.color ? e.color : null,
          !(e.offset && e.size)
        );
        i.ready().then(() => {
          this.patternImage_ = null;
        }), i.getImageState() === ze.IDLE && i.load(), i.getImageState() === ze.LOADING && (this.patternImage_ = i);
      }
      this.color_ = e;
    }
    /**
     * @return {string} Key of the fill for cache lookup.
     */
    getKey() {
      const e = this.getColor();
      return e ? e instanceof CanvasPattern || e instanceof CanvasGradient ? ve(e) : typeof e == "object" && "src" in e ? e.src + ":" + e.offset : Hn(e).toString() : "";
    }
    /**
     * @return {boolean} The fill style is loading an image pattern.
     */
    loading() {
      return !!this.patternImage_;
    }
    /**
     * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
     */
    ready() {
      return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
    }
  }
  function bE(t, e, i, r, n, s, o) {
    let a, A;
    const l = (i - e) / r;
    if (l === 1)
      a = e;
    else if (l === 2)
      a = e, A = n;
    else if (l !== 0) {
      let c = t[e], u = t[e + 1], d = 0;
      const h = [0];
      for (let p = e + r; p < i; p += r) {
        const m = t[p], E = t[p + 1];
        d += Math.sqrt((m - c) * (m - c) + (E - u) * (E - u)), h.push(d), c = m, u = E;
      }
      const g = n * d, f = Rq(h, g);
      f < 0 ? (A = (g - h[-f - 2]) / (h[-f - 1] - h[-f - 2]), a = e + (-f - 2) * r) : a = e + f * r;
    }
    o = o > 1 ? o : 2, s = s || new Array(o);
    for (let c = 0; c < o; ++c)
      s[c] = a === void 0 ? NaN : A === void 0 ? t[a + c] : _n(t[a + c], t[a + r + c], A);
    return s;
  }
  function pb(t, e, i, r, n, s) {
    if (i == e)
      return null;
    let o;
    if (n < t[e + r - 1])
      return s ? (o = t.slice(e, e + r), o[r - 1] = n, o) : null;
    if (t[i - 1] < n)
      return s ? (o = t.slice(i - r, i), o[r - 1] = n, o) : null;
    if (n == t[e + r - 1])
      return t.slice(e, e + r);
    let a = e / r, A = i / r;
    for (; a < A; ) {
      const d = a + A >> 1;
      n < t[(d + 1) * r - 1] ? A = d : a = d + 1;
    }
    const l = t[a * r - 1];
    if (n == l)
      return t.slice((a - 1) * r, (a - 1) * r + r);
    const c = t[(a + 1) * r - 1], u = (n - l) / (c - l);
    o = [];
    for (let d = 0; d < r - 1; ++d)
      o.push(
        _n(
          t[(a - 1) * r + d],
          t[a * r + d],
          u
        )
      );
    return o.push(n), o;
  }
  function oee(t, e, i, r, n, s, o) {
    if (o)
      return pb(
        t,
        e,
        i[i.length - 1],
        r,
        n,
        s
      );
    let a;
    if (n < t[r - 1])
      return s ? (a = t.slice(0, r), a[r - 1] = n, a) : null;
    if (t[t.length - 1] < n)
      return s ? (a = t.slice(t.length - r), a[r - 1] = n, a) : null;
    for (let A = 0, l = i.length; A < l; ++A) {
      const c = i[A];
      if (e != c) {
        if (n < t[e + r - 1])
          return null;
        if (n <= t[c - 1])
          return pb(
            t,
            e,
            c,
            r,
            n,
            !1
          );
        e = c;
      }
    }
    return null;
  }
  function SU(t, e, i, r) {
    let n = t[e], s = t[e + 1], o = 0;
    for (let a = e + r; a < i; a += r) {
      const A = t[a], l = t[a + 1];
      o += Math.sqrt((A - n) * (A - n) + (l - s) * (l - s)), n = A, s = l;
    }
    return o;
  }
  class bn extends jA {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(e, i) {
      super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, i !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
        i,
        /** @type {Array<number>} */
        e
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        e,
        i
      );
    }
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */
    appendCoordinate(e) {
      xr(this.flatCoordinates, e), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     * @override
     */
    clone() {
      const e = new bn(
        this.flatCoordinates.slice(),
        this.layout
      );
      return e.applyProperties(this), e;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      return n < oc(this.getExtent(), e, i) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Mv(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), vv(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        !1,
        e,
        i,
        r,
        n
      ));
    }
    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */
    forEachSegment(e) {
      return EU(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        e
      );
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(e, i) {
      return this.layout != "XYM" && this.layout != "XYZM" ? null : (i = i !== void 0 ? i : !1, pb(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        e,
        i
      ));
    }
    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return hA(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */
    getCoordinateAt(e, i) {
      return bE(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        e,
        i,
        this.stride
      );
    }
    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */
    getLength() {
      return SU(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint() {
      return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
        0.5,
        this.flatMidpoint_ ?? void 0
      ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
      this.flatMidpoint_;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(e) {
      const i = [];
      return i.length = dB(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        e,
        i,
        0
      ), new bn(i, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "LineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      return hB(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        e
      );
    }
    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(e, i) {
      this.setLayout(i, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = uB(
        this.flatCoordinates,
        0,
        e,
        this.stride
      ), this.changed();
    }
  }
  class pr {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
    }
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */
    clone() {
      const e = this.getColor();
      return new pr({
        color: Array.isArray(e) ? e.slice() : e || void 0,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    }
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */
    getLineCap() {
      return this.lineCap_;
    }
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>|null} Line dash.
     * @api
     */
    getLineDash() {
      return this.lineDash_;
    }
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
    getLineDashOffset() {
      return this.lineDashOffset_;
    }
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */
    getLineJoin() {
      return this.lineJoin_;
    }
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
    getMiterLimit() {
      return this.miterLimit_;
    }
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
    getWidth() {
      return this.width_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */
    setColor(e) {
      this.color_ = e;
    }
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */
    setLineCap(e) {
      this.lineCap_ = e;
    }
    /**
     * Set the line dash.
     *
     * @param {Array<number>|null} lineDash Line dash.
     * @api
     */
    setLineDash(e) {
      this.lineDash_ = e;
    }
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
    setLineDashOffset(e) {
      this.lineDashOffset_ = e;
    }
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */
    setLineJoin(e) {
      this.lineJoin_ = e;
    }
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
    setMiterLimit(e) {
      this.miterLimit_ = e;
    }
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
    setWidth(e) {
      this.width_ = e;
    }
  }
  function CD(t) {
    return t[0] > 0 && t[1] > 0;
  }
  function aee(t, e, i) {
    return i === void 0 && (i = [0, 0]), i[0] = t[0] * e + 0.5 | 0, i[1] = t[1] * e + 0.5 | 0, i;
  }
  function mr(t, e) {
    return Array.isArray(t) ? t : (e === void 0 ? e = [t, t] : (e[0] = t, e[1] = t), e);
  }
  class gB {
    /**
     * @param {Options} options Options.
     */
    constructor(e) {
      this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = mr(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
    }
    /**
     * Clones the style.
     * @return {ImageStyle} The cloned style.
     * @api
     */
    clone() {
      const e = this.getScale();
      return new gB({
        opacity: this.getOpacity(),
        scale: Array.isArray(e) ? e.slice() : e,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */
    getOpacity() {
      return this.opacity_;
    }
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */
    getDisplacement() {
      return this.displacement_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */
    getAnchor() {
      return it();
    }
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getImage(e) {
      return it();
    }
    /**
     * @abstract
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getHitDetectionImage() {
      return it();
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    getPixelRatio(e) {
      return 1;
    }
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return it();
    }
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */
    getImageSize() {
      return it();
    }
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */
    getOrigin() {
      return it();
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */
    getSize() {
      return it();
    }
    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */
    setDisplacement(e) {
      this.displacement_ = e;
    }
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */
    setOpacity(e) {
      this.opacity_ = e;
    }
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(e) {
      this.rotateWithView_ = e;
    }
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */
    setRotation(e) {
      this.rotation_ = e;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
    setScale(e) {
      this.scale_ = e, this.scaleArray_ = mr(e);
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    listenImageChange(e) {
      it();
    }
    /**
     * Load not yet loaded URI.
     * @abstract
     */
    load() {
      it();
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    unlistenImageChange(e) {
      it();
    }
    /**
     * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
     */
    ready() {
      return Promise.resolve();
    }
  }
  function Mo(t) {
    return t ? Array.isArray(t) ? Nv(t) : typeof t == "object" && "src" in t ? Aee(t) : t : null;
  }
  function Aee(t) {
    if (!t.offset || !t.size)
      return rs.getPattern(t.src, "anonymous", t.color);
    const e = t.src + ":" + t.offset, i = rs.getPattern(
      e,
      void 0,
      t.color
    );
    if (i)
      return i;
    const r = rs.get(t.src, "anonymous", null);
    if (r.getImageState() !== ze.LOADED)
      return null;
    const n = Di(
      t.size[0],
      t.size[1]
    );
    return n.drawImage(
      r.getImage(1),
      t.offset[0],
      t.offset[1],
      t.size[0],
      t.size[1],
      0,
      0,
      t.size[0],
      t.size[1]
    ), Ov(
      n.canvas,
      e,
      void 0,
      ze.LOADED,
      t.color,
      !0
    ), rs.getPattern(e, void 0, t.color);
  }
  const np = "ol-hidden", lee = "ol-selectable", df = "ol-unselectable", Gv = "ol-control", bD = "ol-collapsed", cee = new RegExp(
    [
      "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
      "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
      "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
      "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
      `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
    ].join(""),
    "i"
  ), MD = [
    "style",
    "variant",
    "weight",
    "size",
    "lineHeight",
    "family"
  ], DU = function(t) {
    const e = t.match(cee);
    if (!e)
      return null;
    const i = (
      /** @type {FontParameters} */
      {
        lineHeight: "normal",
        size: "1.2em",
        style: "normal",
        weight: "normal",
        variant: "normal"
      }
    );
    for (let r = 0, n = MD.length; r < n; ++r) {
      const s = e[r + 1];
      s !== void 0 && (i[MD[r]] = s);
    }
    return i.families = i.family.split(/,\s?/), i;
  }, TU = "10px sans-serif", gn = "#000", nd = "round", Ea = [], ya = 0, sd = "round", dg = 10, hg = "#000", gg = "center", ME = "middle", ml = [0, 0, 0, 0], fg = 1, mo = new no();
  let Jc = null, mb;
  const Eb = {}, RU = function() {
    const e = "32px ", i = ["monospace", "serif"], r = i.length, n = "wmytzilWMYTZIL@#/&?$%10";
    let s, o;
    function a(l, c, u) {
      let d = !0;
      for (let h = 0; h < r; ++h) {
        const g = i[h];
        if (o = IE(
          l + " " + c + " " + e + g,
          n
        ), u != g) {
          const f = IE(
            l + " " + c + " " + e + u + "," + g,
            n
          );
          d = d && f != o;
        }
      }
      return !!d;
    }
    function A() {
      let l = !0;
      const c = mo.getKeys();
      for (let u = 0, d = c.length; u < d; ++u) {
        const h = c[u];
        if (mo.get(h) < 100) {
          const [g, f, p] = h.split(`
`);
          a(g, f, p) ? (nc(Eb), Jc = null, mb = void 0, mo.set(h, 100)) : (mo.set(h, mo.get(h) + 1, !0), l = !1);
        }
      }
      l && (clearInterval(s), s = void 0);
    }
    return function(l) {
      const c = DU(l);
      if (!c)
        return;
      const u = c.families;
      for (let d = 0, h = u.length; d < h; ++d) {
        const g = u[d], f = c.style + `
` + c.weight + `
` + g;
        mo.get(f) === void 0 && (mo.set(f, 100, !0), a(c.style, c.weight, g) || (mo.set(f, 0, !0), s === void 0 && (s = setInterval(A, 32))));
      }
    };
  }(), uee = /* @__PURE__ */ function() {
    let t;
    return function(e) {
      let i = Eb[e];
      if (i == null) {
        if (Lv) {
          const r = DU(e), n = _U(e, "Žg");
          i = (isNaN(Number(r.lineHeight)) ? 1.2 : Number(r.lineHeight)) * (n.actualBoundingBoxAscent + n.actualBoundingBoxDescent);
        } else
          t || (t = document.createElement("div"), t.innerHTML = "M", t.style.minHeight = "0", t.style.maxHeight = "none", t.style.height = "auto", t.style.padding = "0", t.style.border = "none", t.style.position = "absolute", t.style.display = "block", t.style.left = "-99999px"), t.style.font = e, document.body.appendChild(t), i = t.offsetHeight, document.body.removeChild(t);
        Eb[e] = i;
      }
      return i;
    };
  }();
  function _U(t, e) {
    return Jc || (Jc = Di(1, 1)), t != mb && (Jc.font = t, mb = Jc.font), Jc.measureText(e);
  }
  function IE(t, e) {
    return _U(t, e).width;
  }
  function ID(t, e, i) {
    if (e in i)
      return i[e];
    const r = e.split(`
`).reduce((n, s) => Math.max(n, IE(t, s)), 0);
    return i[e] = r, r;
  }
  function dee(t, e) {
    const i = [], r = [], n = [];
    let s = 0, o = 0, a = 0, A = 0;
    for (let l = 0, c = e.length; l <= c; l += 2) {
      const u = e[l];
      if (u === `
` || l === c) {
        s = Math.max(s, o), n.push(o), o = 0, a += A, A = 0;
        continue;
      }
      const d = e[l + 1] || t.font, h = IE(d, u);
      i.push(h), o += h;
      const g = uee(d);
      r.push(g), A = Math.max(A, g);
    }
    return { width: s, height: a, widths: i, heights: r, lineWidths: n };
  }
  function hee(t, e, i, r, n, s, o, a, A, l, c) {
    t.save(), i !== 1 && (t.globalAlpha === void 0 ? t.globalAlpha = (u) => u.globalAlpha *= i : t.globalAlpha *= i), e && t.transform.apply(t, e), /** @type {*} */
    r.contextInstructions ? (t.translate(A, l), t.scale(c[0], c[1]), gee(
      /** @type {Label} */
      r,
      t
    )) : c[0] < 0 || c[1] < 0 ? (t.translate(A, l), t.scale(c[0], c[1]), t.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      r,
      n,
      s,
      o,
      a,
      0,
      0,
      o,
      a
    )) : t.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      r,
      n,
      s,
      o,
      a,
      A,
      l,
      o * c[0],
      a * c[1]
    ), t.restore();
  }
  function gee(t, e) {
    const i = t.contextInstructions;
    for (let r = 0, n = i.length; r < n; r += 2)
      Array.isArray(i[r + 1]) ? e[i[r]].apply(
        e,
        i[r + 1]
      ) : e[i[r]] = i[r + 1];
  }
  class fB extends gB {
    /**
     * @param {Options} options Options.
     */
    constructor(e) {
      super({
        opacity: 1,
        rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
        rotation: e.rotation !== void 0 ? e.rotation : 0,
        scale: e.scale !== void 0 ? e.scale : 1,
        displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
        declutterMode: e.declutterMode
      }), this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius = e.radius, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? ze.LOADING : ze.LOADED, this.imageState_ === ze.LOADING && this.ready().then(() => this.imageState_ = ze.LOADED), this.render();
    }
    /**
     * Clones the style.
     * @return {RegularShape} The cloned style.
     * @api
     * @override
     */
    clone() {
      const e = this.getScale(), i = new fB({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(e) ? e.slice() : e,
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      return i.setOpacity(this.getOpacity()), i;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     * @override
     */
    getAnchor() {
      const e = this.size_, i = this.getDisplacement(), r = this.getScaleArray();
      return [
        e[0] / 2 - i[0] / r[0],
        e[1] / 2 + i[1] / r[1]
      ];
    }
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */
    getAngle() {
      return this.angle_;
    }
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(e) {
      this.fill_ = e, this.render();
    }
    /**
     * @return {HTMLCanvasElement} Image element.
     * @override
     */
    getHitDetectionImage() {
      return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
        this.renderOptions_
      )), this.hitDetectionCanvas_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     * @override
     */
    getImage(e) {
      var s, o;
      const i = (s = this.fill_) == null ? void 0 : s.getKey(), r = `${e},${this.angle_},${this.radius},${this.radius2_},${this.points_},${i}` + Object.values(this.renderOptions_).join(",");
      let n = (
        /** @type {HTMLCanvasElement} */
        (o = rs.get(r, null, null)) == null ? void 0 : o.getImage(1)
      );
      if (!n) {
        const a = this.renderOptions_, A = Math.ceil(a.size * e), l = Di(A, A);
        this.draw_(a, l, e), n = l.canvas, rs.set(
          r,
          null,
          null,
          new FU(n, void 0, null, ze.LOADED, null)
        );
      }
      return n;
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     * @override
     */
    getPixelRatio(e) {
      return e;
    }
    /**
     * @return {import("../size.js").Size} Image size.
     * @override
     */
    getImageSize() {
      return this.size_;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     * @override
     */
    getImageState() {
      return this.imageState_;
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     * @override
     */
    getOrigin() {
      return this.origin_;
    }
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */
    getPoints() {
      return this.points_;
    }
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */
    getRadius() {
      return this.radius;
    }
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */
    getRadius2() {
      return this.radius2_;
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     * @override
     */
    getSize() {
      return this.size_;
    }
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(e) {
      this.stroke_ = e, this.render();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    listenImageChange(e) {
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    unlistenImageChange(e) {
    }
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */
    calculateLineJoinSize_(e, i, r) {
      if (i === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
        return i;
      let n = this.radius, s = this.radius2_ === void 0 ? n : this.radius2_;
      if (n < s) {
        const M = n;
        n = s, s = M;
      }
      const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, a = 2 * Math.PI / o, A = s * Math.sin(a), l = Math.sqrt(s * s - A * A), c = n - l, u = Math.sqrt(A * A + c * c), d = u / A;
      if (e === "miter" && d <= r)
        return d * i;
      const h = i / 2 / d, g = i / 2 * (c / u), p = Math.sqrt((n + h) * (n + h) + g * g) - n;
      if (this.radius2_ === void 0 || e === "bevel")
        return p * 2;
      const m = n * Math.sin(a), E = Math.sqrt(n * n - m * m), y = s - E, w = Math.sqrt(m * m + y * y) / m;
      if (w <= r) {
        const M = w * i / 2 - s - n;
        return 2 * Math.max(p, M);
      }
      return p * 2;
    }
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */
    createRenderOptions() {
      let e = nd, i = sd, r = 0, n = null, s = 0, o, a = 0;
      this.stroke_ && (o = Mo(this.stroke_.getColor() ?? hg), a = this.stroke_.getWidth() ?? fg, n = this.stroke_.getLineDash(), s = this.stroke_.getLineDashOffset() ?? 0, i = this.stroke_.getLineJoin() ?? sd, e = this.stroke_.getLineCap() ?? nd, r = this.stroke_.getMiterLimit() ?? dg);
      const A = this.calculateLineJoinSize_(i, a, r), l = Math.max(this.radius, this.radius2_ || 0), c = Math.ceil(2 * l + A);
      return {
        strokeStyle: o,
        strokeWidth: a,
        size: c,
        lineCap: e,
        lineDash: n,
        lineDashOffset: s,
        lineJoin: i,
        miterLimit: r
      };
    }
    /**
     * @protected
     */
    render() {
      this.renderOptions_ = this.createRenderOptions();
      const e = this.renderOptions_.size;
      this.hitDetectionCanvas_ = null, this.size_ = [e, e];
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */
    draw_(e, i, r) {
      if (i.scale(r, r), i.translate(e.size / 2, e.size / 2), this.createPath_(i), this.fill_) {
        let n = this.fill_.getColor();
        n === null && (n = gn), i.fillStyle = Mo(n), i.fill();
      }
      e.strokeStyle && (i.strokeStyle = e.strokeStyle, i.lineWidth = e.strokeWidth, e.lineDash && (i.setLineDash(e.lineDash), i.lineDashOffset = e.lineDashOffset), i.lineCap = e.lineCap, i.lineJoin = e.lineJoin, i.miterLimit = e.miterLimit, i.stroke());
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @return {HTMLCanvasElement} Canvas containing the icon
     */
    createHitDetectionCanvas_(e) {
      let i;
      if (this.fill_) {
        let r = this.fill_.getColor(), n = 0;
        typeof r == "string" && (r = Hn(r)), r === null ? n = 1 : Array.isArray(r) && (n = r.length === 4 ? r[3] : 1), n === 0 && (i = Di(e.size, e.size), this.drawHitDetectionCanvas_(e, i));
      }
      return i ? i.canvas : this.getImage(1);
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */
    createPath_(e) {
      let i = this.points_;
      const r = this.radius;
      if (i === 1 / 0)
        e.arc(0, 0, r, 0, 2 * Math.PI);
      else {
        const n = this.radius2_ === void 0 ? r : this.radius2_;
        this.radius2_ !== void 0 && (i *= 2);
        const s = this.angle_ - Math.PI / 2, o = 2 * Math.PI / i;
        for (let a = 0; a < i; a++) {
          const A = s + a * o, l = a % 2 === 0 ? r : n;
          e.lineTo(l * Math.cos(A), l * Math.sin(A));
        }
        e.closePath();
      }
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */
    drawHitDetectionCanvas_(e, i) {
      i.translate(e.size / 2, e.size / 2), this.createPath_(i), i.fillStyle = gn, i.fill(), e.strokeStyle && (i.strokeStyle = e.strokeStyle, i.lineWidth = e.strokeWidth, e.lineDash && (i.setLineDash(e.lineDash), i.lineDashOffset = e.lineDashOffset), i.lineJoin = e.lineJoin, i.miterLimit = e.miterLimit, i.stroke());
    }
    /**
     * @override
     */
    ready() {
      return this.fill_ ? this.fill_.ready() : Promise.resolve();
    }
  }
  class Sa extends fB {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || { radius: 5 }, super({
        points: 1 / 0,
        fill: e.fill,
        radius: e.radius,
        stroke: e.stroke,
        scale: e.scale !== void 0 ? e.scale : 1,
        rotation: e.rotation !== void 0 ? e.rotation : 0,
        rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
        displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
        declutterMode: e.declutterMode
      });
    }
    /**
     * Clones the style.
     * @return {CircleStyle} The cloned style.
     * @api
     * @override
     */
    clone() {
      const e = this.getScale(), i = new Sa({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        radius: this.getRadius(),
        scale: Array.isArray(e) ? e.slice() : e,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      return i.setOpacity(this.getOpacity()), i;
    }
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */
    setRadius(e) {
      this.radius = e, this.render();
    }
  }
  class hi {
    /**
     * @param {Options} [options] Style options.
     */
    constructor(e) {
      e = e || {}, this.geometry_ = null, this.geometryFunction_ = vD, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
    }
    /**
     * Clones the style.
     * @return {Style} The cloned style.
     * @api
     */
    clone() {
      let e = this.getGeometry();
      return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
      e.clone()), new hi({
        geometry: e ?? void 0,
        fill: this.getFill() ? this.getFill().clone() : void 0,
        image: this.getImage() ? this.getImage().clone() : void 0,
        renderer: this.getRenderer() ?? void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        text: this.getText() ? this.getText().clone() : void 0,
        zIndex: this.getZIndex()
      });
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setRenderer(e) {
      this.renderer_ = e;
    }
    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setHitDetectionRenderer(e) {
      this.hitDetectionRenderer_ = e;
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getHitDetectionRenderer() {
      return this.hitDetectionRenderer_;
    }
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
    getGeometry() {
      return this.geometry_;
    }
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
    getGeometryFunction() {
      return this.geometryFunction_;
    }
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(e) {
      this.fill_ = e;
    }
    /**
     * Get the image style.
     * @return {import("./Image.js").default|null} Image style.
     * @api
     */
    getImage() {
      return this.image_;
    }
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */
    setImage(e) {
      this.image_ = e;
    }
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(e) {
      this.stroke_ = e;
    }
    /**
     * Get the text style.
     * @return {import("./Text.js").default|null} Text style.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */
    setText(e) {
      this.text_ = e;
    }
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
    getZIndex() {
      return this.zIndex_;
    }
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */
    setGeometry(e) {
      typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(i) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          i.get(e)
        );
      } : e ? e !== void 0 && (this.geometryFunction_ = function() {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          e
        );
      }) : this.geometryFunction_ = vD, this.geometry_ = e;
    }
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
    setZIndex(e) {
      this.zIndex_ = e;
    }
  }
  function fee(t) {
    let e;
    if (typeof t == "function")
      e = t;
    else {
      let i;
      Array.isArray(t) ? i = t : (Mt(
        typeof /** @type {?} */
        t.getZIndex == "function",
        "Expected an `Style` or an array of `Style`"
      ), i = [
        /** @type {Style} */
        t
      ]), e = function() {
        return i;
      };
    }
    return e;
  }
  let C0 = null;
  function kU(t, e) {
    if (!C0) {
      const i = new vr({
        color: "rgba(255,255,255,0.4)"
      }), r = new pr({
        color: "#3399CC",
        width: 1.25
      });
      C0 = [
        new hi({
          image: new Sa({
            fill: i,
            stroke: r,
            radius: 5
          }),
          fill: i,
          stroke: r
        })
      ];
    }
    return C0;
  }
  function jv() {
    const t = {}, e = [255, 255, 255, 1], i = [0, 153, 255, 1], r = 3;
    return t.Polygon = [
      new hi({
        fill: new vr({
          color: [255, 255, 255, 0.5]
        })
      })
    ], t.MultiPolygon = t.Polygon, t.LineString = [
      new hi({
        stroke: new pr({
          color: e,
          width: r + 2
        })
      }),
      new hi({
        stroke: new pr({
          color: i,
          width: r
        })
      })
    ], t.MultiLineString = t.LineString, t.Circle = t.Polygon.concat(t.LineString), t.Point = [
      new hi({
        image: new Sa({
          radius: r * 2,
          fill: new vr({
            color: i
          }),
          stroke: new pr({
            color: e,
            width: r / 2
          })
        }),
        zIndex: 1 / 0
      })
    ], t.MultiPoint = t.Point, t.GeometryCollection = t.Polygon.concat(
      t.LineString,
      t.Point
    ), t;
  }
  function vD(t) {
    return t.getGeometry();
  }
  const pee = "#333";
  class pB {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.keepUpright_ = e.keepUpright, this.scale_ = e.scale, this.scaleArray_ = mr(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new vr({ color: pee }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding, this.declutterMode_ = e.declutterMode;
    }
    /**
     * Clones the style.
     * @return {Text} The cloned style.
     * @api
     */
    clone() {
      const e = this.getScale();
      return new pB({
        font: this.getFont(),
        placement: this.getPlacement(),
        repeat: this.getRepeat(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        keepUpright: this.getKeepUpright(),
        scale: Array.isArray(e) ? e.slice() : e,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
        backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
        padding: this.getPadding() || void 0,
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */
    getOverflow() {
      return this.overflow_;
    }
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */
    getFont() {
      return this.font_;
    }
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */
    getMaxAngle() {
      return this.maxAngle_;
    }
    /**
     * Get the label placement.
     * @return {TextPlacement} Text placement.
     * @api
     */
    getPlacement() {
      return this.placement_;
    }
    /**
     * Get the repeat interval of the text.
     * @return {number|undefined} Repeat interval in pixels.
     * @api
     */
    getRepeat() {
      return this.repeat_;
    }
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */
    getOffsetX() {
      return this.offsetX_;
    }
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */
    getOffsetY() {
      return this.offsetY_;
    }
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Determine whether the text can be rendered upside down.
     * @return {boolean|undefined} Keep text upright.
     * @api
     */
    getKeepUpright() {
      return this.keepUpright_;
    }
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Get the text alignment.
     * @return {CanvasTextAlign|undefined} Text align.
     * @api
     */
    getTextAlign() {
      return this.textAlign_;
    }
    /**
     * Get the justification.
     * @return {TextJustify|undefined} Justification.
     * @api
     */
    getJustify() {
      return this.justify_;
    }
    /**
     * Get the text baseline.
     * @return {CanvasTextBaseline|undefined} Text baseline.
     * @api
     */
    getTextBaseline() {
      return this.textBaseline_;
    }
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default|null} Fill style.
     * @api
     */
    getBackgroundFill() {
      return this.backgroundFill_;
    }
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default|null} Stroke style.
     * @api
     */
    getBackgroundStroke() {
      return this.backgroundStroke_;
    }
    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */
    getPadding() {
      return this.padding_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
     * @api
     */
    getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */
    setOverflow(e) {
      this.overflow_ = e;
    }
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */
    setFont(e) {
      this.font_ = e;
    }
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */
    setMaxAngle(e) {
      this.maxAngle_ = e;
    }
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */
    setOffsetX(e) {
      this.offsetX_ = e;
    }
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */
    setOffsetY(e) {
      this.offsetY_ = e;
    }
    /**
     * Set the text placement.
     *
     * @param {TextPlacement} placement Placement.
     * @api
     */
    setPlacement(e) {
      this.placement_ = e;
    }
    /**
     * Set the repeat interval of the text.
     * @param {number|undefined} [repeat] Repeat interval in pixels.
     * @api
     */
    setRepeat(e) {
      this.repeat_ = e;
    }
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(e) {
      this.rotateWithView_ = e;
    }
    /**
     * Set whether the text can be rendered upside down.
     *
     * @param {boolean} keepUpright Keep text upright.
     * @api
     */
    setKeepUpright(e) {
      this.keepUpright_ = e;
    }
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setFill(e) {
      this.fill_ = e;
    }
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */
    setRotation(e) {
      this.rotation_ = e;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */
    setScale(e) {
      this.scale_ = e, this.scaleArray_ = mr(e !== void 0 ? e : 1);
    }
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setStroke(e) {
      this.stroke_ = e;
    }
    /**
     * Set the text.
     *
     * @param {string|Array<string>|undefined} text Text.
     * @api
     */
    setText(e) {
      this.text_ = e;
    }
    /**
     * Set the text alignment.
     *
     * @param {CanvasTextAlign|undefined} textAlign Text align.
     * @api
     */
    setTextAlign(e) {
      this.textAlign_ = e;
    }
    /**
     * Set the justification.
     *
     * @param {TextJustify|undefined} justify Justification.
     * @api
     */
    setJustify(e) {
      this.justify_ = e;
    }
    /**
     * Set the text baseline.
     *
     * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
     * @api
     */
    setTextBaseline(e) {
      this.textBaseline_ = e;
    }
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default|null} fill Fill style.
     * @api
     */
    setBackgroundFill(e) {
      this.backgroundFill_ = e;
    }
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default|null} stroke Stroke style.
     * @api
     */
    setBackgroundStroke(e) {
      this.backgroundStroke_ = e;
    }
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */
    setPadding(e) {
      this.padding_ = e;
    }
  }
  const qt = {
    OPACITY: "opacity",
    VISIBLE: "visible",
    EXTENT: "extent",
    Z_INDEX: "zIndex",
    MAX_RESOLUTION: "maxResolution",
    MIN_RESOLUTION: "minResolution",
    MAX_ZOOM: "maxZoom",
    MIN_ZOOM: "minZoom",
    SOURCE: "source",
    MAP: "map"
  };
  class YU extends no {
    /**
     * @param {Options} options Layer options.
     */
    constructor(e) {
      super(), this.on, this.once, this.un, this.background_ = e.background;
      const i = Object.assign({}, e);
      typeof e.properties == "object" && (delete i.properties, Object.assign(i, e.properties)), i[qt.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, Mt(
        typeof i[qt.OPACITY] == "number",
        "Layer opacity must be a number"
      ), i[qt.VISIBLE] = e.visible !== void 0 ? e.visible : !0, i[qt.Z_INDEX] = e.zIndex, i[qt.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, i[qt.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, i[qt.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, i[qt.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = i.className !== void 0 ? i.className : "ol-layer", delete i.className, this.setProperties(i), this.state_ = null;
    }
    /**
     * Get the background for this layer.
     * @return {BackgroundColor|false} Layer background.
     */
    getBackground() {
      return this.background_;
    }
    /**
     * @return {string} CSS class name.
     */
    getClassName() {
      return this.className_;
    }
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */
    getLayerState(e) {
      const i = this.state_ || /** @type {?} */
      {
        layer: this,
        managed: e === void 0 ? !0 : e
      }, r = this.getZIndex();
      return i.opacity = yi(Math.round(this.getOpacity() * 100) / 100, 0, 1), i.visible = this.getVisible(), i.extent = this.getExtent(), i.zIndex = r === void 0 && !i.managed ? 1 / 0 : r, i.maxResolution = this.getMaxResolution(), i.minResolution = Math.max(this.getMinResolution(), 0), i.minZoom = this.getMinZoom(), i.maxZoom = this.getMaxZoom(), this.state_ = i, i;
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    getLayersArray(e) {
      return it();
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    getLayerStatesArray(e) {
      return it();
    }
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */
    getExtent() {
      return (
        /** @type {import("../extent.js").Extent|undefined} */
        this.get(qt.EXTENT)
      );
    }
    /**
     * Return the maximum resolution of the layer. Returns Infinity if
     * the layer has no maximum resolution set.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */
    getMaxResolution() {
      return (
        /** @type {number} */
        this.get(qt.MAX_RESOLUTION)
      );
    }
    /**
     * Return the minimum resolution of the layer. Returns 0 if
     * the layer has no minimum resolution set.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */
    getMinResolution() {
      return (
        /** @type {number} */
        this.get(qt.MIN_RESOLUTION)
      );
    }
    /**
     * Return the minimum zoom level of the layer. Returns -Infinity if
     * the layer has no minimum zoom set.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.get(qt.MIN_ZOOM)
      );
    }
    /**
     * Return the maximum zoom level of the layer. Returns Infinity if
     * the layer has no maximum zoom set.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.get(qt.MAX_ZOOM)
      );
    }
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */
    getOpacity() {
      return (
        /** @type {number} */
        this.get(qt.OPACITY)
      );
    }
    /**
     * @abstract
     * @return {import("../source/Source.js").State} Source state.
     */
    getSourceState() {
      return it();
    }
    /**
     * Return the value of this layer's `visible` property. To find out whether the layer
     * is visible on a map, use `isVisible()` instead.
     * @return {boolean} The value of the `visible` property of the layer.
     * @observable
     * @api
     */
    getVisible() {
      return (
        /** @type {boolean} */
        this.get(qt.VISIBLE)
      );
    }
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. Returns undefined if the layer is unmanaged.
     * @return {number|undefined} The Z-index of the layer.
     * @observable
     * @api
     */
    getZIndex() {
      return (
        /** @type {number|undefined} */
        this.get(qt.Z_INDEX)
      );
    }
    /**
     * Sets the background color.
     * @param {BackgroundColor} [background] Background color.
     */
    setBackground(e) {
      this.background_ = e, this.changed();
    }
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */
    setExtent(e) {
      this.set(qt.EXTENT, e);
    }
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */
    setMaxResolution(e) {
      this.set(qt.MAX_RESOLUTION, e);
    }
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */
    setMinResolution(e) {
      this.set(qt.MIN_RESOLUTION, e);
    }
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */
    setMaxZoom(e) {
      this.set(qt.MAX_ZOOM, e);
    }
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */
    setMinZoom(e) {
      this.set(qt.MIN_ZOOM, e);
    }
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */
    setOpacity(e) {
      Mt(typeof e == "number", "Layer opacity must be a number"), this.set(qt.OPACITY, e);
    }
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */
    setVisible(e) {
      this.set(qt.VISIBLE, e);
    }
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */
    setZIndex(e) {
      this.set(qt.Z_INDEX, e);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
    }
  }
  const Ai = {
    ANIMATING: 0,
    INTERACTING: 1
  }, vs = {
    CENTER: "center",
    RESOLUTION: "resolution",
    ROTATION: "rotation"
  }, NU = 42, Hv = 256;
  function xD(t, e, i) {
    return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number|undefined} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @param {Array<number>} [centerShift] Shift between map center and viewport center.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function(r, n, s, o, a) {
        if (!r)
          return;
        if (!n && !e)
          return r;
        const A = e ? 0 : s[0] * n, l = e ? 0 : s[1] * n, c = a ? a[0] : 0, u = a ? a[1] : 0;
        let d = t[0] + A / 2 + c, h = t[2] - A / 2 + c, g = t[1] + l / 2 + u, f = t[3] - l / 2 + u;
        d > h && (d = (h + d) / 2, h = d), g > f && (g = (f + g) / 2, f = g);
        let p = yi(r[0], d, h), m = yi(r[1], g, f);
        if (o && i && n) {
          const E = 30 * n;
          p += -E * Math.log(1 + Math.max(0, d - r[0]) / E) + E * Math.log(1 + Math.max(0, r[0] - h) / E), m += -E * Math.log(1 + Math.max(0, g - r[1]) / E) + E * Math.log(1 + Math.max(0, r[1] - f) / E);
        }
        return [p, m];
      }
    );
  }
  function mee(t) {
    return t;
  }
  function Jv(t, e, i, r) {
    const n = mt(e) / i[0], s = Fi(e) / i[1];
    return r ? Math.min(t, Math.max(n, s)) : Math.min(t, Math.min(n, s));
  }
  function Vv(t, e, i) {
    let r = Math.min(t, e);
    const n = 50;
    return r *= Math.log(1 + n * Math.max(0, t / e - 1)) / n + 1, i && (r = Math.max(r, i), r /= Math.log(1 + n * Math.max(0, i / t - 1)) / n + 1), yi(r, i / 2, e * 2);
  }
  function Eee(t, e, i, r) {
    return e = e !== void 0 ? e : !0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(n, s, o, a) {
      if (n !== void 0) {
        const A = t[0], l = t[t.length - 1], c = i ? Jv(
          A,
          i,
          o,
          r
        ) : A;
        if (a)
          return e ? Vv(
            n,
            c,
            l
          ) : yi(n, l, c);
        const u = Math.min(c, n), d = Math.floor(nB(t, u, s));
        return t[d] > c && d < t.length - 1 ? t[d + 1] : t[d];
      }
    };
  }
  function yee(t, e, i, r, n, s) {
    return r = r !== void 0 ? r : !0, i = i !== void 0 ? i : 0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(o, a, A, l) {
      if (o !== void 0) {
        const c = n ? Jv(
          e,
          n,
          A,
          s
        ) : e;
        if (l)
          return r ? Vv(
            o,
            c,
            i
          ) : yi(o, i, c);
        const u = 1e-9, d = Math.ceil(
          Math.log(e / c) / Math.log(t) - u
        ), h = -a * (0.5 - u) + 0.5, g = Math.min(c, o), f = Math.floor(
          Math.log(e / g) / Math.log(t) + h
        ), p = Math.max(d, f), m = e / Math.pow(t, p);
        return yi(m, i, c);
      }
    };
  }
  function QD(t, e, i, r, n) {
    return i = i !== void 0 ? i : !0, /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(s, o, a, A) {
      if (s !== void 0) {
        const l = r ? Jv(
          t,
          r,
          a,
          n
        ) : t;
        return !i || !A ? yi(s, e, l) : Vv(
          s,
          l,
          e
        );
      }
    };
  }
  function Wv(t) {
    if (t !== void 0)
      return 0;
  }
  function FD(t) {
    if (t !== void 0)
      return t;
  }
  function Bee(t) {
    const e = 2 * Math.PI / t;
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(i, r) {
        if (r)
          return i;
        if (i !== void 0)
          return i = Math.floor(i / e + 0.5) * e, i;
      }
    );
  }
  function wee(t) {
    const e = BA(5);
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(i, r) {
        return r || i === void 0 ? i : Math.abs(i) <= e ? 0 : i;
      }
    );
  }
  function UU(t) {
    return Math.pow(t, 3);
  }
  function Yd(t) {
    return 1 - UU(1 - t);
  }
  function Cee(t) {
    return 3 * t * t - 2 * t * t * t;
  }
  function bee(t) {
    return t;
  }
  const b0 = 0;
  class Ds extends no {
    /**
     * @param {ViewOptions} [options] View options.
     */
    constructor(e) {
      super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = wv(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && lU(), e.center && (e.center = di(e.center, this.projection_)), e.extent && (e.extent = is(e.extent, this.projection_)), this.applyOptions_(e);
    }
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */
    applyOptions_(e) {
      const i = Object.assign({}, e);
      for (const a in vs)
        delete i[a];
      this.setProperties(i, !0);
      const r = Iee(e);
      this.maxResolution_ = r.maxResolution, this.minResolution_ = r.minResolution, this.zoomFactor_ = r.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = r.minZoom;
      const n = Mee(e), s = r.constraint, o = vee(e);
      this.constraints_ = {
        center: n,
        resolution: s,
        rotation: o
      }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
        e.center !== void 0 ? e.center : null
      ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
    }
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */
    get padding() {
      return this.padding_;
    }
    set padding(e) {
      let i = this.padding_;
      this.padding_ = e;
      const r = this.getCenterInternal();
      if (r) {
        const n = e || [0, 0, 0, 0];
        i = i || [0, 0, 0, 0];
        const s = this.getResolution(), o = s / 2 * (n[3] - i[3] + i[1] - n[1]), a = s / 2 * (n[0] - i[0] + i[2] - n[2]);
        this.setCenterInternal([r[0] + o, r[1] - a]);
      }
    }
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */
    getUpdatedOptions_(e) {
      const i = this.getProperties();
      return i.resolution !== void 0 ? i.resolution = this.getResolution() : i.zoom = this.getZoom(), i.center = this.getCenterInternal(), i.rotation = this.getRotation(), Object.assign({}, i, e);
    }
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */
    animate(e) {
      this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
      const i = new Array(arguments.length);
      for (let r = 0; r < i.length; ++r) {
        let n = arguments[r];
        n.center && (n = Object.assign({}, n), n.center = di(
          n.center,
          this.getProjection()
        )), n.anchor && (n = Object.assign({}, n), n.anchor = di(
          n.anchor,
          this.getProjection()
        )), i[r] = n;
      }
      this.animateInternal.apply(this, i);
    }
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */
    animateInternal(e) {
      let i = arguments.length, r;
      i > 1 && typeof arguments[i - 1] == "function" && (r = arguments[i - 1], --i);
      let n = 0;
      for (; n < i && !this.isDef(); ++n) {
        const c = arguments[n];
        c.center && this.setCenterInternal(c.center), c.zoom !== void 0 ? this.setZoom(c.zoom) : c.resolution && this.setResolution(c.resolution), c.rotation !== void 0 && this.setRotation(c.rotation);
      }
      if (n === i) {
        r && sp(r, !0);
        return;
      }
      let s = Date.now(), o = this.targetCenter_.slice(), a = this.targetResolution_, A = this.targetRotation_;
      const l = [];
      for (; n < i; ++n) {
        const c = (
          /** @type {AnimationOptions} */
          arguments[n]
        ), u = {
          start: s,
          complete: !1,
          anchor: c.anchor,
          duration: c.duration !== void 0 ? c.duration : 1e3,
          easing: c.easing || Cee,
          callback: r
        };
        if (c.center && (u.sourceCenter = o, u.targetCenter = c.center.slice(), o = u.targetCenter), c.zoom !== void 0 ? (u.sourceResolution = a, u.targetResolution = this.getResolutionForZoom(c.zoom), a = u.targetResolution) : c.resolution && (u.sourceResolution = a, u.targetResolution = c.resolution, a = u.targetResolution), c.rotation !== void 0) {
          u.sourceRotation = A;
          const d = pa(c.rotation - A + Math.PI, 2 * Math.PI) - Math.PI;
          u.targetRotation = A + d, A = u.targetRotation;
        }
        xee(u) ? u.complete = !0 : s += u.duration, l.push(u);
      }
      this.animations_.push(l), this.setHint(Ai.ANIMATING, 1), this.updateAnimations_();
    }
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */
    getAnimating() {
      return this.hints_[Ai.ANIMATING] > 0;
    }
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */
    getInteracting() {
      return this.hints_[Ai.INTERACTING] > 0;
    }
    /**
     * Cancel any ongoing animations.
     * @api
     */
    cancelAnimations() {
      this.setHint(Ai.ANIMATING, -this.hints_[Ai.ANIMATING]);
      let e;
      for (let i = 0, r = this.animations_.length; i < r; ++i) {
        const n = this.animations_[i];
        if (n[0].callback && sp(n[0].callback, !1), !e)
          for (let s = 0, o = n.length; s < o; ++s) {
            const a = n[s];
            if (!a.complete) {
              e = a.anchor;
              break;
            }
          }
      }
      this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
    }
    /**
     * Update all animations.
     */
    updateAnimations_() {
      if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
        return;
      const e = Date.now();
      let i = !1;
      for (let r = this.animations_.length - 1; r >= 0; --r) {
        const n = this.animations_[r];
        let s = !0;
        for (let o = 0, a = n.length; o < a; ++o) {
          const A = n[o];
          if (A.complete)
            continue;
          const l = e - A.start;
          let c = A.duration > 0 ? l / A.duration : 1;
          c >= 1 ? (A.complete = !0, c = 1) : s = !1;
          const u = A.easing(c);
          if (A.sourceCenter) {
            const d = A.sourceCenter[0], h = A.sourceCenter[1], g = A.targetCenter[0], f = A.targetCenter[1];
            this.nextCenter_ = A.targetCenter;
            const p = d + u * (g - d), m = h + u * (f - h);
            this.targetCenter_ = [p, m];
          }
          if (A.sourceResolution && A.targetResolution) {
            const d = u === 1 ? A.targetResolution : A.sourceResolution + u * (A.targetResolution - A.sourceResolution);
            if (A.anchor) {
              const h = this.getViewportSize_(this.getRotation()), g = this.constraints_.resolution(
                d,
                0,
                h,
                !0
              );
              this.targetCenter_ = this.calculateCenterZoom(
                g,
                A.anchor
              );
            }
            this.nextResolution_ = A.targetResolution, this.targetResolution_ = d, this.applyTargetState_(!0);
          }
          if (A.sourceRotation !== void 0 && A.targetRotation !== void 0) {
            const d = u === 1 ? pa(A.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : A.sourceRotation + u * (A.targetRotation - A.sourceRotation);
            if (A.anchor) {
              const h = this.constraints_.rotation(
                d,
                !0
              );
              this.targetCenter_ = this.calculateCenterRotate(
                h,
                A.anchor
              );
            }
            this.nextRotation_ = A.targetRotation, this.targetRotation_ = d;
          }
          if (this.applyTargetState_(!0), i = !0, !A.complete)
            break;
        }
        if (s) {
          this.animations_[r] = null, this.setHint(Ai.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
          const o = n[0].callback;
          o && sp(o, !0);
        }
      }
      this.animations_ = this.animations_.filter(Boolean), i && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      ));
    }
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */
    calculateCenterRotate(e, i) {
      let r;
      const n = this.getCenterInternal();
      return n !== void 0 && (r = [n[0] - i[0], n[1] - i[1]], pv(r, e - this.getRotation()), eU(r, i)), r;
    }
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */
    calculateCenterZoom(e, i) {
      let r;
      const n = this.getCenterInternal(), s = this.getResolution();
      if (n !== void 0 && s !== void 0) {
        const o = i[0] - e * (i[0] - n[0]) / s, a = i[1] - e * (i[1] - n[1]) / s;
        r = [o, a];
      }
      return r;
    }
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */
    getViewportSize_(e) {
      const i = this.viewportSize_;
      if (e) {
        const r = i[0], n = i[1];
        return [
          Math.abs(r * Math.cos(e)) + Math.abs(n * Math.sin(e)),
          Math.abs(r * Math.sin(e)) + Math.abs(n * Math.cos(e))
        ];
      }
      return i;
    }
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
     */
    setViewportSize(e) {
      this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
    }
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */
    getCenter() {
      const e = this.getCenterInternal();
      return e && QA(e, this.getProjection());
    }
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */
    getCenterInternal() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(vs.CENTER)
      );
    }
    /**
     * @return {Constraints} Constraints.
     */
    getConstraints() {
      return this.constraints_;
    }
    /**
     * @return {boolean} Resolution constraint is set
     */
    getConstrainResolution() {
      return this.get("constrainResolution");
    }
    /**
     * @param {Array<number>} [hints] Destination array.
     * @return {Array<number>} Hint.
     */
    getHints(e) {
      return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
    }
    /**
     * Calculate the extent for the current view state and the passed box size.
     * @param {import("./size.js").Size} [size] The pixel dimensions of the box
     * into which the calculated extent should fit. Defaults to the size of the
     * map the view is associated with.
     * If no map or multiple maps are connected to the view, provide the desired
     * box size (e.g. `map.getSize()`).
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */
    calculateExtent(e) {
      const i = this.calculateExtentInternal(e);
      return lf(i, this.getProjection());
    }
    /**
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */
    calculateExtentInternal(e) {
      e = e || this.getViewportSizeMinusPadding_();
      const i = (
        /** @type {!import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      Mt(i, "The view center is not defined");
      const r = (
        /** @type {!number} */
        this.getResolution()
      );
      Mt(r !== void 0, "The view resolution is not defined");
      const n = (
        /** @type {!number} */
        this.getRotation()
      );
      return Mt(n !== void 0, "The view rotation is not defined"), ag(i, r, n, e);
    }
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */
    getMaxResolution() {
      return this.maxResolution_;
    }
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */
    getMinResolution() {
      return this.minResolution_;
    }
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.minResolution_)
      );
    }
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */
    setMaxZoom(e) {
      this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
    }
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.maxResolution_)
      );
    }
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */
    setMinZoom(e) {
      this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
    }
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */
    setConstrainResolution(e) {
      this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
    }
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */
    getProjection() {
      return this.projection_;
    }
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */
    getResolution() {
      return (
        /** @type {number|undefined} */
        this.get(vs.RESOLUTION)
      );
    }
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */
    getResolutionForExtent(e, i) {
      return this.getResolutionForExtentInternal(
        is(e, this.getProjection()),
        i
      );
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */
    getResolutionForExtentInternal(e, i) {
      i = i || this.getViewportSizeMinusPadding_();
      const r = mt(e) / i[0], n = Fi(e) / i[1];
      return Math.max(r, n);
    }
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Resolution for value function.
     */
    getResolutionForValueFunction(e) {
      e = e || 2;
      const i = this.getConstrainedResolution(this.maxResolution_), r = this.minResolution_, n = Math.log(i / r) / Math.log(e);
      return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function(s) {
          return i / Math.pow(e, s * n);
        }
      );
    }
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */
    getRotation() {
      return (
        /** @type {number} */
        this.get(vs.ROTATION)
      );
    }
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Value for resolution function.
     */
    getValueForResolutionFunction(e) {
      const i = Math.log(e || 2), r = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, s = Math.log(r / n) / i;
      return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function(o) {
          return Math.log(r / o) / i / s;
        }
      );
    }
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */
    getViewportSizeMinusPadding_(e) {
      let i = this.getViewportSize_(e);
      const r = this.padding_;
      return r && (i = [
        i[0] - r[1] - r[3],
        i[1] - r[0] - r[2]
      ]), i;
    }
    /**
     * @return {State} View state.
     */
    getState() {
      const e = this.getProjection(), i = this.getResolution(), r = this.getRotation();
      let n = (
        /** @type {import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      const s = this.padding_;
      if (s) {
        const o = this.getViewportSizeMinusPadding_();
        n = M0(
          n,
          this.getViewportSize_(),
          [o[0] / 2 + s[3], o[1] / 2 + s[0]],
          i,
          r
        );
      }
      return {
        center: n.slice(0),
        projection: e !== void 0 ? e : null,
        resolution: i,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation: r,
        zoom: this.getZoom()
      };
    }
    /**
     * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
     */
    getViewStateAndExtent() {
      return {
        viewState: this.getState(),
        extent: this.calculateExtent()
      };
    }
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */
    getZoom() {
      let e;
      const i = this.getResolution();
      return i !== void 0 && (e = this.getZoomForResolution(i)), e;
    }
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */
    getZoomForResolution(e) {
      let i = this.minZoom_ || 0, r, n;
      if (this.resolutions_) {
        const s = nB(this.resolutions_, e, 1);
        i = s, r = this.resolutions_[s], s == this.resolutions_.length - 1 ? n = 2 : n = r / this.resolutions_[s + 1];
      } else
        r = this.maxResolution_, n = this.zoomFactor_;
      return i + Math.log(r / e) / Math.log(n);
    }
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */
    getResolutionForZoom(e) {
      var i;
      if ((i = this.resolutions_) != null && i.length) {
        if (this.resolutions_.length === 1)
          return this.resolutions_[0];
        const r = yi(
          Math.floor(e),
          0,
          this.resolutions_.length - 2
        ), n = this.resolutions_[r] / this.resolutions_[r + 1];
        return this.resolutions_[r] / Math.pow(n, yi(e - r, 0, 1));
      }
      return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
    }
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [options] Options.
     * @api
     */
    fit(e, i) {
      let r;
      if (Mt(
        Array.isArray(e) || typeof /** @type {?} */
        e.getSimplifiedGeometry == "function",
        "Invalid extent or geometry provided as `geometry`"
      ), Array.isArray(e)) {
        Mt(
          !GA(e),
          "Cannot fit empty extent provided as `geometry`"
        );
        const n = is(e, this.getProjection());
        r = mD(n);
      } else if (e.getType() === "Circle") {
        const n = is(
          e.getExtent(),
          this.getProjection()
        );
        r = mD(n), r.rotate(this.getRotation(), xn(n));
      } else
        r = e;
      this.fitInternal(r, i);
    }
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */
    rotatedExtentForGeometry(e) {
      const i = this.getRotation(), r = Math.cos(i), n = Math.sin(-i), s = e.getFlatCoordinates(), o = e.getStride();
      let a = 1 / 0, A = 1 / 0, l = -1 / 0, c = -1 / 0;
      for (let u = 0, d = s.length; u < d; u += o) {
        const h = s[u] * r - s[u + 1] * n, g = s[u] * n + s[u + 1] * r;
        a = Math.min(a, h), A = Math.min(A, g), l = Math.max(l, h), c = Math.max(c, g);
      }
      return [a, A, l, c];
    }
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [options] Options.
     */
    fitInternal(e, i) {
      i = i || {};
      let r = i.size;
      r || (r = this.getViewportSizeMinusPadding_());
      const n = i.padding !== void 0 ? i.padding : [0, 0, 0, 0], s = i.nearest !== void 0 ? i.nearest : !1;
      let o;
      i.minResolution !== void 0 ? o = i.minResolution : i.maxZoom !== void 0 ? o = this.getResolutionForZoom(i.maxZoom) : o = 0;
      const a = this.rotatedExtentForGeometry(e);
      let A = this.getResolutionForExtentInternal(a, [
        r[0] - n[1] - n[3],
        r[1] - n[0] - n[2]
      ]);
      A = isNaN(A) ? o : Math.max(A, o), A = this.getConstrainedResolution(A, s ? 0 : 1);
      const l = this.getRotation(), c = Math.sin(l), u = Math.cos(l), d = xn(a);
      d[0] += (n[1] - n[3]) / 2 * A, d[1] += (n[0] - n[2]) / 2 * A;
      const h = d[0] * u - d[1] * c, g = d[1] * u + d[0] * c, f = this.getConstrainedCenter([h, g], A), p = i.callback ? i.callback : $u;
      i.duration !== void 0 ? this.animateInternal(
        {
          resolution: A,
          center: f,
          duration: i.duration,
          easing: i.easing
        },
        p
      ) : (this.targetResolution_ = A, this.targetCenter_ = f, this.applyTargetState_(!1, !0), sp(p, !0));
    }
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */
    centerOn(e, i, r) {
      this.centerOnInternal(
        di(e, this.getProjection()),
        i,
        r
      );
    }
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */
    centerOnInternal(e, i, r) {
      this.setCenterInternal(
        M0(
          e,
          i,
          r,
          this.getResolution(),
          this.getRotation()
        )
      );
    }
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */
    calculateCenterShift(e, i, r, n) {
      let s;
      const o = this.padding_;
      if (o && e) {
        const a = this.getViewportSizeMinusPadding_(-r), A = M0(
          e,
          n,
          [a[0] / 2 + o[3], a[1] / 2 + o[0]],
          i,
          r
        );
        s = [
          e[0] - A[0],
          e[1] - A[1]
        ];
      }
      return s;
    }
    /**
     * @return {boolean} Is defined.
     */
    isDef() {
      return !!this.getCenterInternal() && this.getResolution() !== void 0;
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */
    adjustCenter(e) {
      const i = QA(this.targetCenter_, this.getProjection());
      this.setCenter([
        i[0] + e[0],
        i[1] + e[1]
      ]);
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */
    adjustCenterInternal(e) {
      const i = this.targetCenter_;
      this.setCenterInternal([
        i[0] + e[0],
        i[1] + e[1]
      ]);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustResolution(e, i) {
      i = i && di(i, this.getProjection()), this.adjustResolutionInternal(e, i);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    adjustResolutionInternal(e, i) {
      const r = this.getAnimating() || this.getInteracting(), n = this.getViewportSize_(this.getRotation()), s = this.constraints_.resolution(
        this.targetResolution_ * e,
        0,
        n,
        r
      );
      i && (this.targetCenter_ = this.calculateCenterZoom(s, i)), this.targetResolution_ *= e, this.applyTargetState_();
    }
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustZoom(e, i) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -e), i);
    }
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     * @api
     */
    adjustRotation(e, i) {
      i && (i = di(i, this.getProjection())), this.adjustRotationInternal(e, i);
    }
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     */
    adjustRotationInternal(e, i) {
      const r = this.getAnimating() || this.getInteracting(), n = this.constraints_.rotation(
        this.targetRotation_ + e,
        r
      );
      i && (this.targetCenter_ = this.calculateCenterRotate(n, i)), this.targetRotation_ += e, this.applyTargetState_();
    }
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */
    setCenter(e) {
      this.setCenterInternal(
        e && di(e, this.getProjection())
      );
    }
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */
    setCenterInternal(e) {
      this.targetCenter_ = e, this.applyTargetState_();
    }
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */
    setHint(e, i) {
      return this.hints_[e] += i, this.changed(), this.hints_[e];
    }
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */
    setResolution(e) {
      this.targetResolution_ = e, this.applyTargetState_();
    }
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */
    setRotation(e) {
      this.targetRotation_ = e, this.applyTargetState_();
    }
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */
    setZoom(e) {
      this.setResolution(this.getResolutionForZoom(e));
    }
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
     * @private
     */
    applyTargetState_(e, i) {
      const r = this.getAnimating() || this.getInteracting() || i, n = this.constraints_.rotation(
        this.targetRotation_,
        r
      ), s = this.getViewportSize_(n), o = this.constraints_.resolution(
        this.targetResolution_,
        0,
        s,
        r
      ), a = this.constraints_.center(
        this.targetCenter_,
        o,
        s,
        r,
        this.calculateCenterShift(
          this.targetCenter_,
          o,
          n,
          s
        )
      );
      this.get(vs.ROTATION) !== n && this.set(vs.ROTATION, n), this.get(vs.RESOLUTION) !== o && (this.set(vs.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!a || !this.get(vs.CENTER) || !Hr(this.get(vs.CENTER), a)) && this.set(vs.CENTER, a), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
    }
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [duration] The animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    resolveConstraints(e, i, r) {
      e = e !== void 0 ? e : 200;
      const n = i || 0, s = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(s), a = this.constraints_.resolution(
        this.targetResolution_,
        n,
        o
      ), A = this.constraints_.center(
        this.targetCenter_,
        a,
        o,
        !1,
        this.calculateCenterShift(
          this.targetCenter_,
          a,
          s,
          o
        )
      );
      if (e === 0 && !this.cancelAnchor_) {
        this.targetResolution_ = a, this.targetRotation_ = s, this.targetCenter_ = A, this.applyTargetState_();
        return;
      }
      r = r || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== a || this.getRotation() !== s || !this.getCenterInternal() || !Hr(this.getCenterInternal(), A)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
        rotation: s,
        center: A,
        resolution: a,
        duration: e,
        easing: Yd,
        anchor: r
      }));
    }
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */
    beginInteraction() {
      this.resolveConstraints(0), this.setHint(Ai.INTERACTING, 1);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    endInteraction(e, i, r) {
      r = r && di(r, this.getProjection()), this.endInteractionInternal(e, i, r);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    endInteractionInternal(e, i, r) {
      this.getInteracting() && (this.setHint(Ai.INTERACTING, -1), this.resolveConstraints(e, i, r));
    }
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */
    getConstrainedCenter(e, i) {
      const r = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(
        e,
        i || this.getResolution(),
        r
      );
    }
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */
    getConstrainedZoom(e, i) {
      const r = this.getResolutionForZoom(e);
      return this.getZoomForResolution(
        this.getConstrainedResolution(r, i)
      );
    }
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */
    getConstrainedResolution(e, i) {
      i = i || 0;
      const r = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(e, i, r);
    }
  }
  function sp(t, e) {
    setTimeout(function() {
      t(e);
    }, 0);
  }
  function Mee(t) {
    if (t.extent !== void 0) {
      const i = t.smoothExtentConstraint !== void 0 ? t.smoothExtentConstraint : !0;
      return xD(t.extent, t.constrainOnlyCenter, i);
    }
    const e = wv(t.projection, "EPSG:3857");
    if (t.multiWorld !== !0 && e.isGlobal()) {
      const i = e.getExtent().slice();
      return i[0] = -1 / 0, i[2] = 1 / 0, xD(i, !1, !1);
    }
    return mee;
  }
  function Iee(t) {
    let e, i, r, o = t.minZoom !== void 0 ? t.minZoom : b0, a = t.maxZoom !== void 0 ? t.maxZoom : 28;
    const A = t.zoomFactor !== void 0 ? t.zoomFactor : 2, l = t.multiWorld !== void 0 ? t.multiWorld : !1, c = t.smoothResolutionConstraint !== void 0 ? t.smoothResolutionConstraint : !0, u = t.showFullExtent !== void 0 ? t.showFullExtent : !1, d = wv(t.projection, "EPSG:3857"), h = d.getExtent();
    let g = t.constrainOnlyCenter, f = t.extent;
    if (!l && !f && d.isGlobal() && (g = !1, f = h), t.resolutions !== void 0) {
      const p = t.resolutions;
      i = p[o], r = p[a] !== void 0 ? p[a] : p[p.length - 1], t.constrainResolution ? e = Eee(
        p,
        c,
        !g && f,
        u
      ) : e = QD(
        i,
        r,
        c,
        !g && f,
        u
      );
    } else {
      const m = (h ? Math.max(mt(h), Fi(h)) : (
        // use an extent that can fit the whole world if need be
        360 * Fa.degrees / d.getMetersPerUnit()
      )) / Hv / Math.pow(2, b0), E = m / Math.pow(2, 28 - b0);
      i = t.maxResolution, i !== void 0 ? o = 0 : i = m / Math.pow(A, o), r = t.minResolution, r === void 0 && (t.maxZoom !== void 0 ? t.maxResolution !== void 0 ? r = i / Math.pow(A, a) : r = m / Math.pow(A, a) : r = E), a = o + Math.floor(
        Math.log(i / r) / Math.log(A)
      ), r = i / Math.pow(A, a - o), t.constrainResolution ? e = yee(
        A,
        i,
        r,
        c,
        !g && f,
        u
      ) : e = QD(
        i,
        r,
        c,
        !g && f,
        u
      );
    }
    return {
      constraint: e,
      maxResolution: i,
      minResolution: r,
      minZoom: o,
      zoomFactor: A
    };
  }
  function vee(t) {
    if (t.enableRotation !== void 0 ? t.enableRotation : !0) {
      const i = t.constrainRotation;
      return i === void 0 || i === !0 ? wee() : i === !1 ? FD : typeof i == "number" ? Bee(i) : FD;
    }
    return Wv;
  }
  function xee(t) {
    return !(t.sourceCenter && t.targetCenter && !Hr(t.sourceCenter, t.targetCenter) || t.sourceResolution !== t.targetResolution || t.sourceRotation !== t.targetRotation);
  }
  function M0(t, e, i, r, n) {
    const s = Math.cos(-n);
    let o = Math.sin(-n), a = t[0] * s - t[1] * o, A = t[1] * s + t[0] * o;
    a += (e[0] / 2 - i[0]) * r, A += (i[1] - e[1] / 2) * r, o = -o;
    const l = a * s - A * o, c = A * s + a * o;
    return [l, c];
  }
  class HA extends YU {
    /**
     * @param {Options<SourceType>} options Layer options.
     */
    constructor(e) {
      const i = Object.assign({}, e);
      delete i.source, super(i), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
        qt.SOURCE,
        this.handleSourcePropertyChange_
      );
      const r = e.source ? (
        /** @type {SourceType} */
        e.source
      ) : null;
      this.setSource(r);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     * @override
     */
    getLayersArray(e) {
      return e = e || [], e.push(this), e;
    }
    /**
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     * @override
     */
    getLayerStatesArray(e) {
      return e = e || [], e.push(this.getLayerState()), e;
    }
    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */
    getSource() {
      return (
        /** @type {SourceType} */
        this.get(qt.SOURCE) || null
      );
    }
    /**
     * @return {SourceType|null} The source being rendered.
     */
    getRenderSource() {
      return this.getSource();
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     * @override
     */
    getSourceState() {
      const e = this.getSource();
      return e ? e.getState() : "undefined";
    }
    /**
     * @private
     */
    handleSourceChange_() {
      this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
    }
    /**
     * @private
     */
    handleSourcePropertyChange_() {
      this.sourceChangeKey_ && (Pt(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
      const e = this.getSource();
      e && (this.sourceChangeKey_ = nt(
        e,
        Ge.CHANGE,
        this.handleSourceChange_,
        this
      ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
        this.dispatchEvent("sourceready");
      }, 0))), this.changed();
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(e) {
      return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(e) {
      return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
    }
    /**
     * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
     * extent, not set to `visible: false`, and not inside a layer group that is set
     * to `visible: false`.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {boolean} The layer is visible in the map view.
     * @api
     */
    isVisible(e) {
      let i;
      const r = this.getMapInternal();
      !e && r && (e = r.getView()), e instanceof Ds ? i = {
        viewState: e.getState(),
        extent: e.calculateExtent()
      } : i = e, !i.layerStatesArray && r && (i.layerStatesArray = r.getLayerGroup().getLayerStatesArray());
      let n;
      if (i.layerStatesArray) {
        if (n = i.layerStatesArray.find(
          (o) => o.layer === this
        ), !n)
          return !1;
      } else
        n = this.getLayerState();
      const s = this.getExtent();
      return Kv(n, i.viewState) && (!s || Yi(s, i.extent));
    }
    /**
     * Get the attributions of the source of this layer for the given view.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {Array<string>} Attributions for this layer at the given view.
     * @api
     */
    getAttributions(e) {
      var s;
      if (!this.isVisible(e))
        return [];
      const i = (s = this.getSource()) == null ? void 0 : s.getAttributions();
      if (!i)
        return [];
      const r = e instanceof Ds ? e.getViewStateAndExtent() : e;
      let n = i(r);
      return Array.isArray(n) || (n = [n]), n;
    }
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement|null} The rendered element.
     */
    render(e, i) {
      const r = this.getRenderer();
      return r.prepareFrame(e) ? (this.rendered = !0, r.renderFrame(e, i)) : null;
    }
    /**
     * Called when a layer is not visible during a map render.
     */
    unrender() {
      this.rendered = !1;
    }
    /** @return {string} Declutter */
    getDeclutter() {
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../layer/Layer.js").State} layerState Layer state.
     */
    renderDeclutter(e, i) {
    }
    /**
     * When the renderer follows a layout -> render approach, do the final rendering here.
     * @param {import('../Map.js').FrameState} frameState Frame state
     */
    renderDeferred(e) {
      const i = this.getRenderer();
      i && i.renderDeferred(e);
    }
    /**
     * For use inside the library only.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMapInternal(e) {
      e || this.unrender(), this.set(qt.MAP, e);
    }
    /**
     * For use inside the library only.
     * @return {import("../Map.js").default|null} Map.
     */
    getMapInternal() {
      return this.get(qt.MAP);
    }
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(e) {
      this.mapPrecomposeKey_ && (Pt(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (Pt(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = nt(
        e,
        dr.PRECOMPOSE,
        this.handlePrecompose_,
        this
      ), this.mapRenderKey_ = nt(this, Ge.CHANGE, e.render, e), this.changed());
    }
    /**
     * @param {import("../events/Event.js").default} renderEvent Render event
     * @private
     */
    handlePrecompose_(e) {
      const i = (
        /** @type {import("../render/Event.js").default} */
        e.frameState.layerStatesArray
      ), r = this.getLayerState(!1);
      Mt(
        !i.some(
          (n) => n.layer === r.layer
        ),
        "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
      ), i.push(r);
    }
    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */
    setSource(e) {
      this.set(qt.SOURCE, e);
    }
    /**
     * Get the renderer for this layer.
     * @return {RendererType|null} The layer renderer.
     */
    getRenderer() {
      return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
    }
    /**
     * @return {boolean} The layer has a renderer.
     */
    hasRenderer() {
      return !!this.renderer_;
    }
    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */
    createRenderer() {
      return null;
    }
    /**
     * This will clear the renderer so that a new one can be created next time it is needed
     */
    clearRenderer() {
      this.renderer_ && (this.renderer_.dispose(), delete this.renderer_);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.clearRenderer(), this.setSource(null), super.disposeInternal();
    }
  }
  function Kv(t, e) {
    if (!t.visible)
      return !1;
    const i = e.resolution;
    if (i < t.minResolution || i >= t.maxResolution)
      return !1;
    const r = e.zoom;
    return r > t.minZoom && r <= t.maxZoom;
  }
  function LU(t, e, i = 0, r = t.length - 1, n = Qee) {
    for (; r > i; ) {
      if (r - i > 600) {
        const A = r - i + 1, l = e - i + 1, c = Math.log(A), u = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * u * (A - u) / A) * (l - A / 2 < 0 ? -1 : 1), h = Math.max(i, Math.floor(e - l * u / A + d)), g = Math.min(r, Math.floor(e + (A - l) * u / A + d));
        LU(t, e, h, g, n);
      }
      const s = t[e];
      let o = i, a = r;
      for (rh(t, i, e), n(t[r], s) > 0 && rh(t, i, r); o < a; ) {
        for (rh(t, o, a), o++, a--; n(t[o], s) < 0; ) o++;
        for (; n(t[a], s) > 0; ) a--;
      }
      n(t[i], s) === 0 ? rh(t, i, a) : (a++, rh(t, a, r)), a <= e && (i = a + 1), e <= a && (r = a - 1);
    }
  }
  function rh(t, e, i) {
    const r = t[e];
    t[e] = t[i], t[i] = r;
  }
  function Qee(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  let zU = class {
    constructor(e = 9) {
      this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
    }
    all() {
      return this._all(this.data, []);
    }
    search(e) {
      let i = this.data;
      const r = [];
      if (!ap(e, i)) return r;
      const n = this.toBBox, s = [];
      for (; i; ) {
        for (let o = 0; o < i.children.length; o++) {
          const a = i.children[o], A = i.leaf ? n(a) : a;
          ap(e, A) && (i.leaf ? r.push(a) : v0(e, A) ? this._all(a, r) : s.push(a));
        }
        i = s.pop();
      }
      return r;
    }
    collides(e) {
      let i = this.data;
      if (!ap(e, i)) return !1;
      const r = [];
      for (; i; ) {
        for (let n = 0; n < i.children.length; n++) {
          const s = i.children[n], o = i.leaf ? this.toBBox(s) : s;
          if (ap(e, o)) {
            if (i.leaf || v0(e, o)) return !0;
            r.push(s);
          }
        }
        i = r.pop();
      }
      return !1;
    }
    load(e) {
      if (!(e && e.length)) return this;
      if (e.length < this._minEntries) {
        for (let r = 0; r < e.length; r++)
          this.insert(e[r]);
        return this;
      }
      let i = this._build(e.slice(), 0, e.length - 1, 0);
      if (!this.data.children.length)
        this.data = i;
      else if (this.data.height === i.height)
        this._splitRoot(this.data, i);
      else {
        if (this.data.height < i.height) {
          const r = this.data;
          this.data = i, i = r;
        }
        this._insert(i, this.data.height - i.height - 1, !0);
      }
      return this;
    }
    insert(e) {
      return e && this._insert(e, this.data.height - 1), this;
    }
    clear() {
      return this.data = Vc([]), this;
    }
    remove(e, i) {
      if (!e) return this;
      let r = this.data;
      const n = this.toBBox(e), s = [], o = [];
      let a, A, l;
      for (; r || s.length; ) {
        if (r || (r = s.pop(), A = s[s.length - 1], a = o.pop(), l = !0), r.leaf) {
          const c = Fee(e, r.children, i);
          if (c !== -1)
            return r.children.splice(c, 1), s.push(r), this._condense(s), this;
        }
        !l && !r.leaf && v0(r, n) ? (s.push(r), o.push(a), a = 0, A = r, r = r.children[0]) : A ? (a++, r = A.children[a], l = !1) : r = null;
      }
      return this;
    }
    toBBox(e) {
      return e;
    }
    compareMinX(e, i) {
      return e.minX - i.minX;
    }
    compareMinY(e, i) {
      return e.minY - i.minY;
    }
    toJSON() {
      return this.data;
    }
    fromJSON(e) {
      return this.data = e, this;
    }
    _all(e, i) {
      const r = [];
      for (; e; )
        e.leaf ? i.push(...e.children) : r.push(...e.children), e = r.pop();
      return i;
    }
    _build(e, i, r, n) {
      const s = r - i + 1;
      let o = this._maxEntries, a;
      if (s <= o)
        return a = Vc(e.slice(i, r + 1)), Mc(a, this.toBBox), a;
      n || (n = Math.ceil(Math.log(s) / Math.log(o)), o = Math.ceil(s / Math.pow(o, n - 1))), a = Vc([]), a.leaf = !1, a.height = n;
      const A = Math.ceil(s / o), l = A * Math.ceil(Math.sqrt(o));
      SD(e, i, r, l, this.compareMinX);
      for (let c = i; c <= r; c += l) {
        const u = Math.min(c + l - 1, r);
        SD(e, c, u, A, this.compareMinY);
        for (let d = c; d <= u; d += A) {
          const h = Math.min(d + A - 1, u);
          a.children.push(this._build(e, d, h, n - 1));
        }
      }
      return Mc(a, this.toBBox), a;
    }
    _chooseSubtree(e, i, r, n) {
      for (; n.push(i), !(i.leaf || n.length - 1 === r); ) {
        let s = 1 / 0, o = 1 / 0, a;
        for (let A = 0; A < i.children.length; A++) {
          const l = i.children[A], c = I0(l), u = Tee(e, l) - c;
          u < o ? (o = u, s = c < s ? c : s, a = l) : u === o && c < s && (s = c, a = l);
        }
        i = a || i.children[0];
      }
      return i;
    }
    _insert(e, i, r) {
      const n = r ? e : this.toBBox(e), s = [], o = this._chooseSubtree(n, this.data, i, s);
      for (o.children.push(e), ph(o, n); i >= 0 && s[i].children.length > this._maxEntries; )
        this._split(s, i), i--;
      this._adjustParentBBoxes(n, s, i);
    }
    // split overflowed node into two
    _split(e, i) {
      const r = e[i], n = r.children.length, s = this._minEntries;
      this._chooseSplitAxis(r, s, n);
      const o = this._chooseSplitIndex(r, s, n), a = Vc(r.children.splice(o, r.children.length - o));
      a.height = r.height, a.leaf = r.leaf, Mc(r, this.toBBox), Mc(a, this.toBBox), i ? e[i - 1].children.push(a) : this._splitRoot(r, a);
    }
    _splitRoot(e, i) {
      this.data = Vc([e, i]), this.data.height = e.height + 1, this.data.leaf = !1, Mc(this.data, this.toBBox);
    }
    _chooseSplitIndex(e, i, r) {
      let n, s = 1 / 0, o = 1 / 0;
      for (let a = i; a <= r - i; a++) {
        const A = fh(e, 0, a, this.toBBox), l = fh(e, a, r, this.toBBox), c = Ree(A, l), u = I0(A) + I0(l);
        c < s ? (s = c, n = a, o = u < o ? u : o) : c === s && u < o && (o = u, n = a);
      }
      return n || r - i;
    }
    // sorts node children by the best axis for split
    _chooseSplitAxis(e, i, r) {
      const n = e.leaf ? this.compareMinX : See, s = e.leaf ? this.compareMinY : Dee, o = this._allDistMargin(e, i, r, n), a = this._allDistMargin(e, i, r, s);
      o < a && e.children.sort(n);
    }
    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(e, i, r, n) {
      e.children.sort(n);
      const s = this.toBBox, o = fh(e, 0, i, s), a = fh(e, r - i, r, s);
      let A = op(o) + op(a);
      for (let l = i; l < r - i; l++) {
        const c = e.children[l];
        ph(o, e.leaf ? s(c) : c), A += op(o);
      }
      for (let l = r - i - 1; l >= i; l--) {
        const c = e.children[l];
        ph(a, e.leaf ? s(c) : c), A += op(a);
      }
      return A;
    }
    _adjustParentBBoxes(e, i, r) {
      for (let n = r; n >= 0; n--)
        ph(i[n], e);
    }
    _condense(e) {
      for (let i = e.length - 1, r; i >= 0; i--)
        e[i].children.length === 0 ? i > 0 ? (r = e[i - 1].children, r.splice(r.indexOf(e[i]), 1)) : this.clear() : Mc(e[i], this.toBBox);
    }
  };
  function Fee(t, e, i) {
    if (!i) return e.indexOf(t);
    for (let r = 0; r < e.length; r++)
      if (i(t, e[r])) return r;
    return -1;
  }
  function Mc(t, e) {
    fh(t, 0, t.children.length, e, t);
  }
  function fh(t, e, i, r, n) {
    n || (n = Vc(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0;
    for (let s = e; s < i; s++) {
      const o = t.children[s];
      ph(n, t.leaf ? r(o) : o);
    }
    return n;
  }
  function ph(t, e) {
    return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;
  }
  function See(t, e) {
    return t.minX - e.minX;
  }
  function Dee(t, e) {
    return t.minY - e.minY;
  }
  function I0(t) {
    return (t.maxX - t.minX) * (t.maxY - t.minY);
  }
  function op(t) {
    return t.maxX - t.minX + (t.maxY - t.minY);
  }
  function Tee(t, e) {
    return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY));
  }
  function Ree(t, e) {
    const i = Math.max(t.minX, e.minX), r = Math.max(t.minY, e.minY), n = Math.min(t.maxX, e.maxX), s = Math.min(t.maxY, e.maxY);
    return Math.max(0, n - i) * Math.max(0, s - r);
  }
  function v0(t, e) {
    return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
  }
  function ap(t, e) {
    return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
  }
  function Vc(t) {
    return {
      children: t,
      height: 1,
      leaf: !0,
      minX: 1 / 0,
      minY: 1 / 0,
      maxX: -1 / 0,
      maxY: -1 / 0
    };
  }
  function SD(t, e, i, r, n) {
    const s = [e, i];
    for (; s.length; ) {
      if (i = s.pop(), e = s.pop(), i - e <= r) continue;
      const o = e + Math.ceil((i - e) / r / 2) * r;
      LU(t, o, e, i, n), s.push(e, o, o, i);
    }
  }
  function DD(t, e, i, r) {
    return i !== void 0 && r !== void 0 ? [i / t, r / e] : i !== void 0 ? i / t : r !== void 0 ? r / e : 1;
  }
  class Ol extends gB {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {};
      const i = e.opacity !== void 0 ? e.opacity : 1, r = e.rotation !== void 0 ? e.rotation : 0, n = e.scale !== void 0 ? e.scale : 1, s = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
      super({
        opacity: i,
        rotation: r,
        scale: n,
        displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
        rotateWithView: s,
        declutterMode: e.declutterMode
      }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
      const o = e.img !== void 0 ? e.img : null;
      let a = e.src;
      Mt(
        !(a !== void 0 && o),
        "`image` and `src` cannot be provided at the same time"
      ), (a === void 0 || a.length === 0) && o && (a = /** @type {HTMLImageElement} */
      o.src || ve(o)), Mt(
        a !== void 0 && a.length > 0,
        "A defined and non-empty `src` or `image` must be provided"
      ), Mt(
        !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
        "`width` or `height` cannot be provided together with `scale`"
      );
      let A;
      if (e.src !== void 0 ? A = ze.IDLE : o !== void 0 && ("complete" in o ? o.complete ? A = o.src ? ze.LOADED : ze.IDLE : A = ze.LOADING : A = ze.LOADED), this.color_ = e.color !== void 0 ? Hn(e.color) : null, this.iconImage_ = Ov(
        o,
        /** @type {string} */
        a,
        this.crossOrigin_,
        A,
        this.color_
      ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, this.initialOptions_, e.width !== void 0 || e.height !== void 0) {
        let l, c;
        if (e.size)
          [l, c] = e.size;
        else {
          const u = this.getImage(1);
          if (u.width && u.height)
            l = u.width, c = u.height;
          else if (u instanceof HTMLImageElement) {
            this.initialOptions_ = e;
            const d = () => {
              if (this.unlistenImageChange(d), !this.initialOptions_)
                return;
              const h = this.iconImage_.getSize();
              this.setScale(
                DD(
                  h[0],
                  h[1],
                  e.width,
                  e.height
                )
              );
            };
            this.listenImageChange(d);
            return;
          }
        }
        l !== void 0 && this.setScale(
          DD(l, c, e.width, e.height)
        );
      }
    }
    /**
     * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
     * @return {Icon} The cloned style.
     * @api
     * @override
     */
    clone() {
      let e, i, r;
      return this.initialOptions_ ? (i = this.initialOptions_.width, r = this.initialOptions_.height) : (e = this.getScale(), e = Array.isArray(e) ? e.slice() : e), new Ol({
        anchor: this.anchor_.slice(),
        anchorOrigin: this.anchorOrigin_,
        anchorXUnits: this.anchorXUnits_,
        anchorYUnits: this.anchorYUnits_,
        color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
        crossOrigin: this.crossOrigin_,
        offset: this.offset_.slice(),
        offsetOrigin: this.offsetOrigin_,
        opacity: this.getOpacity(),
        rotateWithView: this.getRotateWithView(),
        rotation: this.getRotation(),
        scale: e,
        width: i,
        height: r,
        size: this.size_ !== null ? this.size_.slice() : void 0,
        src: this.getSrc(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     * @override
     */
    getAnchor() {
      let e = this.normalizedAnchor_;
      if (!e) {
        e = this.anchor_;
        const n = this.getSize();
        if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
          if (!n)
            return null;
          e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= n[0]), this.anchorYUnits_ == "fraction" && (e[1] *= n[1]);
        }
        if (this.anchorOrigin_ != "top-left") {
          if (!n)
            return null;
          e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + n[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + n[1]);
        }
        this.normalizedAnchor_ = e;
      }
      const i = this.getDisplacement(), r = this.getScaleArray();
      return [
        e[0] - i[0] / r[0],
        e[1] + i[1] / r[1]
      ];
    }
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */
    setAnchor(e) {
      this.anchor_ = e, this.normalizedAnchor_ = null;
    }
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
     * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
     * @api
     * @override
     */
    getImage(e) {
      return this.iconImage_.getImage(e);
    }
    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     * @override
     */
    getPixelRatio(e) {
      return this.iconImage_.getPixelRatio(e);
    }
    /**
     * @return {import("../size.js").Size} Image size.
     * @override
     */
    getImageSize() {
      return this.iconImage_.getSize();
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     * @override
     */
    getImageState() {
      return this.iconImage_.getImageState();
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     * @override
     */
    getHitDetectionImage() {
      return this.iconImage_.getHitDetectionImage();
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     * @override
     */
    getOrigin() {
      if (this.origin_)
        return this.origin_;
      let e = this.offset_;
      if (this.offsetOrigin_ != "top-left") {
        const i = this.getSize(), r = this.iconImage_.getSize();
        if (!i || !r)
          return null;
        e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = r[0] - i[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = r[1] - i[1] - e[1]);
      }
      return this.origin_ = e, this.origin_;
    }
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */
    getSrc() {
      return this.iconImage_.getSrc();
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     * @override
     */
    getSize() {
      return this.size_ ? this.size_ : this.iconImage_.getSize();
    }
    /**
     * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon width (in pixels).
     * @api
     */
    getWidth() {
      const e = this.getScaleArray();
      if (this.size_)
        return this.size_[0] * e[0];
      if (this.iconImage_.getImageState() == ze.LOADED)
        return this.iconImage_.getSize()[0] * e[0];
    }
    /**
     * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon height (in pixels).
     * @api
     */
    getHeight() {
      const e = this.getScaleArray();
      if (this.size_)
        return this.size_[1] * e[1];
      if (this.iconImage_.getImageState() == ze.LOADED)
        return this.iconImage_.getSize()[1] * e[1];
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     * @override
     */
    setScale(e) {
      delete this.initialOptions_, super.setScale(e);
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    listenImageChange(e) {
      this.iconImage_.addEventListener(Ge.CHANGE, e);
    }
    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     * @override
     */
    load() {
      this.iconImage_.load();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     * @override
     */
    unlistenImageChange(e) {
      this.iconImage_.removeEventListener(Ge.CHANGE, e);
    }
    /**
     * @override
     */
    ready() {
      return this.iconImage_.ready();
    }
  }
  let Ac = 0;
  const Mr = 1 << Ac++, Ve = 1 << Ac++, sr = 1 << Ac++, Qi = 1 << Ac++, tn = 1 << Ac++, Ns = 1 << Ac++, Ap = Math.pow(2, Ac) - 1, Xv = {
    [Mr]: "boolean",
    [Ve]: "number",
    [sr]: "string",
    [Qi]: "color",
    [tn]: "number[]",
    [Ns]: "size"
  }, _ee = Object.keys(Xv).map(Number).sort(Qo);
  function kee(t) {
    return t in Xv;
  }
  function uu(t) {
    const e = [];
    for (const i of _ee)
      mh(t, i) && e.push(Xv[i]);
    return e.length === 0 ? "untyped" : e.length < 3 ? e.join(" or ") : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
  }
  function mh(t, e) {
    return (t & e) === e;
  }
  function Va(t, e) {
    return t === e;
  }
  class nr {
    /**
     * @param {number} type The value type.
     * @param {LiteralValue} value The literal value.
     */
    constructor(e, i) {
      if (!kee(e))
        throw new Error(
          `literal expressions must have a specific type, got ${uu(e)}`
        );
      this.type = e, this.value = i;
    }
  }
  class PU {
    /**
     * @param {number} type The return type.
     * @param {string} operator The operator.
     * @param {...Expression} args The arguments.
     */
    constructor(e, i, ...r) {
      this.type = e, this.operator = i, this.args = r;
    }
  }
  function Zv() {
    return {
      variables: /* @__PURE__ */ new Set(),
      properties: /* @__PURE__ */ new Set(),
      featureId: !1,
      geometryType: !1
    };
  }
  function Er(t, e, i) {
    switch (typeof t) {
      case "boolean": {
        if (Va(e, sr))
          return new nr(sr, t ? "true" : "false");
        if (!mh(e, Mr))
          throw new Error(
            `got a boolean, but expected ${uu(e)}`
          );
        return new nr(Mr, t);
      }
      case "number": {
        if (Va(e, Ns))
          return new nr(Ns, mr(t));
        if (Va(e, Mr))
          return new nr(Mr, !!t);
        if (Va(e, sr))
          return new nr(sr, t.toString());
        if (!mh(e, Ve))
          throw new Error(`got a number, but expected ${uu(e)}`);
        return new nr(Ve, t);
      }
      case "string": {
        if (Va(e, Qi))
          return new nr(Qi, Yv(t));
        if (Va(e, Mr))
          return new nr(Mr, !!t);
        if (!mh(e, sr))
          throw new Error(`got a string, but expected ${uu(e)}`);
        return new nr(sr, t);
      }
    }
    if (!Array.isArray(t))
      throw new Error("expression must be an array or a primitive value");
    if (t.length === 0)
      throw new Error("empty expression");
    if (typeof t[0] == "string")
      return Jee(t, e, i);
    for (const r of t)
      if (typeof r != "number")
        throw new Error("expected an array of numbers");
    if (Va(e, Ns)) {
      if (t.length !== 2)
        throw new Error(
          `expected an array of two values for a size, got ${t.length}`
        );
      return new nr(Ns, t);
    }
    if (Va(e, Qi)) {
      if (t.length === 3)
        return new nr(Qi, [...t, 1]);
      if (t.length === 4)
        return new nr(Qi, t);
      throw new Error(
        `expected an array of 3 or 4 values for a color, got ${t.length}`
      );
    }
    if (!mh(e, tn))
      throw new Error(
        `got an array of numbers, but expected ${uu(e)}`
      );
    return new nr(tn, t);
  }
  const te = {
    Get: "get",
    Var: "var",
    Concat: "concat",
    GeometryType: "geometry-type",
    LineMetric: "line-metric",
    Any: "any",
    All: "all",
    Not: "!",
    Resolution: "resolution",
    Zoom: "zoom",
    Time: "time",
    Equal: "==",
    NotEqual: "!=",
    GreaterThan: ">",
    GreaterThanOrEqualTo: ">=",
    LessThan: "<",
    LessThanOrEqualTo: "<=",
    Multiply: "*",
    Divide: "/",
    Add: "+",
    Subtract: "-",
    Clamp: "clamp",
    Mod: "%",
    Pow: "^",
    Abs: "abs",
    Floor: "floor",
    Ceil: "ceil",
    Round: "round",
    Sin: "sin",
    Cos: "cos",
    Atan: "atan",
    Sqrt: "sqrt",
    Match: "match",
    Between: "between",
    Interpolate: "interpolate",
    Coalesce: "coalesce",
    Case: "case",
    In: "in",
    Number: "number",
    String: "string",
    Array: "array",
    Color: "color",
    Id: "id",
    Band: "band",
    Palette: "palette",
    ToString: "to-string",
    Has: "has"
  }, Yee = {
    [te.Get]: ot(vt(1, 1 / 0), TD),
    [te.Var]: ot(vt(1, 1), Nee),
    [te.Has]: ot(vt(1, 1 / 0), TD),
    [te.Id]: ot(Uee, Ic),
    [te.Concat]: ot(
      vt(2, 1 / 0),
      Zt(sr)
    ),
    [te.GeometryType]: ot(Lee, Ic),
    [te.LineMetric]: ot(Ic),
    [te.Resolution]: ot(Ic),
    [te.Zoom]: ot(Ic),
    [te.Time]: ot(Ic),
    [te.Any]: ot(
      vt(2, 1 / 0),
      Zt(Mr)
    ),
    [te.All]: ot(
      vt(2, 1 / 0),
      Zt(Mr)
    ),
    [te.Not]: ot(
      vt(1, 1),
      Zt(Mr)
    ),
    [te.Equal]: ot(
      vt(2, 2),
      Zt(Ap)
    ),
    [te.NotEqual]: ot(
      vt(2, 2),
      Zt(Ap)
    ),
    [te.GreaterThan]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.GreaterThanOrEqualTo]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.LessThan]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.LessThanOrEqualTo]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.Multiply]: ot(
      vt(2, 1 / 0),
      RD
    ),
    [te.Coalesce]: ot(
      vt(2, 1 / 0),
      RD
    ),
    [te.Divide]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.Add]: ot(
      vt(2, 1 / 0),
      Zt(Ve)
    ),
    [te.Subtract]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.Clamp]: ot(
      vt(3, 3),
      Zt(Ve)
    ),
    [te.Mod]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.Pow]: ot(
      vt(2, 2),
      Zt(Ve)
    ),
    [te.Abs]: ot(
      vt(1, 1),
      Zt(Ve)
    ),
    [te.Floor]: ot(
      vt(1, 1),
      Zt(Ve)
    ),
    [te.Ceil]: ot(
      vt(1, 1),
      Zt(Ve)
    ),
    [te.Round]: ot(
      vt(1, 1),
      Zt(Ve)
    ),
    [te.Sin]: ot(
      vt(1, 1),
      Zt(Ve)
    ),
    [te.Cos]: ot(
      vt(1, 1),
      Zt(Ve)
    ),
    [te.Atan]: ot(
      vt(1, 2),
      Zt(Ve)
    ),
    [te.Sqrt]: ot(
      vt(1, 1),
      Zt(Ve)
    ),
    [te.Match]: ot(
      vt(4, 1 / 0),
      _D,
      Pee
    ),
    [te.Between]: ot(
      vt(3, 3),
      Zt(Ve)
    ),
    [te.Interpolate]: ot(
      vt(6, 1 / 0),
      _D,
      Oee
    ),
    [te.Case]: ot(
      vt(3, 1 / 0),
      zee,
      Gee
    ),
    [te.In]: ot(vt(2, 2), jee),
    [te.Number]: ot(
      vt(1, 1 / 0),
      Zt(Ap)
    ),
    [te.String]: ot(
      vt(1, 1 / 0),
      Zt(Ap)
    ),
    [te.Array]: ot(
      vt(1, 1 / 0),
      Zt(Ve)
    ),
    [te.Color]: ot(
      vt(1, 4),
      Zt(Ve)
    ),
    [te.Band]: ot(
      vt(1, 3),
      Zt(Ve)
    ),
    [te.Palette]: ot(
      vt(2, 2),
      Hee
    ),
    [te.ToString]: ot(
      vt(1, 1),
      Zt(Mr | Ve | sr | Qi)
    )
  };
  function TD(t, e, i) {
    const r = t.length - 1, n = new Array(r);
    for (let s = 0; s < r; ++s) {
      const o = t[s + 1];
      switch (typeof o) {
        case "number": {
          n[s] = new nr(Ve, o);
          break;
        }
        case "string": {
          n[s] = new nr(sr, o);
          break;
        }
        default:
          throw new Error(
            `expected a string key or numeric array index for a get operation, got ${o}`
          );
      }
      s === 0 && i.properties.add(String(o));
    }
    return n;
  }
  function Nee(t, e, i) {
    const r = t[1];
    if (typeof r != "string")
      throw new Error("expected a string argument for var operation");
    return i.variables.add(r), [new nr(sr, r)];
  }
  function Uee(t, e, i) {
    i.featureId = !0;
  }
  function Lee(t, e, i) {
    i.geometryType = !0;
  }
  function Ic(t, e, i) {
    const r = t[0];
    if (t.length !== 1)
      throw new Error(`expected no arguments for ${r} operation`);
    return [];
  }
  function vt(t, e) {
    return function(i, r, n) {
      const s = i[0], o = i.length - 1;
      if (t === e) {
        if (o !== t) {
          const a = t === 1 ? "" : "s";
          throw new Error(
            `expected ${t} argument${a} for ${s}, got ${o}`
          );
        }
      } else if (o < t || o > e) {
        const a = e === 1 / 0 ? `${t} or more` : `${t} to ${e}`;
        throw new Error(
          `expected ${a} arguments for ${s}, got ${o}`
        );
      }
    };
  }
  function RD(t, e, i) {
    const r = t.length - 1, n = new Array(r);
    for (let s = 0; s < r; ++s) {
      const o = Er(t[s + 1], e, i);
      n[s] = o;
    }
    return n;
  }
  function Zt(t) {
    return function(e, i, r) {
      const n = e.length - 1, s = new Array(n);
      for (let o = 0; o < n; ++o) {
        const a = Er(e[o + 1], t, r);
        s[o] = a;
      }
      return s;
    };
  }
  function zee(t, e, i) {
    const r = t[0], n = t.length - 1;
    if (n % 2 === 0)
      throw new Error(
        `expected an odd number of arguments for ${r}, got ${n} instead`
      );
  }
  function _D(t, e, i) {
    const r = t[0], n = t.length - 1;
    if (n % 2 === 1)
      throw new Error(
        `expected an even number of arguments for operation ${r}, got ${n} instead`
      );
  }
  function Pee(t, e, i) {
    const r = t.length - 1, n = sr | Ve | Mr, s = Er(t[1], n, i), o = Er(t[t.length - 1], e, i), a = new Array(r - 2);
    for (let A = 0; A < r - 2; A += 2) {
      try {
        const l = Er(t[A + 2], s.type, i);
        a[A] = l;
      } catch (l) {
        throw new Error(
          `failed to parse argument ${A + 1} of match expression: ${l.message}`
        );
      }
      try {
        const l = Er(t[A + 3], o.type, i);
        a[A + 1] = l;
      } catch (l) {
        throw new Error(
          `failed to parse argument ${A + 2} of match expression: ${l.message}`
        );
      }
    }
    return [s, ...a, o];
  }
  function Oee(t, e, i) {
    const r = t[1];
    let n;
    switch (r[0]) {
      case "linear":
        n = 1;
        break;
      case "exponential":
        const A = r[1];
        if (typeof A != "number" || A <= 0)
          throw new Error(
            `expected a number base for exponential interpolation, got ${JSON.stringify(A)} instead`
          );
        n = A;
        break;
      default:
        throw new Error(
          `invalid interpolation type: ${JSON.stringify(r)}`
        );
    }
    const s = new nr(Ve, n);
    let o;
    try {
      o = Er(t[2], Ve, i);
    } catch (A) {
      throw new Error(
        `failed to parse argument 1 in interpolate expression: ${A.message}`
      );
    }
    const a = new Array(t.length - 3);
    for (let A = 0; A < a.length; A += 2) {
      try {
        const l = Er(t[A + 3], Ve, i);
        a[A] = l;
      } catch (l) {
        throw new Error(
          `failed to parse argument ${A + 2} for interpolate expression: ${l.message}`
        );
      }
      try {
        const l = Er(t[A + 4], e, i);
        a[A + 1] = l;
      } catch (l) {
        throw new Error(
          `failed to parse argument ${A + 3} for interpolate expression: ${l.message}`
        );
      }
    }
    return [s, o, ...a];
  }
  function Gee(t, e, i) {
    const r = Er(t[t.length - 1], e, i), n = new Array(t.length - 1);
    for (let s = 0; s < n.length - 1; s += 2) {
      try {
        const o = Er(t[s + 1], Mr, i);
        n[s] = o;
      } catch (o) {
        throw new Error(
          `failed to parse argument ${s} of case expression: ${o.message}`
        );
      }
      try {
        const o = Er(t[s + 2], r.type, i);
        n[s + 1] = o;
      } catch (o) {
        throw new Error(
          `failed to parse argument ${s + 1} of case expression: ${o.message}`
        );
      }
    }
    return n[n.length - 1] = r, n;
  }
  function jee(t, e, i) {
    let r = t[2];
    if (!Array.isArray(r))
      throw new Error(
        'the second argument for the "in" operator must be an array'
      );
    let n;
    if (typeof r[0] == "string") {
      if (r[0] !== "literal")
        throw new Error(
          'for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions'
        );
      if (!Array.isArray(r[1]))
        throw new Error(
          'failed to parse "in" expression: the literal operator must be followed by an array'
        );
      r = r[1], n = sr;
    } else
      n = Ve;
    const s = new Array(r.length);
    for (let a = 0; a < s.length; a++)
      try {
        const A = Er(r[a], n, i);
        s[a] = A;
      } catch (A) {
        throw new Error(
          `failed to parse haystack item ${a} for "in" expression: ${A.message}`
        );
      }
    return [Er(t[1], n, i), ...s];
  }
  function Hee(t, e, i) {
    let r;
    try {
      r = Er(t[1], Ve, i);
    } catch (o) {
      throw new Error(
        `failed to parse first argument in palette expression: ${o.message}`
      );
    }
    const n = t[2];
    if (!Array.isArray(n))
      throw new Error("the second argument of palette must be an array");
    const s = new Array(n.length);
    for (let o = 0; o < s.length; o++) {
      let a;
      try {
        a = Er(n[o], Qi, i);
      } catch (A) {
        throw new Error(
          `failed to parse color at index ${o} in palette expression: ${A.message}`
        );
      }
      if (!(a instanceof nr))
        throw new Error(
          `the palette color at index ${o} must be a literal value`
        );
      s[o] = a;
    }
    return [r, ...s];
  }
  function ot(...t) {
    return function(e, i, r) {
      const n = e[0];
      let s;
      for (let o = 0; o < t.length; o++) {
        const a = t[o](e, i, r);
        if (o == t.length - 1) {
          if (!a)
            throw new Error(
              "expected last argument validator to return the parsed args"
            );
          s = a;
        }
      }
      return new PU(i, n, ...s);
    };
  }
  function Jee(t, e, i) {
    const r = t[0], n = Yee[r];
    if (!n)
      throw new Error(`unknown operator: ${r}`);
    return n(t, e, i);
  }
  function qv(t) {
    if (!t)
      return "";
    const e = t.getType();
    switch (e) {
      case "Point":
      case "LineString":
      case "Polygon":
        return e;
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
        return (
          /** @type {'Point'|'LineString'|'Polygon'} */
          e.substring(5)
        );
      case "Circle":
        return "Polygon";
      case "GeometryCollection":
        return qv(
          /** @type {import("../geom/GeometryCollection.js").default} */
          t.getGeometries()[0]
        );
      default:
        return "";
    }
  }
  function OU() {
    return {
      variables: {},
      properties: {},
      resolution: NaN,
      featureId: null,
      geometryType: ""
    };
  }
  function Ga(t, e, i) {
    const r = Er(t, e, i);
    return $s(r);
  }
  function $s(t, e) {
    if (t instanceof nr) {
      if (t.type === Qi && typeof t.value == "string") {
        const r = Yv(t.value);
        return function() {
          return r;
        };
      }
      return function() {
        return t.value;
      };
    }
    const i = t.operator;
    switch (i) {
      case te.Number:
      case te.String:
      case te.Coalesce:
        return Vee(t);
      case te.Get:
      case te.Var:
      case te.Has:
        return Wee(t);
      case te.Id:
        return (r) => r.featureId;
      case te.GeometryType:
        return (r) => r.geometryType;
      case te.Concat: {
        const r = t.args.map((n) => $s(n));
        return (n) => "".concat(...r.map((s) => s(n).toString()));
      }
      case te.Resolution:
        return (r) => r.resolution;
      case te.Any:
      case te.All:
      case te.Between:
      case te.In:
      case te.Not:
        return Xee(t);
      case te.Equal:
      case te.NotEqual:
      case te.LessThan:
      case te.LessThanOrEqualTo:
      case te.GreaterThan:
      case te.GreaterThanOrEqualTo:
        return Kee(t);
      case te.Multiply:
      case te.Divide:
      case te.Add:
      case te.Subtract:
      case te.Clamp:
      case te.Mod:
      case te.Pow:
      case te.Abs:
      case te.Floor:
      case te.Ceil:
      case te.Round:
      case te.Sin:
      case te.Cos:
      case te.Atan:
      case te.Sqrt:
        return Zee(t);
      case te.Case:
        return qee(t);
      case te.Match:
        return $ee(t);
      case te.Interpolate:
        return ete(t);
      case te.ToString:
        return tte(t);
      default:
        throw new Error(`Unsupported operator ${i}`);
    }
  }
  function Vee(t, e) {
    const i = t.operator, r = t.args.length, n = new Array(r);
    for (let s = 0; s < r; ++s)
      n[s] = $s(t.args[s]);
    switch (i) {
      case te.Coalesce:
        return (s) => {
          for (let o = 0; o < r; ++o) {
            const a = n[o](s);
            if (typeof a < "u" && a !== null)
              return a;
          }
          throw new Error("Expected one of the values to be non-null");
        };
      case te.Number:
      case te.String:
        return (s) => {
          for (let o = 0; o < r; ++o) {
            const a = n[o](s);
            if (typeof a === i)
              return a;
          }
          throw new Error(`Expected one of the values to be a ${i}`);
        };
      default:
        throw new Error(`Unsupported assertion operator ${i}`);
    }
  }
  function Wee(t, e) {
    const r = (
      /** @type {string} */
      /** @type {LiteralExpression} */
      t.args[0].value
    );
    switch (t.operator) {
      case te.Get:
        return (n) => {
          const s = t.args;
          let o = n.properties[r];
          for (let a = 1, A = s.length; a < A; ++a) {
            const c = (
              /** @type {string|number} */
              /** @type {LiteralExpression} */
              s[a].value
            );
            o = o[c];
          }
          return o;
        };
      case te.Var:
        return (n) => n.variables[r];
      case te.Has:
        return (n) => {
          const s = t.args;
          if (!(r in n.properties))
            return !1;
          let o = n.properties[r];
          for (let a = 1, A = s.length; a < A; ++a) {
            const c = (
              /** @type {string|number} */
              /** @type {LiteralExpression} */
              s[a].value
            );
            if (!o || !Object.hasOwn(o, c))
              return !1;
            o = o[c];
          }
          return !0;
        };
      default:
        throw new Error(`Unsupported accessor operator ${t.operator}`);
    }
  }
  function Kee(t, e) {
    const i = t.operator, r = $s(t.args[0]), n = $s(t.args[1]);
    switch (i) {
      case te.Equal:
        return (s) => r(s) === n(s);
      case te.NotEqual:
        return (s) => r(s) !== n(s);
      case te.LessThan:
        return (s) => r(s) < n(s);
      case te.LessThanOrEqualTo:
        return (s) => r(s) <= n(s);
      case te.GreaterThan:
        return (s) => r(s) > n(s);
      case te.GreaterThanOrEqualTo:
        return (s) => r(s) >= n(s);
      default:
        throw new Error(`Unsupported comparison operator ${i}`);
    }
  }
  function Xee(t, e) {
    const i = t.operator, r = t.args.length, n = new Array(r);
    for (let s = 0; s < r; ++s)
      n[s] = $s(t.args[s]);
    switch (i) {
      case te.Any:
        return (s) => {
          for (let o = 0; o < r; ++o)
            if (n[o](s))
              return !0;
          return !1;
        };
      case te.All:
        return (s) => {
          for (let o = 0; o < r; ++o)
            if (!n[o](s))
              return !1;
          return !0;
        };
      case te.Between:
        return (s) => {
          const o = n[0](s), a = n[1](s), A = n[2](s);
          return o >= a && o <= A;
        };
      case te.In:
        return (s) => {
          const o = n[0](s);
          for (let a = 1; a < r; ++a)
            if (o === n[a](s))
              return !0;
          return !1;
        };
      case te.Not:
        return (s) => !n[0](s);
      default:
        throw new Error(`Unsupported logical operator ${i}`);
    }
  }
  function Zee(t, e) {
    const i = t.operator, r = t.args.length, n = new Array(r);
    for (let s = 0; s < r; ++s)
      n[s] = $s(t.args[s]);
    switch (i) {
      case te.Multiply:
        return (s) => {
          let o = 1;
          for (let a = 0; a < r; ++a)
            o *= n[a](s);
          return o;
        };
      case te.Divide:
        return (s) => n[0](s) / n[1](s);
      case te.Add:
        return (s) => {
          let o = 0;
          for (let a = 0; a < r; ++a)
            o += n[a](s);
          return o;
        };
      case te.Subtract:
        return (s) => n[0](s) - n[1](s);
      case te.Clamp:
        return (s) => {
          const o = n[0](s), a = n[1](s);
          if (o < a)
            return a;
          const A = n[2](s);
          return o > A ? A : o;
        };
      case te.Mod:
        return (s) => n[0](s) % n[1](s);
      case te.Pow:
        return (s) => Math.pow(n[0](s), n[1](s));
      case te.Abs:
        return (s) => Math.abs(n[0](s));
      case te.Floor:
        return (s) => Math.floor(n[0](s));
      case te.Ceil:
        return (s) => Math.ceil(n[0](s));
      case te.Round:
        return (s) => Math.round(n[0](s));
      case te.Sin:
        return (s) => Math.sin(n[0](s));
      case te.Cos:
        return (s) => Math.cos(n[0](s));
      case te.Atan:
        return r === 2 ? (s) => Math.atan2(n[0](s), n[1](s)) : (s) => Math.atan(n[0](s));
      case te.Sqrt:
        return (s) => Math.sqrt(n[0](s));
      default:
        throw new Error(`Unsupported numeric operator ${i}`);
    }
  }
  function qee(t, e) {
    const i = t.args.length, r = new Array(i);
    for (let n = 0; n < i; ++n)
      r[n] = $s(t.args[n]);
    return (n) => {
      for (let s = 0; s < i - 1; s += 2)
        if (r[s](n))
          return r[s + 1](n);
      return r[i - 1](n);
    };
  }
  function $ee(t, e) {
    const i = t.args.length, r = new Array(i);
    for (let n = 0; n < i; ++n)
      r[n] = $s(t.args[n]);
    return (n) => {
      const s = r[0](n);
      for (let o = 1; o < i; o += 2)
        if (s === r[o](n))
          return r[o + 1](n);
      return r[i - 1](n);
    };
  }
  function ete(t, e) {
    const i = t.args.length, r = new Array(i);
    for (let n = 0; n < i; ++n)
      r[n] = $s(t.args[n]);
    return (n) => {
      const s = r[0](n), o = r[1](n);
      let a, A;
      for (let l = 2; l < i; l += 2) {
        const c = r[l](n);
        let u = r[l + 1](n);
        const d = Array.isArray(u);
        if (d && (u = V$(u)), c >= o)
          return l === 2 ? u : d ? ite(
            s,
            o,
            a,
            A,
            c,
            u
          ) : Eh(
            s,
            o,
            a,
            A,
            c,
            u
          );
        a = c, A = u;
      }
      return A;
    };
  }
  function tte(t, e) {
    const i = t.operator, r = t.args.length, n = new Array(r);
    for (let s = 0; s < r; ++s)
      n[s] = $s(t.args[s]);
    switch (i) {
      case te.ToString:
        return (s) => {
          const o = n[0](s);
          return t.args[0].type === Qi ? Nv(o) : o.toString();
        };
      default:
        throw new Error(`Unsupported convert operator ${i}`);
    }
  }
  function Eh(t, e, i, r, n, s) {
    const o = n - i;
    if (o === 0)
      return r;
    const a = e - i, A = t === 1 ? a / o : (Math.pow(t, a) - 1) / (Math.pow(t, o) - 1);
    return r + A * (s - r);
  }
  function ite(t, e, i, r, n, s) {
    if (n - i === 0)
      return r;
    const a = BD(r), A = BD(s);
    let l = A[2] - a[2];
    l > 180 ? l -= 360 : l < -180 && (l += 360);
    const c = [
      Eh(t, e, i, a[0], n, A[0]),
      Eh(t, e, i, a[1], n, A[1]),
      a[2] + Eh(t, e, i, 0, n, l),
      Eh(t, e, i, r[3], n, s[3])
    ];
    return bU(W$(c));
  }
  function rte(t) {
    return !0;
  }
  function nte(t) {
    const e = Zv(), i = ste(t, e), r = OU();
    return function(n, s) {
      if (r.properties = n.getPropertiesInternal(), r.resolution = s, e.featureId) {
        const o = n.getId();
        o !== void 0 ? r.featureId = o : r.featureId = null;
      }
      return e.geometryType && (r.geometryType = qv(
        n.getGeometry()
      )), i(r);
    };
  }
  function kD(t) {
    const e = Zv(), i = t.length, r = new Array(i);
    for (let o = 0; o < i; ++o)
      r[o] = yb(t[o], e);
    const n = OU(), s = new Array(i);
    return function(o, a) {
      if (n.properties = o.getPropertiesInternal(), n.resolution = a, e.featureId) {
        const l = o.getId();
        l !== void 0 ? n.featureId = l : n.featureId = null;
      }
      let A = 0;
      for (let l = 0; l < i; ++l) {
        const c = r[l](n);
        c && (s[A] = c, A += 1);
      }
      return s.length = A, s;
    };
  }
  function ste(t, e) {
    const i = t.length, r = new Array(i);
    for (let n = 0; n < i; ++n) {
      const s = t[n], o = "filter" in s ? Ga(s.filter, Mr, e) : rte;
      let a;
      if (Array.isArray(s.style)) {
        const A = s.style.length;
        a = new Array(A);
        for (let l = 0; l < A; ++l)
          a[l] = yb(s.style[l], e);
      } else
        a = [yb(s.style, e)];
      r[n] = { filter: o, styles: a };
    }
    return function(n) {
      const s = [];
      let o = !1;
      for (let a = 0; a < i; ++a) {
        const A = r[a].filter;
        if (A(n) && !(t[a].else && o)) {
          o = !0;
          for (const l of r[a].styles) {
            const c = l(n);
            c && s.push(c);
          }
        }
      }
      return s;
    };
  }
  function yb(t, e) {
    const i = pg(t, "", e), r = mg(t, "", e), n = ote(t, e), s = ate(t, e), o = En(t, "z-index", e);
    if (!i && !r && !n && !s && !vA(t))
      throw new Error(
        "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(t)
      );
    const a = new hi();
    return function(A) {
      let l = !0;
      if (i) {
        const c = i(A);
        c && (l = !1), a.setFill(c);
      }
      if (r) {
        const c = r(A);
        c && (l = !1), a.setStroke(c);
      }
      if (n) {
        const c = n(A);
        c && (l = !1), a.setText(c);
      }
      if (s) {
        const c = s(A);
        c && (l = !1), a.setImage(c);
      }
      return o && a.setZIndex(o(A)), l ? null : a;
    };
  }
  function pg(t, e, i) {
    let r;
    if (e + "fill-pattern-src" in t)
      r = ute(t, e + "fill-", i);
    else {
      if (t[e + "fill-color"] === "none")
        return (s) => null;
      r = $v(
        t,
        e + "fill-color",
        i
      );
    }
    if (!r)
      return null;
    const n = new vr();
    return function(s) {
      const o = r(s);
      return o === kv ? null : (n.setColor(o), n);
    };
  }
  function mg(t, e, i) {
    const r = En(
      t,
      e + "stroke-width",
      i
    ), n = $v(
      t,
      e + "stroke-color",
      i
    );
    if (!r && !n)
      return null;
    const s = ea(
      t,
      e + "stroke-line-cap",
      i
    ), o = ea(
      t,
      e + "stroke-line-join",
      i
    ), a = GU(
      t,
      e + "stroke-line-dash",
      i
    ), A = En(
      t,
      e + "stroke-line-dash-offset",
      i
    ), l = En(
      t,
      e + "stroke-miter-limit",
      i
    ), c = new pr();
    return function(u) {
      if (n) {
        const d = n(u);
        if (d === kv)
          return null;
        c.setColor(d);
      }
      if (r && c.setWidth(r(u)), s) {
        const d = s(u);
        if (d !== "butt" && d !== "round" && d !== "square")
          throw new Error("Expected butt, round, or square line cap");
        c.setLineCap(d);
      }
      if (o) {
        const d = o(u);
        if (d !== "bevel" && d !== "round" && d !== "miter")
          throw new Error("Expected bevel, round, or miter line join");
        c.setLineJoin(d);
      }
      return a && c.setLineDash(a(u)), A && c.setLineDashOffset(A(u)), l && c.setMiterLimit(l(u)), c;
    };
  }
  function ote(t, e) {
    const i = "text-", r = ea(t, i + "value", e);
    if (!r)
      return null;
    const n = pg(t, i, e), s = pg(
      t,
      i + "background-",
      e
    ), o = mg(t, i, e), a = mg(
      t,
      i + "background-",
      e
    ), A = ea(t, i + "font", e), l = En(
      t,
      i + "max-angle",
      e
    ), c = En(
      t,
      i + "offset-x",
      e
    ), u = En(
      t,
      i + "offset-y",
      e
    ), d = Su(
      t,
      i + "overflow",
      e
    ), h = ea(
      t,
      i + "placement",
      e
    ), g = En(t, i + "repeat", e), f = mB(t, i + "scale", e), p = Su(
      t,
      i + "rotate-with-view",
      e
    ), m = En(
      t,
      i + "rotation",
      e
    ), E = ea(t, i + "align", e), y = ea(
      t,
      i + "justify",
      e
    ), C = ea(
      t,
      i + "baseline",
      e
    ), w = Su(
      t,
      i + "keep-upright",
      e
    ), M = GU(
      t,
      i + "padding",
      e
    ), I = EB(
      t,
      i + "declutter-mode"
    ), b = new pB({ declutterMode: I });
    return function(B) {
      if (b.setText(r(B)), n && b.setFill(n(B)), s && b.setBackgroundFill(s(B)), o && b.setStroke(o(B)), a && b.setBackgroundStroke(a(B)), A && b.setFont(A(B)), l && b.setMaxAngle(l(B)), c && b.setOffsetX(c(B)), u && b.setOffsetY(u(B)), d && b.setOverflow(d(B)), h) {
        const x = h(B);
        if (x !== "point" && x !== "line")
          throw new Error("Expected point or line for text-placement");
        b.setPlacement(x);
      }
      if (g && b.setRepeat(g(B)), f && b.setScale(f(B)), p && b.setRotateWithView(p(B)), m && b.setRotation(m(B)), E) {
        const x = E(B);
        if (x !== "left" && x !== "center" && x !== "right" && x !== "end" && x !== "start")
          throw new Error(
            "Expected left, right, center, start, or end for text-align"
          );
        b.setTextAlign(x);
      }
      if (y) {
        const x = y(B);
        if (x !== "left" && x !== "right" && x !== "center")
          throw new Error("Expected left, right, or center for text-justify");
        b.setJustify(x);
      }
      if (C) {
        const x = C(B);
        if (x !== "bottom" && x !== "top" && x !== "middle" && x !== "alphabetic" && x !== "hanging")
          throw new Error(
            "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
          );
        b.setTextBaseline(x);
      }
      return M && b.setPadding(M(B)), w && b.setKeepUpright(w(B)), b;
    };
  }
  function ate(t, e) {
    return "icon-src" in t ? Ate(t, e) : "shape-points" in t ? lte(t, e) : "circle-radius" in t ? cte(t, e) : null;
  }
  function Ate(t, e) {
    const i = "icon-", r = i + "src", n = jU(t[r], r), s = vE(
      t,
      i + "anchor",
      e
    ), o = mB(t, i + "scale", e), a = En(
      t,
      i + "opacity",
      e
    ), A = vE(
      t,
      i + "displacement",
      e
    ), l = En(
      t,
      i + "rotation",
      e
    ), c = Su(
      t,
      i + "rotate-with-view",
      e
    ), u = ND(t, i + "anchor-origin"), d = UD(
      t,
      i + "anchor-x-units"
    ), h = UD(
      t,
      i + "anchor-y-units"
    ), g = fte(t, i + "color"), f = hte(t, i + "cross-origin"), p = gte(t, i + "offset"), m = ND(t, i + "offset-origin"), E = xE(t, i + "width"), y = xE(t, i + "height"), C = dte(t, i + "size"), w = EB(
      t,
      i + "declutter-mode"
    ), M = new Ol({
      src: n,
      anchorOrigin: u,
      anchorXUnits: d,
      anchorYUnits: h,
      color: g,
      crossOrigin: f,
      offset: p,
      offsetOrigin: m,
      height: y,
      width: E,
      size: C,
      declutterMode: w
    });
    return function(I) {
      return a && M.setOpacity(a(I)), A && M.setDisplacement(A(I)), l && M.setRotation(l(I)), c && M.setRotateWithView(c(I)), o && M.setScale(o(I)), s && M.setAnchor(s(I)), M;
    };
  }
  function lte(t, e) {
    const i = "shape-", r = i + "points", n = i + "radius", s = Bb(t[r], r), o = Bb(t[n], n), a = pg(t, i, e), A = mg(t, i, e), l = mB(t, i + "scale", e), c = vE(
      t,
      i + "displacement",
      e
    ), u = En(
      t,
      i + "rotation",
      e
    ), d = Su(
      t,
      i + "rotate-with-view",
      e
    ), h = xE(t, i + "radius2"), g = xE(t, i + "angle"), f = EB(
      t,
      i + "declutter-mode"
    ), p = new fB({
      points: s,
      radius: o,
      radius2: h,
      angle: g,
      declutterMode: f
    });
    return function(m) {
      return a && p.setFill(a(m)), A && p.setStroke(A(m)), c && p.setDisplacement(c(m)), u && p.setRotation(u(m)), d && p.setRotateWithView(d(m)), l && p.setScale(l(m)), p;
    };
  }
  function cte(t, e) {
    const i = "circle-", r = pg(t, i, e), n = mg(t, i, e), s = En(t, i + "radius", e), o = mB(t, i + "scale", e), a = vE(
      t,
      i + "displacement",
      e
    ), A = En(
      t,
      i + "rotation",
      e
    ), l = Su(
      t,
      i + "rotate-with-view",
      e
    ), c = EB(
      t,
      i + "declutter-mode"
    ), u = new Sa({
      radius: 5,
      // this is arbitrary, but required - the evaluated radius is used below
      declutterMode: c
    });
    return function(d) {
      return s && u.setRadius(s(d)), r && u.setFill(r(d)), n && u.setStroke(n(d)), a && u.setDisplacement(a(d)), A && u.setRotation(A(d)), l && u.setRotateWithView(l(d)), o && u.setScale(o(d)), u;
    };
  }
  function En(t, e, i) {
    if (!(e in t))
      return;
    const r = Ga(t[e], Ve, i);
    return function(n) {
      return Bb(r(n), e);
    };
  }
  function ea(t, e, i) {
    if (!(e in t))
      return null;
    const r = Ga(t[e], sr, i);
    return function(n) {
      return jU(r(n), e);
    };
  }
  function ute(t, e, i) {
    const r = ea(
      t,
      e + "pattern-src",
      i
    ), n = YD(
      t,
      e + "pattern-offset",
      i
    ), s = YD(
      t,
      e + "pattern-size",
      i
    ), o = $v(
      t,
      e + "color",
      i
    );
    return function(a) {
      return {
        src: r(a),
        offset: n && n(a),
        size: s && s(a),
        color: o && o(a)
      };
    };
  }
  function Su(t, e, i) {
    if (!(e in t))
      return null;
    const r = Ga(t[e], Mr, i);
    return function(n) {
      const s = r(n);
      if (typeof s != "boolean")
        throw new Error(`Expected a boolean for ${e}`);
      return s;
    };
  }
  function $v(t, e, i) {
    if (!(e in t))
      return null;
    const r = Ga(t[e], Qi, i);
    return function(n) {
      return HU(r(n), e);
    };
  }
  function GU(t, e, i) {
    if (!(e in t))
      return null;
    const r = Ga(t[e], tn, i);
    return function(n) {
      return hf(r(n), e);
    };
  }
  function vE(t, e, i) {
    if (!(e in t))
      return null;
    const r = Ga(t[e], tn, i);
    return function(n) {
      const s = hf(r(n), e);
      if (s.length !== 2)
        throw new Error(`Expected two numbers for ${e}`);
      return s;
    };
  }
  function YD(t, e, i) {
    if (!(e in t))
      return null;
    const r = Ga(t[e], tn, i);
    return function(n) {
      return JU(r(n), e);
    };
  }
  function mB(t, e, i) {
    if (!(e in t))
      return null;
    const r = Ga(
      t[e],
      tn | Ve,
      i
    );
    return function(n) {
      return pte(r(n), e);
    };
  }
  function xE(t, e) {
    const i = t[e];
    if (i !== void 0) {
      if (typeof i != "number")
        throw new Error(`Expected a number for ${e}`);
      return i;
    }
  }
  function dte(t, e) {
    const i = t[e];
    if (i !== void 0) {
      if (typeof i == "number")
        return mr(i);
      if (!Array.isArray(i))
        throw new Error(`Expected a number or size array for ${e}`);
      if (i.length !== 2 || typeof i[0] != "number" || typeof i[1] != "number")
        throw new Error(`Expected a number or size array for ${e}`);
      return i;
    }
  }
  function hte(t, e) {
    const i = t[e];
    if (i !== void 0) {
      if (typeof i != "string")
        throw new Error(`Expected a string for ${e}`);
      return i;
    }
  }
  function ND(t, e) {
    const i = t[e];
    if (i !== void 0) {
      if (i !== "bottom-left" && i !== "bottom-right" && i !== "top-left" && i !== "top-right")
        throw new Error(
          `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
        );
      return i;
    }
  }
  function UD(t, e) {
    const i = t[e];
    if (i !== void 0) {
      if (i !== "pixels" && i !== "fraction")
        throw new Error(`Expected pixels or fraction for ${e}`);
      return i;
    }
  }
  function gte(t, e) {
    const i = t[e];
    if (i !== void 0)
      return hf(i, e);
  }
  function EB(t, e) {
    const i = t[e];
    if (i !== void 0) {
      if (typeof i != "string")
        throw new Error(`Expected a string for ${e}`);
      if (i !== "declutter" && i !== "obstacle" && i !== "none")
        throw new Error(`Expected declutter, obstacle, or none for ${e}`);
      return i;
    }
  }
  function fte(t, e) {
    const i = t[e];
    if (i !== void 0)
      return HU(i, e);
  }
  function hf(t, e) {
    if (!Array.isArray(t))
      throw new Error(`Expected an array for ${e}`);
    const i = t.length;
    for (let r = 0; r < i; ++r)
      if (typeof t[r] != "number")
        throw new Error(`Expected an array of numbers for ${e}`);
    return t;
  }
  function jU(t, e) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    return t;
  }
  function Bb(t, e) {
    if (typeof t != "number")
      throw new Error(`Expected a number for ${e}`);
    return t;
  }
  function HU(t, e) {
    if (typeof t == "string")
      return t;
    const i = hf(t, e), r = i.length;
    if (r < 3 || r > 4)
      throw new Error(`Expected a color with 3 or 4 values for ${e}`);
    return i;
  }
  function JU(t, e) {
    const i = hf(t, e);
    if (i.length !== 2)
      throw new Error(`Expected an array of two numbers for ${e}`);
    return i;
  }
  function pte(t, e) {
    return typeof t == "number" ? t : JU(t, e);
  }
  const LD = {
    RENDER_ORDER: "renderOrder"
  };
  class gf extends HA {
    /**
     * @param {Options<FeatureType, VectorSourceType>} [options] Options.
     */
    constructor(e) {
      e = e || {};
      const i = Object.assign({}, e);
      delete i.style, delete i.renderBuffer, delete i.updateWhileAnimating, delete i.updateWhileInteracting, super(i), this.declutter_ = e.declutter ? String(e.declutter) : void 0, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
    }
    /**
     * @return {string} Declutter group.
     * @override
     */
    getDeclutter() {
      return this.declutter_;
    }
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
     * @api
     * @override
     */
    getFeatures(e) {
      return super.getFeatures(e);
    }
    /**
     * @return {number|undefined} Render buffer.
     */
    getRenderBuffer() {
      return this.renderBuffer_;
    }
    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */
    getRenderOrder() {
      return (
        /** @type {import("../render.js").OrderFunction|null|undefined} */
        this.get(LD.RENDER_ORDER)
      );
    }
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */
    getUpdateWhileAnimating() {
      return this.updateWhileAnimating_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */
    getUpdateWhileInteracting() {
      return this.updateWhileInteracting_;
    }
    /**
     * Render declutter items for this layer
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../layer/Layer.js").State} layerState Layer state.
     * @override
     */
    renderDeclutter(e, i) {
      const r = this.getDeclutter();
      r in e.declutter || (e.declutter[r] = new zU(9)), this.getRenderer().renderDeclutter(e, i);
    }
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */
    setRenderOrder(e) {
      this.set(LD.RENDER_ORDER, e);
    }
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
     *
     * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
     * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
     * ```js
     * vectorLayer.setStyle({
     *   "fill-color": "yellow",
     *   "stroke-color": "black",
     *   "stroke-width": 4
     * })
     * ```
     *
     * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
     * @api
     */
    setStyle(e) {
      this.style_ = e === void 0 ? kU : e;
      const i = mte(e);
      this.styleFunction_ = e === null ? void 0 : fee(i), this.changed();
    }
    /**
     * @param {boolean|string|number} declutter Declutter images and text.
     * @api
     */
    setDeclutter(e) {
      this.declutter_ = e ? String(e) : void 0, this.changed();
    }
  }
  function mte(t) {
    if (t === void 0)
      return kU;
    if (!t)
      return null;
    if (typeof t == "function" || t instanceof hi)
      return t;
    if (!Array.isArray(t))
      return kD([t]);
    if (t.length === 0)
      return [];
    const e = t.length, i = t[0];
    if (i instanceof hi) {
      const n = new Array(e);
      for (let s = 0; s < e; ++s) {
        const o = t[s];
        if (!(o instanceof hi))
          throw new Error("Expected a list of style instances");
        n[s] = o;
      }
      return n;
    }
    if ("style" in i) {
      const n = new Array(e);
      for (let s = 0; s < e; ++s) {
        const o = t[s];
        if (!("style" in o))
          throw new Error("Expected a list of rules with a style property");
        n[s] = o;
      }
      return nte(n);
    }
    return kD(
      /** @type {Array<import("../style/flat.js").FlatStyle>} */
      t
    );
  }
  const $e = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
  }, lp = [$e.FILL], gA = [$e.STROKE], El = [$e.BEGIN_PATH], zD = [$e.CLOSE_PATH];
  class VU {
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     * @param {number} [index] Render order index.
     */
    drawCustom(e, i, r, n, s) {
    }
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */
    drawGeometry(e) {
    }
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */
    setStyle(e) {
    }
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawCircle(e, i, r) {
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     * @param {number} [index] Render order index.
     */
    drawFeature(e, i, r) {
    }
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawGeometryCollection(e, i, r) {
    }
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawLineString(e, i, r) {
    }
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiLineString(e, i, r) {
    }
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPoint(e, i, r) {
    }
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawMultiPolygon(e, i, r) {
    }
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPoint(e, i, r) {
    }
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawPolygon(e, i, r) {
    }
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     */
    drawText(e, i, r) {
    }
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */
    setFillStrokeStyle(e, i) {
    }
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
     */
    setImageStyle(e, i) {
    }
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
     */
    setTextStyle(e, i) {
    }
  }
  class ff extends VU {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(e, i, r, n) {
      super(), this.tolerance = e, this.maxExtent = i, this.pixelRatio = n, this.maxLineWidth = 0, this.resolution = r, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
      {};
    }
    /**
     * @protected
     * @param {Array<number>} dashArray Dash array.
     * @return {Array<number>} Dash array with pixel ratio applied
     */
    applyPixelRatio(e) {
      const i = this.pixelRatio;
      return i == 1 ? e : e.map(function(r) {
        return r * i;
      });
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */
    appendFlatPointCoordinates(e, i) {
      const r = this.getBufferedMaxExtent(), n = this.tmpCoordinate_, s = this.coordinates;
      let o = s.length;
      for (let a = 0, A = e.length; a < A; a += i)
        n[0] = e[a], n[1] = e[a + 1], zl(r, n) && (s[o++] = n[0], s[o++] = n[1]);
      return o;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */
    appendFlatLineCoordinates(e, i, r, n, s, o) {
      const a = this.coordinates;
      let A = a.length;
      const l = this.getBufferedMaxExtent();
      o && (i += n);
      let c = e[i], u = e[i + 1];
      const d = this.tmpCoordinate_;
      let h = !0, g, f, p;
      for (g = i + n; g < r; g += n)
        d[0] = e[g], d[1] = e[g + 1], p = Ab(l, d), p !== f ? (h && (a[A++] = c, a[A++] = u, h = !1), a[A++] = d[0], a[A++] = d[1]) : p === cr.INTERSECTING ? (a[A++] = d[0], a[A++] = d[1], h = !1) : h = !0, c = d[0], u = d[1], f = p;
      return (s && h || g === i + n) && (a[A++] = c, a[A++] = u), A;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */
    drawCustomCoordinates_(e, i, r, n, s) {
      for (let o = 0, a = r.length; o < a; ++o) {
        const A = r[o], l = this.appendFlatLineCoordinates(
          e,
          i,
          A,
          n,
          !1,
          !1
        );
        s.push(l), i = A;
      }
      return i;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     * @param {number} [index] Render order index.
     * @override
     */
    drawCustom(e, i, r, n, s) {
      this.beginGeometry(e, i, s);
      const o = e.getType(), a = e.getStride(), A = this.coordinates.length;
      let l, c, u, d, h;
      switch (o) {
        case "MultiPolygon":
          l = /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getOrientedFlatCoordinates(), d = [];
          const g = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getEndss()
          );
          h = 0;
          for (let f = 0, p = g.length; f < p; ++f) {
            const m = [];
            h = this.drawCustomCoordinates_(
              l,
              h,
              g[f],
              a,
              m
            ), d.push(m);
          }
          this.instructions.push([
            $e.CUSTOM,
            A,
            d,
            e,
            r,
            gb,
            s
          ]), this.hitDetectionInstructions.push([
            $e.CUSTOM,
            A,
            d,
            e,
            n || r,
            gb,
            s
          ]);
          break;
        case "Polygon":
        case "MultiLineString":
          u = [], l = o == "Polygon" ? (
            /** @type {import("../../geom/Polygon.js").default} */
            e.getOrientedFlatCoordinates()
          ) : e.getFlatCoordinates(), h = this.drawCustomCoordinates_(
            l,
            0,
            /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
            e.getEnds(),
            a,
            u
          ), this.instructions.push([
            $e.CUSTOM,
            A,
            u,
            e,
            r,
            cg,
            s
          ]), this.hitDetectionInstructions.push([
            $e.CUSTOM,
            A,
            u,
            e,
            n || r,
            cg,
            s
          ]);
          break;
        case "LineString":
        case "Circle":
          l = e.getFlatCoordinates(), c = this.appendFlatLineCoordinates(
            l,
            0,
            l.length,
            a,
            !1,
            !1
          ), this.instructions.push([
            $e.CUSTOM,
            A,
            c,
            e,
            r,
            hA,
            s
          ]), this.hitDetectionInstructions.push([
            $e.CUSTOM,
            A,
            c,
            e,
            n || r,
            hA,
            s
          ]);
          break;
        case "MultiPoint":
          l = e.getFlatCoordinates(), c = this.appendFlatPointCoordinates(l, a), c > A && (this.instructions.push([
            $e.CUSTOM,
            A,
            c,
            e,
            r,
            hA,
            s
          ]), this.hitDetectionInstructions.push([
            $e.CUSTOM,
            A,
            c,
            e,
            n || r,
            hA,
            s
          ]));
          break;
        case "Point":
          l = e.getFlatCoordinates(), this.coordinates.push(l[0], l[1]), c = this.coordinates.length, this.instructions.push([
            $e.CUSTOM,
            A,
            c,
            e,
            r,
            void 0,
            s
          ]), this.hitDetectionInstructions.push([
            $e.CUSTOM,
            A,
            c,
            e,
            n || r,
            void 0,
            s
          ]);
          break;
      }
      this.endGeometry(i);
    }
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} index Render order index
     */
    beginGeometry(e, i, r) {
      this.beginGeometryInstruction1_ = [
        $e.BEGIN_GEOMETRY,
        i,
        0,
        e,
        r
      ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
        $e.BEGIN_GEOMETRY,
        i,
        0,
        e,
        r
      ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates
      };
    }
    /**
     * Reverse the hit detection instructions.
     */
    reverseHitDetectionInstructions() {
      const e = this.hitDetectionInstructions;
      e.reverse();
      let i;
      const r = e.length;
      let n, s, o = -1;
      for (i = 0; i < r; ++i)
        n = e[i], s = /** @type {import("./Instruction.js").default} */
        n[0], s == $e.END_GEOMETRY ? o = i : s == $e.BEGIN_GEOMETRY && (n[2] = i, _q(this.hitDetectionInstructions, o, i), o = -1);
    }
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     * @override
     */
    setFillStrokeStyle(e, i) {
      const r = this.state;
      if (e) {
        const n = e.getColor();
        r.fillPatternScale = n && typeof n == "object" && "src" in n ? this.pixelRatio : 1, r.fillStyle = Mo(
          n || gn
        );
      } else
        r.fillStyle = void 0;
      if (i) {
        const n = i.getColor();
        r.strokeStyle = Mo(
          n || hg
        );
        const s = i.getLineCap();
        r.lineCap = s !== void 0 ? s : nd;
        const o = i.getLineDash();
        r.lineDash = o ? o.slice() : Ea;
        const a = i.getLineDashOffset();
        r.lineDashOffset = a || ya;
        const A = i.getLineJoin();
        r.lineJoin = A !== void 0 ? A : sd;
        const l = i.getWidth();
        r.lineWidth = l !== void 0 ? l : fg;
        const c = i.getMiterLimit();
        r.miterLimit = c !== void 0 ? c : dg, r.lineWidth > this.maxLineWidth && (this.maxLineWidth = r.lineWidth, this.bufferedMaxExtent_ = null);
      } else
        r.strokeStyle = void 0, r.lineCap = void 0, r.lineDash = null, r.lineDashOffset = void 0, r.lineJoin = void 0, r.lineWidth = void 0, r.miterLimit = void 0;
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */
    createFill(e) {
      const i = e.fillStyle, r = [$e.SET_FILL_STYLE, i];
      return typeof i != "string" && r.push(e.fillPatternScale), r;
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    applyStroke(e) {
      this.instructions.push(this.createStroke(e));
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */
    createStroke(e) {
      return [
        $e.SET_STROKE_STYLE,
        e.strokeStyle,
        e.lineWidth * this.pixelRatio,
        e.lineCap,
        e.lineJoin,
        e.miterLimit,
        this.applyPixelRatio(e.lineDash),
        e.lineDashOffset * this.pixelRatio
      ];
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */
    updateFillStyle(e, i) {
      const r = e.fillStyle;
      (typeof r != "string" || e.currentFillStyle != r) && (r !== void 0 && this.instructions.push(i.call(this, e)), e.currentFillStyle = r);
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */
    updateStrokeStyle(e, i) {
      const r = e.strokeStyle, n = e.lineCap, s = e.lineDash, o = e.lineDashOffset, a = e.lineJoin, A = e.lineWidth, l = e.miterLimit;
      (e.currentStrokeStyle != r || e.currentLineCap != n || s != e.currentLineDash && !jo(e.currentLineDash, s) || e.currentLineDashOffset != o || e.currentLineJoin != a || e.currentLineWidth != A || e.currentMiterLimit != l) && (r !== void 0 && i.call(this, e), e.currentStrokeStyle = r, e.currentLineCap = n, e.currentLineDash = s, e.currentLineDashOffset = o, e.currentLineJoin = a, e.currentLineWidth = A, e.currentMiterLimit = l);
    }
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    endGeometry(e) {
      this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
      const i = [$e.END_GEOMETRY, e];
      this.instructions.push(i), this.hitDetectionInstructions.push(i);
    }
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */
    getBufferedMaxExtent() {
      if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = XN(this.maxExtent), this.maxLineWidth > 0)) {
        const e = this.resolution * (this.maxLineWidth + 1) / 2;
        $r(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
      }
      return this.bufferedMaxExtent_;
    }
  }
  class Ete extends ff {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(e, i, r, n) {
      super(e, i, r, n), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
    }
    /**
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawPoint(e, i, r) {
      if (!this.image_ || this.maxExtent && !zl(this.maxExtent, e.getFlatCoordinates()))
        return;
      this.beginGeometry(e, i, r);
      const n = e.getFlatCoordinates(), s = e.getStride(), o = this.coordinates.length, a = this.appendFlatPointCoordinates(n, s);
      this.instructions.push([
        $e.DRAW_IMAGE,
        o,
        a,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.hitDetectionInstructions.push([
        $e.DRAW_IMAGE,
        o,
        a,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.endGeometry(i);
    }
    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiPoint(e, i, r) {
      if (!this.image_)
        return;
      this.beginGeometry(e, i, r);
      const n = e.getFlatCoordinates(), s = [];
      for (let A = 0, l = n.length; A < l; A += e.getStride())
        (!this.maxExtent || zl(this.maxExtent, n.slice(A, A + 2))) && s.push(
          n[A],
          n[A + 1]
        );
      const o = this.coordinates.length, a = this.appendFlatPointCoordinates(s, 2);
      this.instructions.push([
        $e.DRAW_IMAGE,
        o,
        a,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.hitDetectionInstructions.push([
        $e.DRAW_IMAGE,
        o,
        a,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]), this.endGeometry(i);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
    }
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    setImageStyle(e, i) {
      const r = e.getAnchor(), n = e.getSize(), s = e.getOrigin();
      this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = r[0], this.anchorY_ = r[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = n[1], this.opacity_ = e.getOpacity(), this.originX_ = s[0], this.originY_ = s[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = n[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = i;
    }
  }
  class yte extends ff {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(e, i, r, n) {
      super(e, i, r, n);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     * @return {number} end.
     */
    drawFlatCoordinates_(e, i, r, n) {
      const s = this.coordinates.length, o = this.appendFlatLineCoordinates(
        e,
        i,
        r,
        n,
        !1,
        !1
      ), a = [
        $e.MOVE_TO_LINE_TO,
        s,
        o
      ];
      return this.instructions.push(a), this.hitDetectionInstructions.push(a), r;
    }
    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawLineString(e, i, r) {
      const n = this.state, s = n.strokeStyle, o = n.lineWidth;
      if (s === void 0 || o === void 0)
        return;
      this.updateStrokeStyle(n, this.applyStroke), this.beginGeometry(e, i, r), this.hitDetectionInstructions.push(
        [
          $e.SET_STROKE_STYLE,
          n.strokeStyle,
          n.lineWidth,
          n.lineCap,
          n.lineJoin,
          n.miterLimit,
          Ea,
          ya
        ],
        El
      );
      const a = e.getFlatCoordinates(), A = e.getStride();
      this.drawFlatCoordinates_(
        a,
        0,
        a.length,
        A
      ), this.hitDetectionInstructions.push(gA), this.endGeometry(i);
    }
    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiLineString(e, i, r) {
      const n = this.state, s = n.strokeStyle, o = n.lineWidth;
      if (s === void 0 || o === void 0)
        return;
      this.updateStrokeStyle(n, this.applyStroke), this.beginGeometry(e, i, r), this.hitDetectionInstructions.push(
        [
          $e.SET_STROKE_STYLE,
          n.strokeStyle,
          n.lineWidth,
          n.lineCap,
          n.lineJoin,
          n.miterLimit,
          Ea,
          ya
        ],
        El
      );
      const a = e.getEnds(), A = e.getFlatCoordinates(), l = e.getStride();
      let c = 0;
      for (let u = 0, d = a.length; u < d; ++u)
        c = this.drawFlatCoordinates_(
          A,
          c,
          /** @type {number} */
          a[u],
          l
        );
      this.hitDetectionInstructions.push(gA), this.endGeometry(i);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      const e = this.state;
      return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(gA), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @override
     */
    applyStroke(e) {
      e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(gA), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(El);
    }
  }
  class PD extends ff {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(e, i, r, n) {
      super(e, i, r, n);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawFlatCoordinatess_(e, i, r, n) {
      const s = this.state, o = s.fillStyle !== void 0, a = s.strokeStyle !== void 0, A = r.length;
      this.instructions.push(El), this.hitDetectionInstructions.push(El);
      for (let l = 0; l < A; ++l) {
        const c = r[l], u = this.coordinates.length, d = this.appendFlatLineCoordinates(
          e,
          i,
          c,
          n,
          !0,
          !a
        ), h = [
          $e.MOVE_TO_LINE_TO,
          u,
          d
        ];
        this.instructions.push(h), this.hitDetectionInstructions.push(h), a && (this.instructions.push(zD), this.hitDetectionInstructions.push(zD)), i = c;
      }
      return o && (this.instructions.push(lp), this.hitDetectionInstructions.push(lp)), a && (this.instructions.push(gA), this.hitDetectionInstructions.push(gA)), i;
    }
    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawCircle(e, i, r) {
      const n = this.state, s = n.fillStyle, o = n.strokeStyle;
      if (s === void 0 && o === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(e, i, r), n.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        $e.SET_FILL_STYLE,
        gn
      ]), n.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        $e.SET_STROKE_STYLE,
        n.strokeStyle,
        n.lineWidth,
        n.lineCap,
        n.lineJoin,
        n.miterLimit,
        Ea,
        ya
      ]);
      const a = e.getFlatCoordinates(), A = e.getStride(), l = this.coordinates.length;
      this.appendFlatLineCoordinates(
        a,
        0,
        a.length,
        A,
        !1,
        !1
      );
      const c = [$e.CIRCLE, l];
      this.instructions.push(El, c), this.hitDetectionInstructions.push(El, c), n.fillStyle !== void 0 && (this.instructions.push(lp), this.hitDetectionInstructions.push(lp)), n.strokeStyle !== void 0 && (this.instructions.push(gA), this.hitDetectionInstructions.push(gA)), this.endGeometry(i);
    }
    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawPolygon(e, i, r) {
      const n = this.state, s = n.fillStyle, o = n.strokeStyle;
      if (s === void 0 && o === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(e, i, r), n.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        $e.SET_FILL_STYLE,
        gn
      ]), n.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        $e.SET_STROKE_STYLE,
        n.strokeStyle,
        n.lineWidth,
        n.lineCap,
        n.lineJoin,
        n.miterLimit,
        Ea,
        ya
      ]);
      const a = e.getEnds(), A = e.getOrientedFlatCoordinates(), l = e.getStride();
      this.drawFlatCoordinatess_(
        A,
        0,
        /** @type {Array<number>} */
        a,
        l
      ), this.endGeometry(i);
    }
    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawMultiPolygon(e, i, r) {
      const n = this.state, s = n.fillStyle, o = n.strokeStyle;
      if (s === void 0 && o === void 0)
        return;
      this.setFillStrokeStyles_(), this.beginGeometry(e, i, r), n.fillStyle !== void 0 && this.hitDetectionInstructions.push([
        $e.SET_FILL_STYLE,
        gn
      ]), n.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
        $e.SET_STROKE_STYLE,
        n.strokeStyle,
        n.lineWidth,
        n.lineCap,
        n.lineJoin,
        n.miterLimit,
        Ea,
        ya
      ]);
      const a = e.getEndss(), A = e.getOrientedFlatCoordinates(), l = e.getStride();
      let c = 0;
      for (let u = 0, d = a.length; u < d; ++u)
        c = this.drawFlatCoordinatess_(
          A,
          c,
          a[u],
          l
        );
      this.endGeometry(i);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      this.reverseHitDetectionInstructions(), this.state = null;
      const e = this.tolerance;
      if (e !== 0) {
        const i = this.coordinates;
        for (let r = 0, n = i.length; r < n; ++r)
          i[r] = al(i[r], e);
      }
      return super.finish();
    }
    /**
     * @private
     */
    setFillStrokeStyles_() {
      const e = this.state;
      e.fillStyle !== void 0 && this.updateFillStyle(e, this.createFill), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this.applyStroke);
    }
  }
  function Bte(t, e, i, r, n) {
    const s = [];
    let o = i, a = 0, A = e.slice(i, 2);
    for (; a < t && o + n < r; ) {
      const [l, c] = A.slice(-2), u = e[o + n], d = e[o + n + 1], h = Math.sqrt(
        (u - l) * (u - l) + (d - c) * (d - c)
      );
      if (a += h, a >= t) {
        const g = (t - a + h) / h, f = _n(l, u, g), p = _n(c, d, g);
        A.push(f, p), s.push(A), A = [f, p], a == t && (o += n), a = 0;
      } else if (a < t)
        A.push(
          e[o + n],
          e[o + n + 1]
        ), o += n;
      else {
        const g = h - a, f = _n(l, u, g / h), p = _n(c, d, g / h);
        A.push(f, p), s.push(A), A = [f, p], a = 0, o += n;
      }
    }
    return a > 0 && s.push(A), s;
  }
  function wte(t, e, i, r, n) {
    let s = i, o = i, a = 0, A = 0, l = i, c, u, d, h, g, f, p, m, E, y;
    for (u = i; u < r; u += n) {
      const C = e[u], w = e[u + 1];
      g !== void 0 && (E = C - g, y = w - f, h = Math.sqrt(E * E + y * y), p !== void 0 && (A += d, c = Math.acos((p * E + m * y) / (d * h)), c > t && (A > a && (a = A, s = l, o = u), A = 0, l = u - n)), d = h, p = E, m = y), g = C, f = w;
    }
    return A += h, A > a ? [l, u] : [s, o];
  }
  const QE = {
    left: 0,
    center: 0.5,
    right: 1,
    top: 0,
    middle: 0.5,
    hanging: 0.2,
    alphabetic: 0.8,
    ideographic: 0.8,
    bottom: 1
  };
  class Cte extends ff {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(e, i, r, n) {
      super(e, i, r, n), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textKeepUpright_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[gn] = { fillStyle: gn }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
      {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     * @override
     */
    finish() {
      const e = super.finish();
      return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} [index] Render order index.
     * @override
     */
    drawText(e, i, r) {
      const n = this.textFillState_, s = this.textStrokeState_, o = this.textState_;
      if (this.text_ === "" || !o || !n && !s)
        return;
      const a = this.coordinates;
      let A = a.length;
      const l = e.getType();
      let c = null, u = e.getStride();
      if (o.placement === "line" && (l == "LineString" || l == "MultiLineString" || l == "Polygon" || l == "MultiPolygon")) {
        if (!Yi(this.maxExtent, e.getExtent()))
          return;
        let d;
        if (c = e.getFlatCoordinates(), l == "LineString")
          d = [c.length];
        else if (l == "MultiLineString")
          d = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getEnds();
        else if (l == "Polygon")
          d = /** @type {import("../../geom/Polygon.js").default} */
          e.getEnds().slice(0, 1);
        else if (l == "MultiPolygon") {
          const p = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getEndss()
          );
          d = [];
          for (let m = 0, E = p.length; m < E; ++m)
            d.push(p[m][0]);
        }
        this.beginGeometry(e, i, r);
        const h = o.repeat, g = h ? void 0 : o.textAlign;
        let f = 0;
        for (let p = 0, m = d.length; p < m; ++p) {
          let E;
          h ? E = Bte(
            h * this.resolution,
            c,
            f,
            d[p],
            u
          ) : E = [c.slice(f, d[p])];
          for (let y = 0, C = E.length; y < C; ++y) {
            const w = E[y];
            let M = 0, I = w.length;
            if (g == null) {
              const B = wte(
                o.maxAngle,
                w,
                0,
                w.length,
                2
              );
              M = B[0], I = B[1];
            }
            for (let B = M; B < I; B += u)
              a.push(w[B], w[B + 1]);
            const b = a.length;
            f = d[p], this.drawChars_(A, b), A = b;
          }
        }
        this.endGeometry(i);
      } else {
        let d = o.overflow ? null : [];
        switch (l) {
          case "Point":
          case "MultiPoint":
            c = /** @type {import("../../geom/MultiPoint.js").default} */
            e.getFlatCoordinates();
            break;
          case "LineString":
            c = /** @type {import("../../geom/LineString.js").default} */
            e.getFlatMidpoint();
            break;
          case "Circle":
            c = /** @type {import("../../geom/Circle.js").default} */
            e.getCenter();
            break;
          case "MultiLineString":
            c = /** @type {import("../../geom/MultiLineString.js").default} */
            e.getFlatMidpoints(), u = 2;
            break;
          case "Polygon":
            c = /** @type {import("../../geom/Polygon.js").default} */
            e.getFlatInteriorPoint(), o.overflow || d.push(c[2] / this.resolution), u = 3;
            break;
          case "MultiPolygon":
            const E = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              e.getFlatInteriorPoints()
            );
            c = [];
            for (let y = 0, C = E.length; y < C; y += 3)
              o.overflow || d.push(E[y + 2] / this.resolution), c.push(E[y], E[y + 1]);
            if (c.length === 0)
              return;
            u = 2;
            break;
        }
        const h = this.appendFlatPointCoordinates(c, u);
        if (h === A)
          return;
        if (d && (h - A) / 2 !== c.length / u) {
          let E = A / 2;
          d = d.filter((y, C) => {
            const w = a[(E + C) * 2] === c[C * u] && a[(E + C) * 2 + 1] === c[C * u + 1];
            return w || --E, w;
          });
        }
        this.saveTextStates_(), (o.backgroundFill || o.backgroundStroke) && (this.setFillStrokeStyle(
          o.backgroundFill,
          o.backgroundStroke
        ), o.backgroundFill && this.updateFillStyle(this.state, this.createFill), o.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(e, i, r);
        let g = o.padding;
        if (g != ml && (o.scale[0] < 0 || o.scale[1] < 0)) {
          let E = o.padding[0], y = o.padding[1], C = o.padding[2], w = o.padding[3];
          o.scale[0] < 0 && (y = -y, w = -w), o.scale[1] < 0 && (E = -E, C = -C), g = [E, y, C, w];
        }
        const f = this.pixelRatio;
        this.instructions.push([
          $e.DRAW_IMAGE,
          A,
          h,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [1, 1],
          NaN,
          this.declutterMode_,
          this.declutterImageWithText_,
          g == ml ? ml : g.map(function(E) {
            return E * f;
          }),
          !!o.backgroundFill,
          !!o.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          d
        ]);
        const p = 1 / f, m = this.state.fillStyle;
        o.backgroundFill && (this.state.fillStyle = gn, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
          $e.DRAW_IMAGE,
          A,
          h,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [p, p],
          NaN,
          this.declutterMode_,
          this.declutterImageWithText_,
          g,
          !!o.backgroundFill,
          !!o.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_ ? gn : this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          d
        ]), o.backgroundFill && (this.state.fillStyle = m, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(i);
      }
    }
    /**
     * @private
     */
    saveTextStates_() {
      const e = this.textStrokeState_, i = this.textState_, r = this.textFillState_, n = this.strokeKey_;
      e && (n in this.strokeStates || (this.strokeStates[n] = {
        strokeStyle: e.strokeStyle,
        lineCap: e.lineCap,
        lineDashOffset: e.lineDashOffset,
        lineWidth: e.lineWidth,
        lineJoin: e.lineJoin,
        miterLimit: e.miterLimit,
        lineDash: e.lineDash
      }));
      const s = this.textKey_;
      s in this.textStates || (this.textStates[s] = {
        font: i.font,
        textAlign: i.textAlign || gg,
        justify: i.justify,
        textBaseline: i.textBaseline || ME,
        scale: i.scale
      });
      const o = this.fillKey_;
      r && (o in this.fillStates || (this.fillStates[o] = {
        fillStyle: r.fillStyle
      }));
    }
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */
    drawChars_(e, i) {
      const r = this.textStrokeState_, n = this.textState_, s = this.strokeKey_, o = this.textKey_, a = this.fillKey_;
      this.saveTextStates_();
      const A = this.pixelRatio, l = QE[n.textBaseline], c = this.textOffsetY_ * A, u = this.text_, d = r ? r.lineWidth * Math.abs(n.scale[0]) / 2 : 0;
      this.instructions.push([
        $e.DRAW_CHARS,
        e,
        i,
        l,
        n.overflow,
        a,
        n.maxAngle,
        A,
        c,
        s,
        d * A,
        u,
        o,
        1,
        this.declutterMode_,
        this.textKeepUpright_
      ]), this.hitDetectionInstructions.push([
        $e.DRAW_CHARS,
        e,
        i,
        l,
        n.overflow,
        a && gn,
        n.maxAngle,
        A,
        c,
        s,
        d * A,
        u,
        o,
        1 / A,
        this.declutterMode_,
        this.textKeepUpright_
      ]);
    }
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [sharedData] Shared data.
     * @override
     */
    setTextStyle(e, i) {
      let r, n, s;
      if (!e)
        this.text_ = "";
      else {
        const o = e.getFill();
        o ? (n = this.textFillState_, n || (n = /** @type {import("../canvas.js").FillState} */
        {}, this.textFillState_ = n), n.fillStyle = Mo(
          o.getColor() || gn
        )) : (n = null, this.textFillState_ = n);
        const a = e.getStroke();
        if (!a)
          s = null, this.textStrokeState_ = s;
        else {
          s = this.textStrokeState_, s || (s = /** @type {import("../canvas.js").StrokeState} */
          {}, this.textStrokeState_ = s);
          const f = a.getLineDash(), p = a.getLineDashOffset(), m = a.getWidth(), E = a.getMiterLimit();
          s.lineCap = a.getLineCap() || nd, s.lineDash = f ? f.slice() : Ea, s.lineDashOffset = p === void 0 ? ya : p, s.lineJoin = a.getLineJoin() || sd, s.lineWidth = m === void 0 ? fg : m, s.miterLimit = E === void 0 ? dg : E, s.strokeStyle = Mo(
            a.getColor() || hg
          );
        }
        r = this.textState_;
        const A = e.getFont() || TU;
        RU(A);
        const l = e.getScaleArray();
        r.overflow = e.getOverflow(), r.font = A, r.maxAngle = e.getMaxAngle(), r.placement = e.getPlacement(), r.textAlign = e.getTextAlign(), r.repeat = e.getRepeat(), r.justify = e.getJustify(), r.textBaseline = e.getTextBaseline() || ME, r.backgroundFill = e.getBackgroundFill(), r.backgroundStroke = e.getBackgroundStroke(), r.padding = e.getPadding() || ml, r.scale = l === void 0 ? [1, 1] : l;
        const c = e.getOffsetX(), u = e.getOffsetY(), d = e.getRotateWithView(), h = e.getKeepUpright(), g = e.getRotation();
        this.text_ = e.getText() || "", this.textOffsetX_ = c === void 0 ? 0 : c, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = d === void 0 ? !1 : d, this.textKeepUpright_ = h === void 0 ? !0 : h, this.textRotation_ = g === void 0 ? 0 : g, this.strokeKey_ = s ? (typeof s.strokeStyle == "string" ? s.strokeStyle : ve(s.strokeStyle)) + s.lineCap + s.lineDashOffset + "|" + s.lineWidth + s.lineJoin + s.miterLimit + "[" + s.lineDash.join() + "]" : "", this.textKey_ = r.font + r.scale + (r.textAlign || "?") + (r.repeat || "?") + (r.justify || "?") + (r.textBaseline || "?"), this.fillKey_ = n && n.fillStyle ? typeof n.fillStyle == "string" ? n.fillStyle : "|" + ve(n.fillStyle) : "";
      }
      this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = i;
    }
  }
  const bte = {
    Circle: PD,
    Default: ff,
    Image: Ete,
    LineString: yte,
    Polygon: PD,
    Text: Cte
  };
  class WU {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Max extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(e, i, r, n) {
      this.tolerance_ = e, this.maxExtent_ = i, this.pixelRatio_ = n, this.resolution_ = r, this.buildersByZIndex_ = {};
    }
    /**
     * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
     */
    finish() {
      const e = {};
      for (const i in this.buildersByZIndex_) {
        e[i] = e[i] || {};
        const r = this.buildersByZIndex_[i];
        for (const n in r) {
          const s = r[n].finish();
          e[i][n] = s;
        }
      }
      return e;
    }
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("../canvas.js").BuilderType} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */
    getBuilder(e, i) {
      const r = e !== void 0 ? e.toString() : "0";
      let n = this.buildersByZIndex_[r];
      n === void 0 && (n = {}, this.buildersByZIndex_[r] = n);
      let s = n[i];
      if (s === void 0) {
        const o = bte[i];
        s = new o(
          this.tolerance_,
          this.maxExtent_,
          this.resolution_,
          this.pixelRatio_
        ), n[i] = s;
      }
      return s;
    }
  }
  const Mte = 5;
  class KU extends rf {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(e) {
      super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e, this.staleKeys_ = new Array(), this.maxStaleKeys = Mte;
    }
    /**
     * @return {Array<string>} Get the list of stale keys.
     */
    getStaleKeys() {
      return this.staleKeys_;
    }
    /**
     * @param {string} key The new stale key.
     */
    prependStaleKey(e) {
      this.staleKeys_.unshift(e), this.staleKeys_.length > this.maxStaleKeys && (this.staleKeys_.length = this.maxStaleKeys);
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(e) {
      return it();
    }
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(e) {
      return null;
    }
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    prepareFrame(e) {
      return it();
    }
    /**
     * Render the layer.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
    renderFrame(e, i) {
      return it();
    }
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(e, i, r, n, s) {
    }
    /**
     * @return {LayerType} Layer.
     */
    getLayer() {
      return this.layer_;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */
    handleFontsChanged() {
    }
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */
    handleImageChange_(e) {
      const i = (
        /** @type {import("../Image.js").default} */
        e.target
      );
      (i.getState() === ze.LOADED || i.getState() === ze.ERROR) && this.renderIfReadyAndVisible();
    }
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../Image.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */
    loadImage(e) {
      let i = e.getState();
      return i != ze.LOADED && i != ze.ERROR && e.addEventListener(Ge.CHANGE, this.boundHandleImageChange_), i == ze.IDLE && (e.load(), i = e.getState()), i == ze.LOADED;
    }
    /**
     * @protected
     */
    renderIfReadyAndVisible() {
      const e = this.getLayer();
      e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    renderDeferred(e) {
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      delete this.layer_, super.disposeInternal();
    }
  }
  class Lh extends on {
    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
     */
    constructor(e, i, r, n) {
      super(e), this.inversePixelTransform = i, this.frameState = r, this.context = n;
    }
  }
  class ex {
    constructor() {
      /**
       * @private
       * @param {...*} args Args.
       * @return {ZIndexContext} This.
       */
      Ne(this, "pushMethodArgs_", (...e) => (this.instructions_[this.zIndex + this.offset_].push(e), this));
      this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
      new Proxy(CE(), {
        get: (e, i) => {
          if (typeof /** @type {*} */
          CE()[i] == "function")
            return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(i), this.pushMethodArgs_;
        },
        set: (e, i, r) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(i, r), !0)
      });
    }
    /**
     * Push a function that renders to the context directly.
     * @param {function(CanvasRenderingContext2D): void} render Function.
     */
    pushFunction(e) {
      this.instructions_[this.zIndex + this.offset_].push(e);
    }
    /**
     * Get a proxy for CanvasRenderingContext2D which does not support getting state
     * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
     * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
     * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
     * @return {ZIndexContextProxy} Context.
     */
    getContext() {
      return this.context_;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     */
    draw(e) {
      this.instructions_.forEach((i) => {
        for (let r = 0, n = i.length; r < n; ++r) {
          const s = i[r];
          if (typeof s == "function") {
            s(e);
            continue;
          }
          const o = i[++r];
          if (typeof /** @type {*} */
          e[s] == "function")
            e[s](...o);
          else {
            if (typeof o == "function") {
              e[s] = o(e);
              continue;
            }
            e[s] = o;
          }
        }
      });
    }
    clear() {
      this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
    }
    /**
     * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
     * avoid conflicting context.clip() or context.save()/restore() calls.
     */
    offset() {
      this.offset_ = this.instructions_.length, this.zIndex = 0;
    }
  }
  const OD = [];
  let Wc = null;
  function Ite() {
    Wc = Di(1, 1, void 0, {
      willReadFrequently: !0
    });
  }
  class tx extends KU {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(e) {
      super(e), this.container = null, this.renderedResolution, this.tempTransform = ri(), this.pixelTransform = ri(), this.inversePixelTransform = ri(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.frameState = null;
    }
    /**
     * @param {import('../../DataTile.js').ImageLike} image Image.
     * @param {number} col The column index.
     * @param {number} row The row index.
     * @return {Uint8ClampedArray|null} The image data.
     */
    getImageData(e, i, r) {
      Wc || Ite(), Wc.clearRect(0, 0, 1, 1);
      let n;
      try {
        Wc.drawImage(e, i, r, 1, 1, 0, 0, 1, 1), n = Wc.getImageData(0, 0, 1, 1).data;
      } catch {
        return Wc = null, null;
      }
      return n;
    }
    /**
     * @param {import('../../Map.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */
    getBackground(e) {
      let r = this.getLayer().getBackground();
      return typeof r == "function" && (r = r(e.viewState.resolution)), r || void 0;
    }
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {string} [backgroundColor] Background color.
     */
    useContainer(e, i, r) {
      const n = this.getLayer().getClassName();
      let s, o;
      if (e && e.className === n && (!r || e && e.style.backgroundColor && jo(
        Hn(e.style.backgroundColor),
        Hn(r)
      ))) {
        const a = e.firstElementChild;
        a instanceof HTMLCanvasElement && (o = a.getContext("2d"));
      }
      if (o && o.canvas.style.transform === i ? (this.container = e, this.context = o, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
        s = document.createElement("div"), s.className = n;
        let a = s.style;
        a.position = "absolute", a.width = "100%", a.height = "100%", o = Di();
        const A = o.canvas;
        s.appendChild(A), a = A.style, a.position = "absolute", a.left = "0", a.transformOrigin = "top left", this.container = s, this.context = o;
      }
      !this.containerReused && r && !this.container.style.backgroundColor && (this.container.style.backgroundColor = r);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */
    clipUnrotated(e, i, r) {
      const n = qs(r), s = AB(r), o = aB(r), a = oB(r);
      Ei(i.coordinateToPixelTransform, n), Ei(i.coordinateToPixelTransform, s), Ei(i.coordinateToPixelTransform, o), Ei(i.coordinateToPixelTransform, a);
      const A = this.inversePixelTransform;
      Ei(A, n), Ei(A, s), Ei(A, o), Ei(A, a), e.save(), e.beginPath(), e.moveTo(Math.round(n[0]), Math.round(n[1])), e.lineTo(Math.round(s[0]), Math.round(s[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.clip();
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @protected
     */
    prepareContainer(e, i) {
      const r = e.extent, n = e.viewState.resolution, s = e.viewState.rotation, o = e.pixelRatio, a = Math.round(mt(r) / n * o), A = Math.round(Fi(r) / n * o);
      gs(
        this.pixelTransform,
        e.size[0] / 2,
        e.size[1] / 2,
        1 / o,
        1 / o,
        s,
        -a / 2,
        -A / 2
      ), xA(this.inversePixelTransform, this.pixelTransform);
      const l = Pq(this.pixelTransform);
      if (this.useContainer(i, l, this.getBackground(e)), !this.containerReused) {
        const c = this.context.canvas;
        c.width != a || c.height != A ? (c.width = a, c.height = A) : this.context.clearRect(0, 0, a, A), l !== c.style.transform && (c.style.transform = l);
      }
    }
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
    dispatchRenderEvent_(e, i, r) {
      const n = this.getLayer();
      if (n.hasListener(e)) {
        const s = new Lh(
          e,
          this.inversePixelTransform,
          r,
          i
        );
        n.dispatchEvent(s);
      }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    preRender(e, i) {
      this.frameState = i, !i.declutter && this.dispatchRenderEvent_(dr.PRERENDER, e, i);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    postRender(e, i) {
      i.declutter || this.dispatchRenderEvent_(dr.POSTRENDER, e, i);
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeferredInternal(e) {
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
     */
    getRenderContext(e) {
      return e.declutter && !this.deferredContext_ && (this.deferredContext_ = new ex()), e.declutter ? this.deferredContext_.getContext() : this.context;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderDeferred(e) {
      e.declutter && (this.dispatchRenderEvent_(
        dr.PRERENDER,
        this.context,
        e
      ), e.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(e), this.dispatchRenderEvent_(
        dr.POSTRENDER,
        this.context,
        e
      ));
    }
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */
    getRenderTransform(e, i, r, n, s, o, a) {
      const A = s / 2, l = o / 2, c = n / i, u = -c, d = -e[0] + a, h = -e[1];
      return gs(
        this.tempTransform,
        A,
        l,
        c,
        u,
        -r,
        d,
        h
      );
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      delete this.frameState, super.disposeInternal();
    }
  }
  function vte(t, e, i, r, n, s, o, a, A, l, c, u, d = !0) {
    let h = t[e], g = t[e + 1], f = 0, p = 0, m = 0, E = 0;
    function y() {
      f = h, p = g, e += r, h = t[e], g = t[e + 1], E += m, m = Math.sqrt((h - f) * (h - f) + (g - p) * (g - p));
    }
    do
      y();
    while (e < i - r && E + m < s);
    let C = m === 0 ? 0 : (s - E) / m;
    const w = _n(f, h, C), M = _n(p, g, C), I = e - r, b = E, B = s + a * A(l, n, c);
    for (; e < i - r && E + m < B; )
      y();
    C = m === 0 ? 0 : (B - E) / m;
    const x = _n(f, h, C), Q = _n(p, g, C);
    let v = !1;
    if (d)
      if (u) {
        const R = [w, M, x, Q];
        Cv(R, 0, 4, 2, u, R, R), v = R[0] > R[2];
      } else
        v = w > x;
    const T = Math.PI, S = [], D = I + r === e;
    e = I, m = 0, E = b, h = t[e], g = t[e + 1];
    let F;
    if (D) {
      y(), F = Math.atan2(g - p, h - f), v && (F += F > 0 ? -T : T);
      const R = (x + w) / 2, Y = (Q + M) / 2;
      return S[0] = [R, Y, (B - s) / 2, F, n], S;
    }
    n = n.replace(/\n/g, " ");
    for (let R = 0, Y = n.length; R < Y; ) {
      y();
      let L = Math.atan2(g - p, h - f);
      if (v && (L += L > 0 ? -T : T), F !== void 0) {
        let Z = L - F;
        if (Z += Z > T ? -2 * T : Z < -T ? 2 * T : 0, Math.abs(Z) > o)
          return null;
      }
      F = L;
      const N = R;
      let H = 0;
      for (; R < Y; ++R) {
        const Z = v ? Y - R - 1 : R, se = a * A(l, n[Z], c);
        if (e + r < i && E + m < s + H + se / 2)
          break;
        H += se;
      }
      if (R === N)
        continue;
      const P = v ? n.substring(Y - N, Y - R) : n.substring(N, R);
      C = m === 0 ? 0 : (s + H / 2 - E) / m;
      const ie = _n(f, h, C), V = _n(p, g, C);
      S.push([ie, V, H / 2, L, P]), s += H;
    }
    return S;
  }
  const vc = yr(), Wa = [], Wo = [], Ko = [], Ka = [];
  function GD(t) {
    return t[3].declutterBox;
  }
  const jD = new RegExp(
    /* eslint-disable prettier/prettier */
    "[֑-ࣿיִ-﷿ﹰ-ﻼࠀ-࿿-]"
    /* eslint-enable prettier/prettier */
  );
  function x0(t, e) {
    return e === "start" ? e = jD.test(t) ? "right" : "left" : e === "end" && (e = jD.test(t) ? "left" : "right"), QE[e];
  }
  function xte(t, e, i) {
    return i > 0 && t.push(`
`, ""), t.push(e, ""), t;
  }
  class Qte {
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The replay can have overlapping geometries.
     * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
     * @param {boolean} [deferredRendering] Enable deferred rendering.
     */
    constructor(e, i, r, n, s) {
      this.overlaps = r, this.pixelRatio = i, this.resolution = e, this.alignAndScaleFill_, this.instructions = n.instructions, this.coordinates = n.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = ri(), this.hitDetectionInstructions = n.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = n.fillStates || {}, this.strokeStates = n.strokeStates || {}, this.textStates = n.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = s ? new ex() : null;
    }
    /**
     * @return {ZIndexContext} ZIndex context.
     */
    getZIndexContext() {
      return this.zIndexContext_;
    }
    /**
     * @param {string|Array<string>} text Text.
     * @param {string} textKey Text style key.
     * @param {string} fillKey Fill style key.
     * @param {string} strokeKey Stroke style key.
     * @return {import("../canvas.js").Label} Label.
     */
    createLabel(e, i, r, n) {
      const s = e + i + r + n;
      if (this.labels_[s])
        return this.labels_[s];
      const o = n ? this.strokeStates[n] : null, a = r ? this.fillStates[r] : null, A = this.textStates[i], l = this.pixelRatio, c = [
        A.scale[0] * l,
        A.scale[1] * l
      ], u = A.justify ? QE[A.justify] : x0(
        Array.isArray(e) ? e[0] : e,
        A.textAlign || gg
      ), d = n && o.lineWidth ? o.lineWidth : 0, h = Array.isArray(e) ? e : String(e).split(`
`).reduce(xte, []), { width: g, height: f, widths: p, heights: m, lineWidths: E } = dee(
        A,
        h
      ), y = g + d, C = [], w = (y + 2) * c[0], M = (f + d) * c[1], I = {
        width: w < 0 ? Math.floor(w) : Math.ceil(w),
        height: M < 0 ? Math.floor(M) : Math.ceil(M),
        contextInstructions: C
      };
      (c[0] != 1 || c[1] != 1) && C.push("scale", c), n && (C.push("strokeStyle", o.strokeStyle), C.push("lineWidth", d), C.push("lineCap", o.lineCap), C.push("lineJoin", o.lineJoin), C.push("miterLimit", o.miterLimit), C.push("setLineDash", [o.lineDash]), C.push("lineDashOffset", o.lineDashOffset)), r && C.push("fillStyle", a.fillStyle), C.push("textBaseline", "middle"), C.push("textAlign", "center");
      const b = 0.5 - u;
      let B = u * y + b * d;
      const x = [], Q = [];
      let v = 0, T = 0, S = 0, D = 0, F;
      for (let R = 0, Y = h.length; R < Y; R += 2) {
        const L = h[R];
        if (L === `
`) {
          T += v, v = 0, B = u * y + b * d, ++D;
          continue;
        }
        const N = h[R + 1] || A.font;
        N !== F && (n && x.push("font", N), r && Q.push("font", N), F = N), v = Math.max(v, m[S]);
        const H = [
          L,
          B + b * p[S] + u * (p[S] - E[D]),
          0.5 * (d + v) + T
        ];
        B += p[S], n && x.push("strokeText", H), r && Q.push("fillText", H), ++S;
      }
      return Array.prototype.push.apply(C, x), Array.prototype.push.apply(C, Q), this.labels_[s] = I, I;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */
    replayTextBackground_(e, i, r, n, s, o, a) {
      e.beginPath(), e.moveTo.apply(e, i), e.lineTo.apply(e, r), e.lineTo.apply(e, n), e.lineTo.apply(e, s), e.lineTo.apply(e, i), o && (this.alignAndScaleFill_ = /** @type {number} */
      o[2], this.fill_(e)), a && (this.setStrokeStyle_(
        e,
        /** @type {Array<*>} */
        a
      ), e.stroke());
    }
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */
    calculateImageOrLabelDimensions_(e, i, r, n, s, o, a, A, l, c, u, d, h, g, f, p) {
      a *= d[0], A *= d[1];
      let m = r - a, E = n - A;
      const y = s + l > e ? e - l : s, C = o + c > i ? i - c : o, w = g[3] + y * d[0] + g[1], M = g[0] + C * d[1] + g[2], I = m - g[3], b = E - g[0];
      (f || u !== 0) && (Wa[0] = I, Ka[0] = I, Wa[1] = b, Wo[1] = b, Wo[0] = I + w, Ko[0] = Wo[0], Ko[1] = b + M, Ka[1] = Ko[1]);
      let B;
      return u !== 0 ? (B = gs(
        ri(),
        r,
        n,
        1,
        1,
        u,
        -r,
        -n
      ), Ei(B, Wa), Ei(B, Wo), Ei(B, Ko), Ei(B, Ka), fs(
        Math.min(Wa[0], Wo[0], Ko[0], Ka[0]),
        Math.min(Wa[1], Wo[1], Ko[1], Ka[1]),
        Math.max(Wa[0], Wo[0], Ko[0], Ka[0]),
        Math.max(Wa[1], Wo[1], Ko[1], Ka[1]),
        vc
      )) : fs(
        Math.min(I, I + w),
        Math.min(b, b + M),
        Math.max(I, I + w),
        Math.max(b, b + M),
        vc
      ), h && (m = Math.round(m), E = Math.round(E)), {
        drawImageX: m,
        drawImageY: E,
        drawImageW: y,
        drawImageH: C,
        originX: l,
        originY: c,
        declutterBox: {
          minX: vc[0],
          minY: vc[1],
          maxX: vc[2],
          maxY: vc[3],
          value: p
        },
        canvasTransform: B,
        scale: d
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */
    replayImageOrLabel_(e, i, r, n, s, o, a) {
      const A = !!(o || a), l = n.declutterBox, c = a ? a[2] * n.scale[0] / 2 : 0;
      return l.minX - c <= i[0] && l.maxX + c >= 0 && l.minY - c <= i[1] && l.maxY + c >= 0 && (A && this.replayTextBackground_(
        e,
        Wa,
        Wo,
        Ko,
        Ka,
        /** @type {Array<*>} */
        o,
        /** @type {Array<*>} */
        a
      ), hee(
        e,
        n.canvasTransform,
        s,
        r,
        n.originX,
        n.originY,
        n.drawImageW,
        n.drawImageH,
        n.drawImageX,
        n.drawImageY,
        n.scale
      )), !0;
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */
    fill_(e) {
      const i = this.alignAndScaleFill_;
      if (i) {
        const r = Ei(this.renderedTransform_, [0, 0]), n = 512 * this.pixelRatio;
        e.save(), e.translate(r[0] % n, r[1] % n), i !== 1 && e.scale(i, i), e.rotate(this.viewRotation_);
      }
      e.fill(), i && e.restore();
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */
    setStrokeStyle_(e, i) {
      e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
      i[1], e.lineWidth = /** @type {number} */
      i[2], e.lineCap = /** @type {CanvasLineCap} */
      i[3], e.lineJoin = /** @type {CanvasLineJoin} */
      i[4], e.miterLimit = /** @type {number} */
      i[5], e.lineDashOffset = /** @type {number} */
      i[7], e.setLineDash(
        /** @type {Array<number>} */
        i[6]
      );
    }
    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */
    drawLabelWithPointPlacement_(e, i, r, n) {
      const s = this.textStates[i], o = this.createLabel(e, i, n, r), a = this.strokeStates[r], A = this.pixelRatio, l = x0(
        Array.isArray(e) ? e[0] : e,
        s.textAlign || gg
      ), c = QE[s.textBaseline || ME], u = a && a.lineWidth ? a.lineWidth : 0, d = o.width / A - 2 * s.scale[0], h = l * d + 2 * (0.5 - l) * u, g = c * o.height / A + 2 * (0.5 - c) * u;
      return {
        label: o,
        anchorX: h,
        anchorY: g
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */
    execute_(e, i, r, n, s, o, a, A) {
      const l = this.zIndexContext_;
      let c;
      this.pixelCoordinates_ && jo(r, this.renderedTransform_) ? c = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), c = So(
        this.coordinates,
        0,
        this.coordinates.length,
        2,
        r,
        this.pixelCoordinates_
      ), fE(this.renderedTransform_, r));
      let u = 0;
      const d = n.length;
      let h = 0, g, f, p, m, E, y, C, w, M, I, b, B, x, Q = 0, v = 0, T = null, S = null;
      const D = this.coordinateCache_, F = this.viewRotation_, R = Math.round(Math.atan2(-r[1], r[0]) * 1e12) / 1e12, Y = (
        /** @type {import("../../render.js").State} */
        {
          context: e,
          pixelRatio: this.pixelRatio,
          resolution: this.resolution,
          rotation: F
        }
      ), L = this.instructions != n || this.overlaps ? 0 : 200;
      let N, H, P, ie;
      for (; u < d; ) {
        const V = n[u];
        switch (
          /** @type {import("./Instruction.js").default} */
          V[0]
        ) {
          case $e.BEGIN_GEOMETRY:
            N = /** @type {import("../../Feature.js").FeatureLike} */
            V[1], ie = V[3], N.getGeometry() ? a !== void 0 && !Yi(a, ie.getExtent()) ? u = /** @type {number} */
            V[2] + 1 : ++u : u = /** @type {number} */
            V[2], l && (l.zIndex = V[4]);
            break;
          case $e.BEGIN_PATH:
            Q > L && (this.fill_(e), Q = 0), v > L && (e.stroke(), v = 0), !Q && !v && (e.beginPath(), E = NaN, y = NaN), ++u;
            break;
          case $e.CIRCLE:
            h = /** @type {number} */
            V[1];
            const se = c[h], k = c[h + 1], _ = c[h + 2], q = c[h + 3], U = _ - se, J = q - k, ae = Math.sqrt(U * U + J * J);
            e.moveTo(se + ae, k), e.arc(se, k, ae, 0, 2 * Math.PI, !0), ++u;
            break;
          case $e.CLOSE_PATH:
            e.closePath(), ++u;
            break;
          case $e.CUSTOM:
            h = /** @type {number} */
            V[1], g = V[2];
            const $ = (
              /** @type {import("../../geom/SimpleGeometry.js").default} */
              V[3]
            ), Ce = V[4], Re = V[5];
            Y.geometry = $, Y.feature = N, u in D || (D[u] = []);
            const Oe = D[u];
            Re ? Re(c, h, g, 2, Oe) : (Oe[0] = c[h], Oe[1] = c[h + 1], Oe.length = 2), l && (l.zIndex = V[6]), Ce(Oe, Y), ++u;
            break;
          case $e.DRAW_IMAGE:
            h = /** @type {number} */
            V[1], g = /** @type {number} */
            V[2], M = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
            V[3], f = /** @type {number} */
            V[4], p = /** @type {number} */
            V[5];
            let K = (
              /** @type {number} */
              V[6]
            );
            const Ae = (
              /** @type {number} */
              V[7]
            ), ut = (
              /** @type {number} */
              V[8]
            ), Me = (
              /** @type {number} */
              V[9]
            ), Fe = (
              /** @type {boolean} */
              V[10]
            );
            let jt = (
              /** @type {number} */
              V[11]
            );
            const Rt = (
              /** @type {import("../../size.js").Size} */
              V[12]
            );
            let rt = (
              /** @type {number} */
              V[13]
            );
            m = V[14] || "declutter";
            const Ke = (
              /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
              V[15]
            );
            if (!M && V.length >= 20) {
              I = /** @type {string} */
              V[19], b = /** @type {string} */
              V[20], B = /** @type {string} */
              V[21], x = /** @type {string} */
              V[22];
              const we = this.drawLabelWithPointPlacement_(
                I,
                b,
                B,
                x
              );
              M = we.label, V[3] = M;
              const St = (
                /** @type {number} */
                V[23]
              );
              f = (we.anchorX - St) * this.pixelRatio, V[4] = f;
              const Xt = (
                /** @type {number} */
                V[24]
              );
              p = (we.anchorY - Xt) * this.pixelRatio, V[5] = p, K = M.height, V[6] = K, rt = M.width, V[13] = rt;
            }
            let Qt;
            V.length > 25 && (Qt = /** @type {number} */
            V[25]);
            let Ht, lt, Ft;
            V.length > 17 ? (Ht = /** @type {Array<number>} */
            V[16], lt = /** @type {boolean} */
            V[17], Ft = /** @type {boolean} */
            V[18]) : (Ht = ml, lt = !1, Ft = !1), Fe && R ? jt += F : !Fe && !R && (jt -= F);
            let si = 0;
            for (; h < g; h += 2) {
              if (Qt && Qt[si++] < rt / this.pixelRatio)
                continue;
              const we = this.calculateImageOrLabelDimensions_(
                M.width,
                M.height,
                c[h],
                c[h + 1],
                rt,
                K,
                f,
                p,
                ut,
                Me,
                jt,
                Rt,
                s,
                Ht,
                lt || Ft,
                N
              ), St = [
                e,
                i,
                M,
                we,
                Ae,
                lt ? (
                  /** @type {Array<*>} */
                  T
                ) : null,
                Ft ? (
                  /** @type {Array<*>} */
                  S
                ) : null
              ];
              if (A) {
                let Xt, wr, Ar;
                if (Ke) {
                  const bi = g - h;
                  if (!Ke[bi]) {
                    Ke[bi] = { args: St, declutterMode: m };
                    continue;
                  }
                  const lr = Ke[bi];
                  Xt = lr.args, wr = lr.declutterMode, delete Ke[bi], Ar = GD(Xt);
                }
                let Cs, bs;
                if (Xt && (wr !== "declutter" || !A.collides(Ar)) && (Cs = !0), (m !== "declutter" || !A.collides(we.declutterBox)) && (bs = !0), wr === "declutter" && m === "declutter") {
                  const bi = Cs && bs;
                  Cs = bi, bs = bi;
                }
                Cs && (wr !== "none" && A.insert(Ar), this.replayImageOrLabel_.apply(this, Xt)), bs && (m !== "none" && A.insert(we.declutterBox), this.replayImageOrLabel_.apply(this, St));
              } else
                this.replayImageOrLabel_.apply(this, St);
            }
            ++u;
            break;
          case $e.DRAW_CHARS:
            const pi = (
              /** @type {number} */
              V[1]
            ), Ti = (
              /** @type {number} */
              V[2]
            ), Li = (
              /** @type {number} */
              V[3]
            ), zi = (
              /** @type {number} */
              V[4]
            );
            x = /** @type {string} */
            V[5];
            const Ri = (
              /** @type {number} */
              V[6]
            ), ei = (
              /** @type {number} */
              V[7]
            ), oi = (
              /** @type {number} */
              V[8]
            );
            B = /** @type {string} */
            V[9];
            const Wi = (
              /** @type {number} */
              V[10]
            );
            I = /** @type {string} */
            V[11], b = /** @type {string} */
            V[12];
            const Ki = [
              /** @type {number} */
              V[13],
              /** @type {number} */
              V[13]
            ];
            m = V[14] || "declutter";
            const Ut = (
              /** @type {boolean} */
              V[15]
            ), zr = this.textStates[b], an = zr.font, An = [
              zr.scale[0] * ei,
              zr.scale[1] * ei
            ];
            let Wn;
            an in this.widths_ ? Wn = this.widths_[an] : (Wn = {}, this.widths_[an] = Wn);
            const oe = SU(c, pi, Ti, 2), le = Math.abs(An[0]) * ID(an, I, Wn);
            if (zi || le <= oe) {
              const we = this.textStates[b].textAlign, St = (oe - le) * x0(I, we), Xt = vte(
                c,
                pi,
                Ti,
                2,
                I,
                St,
                Ri,
                Math.abs(An[0]),
                ID,
                an,
                Wn,
                R ? 0 : this.viewRotation_,
                Ut
              );
              e: if (Xt) {
                const wr = [];
                let Ar, Cs, bs, bi, lr;
                if (B)
                  for (Ar = 0, Cs = Xt.length; Ar < Cs; ++Ar) {
                    lr = Xt[Ar], bs = /** @type {string} */
                    lr[4], bi = this.createLabel(bs, b, "", B), f = /** @type {number} */
                    lr[2] + (An[0] < 0 ? -Wi : Wi), p = Li * bi.height + (0.5 - Li) * 2 * Wi * An[1] / An[0] - oi;
                    const Ms = this.calculateImageOrLabelDimensions_(
                      bi.width,
                      bi.height,
                      lr[0],
                      lr[1],
                      bi.width,
                      bi.height,
                      f,
                      p,
                      0,
                      0,
                      lr[3],
                      Ki,
                      !1,
                      ml,
                      !1,
                      N
                    );
                    if (A && m === "declutter" && A.collides(Ms.declutterBox))
                      break e;
                    wr.push([
                      e,
                      i,
                      bi,
                      Ms,
                      1,
                      null,
                      null
                    ]);
                  }
                if (x)
                  for (Ar = 0, Cs = Xt.length; Ar < Cs; ++Ar) {
                    lr = Xt[Ar], bs = /** @type {string} */
                    lr[4], bi = this.createLabel(bs, b, x, ""), f = /** @type {number} */
                    lr[2], p = Li * bi.height - oi;
                    const Ms = this.calculateImageOrLabelDimensions_(
                      bi.width,
                      bi.height,
                      lr[0],
                      lr[1],
                      bi.width,
                      bi.height,
                      f,
                      p,
                      0,
                      0,
                      lr[3],
                      Ki,
                      !1,
                      ml,
                      !1,
                      N
                    );
                    if (A && m === "declutter" && A.collides(Ms.declutterBox))
                      break e;
                    wr.push([
                      e,
                      i,
                      bi,
                      Ms,
                      1,
                      null,
                      null
                    ]);
                  }
                A && m !== "none" && A.load(wr.map(GD));
                for (let Ms = 0, z = wr.length; Ms < z; ++Ms)
                  this.replayImageOrLabel_.apply(this, wr[Ms]);
              }
            }
            ++u;
            break;
          case $e.END_GEOMETRY:
            if (o !== void 0) {
              N = /** @type {import("../../Feature.js").FeatureLike} */
              V[1];
              const we = o(
                N,
                ie,
                m
              );
              if (we)
                return we;
            }
            ++u;
            break;
          case $e.FILL:
            L ? Q++ : this.fill_(e), ++u;
            break;
          case $e.MOVE_TO_LINE_TO:
            for (h = /** @type {number} */
            V[1], g = /** @type {number} */
            V[2], H = c[h], P = c[h + 1], e.moveTo(H, P), E = H + 0.5 | 0, y = P + 0.5 | 0, h += 2; h < g; h += 2)
              H = c[h], P = c[h + 1], C = H + 0.5 | 0, w = P + 0.5 | 0, (h == g - 2 || C !== E || w !== y) && (e.lineTo(H, P), E = C, y = w);
            ++u;
            break;
          case $e.SET_FILL_STYLE:
            T = V, this.alignAndScaleFill_ = V[2], Q && (this.fill_(e), Q = 0, v && (e.stroke(), v = 0)), e.fillStyle = V[1], ++u;
            break;
          case $e.SET_STROKE_STYLE:
            S = V, v && (e.stroke(), v = 0), this.setStrokeStyle_(
              e,
              /** @type {Array<*>} */
              V
            ), ++u;
            break;
          case $e.STROKE:
            L ? v++ : e.stroke(), ++u;
            break;
          default:
            ++u;
            break;
        }
      }
      Q && this.fill_(e), v && e.stroke();
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default<DeclutterEntry>} [declutterTree] Declutter tree.
     */
    execute(e, i, r, n, s, o) {
      this.viewRotation_ = n, this.execute_(
        e,
        i,
        r,
        this.instructions,
        s,
        void 0,
        void 0,
        o
      );
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */
    executeHitDetection(e, i, r, n, s) {
      return this.viewRotation_ = r, this.execute_(
        e,
        [e.canvas.width, e.canvas.height],
        i,
        this.hitDetectionInstructions,
        !0,
        n,
        s
      );
    }
  }
  const du = [
    "Polygon",
    "Circle",
    "LineString",
    "Image",
    "Text",
    "Default"
  ], FE = ["Image", "Text"], Fte = du.filter(
    (t) => !FE.includes(t)
  );
  class XU {
    /**
     * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
     * should be set here, unless the target context does not exceed that extent (which
     * can be the case when rendering to tiles).
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The executor group can have overlapping geometries.
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
     * The serializable instructions.
     * @param {number} [renderBuffer] Optional rendering buffer.
     * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
     */
    constructor(e, i, r, n, s, o, a) {
      this.maxExtent_ = e, this.overlaps_ = n, this.pixelRatio_ = r, this.resolution_ = i, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = ri(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(s, a);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    clip(e, i) {
      const r = this.getClipCoords(i);
      e.beginPath(), e.moveTo(r[0], r[1]), e.lineTo(r[2], r[3]), e.lineTo(r[4], r[5]), e.lineTo(r[6], r[7]), e.clip();
    }
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     * @param {boolean} deferredRendering Enable deferred rendering.
     */
    createExecutors_(e, i) {
      for (const r in e) {
        let n = this.executorsByZIndex_[r];
        n === void 0 && (n = {}, this.executorsByZIndex_[r] = n);
        const s = e[r];
        for (const o in s) {
          const a = s[o];
          n[o] = new Qte(
            this.resolution_,
            this.pixelRatio_,
            this.overlaps_,
            a,
            i
          );
        }
      }
    }
    /**
     * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */
    hasExecutors(e) {
      for (const i in this.executorsByZIndex_) {
        const r = this.executorsByZIndex_[i];
        for (let n = 0, s = e.length; n < s; ++n)
          if (e[n] in r)
            return !0;
      }
      return !1;
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(e, i, r, n, s, o) {
      n = Math.round(n);
      const a = n * 2 + 1, A = gs(
        this.hitDetectionTransform_,
        n + 0.5,
        n + 0.5,
        1 / i,
        -1 / i,
        -r,
        -e[0],
        -e[1]
      ), l = !this.hitDetectionContext_;
      l && (this.hitDetectionContext_ = Di(
        a,
        a,
        void 0,
        { willReadFrequently: !0 }
      ));
      const c = this.hitDetectionContext_;
      c.canvas.width !== a || c.canvas.height !== a ? (c.canvas.width = a, c.canvas.height = a) : l || c.clearRect(0, 0, a, a);
      let u;
      this.renderBuffer_ !== void 0 && (u = yr(), Uh(u, e), $r(
        u,
        i * (this.renderBuffer_ + n),
        u
      ));
      const d = Ste(n);
      let h;
      function g(w, M, I) {
        const b = c.getImageData(
          0,
          0,
          a,
          a
        ).data;
        for (let B = 0, x = d.length; B < x; B++)
          if (b[d[B]] > 0) {
            if (!o || I === "none" || h !== "Image" && h !== "Text" || o.includes(w)) {
              const Q = (d[B] - 3) / 4, v = n - Q % a, T = n - (Q / a | 0), S = s(w, M, v * v + T * T);
              if (S)
                return S;
            }
            c.clearRect(0, 0, a, a);
            break;
          }
      }
      const f = Object.keys(this.executorsByZIndex_).map(Number);
      f.sort(Qo);
      let p, m, E, y, C;
      for (p = f.length - 1; p >= 0; --p) {
        const w = f[p].toString();
        for (E = this.executorsByZIndex_[w], m = du.length - 1; m >= 0; --m)
          if (h = du[m], y = E[h], y !== void 0 && (C = y.executeHitDetection(
            c,
            A,
            r,
            g,
            u
          ), C))
            return C;
      }
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>|null} Clip coordinates.
     */
    getClipCoords(e) {
      const i = this.maxExtent_;
      if (!i)
        return null;
      const r = i[0], n = i[1], s = i[2], o = i[3], a = [r, n, r, o, s, o, s, n];
      return So(a, 0, 8, 2, e, a), a;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return vA(this.executorsByZIndex_);
    }
    /**
     * @param {CanvasRenderingContext2D} targetContext Context.
     * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ALL}
     * @param {import("rbush").default<import('./Executor.js').DeclutterEntry>|null} [declutterTree] Declutter tree.
     *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
     */
    execute(e, i, r, n, s, o, a) {
      const A = Object.keys(this.executorsByZIndex_).map(Number);
      A.sort(a ? WN : Qo), o = o || du;
      const l = du.length;
      for (let c = 0, u = A.length; c < u; ++c) {
        const d = A[c].toString(), h = this.executorsByZIndex_[d];
        for (let g = 0, f = o.length; g < f; ++g) {
          const p = o[g], m = h[p];
          if (m !== void 0) {
            const E = a === null ? void 0 : m.getZIndexContext(), y = E ? E.getContext() : e, C = this.maxExtent_ && p !== "Image" && p !== "Text";
            if (C && (y.save(), this.clip(y, r)), !E || p === "Text" || p === "Image" ? m.execute(
              y,
              i,
              r,
              n,
              s,
              a
            ) : E.pushFunction(
              (w) => m.execute(
                w,
                i,
                r,
                n,
                s,
                a
              )
            ), C && y.restore(), E) {
              E.offset();
              const w = A[c] * l + g;
              this.deferredZIndexContexts_[w] || (this.deferredZIndexContexts_[w] = []), this.deferredZIndexContexts_[w].push(E);
            }
          }
        }
      }
      this.renderedContext_ = e;
    }
    getDeferredZIndexContexts() {
      return this.deferredZIndexContexts_;
    }
    getRenderedContext() {
      return this.renderedContext_;
    }
    renderDeferred() {
      const e = this.deferredZIndexContexts_, i = Object.keys(e).map(Number).sort(Qo);
      for (let r = 0, n = i.length; r < n; ++r)
        e[i[r]].forEach((s) => {
          s.draw(this.renderedContext_), s.clear();
        }), e[i[r]].length = 0;
    }
  }
  const Q0 = {};
  function Ste(t) {
    if (Q0[t] !== void 0)
      return Q0[t];
    const e = t * 2 + 1, i = t * t, r = new Array(i + 1);
    for (let s = 0; s <= t; ++s)
      for (let o = 0; o <= t; ++o) {
        const a = s * s + o * o;
        if (a > i)
          break;
        let A = r[a];
        A || (A = [], r[a] = A), A.push(((t + s) * e + (t + o)) * 4 + 3), s > 0 && A.push(((t - s) * e + (t + o)) * 4 + 3), o > 0 && (A.push(((t + s) * e + (t - o)) * 4 + 3), s > 0 && A.push(((t - s) * e + (t - o)) * 4 + 3));
      }
    const n = [];
    for (let s = 0, o = r.length; s < o; ++s)
      r[s] && n.push(...r[s]);
    return Q0[t] = n, n;
  }
  class Dte extends VU {
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
     * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
     */
    constructor(e, i, r, n, s, o, a) {
      super(), this.context_ = e, this.pixelRatio_ = i, this.extent_ = r, this.transform_ = n, this.transformRotation_ = n ? af(Math.atan2(n[1], n[0]), 10) : 0, this.viewRotation_ = s, this.squaredTolerance_ = o, this.userTransform_ = a, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = ri();
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawImages_(e, i, r, n) {
      if (!this.image_)
        return;
      const s = So(
        e,
        i,
        r,
        n,
        this.transform_,
        this.pixelCoordinates_
      ), o = this.context_, a = this.tmpLocalTransform_, A = o.globalAlpha;
      this.imageOpacity_ != 1 && (o.globalAlpha = A * this.imageOpacity_);
      let l = this.imageRotation_;
      this.transformRotation_ === 0 && (l -= this.viewRotation_), this.imageRotateWithView_ && (l += this.viewRotation_);
      for (let c = 0, u = s.length; c < u; c += 2) {
        const d = s[c] - this.imageAnchorX_, h = s[c + 1] - this.imageAnchorY_;
        if (l !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
          const g = d + this.imageAnchorX_, f = h + this.imageAnchorY_;
          gs(
            a,
            g,
            f,
            1,
            1,
            l,
            -g,
            -f
          ), o.save(), o.transform.apply(o, a), o.translate(g, f), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            -this.imageAnchorX_,
            -this.imageAnchorY_,
            this.imageWidth_,
            this.imageHeight_
          ), o.restore();
        } else
          o.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            d,
            h,
            this.imageWidth_,
            this.imageHeight_
          );
      }
      this.imageOpacity_ != 1 && (o.globalAlpha = A);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawText_(e, i, r, n) {
      if (!this.textState_ || this.text_ === "")
        return;
      this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
      const s = So(
        e,
        i,
        r,
        n,
        this.transform_,
        this.pixelCoordinates_
      ), o = this.context_;
      let a = this.textRotation_;
      for (this.transformRotation_ === 0 && (a -= this.viewRotation_), this.textRotateWithView_ && (a += this.viewRotation_); i < r; i += n) {
        const A = s[i] + this.textOffsetX_, l = s[i + 1] + this.textOffsetY_;
        a !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(A - this.textOffsetX_, l - this.textOffsetY_), o.rotate(a), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, A, l), this.textFillState_ && o.fillText(this.text_, A, l));
      }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */
    moveToLineTo_(e, i, r, n, s) {
      const o = this.context_, a = So(
        e,
        i,
        r,
        n,
        this.transform_,
        this.pixelCoordinates_
      );
      o.moveTo(a[0], a[1]);
      let A = a.length;
      s && (A -= 2);
      for (let l = 2; l < A; l += 2)
        o.lineTo(a[l], a[l + 1]);
      return s && o.closePath(), r;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawRings_(e, i, r, n) {
      for (let s = 0, o = r.length; s < o; ++s)
        i = this.moveToLineTo_(
          e,
          i,
          r[s],
          n,
          !0
        );
      return i;
    }
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     * @override
     */
    drawCircle(e) {
      if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Circle.js").default} */
      e.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!Yi(this.extent_, e.getExtent())) {
        if (this.fillState_ || this.strokeState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const i = D$(
            e,
            this.transform_,
            this.pixelCoordinates_
          ), r = i[2] - i[0], n = i[3] - i[1], s = Math.sqrt(r * r + n * n), o = this.context_;
          o.beginPath(), o.arc(
            i[0],
            i[1],
            s,
            0,
            2 * Math.PI
          ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
        }
        this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
      }
    }
    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     * @override
     */
    setStyle(e) {
      this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    setTransform(e) {
      this.transform_ = e;
    }
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     * @override
     */
    drawGeometry(e) {
      switch (e.getType()) {
        case "Point":
          this.drawPoint(
            /** @type {import("../../geom/Point.js").default} */
            e
          );
          break;
        case "LineString":
          this.drawLineString(
            /** @type {import("../../geom/LineString.js").default} */
            e
          );
          break;
        case "Polygon":
          this.drawPolygon(
            /** @type {import("../../geom/Polygon.js").default} */
            e
          );
          break;
        case "MultiPoint":
          this.drawMultiPoint(
            /** @type {import("../../geom/MultiPoint.js").default} */
            e
          );
          break;
        case "MultiLineString":
          this.drawMultiLineString(
            /** @type {import("../../geom/MultiLineString.js").default} */
            e
          );
          break;
        case "MultiPolygon":
          this.drawMultiPolygon(
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e
          );
          break;
        case "GeometryCollection":
          this.drawGeometryCollection(
            /** @type {import("../../geom/GeometryCollection.js").default} */
            e
          );
          break;
        case "Circle":
          this.drawCircle(
            /** @type {import("../../geom/Circle.js").default} */
            e
          );
          break;
      }
    }
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     * @override
     */
    drawFeature(e, i) {
      const r = i.getGeometryFunction()(e);
      r && (this.setStyle(i), this.drawGeometry(r));
    }
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     * @override
     */
    drawGeometryCollection(e) {
      const i = e.getGeometriesArray();
      for (let r = 0, n = i.length; r < n; ++r)
        this.drawGeometry(i[r]);
    }
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     * @override
     */
    drawPoint(e) {
      this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
      e.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const i = e.getFlatCoordinates(), r = e.getStride();
      this.image_ && this.drawImages_(i, 0, i.length, r), this.text_ !== "" && this.drawText_(i, 0, i.length, r);
    }
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     * @override
     */
    drawMultiPoint(e) {
      this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
      e.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const i = e.getFlatCoordinates(), r = e.getStride();
      this.image_ && this.drawImages_(i, 0, i.length, r), this.text_ !== "" && this.drawText_(i, 0, i.length, r);
    }
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     * @override
     */
    drawLineString(e) {
      if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
      e.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!Yi(this.extent_, e.getExtent())) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const i = this.context_, r = e.getFlatCoordinates();
          i.beginPath(), this.moveToLineTo_(
            r,
            0,
            r.length,
            e.getStride(),
            !1
          ), i.stroke();
        }
        if (this.text_ !== "") {
          const i = e.getFlatMidpoint();
          this.drawText_(i, 0, 2, 2);
        }
      }
    }
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     * @override
     */
    drawMultiLineString(e) {
      this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
      e.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      ));
      const i = e.getExtent();
      if (Yi(this.extent_, i)) {
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const r = this.context_, n = e.getFlatCoordinates();
          let s = 0;
          const o = (
            /** @type {Array<number>} */
            e.getEnds()
          ), a = e.getStride();
          r.beginPath();
          for (let A = 0, l = o.length; A < l; ++A)
            s = this.moveToLineTo_(
              n,
              s,
              o[A],
              a,
              !1
            );
          r.stroke();
        }
        if (this.text_ !== "") {
          const r = e.getFlatMidpoints();
          this.drawText_(r, 0, r.length, 2);
        }
      }
    }
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     * @override
     */
    drawPolygon(e) {
      if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
      e.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!Yi(this.extent_, e.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const i = this.context_;
          i.beginPath(), this.drawRings_(
            e.getOrientedFlatCoordinates(),
            0,
            /** @type {Array<number>} */
            e.getEnds(),
            e.getStride()
          ), this.fillState_ && i.fill(), this.strokeState_ && i.stroke();
        }
        if (this.text_ !== "") {
          const i = e.getFlatInteriorPoint();
          this.drawText_(i, 0, 2, 2);
        }
      }
    }
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @override
     */
    drawMultiPolygon(e) {
      if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
      e.simplifyTransformed(
        this.squaredTolerance_,
        this.userTransform_
      )), !!Yi(this.extent_, e.getExtent())) {
        if (this.strokeState_ || this.fillState_) {
          this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
          const i = this.context_, r = e.getOrientedFlatCoordinates();
          let n = 0;
          const s = e.getEndss(), o = e.getStride();
          i.beginPath();
          for (let a = 0, A = s.length; a < A; ++a) {
            const l = s[a];
            n = this.drawRings_(r, n, l, o);
          }
          this.fillState_ && i.fill(), this.strokeState_ && i.stroke();
        }
        if (this.text_ !== "") {
          const i = e.getFlatInteriorPoints();
          this.drawText_(i, 0, i.length, 2);
        }
      }
    }
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */
    setContextFillState_(e) {
      const i = this.context_, r = this.contextFillState_;
      r ? r.fillStyle != e.fillStyle && (r.fillStyle = e.fillStyle, i.fillStyle = e.fillStyle) : (i.fillStyle = e.fillStyle, this.contextFillState_ = {
        fillStyle: e.fillStyle
      });
    }
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */
    setContextStrokeState_(e) {
      const i = this.context_, r = this.contextStrokeState_;
      r ? (r.lineCap != e.lineCap && (r.lineCap = e.lineCap, i.lineCap = e.lineCap), jo(r.lineDash, e.lineDash) || i.setLineDash(
        r.lineDash = e.lineDash
      ), r.lineDashOffset != e.lineDashOffset && (r.lineDashOffset = e.lineDashOffset, i.lineDashOffset = e.lineDashOffset), r.lineJoin != e.lineJoin && (r.lineJoin = e.lineJoin, i.lineJoin = e.lineJoin), r.lineWidth != e.lineWidth && (r.lineWidth = e.lineWidth, i.lineWidth = e.lineWidth), r.miterLimit != e.miterLimit && (r.miterLimit = e.miterLimit, i.miterLimit = e.miterLimit), r.strokeStyle != e.strokeStyle && (r.strokeStyle = e.strokeStyle, i.strokeStyle = e.strokeStyle)) : (i.lineCap = e.lineCap, i.setLineDash(e.lineDash), i.lineDashOffset = e.lineDashOffset, i.lineJoin = e.lineJoin, i.lineWidth = e.lineWidth, i.miterLimit = e.miterLimit, i.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
        lineCap: e.lineCap,
        lineDash: e.lineDash,
        lineDashOffset: e.lineDashOffset,
        lineJoin: e.lineJoin,
        lineWidth: e.lineWidth,
        miterLimit: e.miterLimit,
        strokeStyle: e.strokeStyle
      });
    }
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */
    setContextTextState_(e) {
      const i = this.context_, r = this.contextTextState_, n = e.textAlign ? e.textAlign : gg;
      r ? (r.font != e.font && (r.font = e.font, i.font = e.font), r.textAlign != n && (r.textAlign = n, i.textAlign = n), r.textBaseline != e.textBaseline && (r.textBaseline = e.textBaseline, i.textBaseline = e.textBaseline)) : (i.font = e.font, i.textAlign = n, i.textBaseline = e.textBaseline, this.contextTextState_ = {
        font: e.font,
        textAlign: n,
        textBaseline: e.textBaseline
      });
    }
    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     * @override
     */
    setFillStrokeStyle(e, i) {
      if (!e)
        this.fillState_ = null;
      else {
        const r = e.getColor();
        this.fillState_ = {
          fillStyle: Mo(
            r || gn
          )
        };
      }
      if (!i)
        this.strokeState_ = null;
      else {
        const r = i.getColor(), n = i.getLineCap(), s = i.getLineDash(), o = i.getLineDashOffset(), a = i.getLineJoin(), A = i.getWidth(), l = i.getMiterLimit(), c = s || Ea;
        this.strokeState_ = {
          lineCap: n !== void 0 ? n : nd,
          lineDash: this.pixelRatio_ === 1 ? c : c.map((u) => u * this.pixelRatio_),
          lineDashOffset: (o || ya) * this.pixelRatio_,
          lineJoin: a !== void 0 ? a : sd,
          lineWidth: (A !== void 0 ? A : fg) * this.pixelRatio_,
          miterLimit: l !== void 0 ? l : dg,
          strokeStyle: Mo(
            r || hg
          )
        };
      }
    }
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @override
     */
    setImageStyle(e) {
      let i;
      if (!e || !(i = e.getSize())) {
        this.image_ = null;
        return;
      }
      const r = e.getPixelRatio(this.pixelRatio_), n = e.getAnchor(), s = e.getOrigin();
      this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = n[0] * r, this.imageAnchorY_ = n[1] * r, this.imageHeight_ = i[1] * r, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = s[0], this.imageOriginY_ = s[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
      const o = e.getScaleArray();
      this.imageScale_ = [
        o[0] * this.pixelRatio_ / r,
        o[1] * this.pixelRatio_ / r
      ], this.imageWidth_ = i[0] * r;
    }
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @override
     */
    setTextStyle(e) {
      if (!e)
        this.text_ = "";
      else {
        const i = e.getFill();
        if (!i)
          this.textFillState_ = null;
        else {
          const h = i.getColor();
          this.textFillState_ = {
            fillStyle: Mo(
              h || gn
            )
          };
        }
        const r = e.getStroke();
        if (!r)
          this.textStrokeState_ = null;
        else {
          const h = r.getColor(), g = r.getLineCap(), f = r.getLineDash(), p = r.getLineDashOffset(), m = r.getLineJoin(), E = r.getWidth(), y = r.getMiterLimit();
          this.textStrokeState_ = {
            lineCap: g !== void 0 ? g : nd,
            lineDash: f || Ea,
            lineDashOffset: p || ya,
            lineJoin: m !== void 0 ? m : sd,
            lineWidth: E !== void 0 ? E : fg,
            miterLimit: y !== void 0 ? y : dg,
            strokeStyle: Mo(
              h || hg
            )
          };
        }
        const n = e.getFont(), s = e.getOffsetX(), o = e.getOffsetY(), a = e.getRotateWithView(), A = e.getRotation(), l = e.getScaleArray(), c = e.getText(), u = e.getTextAlign(), d = e.getTextBaseline();
        this.textState_ = {
          font: n !== void 0 ? n : TU,
          textAlign: u !== void 0 ? u : gg,
          textBaseline: d !== void 0 ? d : ME
        }, this.text_ = c !== void 0 ? Array.isArray(c) ? c.reduce((h, g, f) => h += f % 2 ? " " : g, "") : c : "", this.textOffsetX_ = s !== void 0 ? this.pixelRatio_ * s : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = a !== void 0 ? a : !1, this.textRotation_ = A !== void 0 ? A : 0, this.textScale_ = [
          this.pixelRatio_ * l[0],
          this.pixelRatio_ * l[1]
        ];
      }
    }
  }
  const kn = 0.5;
  function ZU(t, e, i, r, n, s, o, a, A) {
    const l = A ? lf(n) : n, c = t[0] * kn, u = t[1] * kn, d = Di(c, u);
    d.imageSmoothingEnabled = !1;
    const h = d.canvas, g = new Dte(
      d,
      kn,
      n,
      null,
      o,
      a,
      A ? Af(x$(), A) : null
    ), f = i.length, p = Math.floor((256 * 256 * 256 - 1) / f), m = {};
    for (let y = 1; y <= f; ++y) {
      const C = i[y - 1], w = C.getStyleFunction() || r;
      if (!w)
        continue;
      let M = w(C, s);
      if (!M)
        continue;
      Array.isArray(M) || (M = [M]);
      const b = (y * p).toString(16).padStart(7, "#00000");
      for (let B = 0, x = M.length; B < x; ++B) {
        const Q = M[B], v = Q.getGeometryFunction()(C);
        if (!v || !Yi(l, v.getExtent()))
          continue;
        const T = Q.clone(), S = T.getFill();
        S && S.setColor(b);
        const D = T.getStroke();
        D && (D.setColor(b), D.setLineDash(null)), T.setText(void 0);
        const F = Q.getImage();
        if (F) {
          const N = F.getImageSize();
          if (!N)
            continue;
          const H = Di(
            N[0],
            N[1],
            void 0,
            { alpha: !1 }
          ), P = H.canvas;
          H.fillStyle = b, H.fillRect(0, 0, P.width, P.height), T.setImage(
            new Ol({
              img: P,
              anchor: F.getAnchor(),
              anchorXUnits: "pixels",
              anchorYUnits: "pixels",
              offset: F.getOrigin(),
              opacity: 1,
              size: F.getSize(),
              scale: F.getScale(),
              rotation: F.getRotation(),
              rotateWithView: F.getRotateWithView()
            })
          );
        }
        const R = T.getZIndex() || 0;
        let Y = m[R];
        Y || (Y = {}, m[R] = Y, Y.Polygon = [], Y.Circle = [], Y.LineString = [], Y.Point = []);
        const L = v.getType();
        if (L === "GeometryCollection") {
          const N = (
            /** @type {import("../../geom/GeometryCollection.js").default} */
            v.getGeometriesArrayRecursive()
          );
          for (let H = 0, P = N.length; H < P; ++H) {
            const ie = N[H];
            Y[ie.getType().replace("Multi", "")].push(
              ie,
              T
            );
          }
        } else
          Y[L.replace("Multi", "")].push(v, T);
      }
    }
    const E = Object.keys(m).map(Number).sort(Qo);
    for (let y = 0, C = E.length; y < C; ++y) {
      const w = m[E[y]];
      for (const M in w) {
        const I = w[M];
        for (let b = 0, B = I.length; b < B; b += 2) {
          g.setStyle(I[b + 1]);
          for (let x = 0, Q = e.length; x < Q; ++x)
            g.setTransform(e[x]), g.drawGeometry(I[b]);
        }
      }
    }
    return d.getImageData(0, 0, h.width, h.height);
  }
  function qU(t, e, i) {
    const r = [];
    if (i) {
      const n = Math.floor(Math.round(t[0]) * kn), s = Math.floor(Math.round(t[1]) * kn), o = (yi(n, 0, i.width - 1) + yi(s, 0, i.height - 1) * i.width) * 4, a = i.data[o], A = i.data[o + 1], c = i.data[o + 2] + 256 * (A + 256 * a), u = Math.floor((256 * 256 * 256 - 1) / e.length);
      c && c % u === 0 && r.push(e[c / u - 1]);
    }
    return r;
  }
  const Tte = 0.5, $U = {
    Point: zte,
    LineString: Nte,
    Polygon: Ote,
    MultiPoint: Pte,
    MultiLineString: Ute,
    MultiPolygon: Lte,
    GeometryCollection: Yte,
    Circle: _te
  };
  function Rte(t, e) {
    return parseInt(ve(t), 10) - parseInt(ve(e), 10);
  }
  function wb(t, e) {
    const i = eL(t, e);
    return i * i;
  }
  function eL(t, e) {
    return Tte * t / e;
  }
  function _te(t, e, i, r, n) {
    const s = i.getFill(), o = i.getStroke();
    if (s || o) {
      const A = t.getBuilder(i.getZIndex(), "Circle");
      A.setFillStrokeStyle(s, o), A.drawCircle(e, r, n);
    }
    const a = i.getText();
    if (a && a.getText()) {
      const A = t.getBuilder(i.getZIndex(), "Text");
      A.setTextStyle(a), A.drawText(e, r);
    }
  }
  function SE(t, e, i, r, n, s, o, a) {
    const A = [], l = i.getImage();
    if (l) {
      let d = !0;
      const h = l.getImageState();
      h == ze.LOADED || h == ze.ERROR ? d = !1 : h == ze.IDLE && l.load(), d && A.push(l.ready());
    }
    const c = i.getFill();
    c && c.loading() && A.push(c.ready());
    const u = A.length > 0;
    return u && Promise.all(A).then(() => n(null)), kte(
      t,
      e,
      i,
      r,
      s,
      o,
      a
    ), u;
  }
  function kte(t, e, i, r, n, s, o) {
    const a = i.getGeometryFunction()(e);
    if (!a)
      return;
    const A = a.simplifyTransformed(
      r,
      n
    );
    if (i.getRenderer())
      tL(t, A, i, e, o);
    else {
      const c = $U[A.getType()];
      c(
        t,
        A,
        i,
        e,
        o,
        s
      );
    }
  }
  function tL(t, e, i, r, n) {
    if (e.getType() == "GeometryCollection") {
      const o = (
        /** @type {import("../geom/GeometryCollection.js").default} */
        e.getGeometries()
      );
      for (let a = 0, A = o.length; a < A; ++a)
        tL(t, o[a], i, r, n);
      return;
    }
    t.getBuilder(i.getZIndex(), "Default").drawCustom(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      e,
      r,
      i.getRenderer(),
      i.getHitDetectionRenderer(),
      n
    );
  }
  function Yte(t, e, i, r, n, s) {
    const o = e.getGeometriesArray();
    let a, A;
    for (a = 0, A = o.length; a < A; ++a) {
      const l = $U[o[a].getType()];
      l(
        t,
        o[a],
        i,
        r,
        n,
        s
      );
    }
  }
  function Nte(t, e, i, r, n) {
    const s = i.getStroke();
    if (s) {
      const a = t.getBuilder(
        i.getZIndex(),
        "LineString"
      );
      a.setFillStrokeStyle(null, s), a.drawLineString(e, r, n);
    }
    const o = i.getText();
    if (o && o.getText()) {
      const a = t.getBuilder(i.getZIndex(), "Text");
      a.setTextStyle(o), a.drawText(e, r, n);
    }
  }
  function Ute(t, e, i, r, n) {
    const s = i.getStroke();
    if (s) {
      const a = t.getBuilder(
        i.getZIndex(),
        "LineString"
      );
      a.setFillStrokeStyle(null, s), a.drawMultiLineString(e, r, n);
    }
    const o = i.getText();
    if (o && o.getText()) {
      const a = t.getBuilder(i.getZIndex(), "Text");
      a.setTextStyle(o), a.drawText(e, r, n);
    }
  }
  function Lte(t, e, i, r, n) {
    const s = i.getFill(), o = i.getStroke();
    if (o || s) {
      const A = t.getBuilder(i.getZIndex(), "Polygon");
      A.setFillStrokeStyle(s, o), A.drawMultiPolygon(e, r, n);
    }
    const a = i.getText();
    if (a && a.getText()) {
      const A = t.getBuilder(i.getZIndex(), "Text");
      A.setTextStyle(a), A.drawText(e, r, n);
    }
  }
  function zte(t, e, i, r, n, s) {
    const o = i.getImage(), a = i.getText(), A = a && a.getText(), l = s && o && A ? {} : void 0;
    if (o) {
      if (o.getImageState() != ze.LOADED)
        return;
      const c = t.getBuilder(i.getZIndex(), "Image");
      c.setImageStyle(o, l), c.drawPoint(e, r, n);
    }
    if (A) {
      const c = t.getBuilder(i.getZIndex(), "Text");
      c.setTextStyle(a, l), c.drawText(e, r, n);
    }
  }
  function Pte(t, e, i, r, n, s) {
    const o = i.getImage(), a = o && o.getOpacity() !== 0, A = i.getText(), l = A && A.getText(), c = s && a && l ? {} : void 0;
    if (a) {
      if (o.getImageState() != ze.LOADED)
        return;
      const u = t.getBuilder(i.getZIndex(), "Image");
      u.setImageStyle(o, c), u.drawMultiPoint(e, r, n);
    }
    if (l) {
      const u = t.getBuilder(i.getZIndex(), "Text");
      u.setTextStyle(A, c), u.drawText(e, r, n);
    }
  }
  function Ote(t, e, i, r, n) {
    const s = i.getFill(), o = i.getStroke();
    if (s || o) {
      const A = t.getBuilder(i.getZIndex(), "Polygon");
      A.setFillStrokeStyle(s, o), A.drawPolygon(e, r, n);
    }
    const a = i.getText();
    if (a && a.getText()) {
      const A = t.getBuilder(i.getZIndex(), "Text");
      A.setTextStyle(a), A.drawText(e, r, n);
    }
  }
  class Gte extends tx {
    /**
     * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
     */
    constructor(e) {
      super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = yr(), this.wrappedRenderedExtent_ = yr(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
    }
    /**
     * @param {ExecutorGroup} executorGroup Executor group.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {boolean} [declutterable] `true` to only render declutterable items,
     *     `false` to only render non-declutterable items, `undefined` to render all.
     */
    renderWorlds(e, i, r) {
      const n = i.extent, s = i.viewState, o = s.center, a = s.resolution, A = s.projection, l = s.rotation, c = A.getExtent(), u = this.getLayer().getSource(), d = this.getLayer().getDeclutter(), h = i.pixelRatio, g = i.viewHints, f = !(g[Ai.ANIMATING] || g[Ai.INTERACTING]), p = this.context, m = Math.round(mt(n) / a * h), E = Math.round(Fi(n) / a * h), y = u.getWrapX() && A.canWrapX(), C = y ? mt(c) : null, w = y ? Math.ceil((n[2] - c[2]) / C) + 1 : 1;
      let M = y ? Math.floor((n[0] - c[0]) / C) : 0;
      do {
        let I = this.getRenderTransform(
          o,
          a,
          0,
          h,
          m,
          E,
          M * C
        );
        i.declutter && (I = I.slice(0)), e.execute(
          p,
          [p.canvas.width, p.canvas.height],
          I,
          l,
          f,
          r === void 0 ? du : r ? FE : Fte,
          r ? d && i.declutter[d] : void 0
        );
      } while (++M < w);
    }
    /**
     * @private
     */
    setDrawContext_() {
      this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = Di(
        this.context.canvas.width,
        this.context.canvas.height,
        OD
      ));
    }
    /**
     * @private
     */
    resetDrawContext_() {
      if (this.opacity_ !== 1) {
        const e = this.targetContext_.globalAlpha;
        this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = e, uf(this.context), OD.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
      }
    }
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(e) {
      !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, e, !0);
    }
    /**
     * Render deferred instructions.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderDeferredInternal(e) {
      this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     * @override
     */
    renderFrame(e, i) {
      const r = e.layerStatesArray[e.layerIndex];
      this.opacity_ = r.opacity;
      const n = e.viewState;
      this.prepareContainer(e, i);
      const s = this.context, o = this.replayGroup_;
      let a = o && !o.isEmpty();
      if (!a && !(this.getLayer().hasListener(dr.PRERENDER) || this.getLayer().hasListener(dr.POSTRENDER)))
        return null;
      if (this.setDrawContext_(), this.preRender(s, e), n.projection, this.clipped_ = !1, a && r.extent && this.clipping) {
        const A = is(r.extent);
        a = Yi(A, e.extent), this.clipped_ = a && !ts(A, e.extent), this.clipped_ && this.clipUnrotated(s, e, A);
      }
      return a && this.renderWorlds(
        o,
        e,
        this.getLayer().getDeclutter() ? !1 : void 0
      ), !e.declutter && this.clipped_ && s.restore(), this.postRender(s, e), this.renderedRotation_ !== n.rotation && (this.renderedRotation_ = n.rotation, this.hitDetectionImageData_ = null), e.declutter || this.resetDrawContext_(), this.container;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise
     * that resolves with an array of features.
     * @override
     */
    getFeatures(e) {
      return new Promise((i) => {
        if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const r = this.frameState.size.slice(), n = this.renderedCenter_, s = this.renderedResolution_, o = this.renderedRotation_, a = this.renderedProjection_, A = this.wrappedRenderedExtent_, l = this.getLayer(), c = [], u = r[0] * kn, d = r[1] * kn;
          c.push(
            this.getRenderTransform(
              n,
              s,
              o,
              kn,
              u,
              d,
              0
            ).slice()
          );
          const h = l.getSource(), g = a.getExtent();
          if (h.getWrapX() && a.canWrapX() && !ts(g, A)) {
            let f = A[0];
            const p = mt(g);
            let m = 0, E;
            for (; f < g[0]; )
              --m, E = p * m, c.push(
                this.getRenderTransform(
                  n,
                  s,
                  o,
                  kn,
                  u,
                  d,
                  E
                ).slice()
              ), f += p;
            for (m = 0, f = A[2]; f > g[2]; )
              ++m, E = p * m, c.push(
                this.getRenderTransform(
                  n,
                  s,
                  o,
                  kn,
                  u,
                  d,
                  E
                ).slice()
              ), f -= p;
          }
          this.hitDetectionImageData_ = ZU(
            r,
            c,
            this.renderedFeatures_,
            l.getStyleFunction(),
            A,
            s,
            o,
            wb(s, this.renderedPixelRatio_),
            null
          );
        }
        i(
          qU(e, this.renderedFeatures_, this.hitDetectionImageData_)
        );
      });
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     * @override
     */
    forEachFeatureAtCoordinate(e, i, r, n, s) {
      if (!this.replayGroup_)
        return;
      const o = i.viewState.resolution, a = i.viewState.rotation, A = this.getLayer(), l = {}, c = function(d, h, g) {
        const f = ve(d), p = l[f];
        if (p) {
          if (p !== !0 && g < p.distanceSq) {
            if (g === 0)
              return l[f] = !0, s.splice(s.lastIndexOf(p), 1), n(d, A, h);
            p.geometry = h, p.distanceSq = g;
          }
        } else {
          if (g === 0)
            return l[f] = !0, n(d, A, h);
          s.push(
            l[f] = {
              feature: d,
              layer: A,
              geometry: h,
              distanceSq: g,
              callback: n
            }
          );
        }
      }, u = this.getLayer().getDeclutter();
      return this.replayGroup_.forEachFeatureAtCoordinate(
        e,
        o,
        a,
        r,
        c,
        u ? i.declutter[u].all().map((d) => d.value) : null
      );
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @override
     */
    handleFontsChanged() {
      const e = this.getLayer();
      e.getVisible() && this.replayGroup_ && e.changed();
    }
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    handleStyleImageChange_(e) {
      this.renderIfReadyAndVisible();
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(e) {
      const i = this.getLayer(), r = i.getSource();
      if (!r)
        return !1;
      const n = e.viewHints[Ai.ANIMATING], s = e.viewHints[Ai.INTERACTING], o = i.getUpdateWhileAnimating(), a = i.getUpdateWhileInteracting();
      if (this.ready && !o && n || !a && s)
        return this.animatingOrInteracting_ = !0, !0;
      this.animatingOrInteracting_ = !1;
      const A = e.extent, l = e.viewState, c = l.projection, u = l.resolution, d = e.pixelRatio, h = i.getRevision(), g = i.getRenderBuffer();
      let f = i.getRenderOrder();
      f === void 0 && (f = Rte);
      const p = l.center.slice(), m = $r(
        A,
        g * u
      ), E = m.slice(), y = [m.slice()], C = c.getExtent();
      if (r.getWrapX() && c.canWrapX() && !ts(C, e.extent)) {
        const S = mt(C), D = Math.max(mt(m) / 2, S);
        m[0] = C[0] - D, m[2] = C[2] + D, mv(p, c);
        const F = $N(y[0], c);
        F[0] < C[0] && F[2] < C[2] ? y.push([
          F[0] + S,
          F[1],
          F[2] + S,
          F[3]
        ]) : F[0] > C[0] && F[2] > C[2] && y.push([
          F[0] - S,
          F[1],
          F[2] - S,
          F[3]
        ]);
      }
      if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == h && this.renderedRenderOrder_ == f && this.renderedFrameDeclutter_ === !!e.declutter && ts(this.wrappedRenderedExtent_, m))
        return jo(this.renderedExtent_, E) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = E), this.renderedCenter_ = p, this.replayGroupChanged = !1, !0;
      this.replayGroup_ = null;
      const w = new WU(
        eL(u, d),
        m,
        u,
        d
      );
      let M;
      for (let S = 0, D = y.length; S < D; ++S)
        r.loadFeatures(y[S], u, c);
      const I = wb(u, d);
      let b = !0;
      const B = (
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         * @param {number} index Index.
         */
        (S, D) => {
          let F;
          const R = S.getStyleFunction() || i.getStyleFunction();
          if (R && (F = R(S, u)), F) {
            const Y = this.renderFeature(
              S,
              I,
              F,
              w,
              M,
              this.getLayer().getDeclutter(),
              D
            );
            b = b && !Y;
          }
        }
      ), x = lf(m), Q = r.getFeaturesInExtent(x);
      f && Q.sort(f);
      for (let S = 0, D = Q.length; S < D; ++S)
        B(Q[S], S);
      this.renderedFeatures_ = Q, this.ready = b;
      const v = w.finish(), T = new XU(
        m,
        u,
        d,
        r.getOverlaps(),
        v,
        i.getRenderBuffer(),
        !!e.declutter
      );
      return this.renderedResolution_ = u, this.renderedRevision_ = h, this.renderedRenderOrder_ = f, this.renderedFrameDeclutter_ = !!e.declutter, this.renderedExtent_ = E, this.wrappedRenderedExtent_ = m, this.renderedCenter_ = p, this.renderedProjection_ = c, this.renderedPixelRatio_ = d, this.replayGroup_ = T, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
    }
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
     * @param {boolean} [declutter] Enable decluttering.
     * @param {number} [index] Render order index.
     * @return {boolean} `true` if an image is loading.
     */
    renderFeature(e, i, r, n, s, o, a) {
      if (!r)
        return !1;
      let A = !1;
      if (Array.isArray(r))
        for (let l = 0, c = r.length; l < c; ++l)
          A = SE(
            n,
            e,
            r[l],
            i,
            this.boundHandleStyleImageChange_,
            s,
            o,
            a
          ) || A;
      else
        A = SE(
          n,
          e,
          r,
          i,
          this.boundHandleStyleImageChange_,
          s,
          o,
          a
        );
      return A;
    }
  }
  class Bs extends gf {
    /**
     * @param {Options<VectorSourceType, FeatureType>} [options] Options.
     */
    constructor(e) {
      super(e);
    }
    /**
     * @override
     */
    createRenderer() {
      return new Gte(this);
    }
  }
  class DE {
    /**
     * @param {number} [maxEntries] Max entries.
     */
    constructor(e) {
      this.rbush_ = new zU(e), this.items_ = {};
    }
    /**
     * Insert a value into the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    insert(e, i) {
      const r = {
        minX: e[0],
        minY: e[1],
        maxX: e[2],
        maxY: e[3],
        value: i
      };
      this.rbush_.insert(r), this.items_[ve(i)] = r;
    }
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */
    load(e, i) {
      const r = new Array(i.length);
      for (let n = 0, s = i.length; n < s; n++) {
        const o = e[n], a = i[n], A = {
          minX: o[0],
          minY: o[1],
          maxX: o[2],
          maxY: o[3],
          value: a
        };
        r[n] = A, this.items_[ve(a)] = A;
      }
      this.rbush_.load(r);
    }
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
    remove(e) {
      const i = ve(e), r = this.items_[i];
      return delete this.items_[i], this.rbush_.remove(r) !== null;
    }
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    update(e, i) {
      const r = this.items_[ve(i)], n = [r.minX, r.minY, r.maxX, r.maxY];
      Zs(n, e) || (this.remove(i), this.insert(e, i));
    }
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */
    getAll() {
      return this.rbush_.all().map(function(i) {
        return i.value;
      });
    }
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */
    getInExtent(e) {
      const i = {
        minX: e[0],
        minY: e[1],
        maxX: e[2],
        maxY: e[3]
      };
      return this.rbush_.search(i).map(function(n) {
        return n.value;
      });
    }
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEach(e) {
      return this.forEach_(this.getAll(), e);
    }
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     */
    forEachInExtent(e, i) {
      return this.forEach_(this.getInExtent(e), i);
    }
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): R} callback Callback.
     * @return {R|undefined} Callback return value.
     * @template R
     * @private
     */
    forEach_(e, i) {
      let r;
      for (let n = 0, s = e.length; n < s; n++)
        if (r = i(e[n]), r)
          return r;
      return r;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return vA(this.items_);
    }
    /**
     * Remove all values from the RBush.
     */
    clear() {
      this.rbush_.clear(), this.items_ = {};
    }
    /**
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */
    getExtent(e) {
      const i = this.rbush_.toJSON();
      return fs(i.minX, i.minY, i.maxX, i.maxY, e);
    }
    /**
     * @param {RBush<T>} rbush R-Tree.
     */
    concat(e) {
      this.rbush_.load(e.rbush_.all());
      for (const i in e.items_)
        this.items_[i] = e.items_[i];
    }
  }
  class od extends jA {
    /**
     * @param {!import("../coordinate.js").Coordinate} center Center.
     *     For internal use, flat coordinates in combination with `layout` and no
     *     `radius` are also accepted.
     * @param {number} [radius] Radius in units of the projection.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(e, i, r) {
      super(), r !== void 0 && i === void 0 ? this.setFlatCoordinates(r, e) : (i = i || 0, this.setCenterAndRadius(e, i, r));
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Circle} Clone.
     * @api
     * @override
     */
    clone() {
      const e = new od(
        this.flatCoordinates.slice(),
        void 0,
        this.layout
      );
      return e.applyProperties(this), e;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      const s = this.flatCoordinates, o = e - s[0], a = i - s[1], A = o * o + a * a;
      if (A < n) {
        if (A === 0)
          for (let l = 0; l < this.stride; ++l)
            r[l] = s[l];
        else {
          const l = this.getRadius() / Math.sqrt(A);
          r[0] = s[0] + l * o, r[1] = s[1] + l * a;
          for (let c = 2; c < this.stride; ++c)
            r[c] = s[c];
        }
        return r.length = this.stride, A;
      }
      return n;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(e, i) {
      const r = this.flatCoordinates, n = e - r[0], s = i - r[1];
      return n * n + s * s <= this.getRadiusSquared_();
    }
    /**
     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @return {import("../coordinate.js").Coordinate} Center.
     * @api
     */
    getCenter() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(e) {
      const i = this.flatCoordinates, r = i[this.stride] - i[0];
      return fs(
        i[0] - r,
        i[1] - r,
        i[0] + r,
        i[1] + r,
        e
      );
    }
    /**
     * Return the radius of the circle.
     * @return {number} Radius.
     * @api
     */
    getRadius() {
      return Math.sqrt(this.getRadiusSquared_());
    }
    /**
     * @private
     * @return {number} Radius squared.
     */
    getRadiusSquared_() {
      const e = this.flatCoordinates[this.stride] - this.flatCoordinates[0], i = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
      return e * e + i * i;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "Circle";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      const i = this.getExtent();
      if (Yi(e, i)) {
        const r = this.getCenter();
        return e[0] <= r[0] && e[2] >= r[0] || e[1] <= r[1] && e[3] >= r[1] ? !0 : dv(e, this.intersectsCoordinate.bind(this));
      }
      return !1;
    }
    /**
     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @api
     */
    setCenter(e) {
      const i = this.stride, r = this.flatCoordinates[i] - this.flatCoordinates[0], n = e.slice();
      n[i] = n[0] + r;
      for (let s = 1; s < i; ++s)
        n[i + s] = e[s];
      this.setFlatCoordinates(this.layout, n), this.changed();
    }
    /**
     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
     * number) of the circle.
     * @param {!import("../coordinate.js").Coordinate} center Center.
     * @param {number} radius Radius.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCenterAndRadius(e, i, r) {
      this.setLayout(r, e, 0), this.flatCoordinates || (this.flatCoordinates = []);
      const n = this.flatCoordinates;
      let s = uU(n, 0, e, this.stride);
      n[s++] = n[0] + i;
      for (let o = 1, a = this.stride; o < a; ++o)
        n[s++] = n[o];
      n.length = s, this.changed();
    }
    /**
     * @override
     */
    getCoordinates() {
      return null;
    }
    /**
     * @override
     */
    setCoordinates(e, i) {
    }
    /**
     * Set the radius of the circle. The radius is in the units of the projection.
     * @param {number} radius Radius.
     * @api
     */
    setRadius(e) {
      this.flatCoordinates[this.stride] = this.flatCoordinates[0] + e, this.changed();
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(e, i) {
      const r = this.getCenter(), n = this.getStride();
      this.setCenter(
        Cv(r, 0, r.length, n, e, i, r)
      ), this.changed();
    }
  }
  od.prototype.transform;
  class Eg extends bv {
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    constructor(e) {
      super(), this.geometries_ = e, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
    }
    /**
     * @private
     */
    unlistenGeometriesChange_() {
      this.changeEventsKeys_.forEach(Pt), this.changeEventsKeys_.length = 0;
    }
    /**
     * @private
     */
    listenGeometriesChange_() {
      const e = this.geometries_;
      for (let i = 0, r = e.length; i < r; ++i)
        this.changeEventsKeys_.push(
          nt(e[i], Ge.CHANGE, this.changed, this)
        );
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!GeometryCollection} Clone.
     * @api
     * @override
     */
    clone() {
      const e = new Eg(
        F0(this.geometries_)
      );
      return e.applyProperties(this), e;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      if (n < oc(this.getExtent(), e, i))
        return n;
      const s = this.geometries_;
      for (let o = 0, a = s.length; o < a; ++o)
        n = s[o].closestPointXY(
          e,
          i,
          r,
          n
        );
      return n;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(e, i) {
      const r = this.geometries_;
      for (let n = 0, s = r.length; n < s; ++n)
        if (r[n].containsXY(e, i))
          return !0;
      return !1;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     * @override
     */
    computeExtent(e) {
      _d(e);
      const i = this.geometries_;
      for (let r = 0, n = i.length; r < n; ++r)
        uv(e, i[r].getExtent());
      return e;
    }
    /**
     * Return the geometries that make up this geometry collection.
     * @return {Array<Geometry>} Geometries.
     * @api
     */
    getGeometries() {
      return F0(this.geometries_);
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArray() {
      return this.geometries_;
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArrayRecursive() {
      let e = [];
      const i = this.geometries_;
      for (let r = 0, n = i.length; r < n; ++r)
        i[r].getType() === this.getType() ? e = e.concat(
          /** @type {GeometryCollection} */
          i[r].getGeometriesArrayRecursive()
        ) : e.push(i[r]);
      return e;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {GeometryCollection} Simplified GeometryCollection.
     * @override
     */
    getSimplifiedGeometry(e) {
      if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
        return this;
      const i = [], r = this.geometries_;
      let n = !1;
      for (let s = 0, o = r.length; s < o; ++s) {
        const a = r[s], A = a.getSimplifiedGeometry(e);
        i.push(A), A !== a && (n = !0);
      }
      return n ? new Eg(
        i
      ) : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "GeometryCollection";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      const i = this.geometries_;
      for (let r = 0, n = i.length; r < n; ++r)
        if (i[r].intersectsExtent(e))
          return !0;
      return !1;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.geometries_.length === 0;
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     * @override
     */
    rotate(e, i) {
      const r = this.geometries_;
      for (let n = 0, s = r.length; n < s; ++n)
        r[n].rotate(e, i);
      this.changed();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     * @override
     */
    scale(e, i, r) {
      r || (r = xn(this.getExtent()));
      const n = this.geometries_;
      for (let s = 0, o = n.length; s < o; ++s)
        n[s].scale(e, i, r);
      this.changed();
    }
    /**
     * Set the geometries that make up this geometry collection.
     * @param {Array<Geometry>} geometries Geometries.
     * @api
     */
    setGeometries(e) {
      this.setGeometriesArray(F0(e));
    }
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    setGeometriesArray(e) {
      this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     * @override
     */
    applyTransform(e) {
      const i = this.geometries_;
      for (let r = 0, n = i.length; r < n; ++r)
        i[r].applyTransform(e);
      this.changed();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     * @override
     */
    translate(e, i) {
      const r = this.geometries_;
      for (let n = 0, s = r.length; n < s; ++n)
        r[n].translate(e, i);
      this.changed();
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.unlistenGeometriesChange_(), super.disposeInternal();
    }
  }
  function F0(t) {
    return t.map((e) => e.clone());
  }
  class Da extends jA {
    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Flat coordinate ends for internal use.
     */
    constructor(e, i, r) {
      if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
        this.setCoordinates(
          /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
          e,
          i
        );
      else if (i !== void 0 && r)
        this.setFlatCoordinates(
          i,
          /** @type {Array<number>} */
          e
        ), this.ends_ = r;
      else {
        const n = (
          /** @type {Array<LineString>} */
          e
        ), s = [], o = [];
        for (let A = 0, l = n.length; A < l; ++A) {
          const c = n[A];
          xr(s, c.getFlatCoordinates()), o.push(s.length);
        }
        const a = n.length === 0 ? this.getLayout() : n[0].getLayout();
        this.setFlatCoordinates(a, s), this.ends_ = o;
      }
    }
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */
    appendLineString(e) {
      xr(this.flatCoordinates, e.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     * @override
     */
    clone() {
      const e = new Da(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      return e.applyProperties(this), e;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      return n < oc(this.getExtent(), e, i) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        Iv(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), xv(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        !1,
        e,
        i,
        r,
        n
      ));
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(e, i, r) {
      return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (i = i !== void 0 ? i : !1, r = r !== void 0 ? r : !1, oee(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        e,
        i,
        r
      ));
    }
    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return cg(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */
    getLineString(e) {
      return e < 0 || this.ends_.length <= e ? null : new bn(
        this.flatCoordinates.slice(
          e === 0 ? 0 : this.ends_[e - 1],
          this.ends_[e]
        ),
        this.layout
      );
    }
    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */
    getLineStrings() {
      const e = this.flatCoordinates, i = this.ends_, r = this.layout, n = [];
      let s = 0;
      for (let o = 0, a = i.length; o < a; ++o) {
        const A = i[o], l = new bn(
          e.slice(s, A),
          r
        );
        n.push(l), s = A;
      }
      return n;
    }
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints() {
      const e = [], i = this.flatCoordinates;
      let r = 0;
      const n = this.ends_, s = this.stride;
      for (let o = 0, a = n.length; o < a; ++o) {
        const A = n[o], l = bE(
          i,
          r,
          A,
          s,
          0.5
        );
        xr(e, l), r = A;
      }
      return e;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(e) {
      const i = [], r = [];
      return i.length = hU(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        e,
        i,
        0,
        r
      ), new Da(i, "XY", r);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiLineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      return L$(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        e
      );
    }
    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(e, i) {
      this.setLayout(i, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
      const r = cf(
        this.flatCoordinates,
        0,
        e,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = r.length === 0 ? 0 : r[r.length - 1], this.changed();
    }
  }
  class lc extends jA {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(e, i) {
      super(), i && !Array.isArray(e[0]) ? this.setFlatCoordinates(
        i,
        /** @type {Array<number>} */
        e
      ) : this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        e,
        i
      );
    }
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */
    appendPoint(e) {
      xr(this.flatCoordinates, e.getFlatCoordinates()), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     * @override
     */
    clone() {
      const e = new lc(
        this.flatCoordinates.slice(),
        this.layout
      );
      return e.applyProperties(this), e;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      if (n < oc(this.getExtent(), e, i))
        return n;
      const s = this.flatCoordinates, o = this.stride;
      for (let a = 0, A = s.length; a < A; a += o) {
        const l = fa(
          e,
          i,
          s[a],
          s[a + 1]
        );
        if (l < n) {
          n = l;
          for (let c = 0; c < o; ++c)
            r[c] = s[a + c];
          r.length = o;
        }
      }
      return n;
    }
    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     * @override
     */
    getCoordinates() {
      return hA(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */
    getPoint(e) {
      const i = this.flatCoordinates.length / this.stride;
      return e < 0 || i <= e ? null : new Cn(
        this.flatCoordinates.slice(
          e * this.stride,
          (e + 1) * this.stride
        ),
        this.layout
      );
    }
    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */
    getPoints() {
      const e = this.flatCoordinates, i = this.layout, r = this.stride, n = [];
      for (let s = 0, o = e.length; s < o; s += r) {
        const a = new Cn(e.slice(s, s + r), i);
        n.push(a);
      }
      return n;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiPoint";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      const i = this.flatCoordinates, r = this.stride;
      for (let n = 0, s = i.length; n < s; n += r) {
        const o = i[n], a = i[n + 1];
        if (lv(e, o, a))
          return !0;
      }
      return !1;
    }
    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(e, i) {
      this.setLayout(i, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = uB(
        this.flatCoordinates,
        0,
        e,
        this.stride
      ), this.changed();
    }
  }
  function iL(t, e, i, r) {
    const n = [];
    let s = yr();
    for (let o = 0, a = i.length; o < a; ++o) {
      const A = i[o];
      s = cv(
        t,
        e,
        A[0],
        r
      ), n.push((s[0] + s[2]) / 2, (s[1] + s[3]) / 2), e = A[A.length - 1];
    }
    return n;
  }
  class Ta extends jA {
    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
     */
    constructor(e, i, r) {
      if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !r && !Array.isArray(e[0])) {
        const n = (
          /** @type {Array<Polygon>} */
          e
        ), s = [], o = [];
        for (let a = 0, A = n.length; a < A; ++a) {
          const l = n[a], c = s.length, u = l.getEnds();
          for (let d = 0, h = u.length; d < h; ++d)
            u[d] += c;
          xr(s, l.getFlatCoordinates()), o.push(u);
        }
        i = n.length === 0 ? this.getLayout() : n[0].getLayout(), e = s, r = o;
      }
      i !== void 0 && r ? (this.setFlatCoordinates(
        i,
        /** @type {Array<number>} */
        e
      ), this.endss_ = r) : this.setCoordinates(
        /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
        e,
        i
      );
    }
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */
    appendPolygon(e) {
      let i;
      if (!this.flatCoordinates)
        this.flatCoordinates = e.getFlatCoordinates().slice(), i = e.getEnds().slice(), this.endss_.push();
      else {
        const r = this.flatCoordinates.length;
        xr(this.flatCoordinates, e.getFlatCoordinates()), i = e.getEnds().slice();
        for (let n = 0, s = i.length; n < s; ++n)
          i[n] += r;
      }
      this.endss_.push(i), this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     * @override
     */
    clone() {
      const e = this.endss_.length, i = new Array(e);
      for (let n = 0; n < e; ++n)
        i[n] = this.endss_[n].slice();
      const r = new Ta(
        this.flatCoordinates.slice(),
        this.layout,
        i
      );
      return r.applyProperties(this), r;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     * @override
     */
    closestPointXY(e, i, r, n) {
      return n < oc(this.getExtent(), e, i) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
        T$(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          0
        )
      ), this.maxDeltaRevision_ = this.getRevision()), R$(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        this.maxDelta_,
        !0,
        e,
        i,
        r,
        n
      ));
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     * @override
     */
    containsXY(e, i) {
      return U$(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e,
        i
      );
    }
    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return Y$(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     * @override
     */
    getCoordinates(e) {
      let i;
      return e !== void 0 ? (i = this.getOrientedFlatCoordinates().slice(), fb(
        i,
        0,
        this.endss_,
        this.stride,
        e
      )) : i = this.flatCoordinates, gb(
        i,
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * @return {Array<Array<number>>} Endss.
     */
    getEndss() {
      return this.endss_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints() {
      if (this.flatInteriorPointsRevision_ != this.getRevision()) {
        const e = iL(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
        this.flatInteriorPoints_ = mU(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          e
        ), this.flatInteriorPointsRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.flatInteriorPoints_
      );
    }
    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoints() {
      return new lc(this.getFlatInteriorPoints().slice(), "XYM");
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const e = this.flatCoordinates;
        wU(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = fb(
          this.orientedFlatCoordinates_,
          0,
          this.endss_,
          this.stride
        )), this.orientedRevision_ = this.getRevision();
      }
      return (
        /** @type {Array<number>} */
        this.orientedFlatCoordinates_
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     * @override
     */
    getSimplifiedGeometryInternal(e) {
      const i = [], r = [];
      return i.length = k$(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        Math.sqrt(e),
        i,
        0,
        r
      ), new Ta(i, "XY", r);
    }
    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */
    getPolygon(e) {
      if (e < 0 || this.endss_.length <= e)
        return null;
      let i;
      if (e === 0)
        i = 0;
      else {
        const s = this.endss_[e - 1];
        i = s[s.length - 1];
      }
      const r = this.endss_[e].slice(), n = r[r.length - 1];
      if (i !== 0)
        for (let s = 0, o = r.length; s < o; ++s)
          r[s] -= i;
      return new en(
        this.flatCoordinates.slice(i, n),
        this.layout,
        r
      );
    }
    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */
    getPolygons() {
      const e = this.layout, i = this.flatCoordinates, r = this.endss_, n = [];
      let s = 0;
      for (let o = 0, a = r.length; o < a; ++o) {
        const A = r[o].slice(), l = A[A.length - 1];
        if (s !== 0)
          for (let u = 0, d = A.length; u < d; ++u)
            A[u] -= s;
        const c = new en(
          i.slice(s, l),
          e,
          A
        );
        n.push(c), s = l;
      }
      return n;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     * @override
     */
    getType() {
      return "MultiPolygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     * @override
     */
    intersectsExtent(e) {
      return z$(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      );
    }
    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     * @override
     */
    setCoordinates(e, i) {
      this.setLayout(i, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
      const r = dU(
        this.flatCoordinates,
        0,
        e,
        this.stride,
        this.endss_
      );
      if (r.length === 0)
        this.flatCoordinates.length = 0;
      else {
        const n = r[r.length - 1];
        this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1];
      }
      this.changed();
    }
  }
  const HD = ri();
  class Ir {
    /**
     * @param {Type} type Geometry type.
     * @param {Array<number>} flatCoordinates Flat coordinates. These always need
     *     to be right-handed for polygons.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Object<string, *>} properties Properties.
     * @param {number|string|undefined} id Feature id.
     */
    constructor(e, i, r, n, s, o) {
      this.styleFunction, this.extent_, this.id_ = o, this.type_ = e, this.flatCoordinates_ = i, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = r || null, this.properties_ = s, this.squaredTolerance_, this.stride_ = n, this.simplifiedGeometry_;
    }
    /**
     * Get a feature property by its key.
     * @param {string} key Key
     * @return {*} Value for the requested key.
     * @api
     */
    get(e) {
      return this.properties_[e];
    }
    /**
     * Get the extent of this feature's geometry.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_ || (this.extent_ = this.type_ === "Point" ? Qu(this.flatCoordinates_) : cv(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2
      )), this.extent_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoint() {
      if (!this.flatInteriorPoints_) {
        const e = xn(this.getExtent());
        this.flatInteriorPoints_ = Sv(
          this.flatCoordinates_,
          0,
          this.ends_,
          2,
          e,
          0
        );
      }
      return this.flatInteriorPoints_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints() {
      if (!this.flatInteriorPoints_) {
        const e = Rv(this.flatCoordinates_, this.ends_), i = iL(this.flatCoordinates_, 0, e, 2);
        this.flatInteriorPoints_ = mU(
          this.flatCoordinates_,
          0,
          e,
          2,
          i
        );
      }
      return this.flatInteriorPoints_;
    }
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint() {
      return this.flatMidpoints_ || (this.flatMidpoints_ = bE(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        0.5
      )), this.flatMidpoints_;
    }
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints() {
      if (!this.flatMidpoints_) {
        this.flatMidpoints_ = [];
        const e = this.flatCoordinates_;
        let i = 0;
        const r = (
          /** @type {Array<number>} */
          this.ends_
        );
        for (let n = 0, s = r.length; n < s; ++n) {
          const o = r[n], a = bE(e, i, o, 2, 0.5);
          xr(this.flatMidpoints_, a), i = o;
        }
      }
      return this.flatMidpoints_;
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is set when reading data from a remote source.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id_;
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getOrientedFlatCoordinates() {
      return this.flatCoordinates_;
    }
    /**
     * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
     * determining the geometry type in style function (see {@link #getType}).
     * @return {RenderFeature} Feature.
     * @api
     */
    getGeometry() {
      return this;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {RenderFeature} Simplified geometry.
     */
    getSimplifiedGeometry(e) {
      return this;
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {RenderFeature} Simplified geometry.
     */
    simplifyTransformed(e, i) {
      return this;
    }
    /**
     * Get the feature properties.
     * @return {Object<string, *>} Feature properties.
     * @api
     */
    getProperties() {
      return this.properties_;
    }
    /**
     * Get an object of all property names and values.  This has the same behavior as getProperties,
     * but is here to conform with the {@link module:ol/Feature~Feature} interface.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal() {
      return this.properties_;
    }
    /**
     * @return {number} Stride.
     */
    getStride() {
      return this.stride_;
    }
    /**
     * @return {import('../style/Style.js').StyleFunction|undefined} Style
     */
    getStyleFunction() {
      return this.styleFunction;
    }
    /**
     * Get the type of this feature's geometry.
     * @return {Type} Geometry type.
     * @api
     */
    getType() {
      return this.type_;
    }
    /**
     * Transform geometry coordinates from tile pixel space to projected.
     *
     * @param {import("../proj.js").ProjectionLike} projection The data projection
     */
    transform(e) {
      e = Xe(e);
      const i = e.getExtent(), r = e.getWorldExtent();
      if (i && r) {
        const n = Fi(r) / Fi(i);
        gs(
          HD,
          r[0],
          r[3],
          n,
          -n,
          0,
          0,
          0
        ), So(
          this.flatCoordinates_,
          0,
          this.flatCoordinates_.length,
          2,
          HD,
          this.flatCoordinates_
        );
      }
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     */
    applyTransform(e) {
      e(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
    }
    /**
     * @return {RenderFeature} A cloned render feature.
     */
    clone() {
      var e;
      return new Ir(
        this.type_,
        this.flatCoordinates_.slice(),
        (e = this.ends_) == null ? void 0 : e.slice(),
        this.stride_,
        Object.assign({}, this.properties_),
        this.id_
      );
    }
    /**
     * @return {Array<number>|null} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * Add transform and resolution based geometry simplification to this instance.
     * @return {RenderFeature} This render feature.
     */
    enableSimplifyTransformed() {
      return this.simplifyTransformed = KN((e, i) => {
        if (e === this.squaredTolerance_)
          return this.simplifiedGeometry_;
        this.simplifiedGeometry_ = this.clone(), i && this.simplifiedGeometry_.applyTransform(i);
        const r = this.simplifiedGeometry_.getFlatCoordinates();
        let n;
        switch (this.type_) {
          case "LineString":
            r.length = dB(
              r,
              0,
              this.simplifiedGeometry_.flatCoordinates_.length,
              this.simplifiedGeometry_.stride_,
              e,
              r,
              0
            ), n = [r.length];
            break;
          case "MultiLineString":
            n = [], r.length = hU(
              r,
              0,
              this.simplifiedGeometry_.ends_,
              this.simplifiedGeometry_.stride_,
              e,
              r,
              0,
              n
            );
            break;
          case "Polygon":
            n = [], r.length = Qv(
              r,
              0,
              this.simplifiedGeometry_.ends_,
              this.simplifiedGeometry_.stride_,
              Math.sqrt(e),
              r,
              0,
              n
            );
            break;
        }
        return n && (this.simplifiedGeometry_ = new Ir(
          this.type_,
          r,
          n,
          2,
          this.properties_,
          this.id_
        )), this.squaredTolerance_ = e, this.simplifiedGeometry_;
      }), this;
    }
  }
  Ir.prototype.getFlatCoordinates = Ir.prototype.getOrientedFlatCoordinates;
  class Nd extends no {
    /**
     * @param {Options} options Source options.
     */
    constructor(e) {
      super(), this.projection = Xe(e.projection), this.attributions_ = JD(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible ?? !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
      const i = this;
      this.viewPromise_ = new Promise(function(r, n) {
        i.viewResolver = r, i.viewRejector = n;
      });
    }
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */
    getAttributions() {
      return this.attributions_;
    }
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */
    getAttributionsCollapsible() {
      return this.attributionsCollapsible_;
    }
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default|null} Projection.
     * @api
     */
    getProjection() {
      return this.projection;
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
    getResolutions(e) {
      return null;
    }
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */
    getView() {
      return this.viewPromise_;
    }
    /**
     * Get the state of the source, see {@link import("./Source.js").State} for possible states.
     * @return {import("./Source.js").State} State.
     * @api
     */
    getState() {
      return this.state_;
    }
    /**
     * @return {boolean|undefined} Wrap X.
     */
    getWrapX() {
      return this.wrapX_;
    }
    /**
     * @return {boolean} Use linear interpolation when resampling.
     */
    getInterpolate() {
      return this.interpolate_;
    }
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */
    refresh() {
      this.changed();
    }
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */
    setAttributions(e) {
      this.attributions_ = JD(e), this.changed();
    }
    /**
     * Set the state of the source.
     * @param {import("./Source.js").State} state State.
     */
    setState(e) {
      this.state_ = e, this.changed();
    }
  }
  function JD(t) {
    return t ? typeof t == "function" ? t : (Array.isArray(t) || (t = [t]), (e) => t) : null;
  }
  const Ii = {
    /**
     * Triggered when a feature is added to the source.
     * @event module:ol/source/Vector.VectorSourceEvent#addfeature
     * @api
     */
    ADDFEATURE: "addfeature",
    /**
     * Triggered when a feature is updated.
     * @event module:ol/source/Vector.VectorSourceEvent#changefeature
     * @api
     */
    CHANGEFEATURE: "changefeature",
    /**
     * Triggered when the clear method is called on the source.
     * @event module:ol/source/Vector.VectorSourceEvent#clear
     * @api
     */
    CLEAR: "clear",
    /**
     * Triggered when a feature is removed from the source.
     * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
     * @event module:ol/source/Vector.VectorSourceEvent#removefeature
     * @api
     */
    REMOVEFEATURE: "removefeature",
    /**
     * Triggered when features starts loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
     * @api
     */
    FEATURESLOADSTART: "featuresloadstart",
    /**
     * Triggered when features finishes loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
     * @api
     */
    FEATURESLOADEND: "featuresloadend",
    /**
     * Triggered if feature loading results in an error.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
     * @api
     */
    FEATURESLOADERROR: "featuresloaderror"
  };
  function jte(t, e) {
    return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
  }
  function Du(t, e) {
    return [t];
  }
  let Hte = !1;
  function rL(t, e, i, r, n, s, o) {
    const a = new XMLHttpRequest();
    a.open(
      "GET",
      typeof t == "function" ? t(i, r, n) : t,
      !0
    ), e.getType() == "arraybuffer" && (a.responseType = "arraybuffer"), a.withCredentials = Hte, a.onload = function(A) {
      if (!a.status || a.status >= 200 && a.status < 300) {
        const l = e.getType();
        try {
          let c;
          l == "text" || l == "json" ? c = a.responseText : l == "xml" ? c = a.responseXML || a.responseText : l == "arraybuffer" && (c = /** @type {ArrayBuffer} */
          a.response), c ? s(
            /** @type {Array<FeatureType>} */
            e.readFeatures(c, {
              extent: i,
              featureProjection: n
            }),
            e.readProjection(c)
          ) : o();
        } catch {
          o();
        }
      } else
        o();
    }, a.onerror = o, a.send();
  }
  function VD(t, e) {
    return function(i, r, n, s, o) {
      const a = (
        /** @type {import("./source/Vector").default<FeatureType>} */
        this
      );
      rL(
        t,
        e,
        i,
        r,
        n,
        /**
         * @param {Array<FeatureType>} features The loaded features.
         * @param {import("./proj/Projection.js").default} dataProjection Data
         * projection.
         */
        function(A, l) {
          a.addFeatures(A), s !== void 0 && s(A);
        },
        /* FIXME handle error */
        o || $u
      );
    };
  }
  class Xa extends on {
    /**
     * @param {string} type Type.
     * @param {FeatureType} [feature] Feature.
     * @param {Array<FeatureType>} [features] Features.
     */
    constructor(e, i, r) {
      super(e), this.feature = i, this.features = r;
    }
  }
  class Do extends Nd {
    /**
     * @param {Options<FeatureType>} [options] Vector source options.
     */
    constructor(e) {
      e = e || {}, super({
        attributions: e.attributions,
        interpolate: !0,
        projection: void 0,
        state: "ready",
        wrapX: e.wrapX !== void 0 ? e.wrapX : !0
      }), this.on, this.once, this.un, this.loader_ = $u, this.format_ = e.format || null, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (Mt(this.format_, "`format` must be set when `url` is set"), this.loader_ = VD(this.url_, this.format_)), this.strategy_ = e.strategy !== void 0 ? e.strategy : jte;
      const i = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
      this.featuresRtree_ = i ? new DE() : null, this.loadedExtentsRtree_ = new DE(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
      let r, n;
      Array.isArray(e.features) ? n = e.features : e.features && (r = e.features, n = r.getArray()), !i && r === void 0 && (r = new Bn(n)), n !== void 0 && this.addFeaturesInternal(n), r !== void 0 && this.bindFeaturesCollection_(r);
    }
    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * Note: this also applies if a {@link module:ol/Collection~Collection} is used for features,
     * meaning that if a feature with a duplicate id is added in the collection, it will
     * be removed from it right away.
     * @param {FeatureType} feature Feature to add.
     * @api
     */
    addFeature(e) {
      this.addFeatureInternal(e), this.changed();
    }
    /**
     * Add a feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @protected
     */
    addFeatureInternal(e) {
      const i = ve(e);
      if (!this.addToIndex_(i, e)) {
        this.featuresCollection_ && this.featuresCollection_.remove(e);
        return;
      }
      this.setupChangeEvents_(i, e);
      const r = e.getGeometry();
      if (r) {
        const n = r.getExtent();
        this.featuresRtree_ && this.featuresRtree_.insert(n, e);
      } else
        this.nullGeometryFeatures_[i] = e;
      this.dispatchEvent(
        new Xa(Ii.ADDFEATURE, e)
      );
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @private
     */
    setupChangeEvents_(e, i) {
      i instanceof Ir || (this.featureChangeKeys_[e] = [
        nt(i, Ge.CHANGE, this.handleFeatureChange_, this),
        nt(
          i,
          qu.PROPERTYCHANGE,
          this.handleFeatureChange_,
          this
        )
      ]);
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {FeatureType} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
    addToIndex_(e, i) {
      let r = !0;
      if (i.getId() !== void 0) {
        const n = String(i.getId());
        if (!(n in this.idIndex_))
          this.idIndex_[n] = i;
        else if (i instanceof Ir) {
          const s = this.idIndex_[n];
          s instanceof Ir ? Array.isArray(s) ? s.push(i) : this.idIndex_[n] = [s, i] : r = !1;
        } else
          r = !1;
      }
      return r && (Mt(
        !(e in this.uidIndex_),
        "The passed `feature` was already added to the source"
      ), this.uidIndex_[e] = i), r;
    }
    /**
     * Add a batch of features to the source.
     * @param {Array<FeatureType>} features Features to add.
     * @api
     */
    addFeatures(e) {
      this.addFeaturesInternal(e), this.changed();
    }
    /**
     * Add features without firing a `change` event.
     * @param {Array<FeatureType>} features Features.
     * @protected
     */
    addFeaturesInternal(e) {
      const i = [], r = [], n = [];
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s], A = ve(a);
        this.addToIndex_(A, a) && r.push(a);
      }
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s], A = ve(a);
        this.setupChangeEvents_(A, a);
        const l = a.getGeometry();
        if (l) {
          const c = l.getExtent();
          i.push(c), n.push(a);
        } else
          this.nullGeometryFeatures_[A] = a;
      }
      if (this.featuresRtree_ && this.featuresRtree_.load(i, n), this.hasListener(Ii.ADDFEATURE))
        for (let s = 0, o = r.length; s < o; s++)
          this.dispatchEvent(
            new Xa(Ii.ADDFEATURE, r[s])
          );
    }
    /**
     * @param {!Collection<FeatureType>} collection Collection.
     * @private
     */
    bindFeaturesCollection_(e) {
      let i = !1;
      this.addEventListener(
        Ii.ADDFEATURE,
        /**
         * @param {VectorSourceEvent<FeatureType>} evt The vector source event
         */
        function(r) {
          i || (i = !0, e.push(r.feature), i = !1);
        }
      ), this.addEventListener(
        Ii.REMOVEFEATURE,
        /**
         * @param {VectorSourceEvent<FeatureType>} evt The vector source event
         */
        function(r) {
          i || (i = !0, e.remove(r.feature), i = !1);
        }
      ), e.addEventListener(
        Ui.ADD,
        /**
         * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
         */
        (r) => {
          i || (i = !0, this.addFeature(r.element), i = !1);
        }
      ), e.addEventListener(
        Ui.REMOVE,
        /**
         * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
         */
        (r) => {
          i || (i = !0, this.removeFeature(r.element), i = !1);
        }
      ), this.featuresCollection_ = e;
    }
    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
     * @api
     */
    clear(e) {
      if (e) {
        for (const r in this.featureChangeKeys_)
          this.featureChangeKeys_[r].forEach(Pt);
        this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
      } else if (this.featuresRtree_) {
        this.featuresRtree_.forEach((r) => {
          this.removeFeatureInternal(r);
        });
        for (const r in this.nullGeometryFeatures_)
          this.removeFeatureInternal(this.nullGeometryFeatures_[r]);
      }
      this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
      const i = new Xa(Ii.CLEAR);
      this.dispatchEvent(i), this.changed();
    }
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(FeatureType): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeature(e) {
      if (this.featuresRtree_)
        return this.featuresRtree_.forEach(e);
      this.featuresCollection_ && this.featuresCollection_.forEach(e);
    }
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
     * called for all features.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    forEachFeatureAtCoordinateDirect(e, i) {
      const r = [e[0], e[1], e[0], e[1]];
      return this.forEachFeatureInExtent(r, function(n) {
        const s = n.getGeometry();
        if (s instanceof Ir || s.intersectsCoordinate(e))
          return i(n);
      });
    }
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureInExtent(e, i) {
      if (this.featuresRtree_)
        return this.featuresRtree_.forEachInExtent(e, i);
      this.featuresCollection_ && this.featuresCollection_.forEach(i);
    }
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(FeatureType): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureIntersectingExtent(e, i) {
      return this.forEachFeatureInExtent(
        e,
        /**
         * @param {FeatureType} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         */
        function(r) {
          const n = r.getGeometry();
          if (n instanceof Ir || n.intersectsExtent(e)) {
            const s = i(r);
            if (s)
              return s;
          }
        }
      );
    }
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with a {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<FeatureType>|null} The collection of features.
     * @api
     */
    getFeaturesCollection() {
      return this.featuresCollection_;
    }
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeatures() {
      let e;
      return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), vA(this.nullGeometryFeatures_) || xr(e, Object.values(this.nullGeometryFeatures_))), e;
    }
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesAtCoordinate(e) {
      const i = [];
      return this.forEachFeatureAtCoordinateDirect(e, function(r) {
        i.push(r);
      }), i;
    }
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../proj/Projection.js").default} [projection] Include features
     * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesInExtent(e, i) {
      if (this.featuresRtree_) {
        if (!(i && i.canWrapX() && this.getWrapX()))
          return this.featuresRtree_.getInExtent(e);
        const n = hv(e, i);
        return [].concat(
          ...n.map((s) => this.featuresRtree_.getInExtent(s))
        );
      }
      return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
    }
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false` and the features in this source are of type
     * {@link module:ol/Feature~Feature}.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(FeatureType):boolean} [filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {FeatureType} Closest feature.
     * @api
     */
    getClosestFeatureToCoordinate(e, i) {
      const r = e[0], n = e[1];
      let s = null;
      const o = [NaN, NaN];
      let a = 1 / 0;
      const A = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
      return i = i || Qa, this.featuresRtree_.forEachInExtent(
        A,
        /**
         * @param {FeatureType} feature Feature.
         */
        function(l) {
          if (i(l)) {
            const c = l.getGeometry(), u = a;
            if (a = c instanceof Ir ? 0 : c.closestPointXY(r, n, o, a), a < u) {
              s = l;
              const d = Math.sqrt(a);
              A[0] = r - d, A[1] = n - d, A[2] = r + d, A[3] = n + d;
            }
          }
        }
      ), s;
    }
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(e) {
      return this.featuresRtree_.getExtent(e);
    }
    /**
     * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
     * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
     * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
     * `GeometryCollection` member.
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
     * @api
     */
    getFeatureById(e) {
      const i = this.idIndex_[e.toString()];
      return i !== void 0 ? (
        /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
        i
      ) : null;
    }
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {FeatureType|null} The feature (or `null` if not found).
     */
    getFeatureByUid(e) {
      const i = this.uidIndex_[e];
      return i !== void 0 ? i : null;
    }
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default<FeatureType>|null}} The feature format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    getOverlaps() {
      return this.overlaps_;
    }
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */
    getUrl() {
      return this.url_;
    }
    /**
     * @param {Event} event Event.
     * @private
     */
    handleFeatureChange_(e) {
      const i = (
        /** @type {FeatureType} */
        e.target
      ), r = ve(i), n = i.getGeometry();
      if (!n)
        r in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(i), this.nullGeometryFeatures_[r] = i);
      else {
        const o = n.getExtent();
        r in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[r], this.featuresRtree_ && this.featuresRtree_.insert(o, i)) : this.featuresRtree_ && this.featuresRtree_.update(o, i);
      }
      const s = i.getId();
      if (s !== void 0) {
        const o = s.toString();
        this.idIndex_[o] !== i && (this.removeFromIdIndex_(i), this.idIndex_[o] = i);
      } else
        this.removeFromIdIndex_(i), this.uidIndex_[r] = i;
      this.changed(), this.dispatchEvent(
        new Xa(Ii.CHANGEFEATURE, i)
      );
    }
    /**
     * Returns true if the feature is contained within the source.
     * @param {FeatureType} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
    hasFeature(e) {
      const i = e.getId();
      return i !== void 0 ? i in this.idIndex_ : ve(e) in this.uidIndex_;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && vA(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    loadFeatures(e, i, r) {
      const n = this.loadedExtentsRtree_, s = this.strategy_(e, i, r);
      for (let o = 0, a = s.length; o < a; ++o) {
        const A = s[o];
        n.forEachInExtent(
          A,
          /**
           * @param {{extent: import("../extent.js").Extent}} object Object.
           * @return {boolean} Contains.
           */
          function(c) {
            return ts(c.extent, A);
          }
        ) || (++this.loadingExtentsCount_, this.dispatchEvent(
          new Xa(Ii.FEATURESLOADSTART)
        ), this.loader_.call(
          this,
          A,
          i,
          r,
          /**
           * @param {Array<FeatureType>} features Loaded features
           */
          (c) => {
            --this.loadingExtentsCount_, this.dispatchEvent(
              new Xa(
                Ii.FEATURESLOADEND,
                void 0,
                c
              )
            );
          },
          () => {
            --this.loadingExtentsCount_, this.dispatchEvent(
              new Xa(Ii.FEATURESLOADERROR)
            );
          }
        ), n.insert(A, { extent: A.slice() }));
      }
      this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
    }
    /**
     * @override
     */
    refresh() {
      this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
    }
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    removeLoadedExtent(e) {
      const i = this.loadedExtentsRtree_, r = i.forEachInExtent(e, function(n) {
        if (Zs(n.extent, e))
          return n;
      });
      r && i.remove(r);
    }
    /**
     * Batch remove features from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {Array<FeatureType>} features Features to remove.
     * @api
     */
    removeFeatures(e) {
      let i = !1;
      for (let r = 0, n = e.length; r < n; ++r)
        i = this.removeFeatureInternal(e[r]) || i;
      i && this.changed();
    }
    /**
     * Remove a single feature from the source. If you want to batch remove
     * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
     * instead.
     * @param {FeatureType} feature Feature to remove.
     * @api
     */
    removeFeature(e) {
      if (!e)
        return;
      this.removeFeatureInternal(e) && this.changed();
    }
    /**
     * Remove feature without firing a `change` event.
     * @param {FeatureType} feature Feature.
     * @return {boolean} True if the feature was removed, false if it was not found.
     * @protected
     */
    removeFeatureInternal(e) {
      const i = ve(e);
      if (!(i in this.uidIndex_))
        return !1;
      i in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[i] : this.featuresRtree_ && this.featuresRtree_.remove(e);
      const r = this.featureChangeKeys_[i];
      r == null || r.forEach(Pt), delete this.featureChangeKeys_[i];
      const n = e.getId();
      if (n !== void 0) {
        const s = n.toString(), o = this.idIndex_[s];
        o === e ? delete this.idIndex_[s] : Array.isArray(o) && (o.splice(o.indexOf(e), 1), o.length === 1 && (this.idIndex_[s] = o[0]));
      }
      return delete this.uidIndex_[i], this.hasListener(Ii.REMOVEFEATURE) && this.dispatchEvent(
        new Xa(Ii.REMOVEFEATURE, e)
      ), !0;
    }
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {FeatureType} feature The feature.
     * @private
     */
    removeFromIdIndex_(e) {
      for (const i in this.idIndex_)
        if (this.idIndex_[i] === e) {
          delete this.idIndex_[i];
          break;
        }
    }
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader<FeatureType>} loader The loader to set.
     * @api
     */
    setLoader(e) {
      this.loader_ = e;
    }
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */
    setUrl(e) {
      Mt(this.format_, "`format` must be set when `url` is set"), this.url_ = e, this.setLoader(VD(e, this.format_));
    }
    /**
     * @param {boolean} overlaps The source can have overlapping geometries.
     */
    setOverlaps(e) {
      this.overlaps_ = e, this.changed();
    }
  }
  class Jte extends Pv {
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {HTMLCanvasElement} canvas Canvas.
     * @param {Loader} [loader] Optional loader function to
     *     support asynchronous canvas drawing.
     */
    constructor(e, i, r, n, s) {
      const o = s !== void 0 ? ze.IDLE : ze.LOADED;
      super(e, i, r, o), this.loader_ = s !== void 0 ? s : null, this.canvas_ = n, this.error_ = null;
    }
    /**
     * Get any error associated with asynchronous rendering.
     * @return {?Error} Any error that occurred during rendering.
     */
    getError() {
      return this.error_;
    }
    /**
     * Handle async drawing complete.
     * @param {Error} [err] Any error during drawing.
     * @private
     */
    handleLoad_(e) {
      e ? (this.error_ = e, this.state = ze.ERROR) : this.state = ze.LOADED, this.changed();
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      this.state == ze.IDLE && (this.state = ze.LOADING, this.changed(), this.loader_(this.handleLoad_.bind(this)));
    }
    /**
     * @return {HTMLCanvasElement} Canvas element.
     * @override
     */
    getImage() {
      return this.canvas_;
    }
  }
  const pe = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
     * Indicates that tile loading failed
     * @type {number}
     */
    ERROR: 3,
    EMPTY: 4
  };
  class pf extends Rd {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {Options} [options] Tile options.
     */
    constructor(e, i, r) {
      super(), r = r || {}, this.tileCoord = e, this.state = i, this.key = "", this.transition_ = r.transition === void 0 ? 250 : r.transition, this.transitionStarts_ = {}, this.interpolate = !!r.interpolate;
    }
    /**
     * @protected
     */
    changed() {
      this.dispatchEvent(Ge.CHANGE);
    }
    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */
    release() {
      this.state === pe.ERROR && this.setState(pe.EMPTY);
    }
    /**
     * @return {string} Key.
     */
    getKey() {
      return this.key + "/" + this.tileCoord;
    }
    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */
    getTileCoord() {
      return this.tileCoord;
    }
    /**
     * @return {import("./TileState.js").default} State.
     */
    getState() {
      return this.state;
    }
    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */
    setState(e) {
      if (this.state !== pe.ERROR && this.state > e)
        throw new Error("Tile load sequence violation");
      this.state = e, this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */
    load() {
      it();
    }
    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */
    getAlpha(e, i) {
      if (!this.transition_)
        return 1;
      let r = this.transitionStarts_[e];
      if (!r)
        r = i, this.transitionStarts_[e] = r;
      else if (r === -1)
        return 1;
      const n = i - r + 1e3 / 60;
      return n >= this.transition_ ? 1 : UU(n / this.transition_);
    }
    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */
    inTransition(e) {
      return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
    }
    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */
    endTransition(e) {
      this.transition_ && (this.transitionStarts_[e] = -1);
    }
    /**
     * @override
     */
    disposeInternal() {
      this.release(), super.disposeInternal();
    }
  }
  class ix extends pf {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [options] Tile options.
     */
    constructor(e, i, r, n, s, o) {
      super(e, i, o), this.crossOrigin_ = n, this.src_ = r, this.key = r, this.image_ = new Image(), n !== null && (this.image_.crossOrigin = n), this.unlisten_ = null, this.tileLoadFunction_ = s;
    }
    /**
     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */
    getImage() {
      return this.image_;
    }
    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */
    setImage(e) {
      this.image_ = e, this.state = pe.LOADED, this.unlistenImage_(), this.changed();
    }
    /**
     * Tracks loading or read errors.
     *
     * @private
     */
    handleImageError_() {
      this.state = pe.ERROR, this.unlistenImage_(), this.image_ = Vte(), this.changed();
    }
    /**
     * Tracks successful image load.
     *
     * @private
     */
    handleImageLoad_() {
      const e = (
        /** @type {HTMLImageElement} */
        this.image_
      );
      e.naturalWidth && e.naturalHeight ? this.state = pe.LOADED : this.state = pe.EMPTY, this.unlistenImage_(), this.changed();
    }
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     *
     * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
     * that checks for error status codes and reloads only when the status code is
     * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
     * made already:
     *
     * ```js
     * const retryCodes = [408, 429, 500, 502, 503, 504];
     * const retries = {};
     * source.setTileLoadFunction((tile, src) => {
     *   const image = tile.getImage();
     *   fetch(src)
     *     .then((response) => {
     *       if (retryCodes.includes(response.status)) {
     *         retries[src] = (retries[src] || 0) + 1;
     *         if (retries[src] <= 3) {
     *           setTimeout(() => tile.load(), retries[src] * 1000);
     *         }
     *         return Promise.reject();
     *       }
     *       return response.blob();
     *     })
     *     .then((blob) => {
     *       const imageUrl = URL.createObjectURL(blob);
     *       image.src = imageUrl;
     *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
     *     })
     *     .catch(() => tile.setState(3)); // error
     * });
     * ```
     * @api
     * @override
     */
    load() {
      this.state == pe.ERROR && (this.state = pe.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == pe.IDLE && (this.state = pe.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = ree(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      ));
    }
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */
    unlistenImage_() {
      this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
    }
    /**
     * @override
     */
    disposeInternal() {
      this.unlistenImage_(), this.image_ = null, super.disposeInternal();
    }
  }
  function Vte() {
    const t = Di(1, 1);
    return t.fillStyle = "rgba(0,0,0,0)", t.fillRect(0, 0, 1, 1), t.canvas;
  }
  class Wte {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */
    constructor(e, i, r) {
      this.decay_ = e, this.minVelocity_ = i, this.delay_ = r, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
    }
    /**
     * FIXME empty description for jsdoc
     */
    begin() {
      this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
    update(e, i) {
      this.points_.push(e, i, Date.now());
    }
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
    end() {
      if (this.points_.length < 6)
        return !1;
      const e = Date.now() - this.delay_, i = this.points_.length - 3;
      if (this.points_[i + 2] < e)
        return !1;
      let r = i - 3;
      for (; r > 0 && this.points_[r + 2] > e; )
        r -= 3;
      const n = this.points_[i + 2] - this.points_[r + 2];
      if (n < 1e3 / 60)
        return !1;
      const s = this.points_[i] - this.points_[r], o = this.points_[i + 1] - this.points_[r + 1];
      return this.angle_ = Math.atan2(o, s), this.initialVelocity_ = Math.sqrt(s * s + o * o) / n, this.initialVelocity_ > this.minVelocity_;
    }
    /**
     * @return {number} Total distance travelled (pixels).
     */
    getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
    getAngle() {
      return this.angle_;
    }
  }
  class Kte extends Td {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(e) {
      super(), this.map_ = e;
    }
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    dispatchRenderEvent(e, i) {
      it();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @protected
     */
    calculateMatrices2D(e) {
      const i = e.viewState, r = e.coordinateToPixelTransform, n = e.pixelToCoordinateTransform;
      gs(
        r,
        e.size[0] / 2,
        e.size[1] / 2,
        1 / i.resolution,
        -1 / i.resolution,
        -i.rotation,
        -i.center[0],
        -i.center[1]
      ), xA(n, r);
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */
    forEachFeatureAtCoordinate(e, i, r, n, s, o, a, A) {
      let l;
      const c = i.viewState;
      function u(C, w, M, I) {
        return s.call(o, w, C ? M : null, I);
      }
      const d = c.projection, h = mv(e.slice(), d), g = [[0, 0]];
      if (d.canWrapX() && n) {
        const C = d.getExtent(), w = mt(C);
        g.push([-w, 0], [w, 0]);
      }
      const f = i.layerStatesArray, p = f.length, m = (
        /** @type {Array<HitMatch<T>>} */
        []
      ), E = [];
      for (let C = 0; C < g.length; C++)
        for (let w = p - 1; w >= 0; --w) {
          const M = f[w], I = M.layer;
          if (I.hasRenderer() && Kv(M, c) && a.call(A, I)) {
            const b = I.getRenderer(), B = I.getSource();
            if (b && B) {
              const x = B.getWrapX() ? h : e, Q = u.bind(
                null,
                M.managed
              );
              E[0] = x[0] + g[C][0], E[1] = x[1] + g[C][1], l = b.forEachFeatureAtCoordinate(
                E,
                i,
                r,
                Q,
                m
              );
            }
            if (l)
              return l;
          }
        }
      if (m.length === 0)
        return;
      const y = 1 / m.length;
      return m.forEach((C, w) => C.distanceSq += w * y), m.sort((C, w) => C.distanceSq - w.distanceSq), m.some((C) => l = C.callback(C.feature, C.layer, C.geometry)), l;
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */
    hasFeatureAtCoordinate(e, i, r, n, s, o) {
      return this.forEachFeatureAtCoordinate(
        e,
        i,
        r,
        n,
        Qa,
        this,
        s,
        o
      ) !== void 0;
    }
    /**
     * @return {import("../Map.js").default} Map.
     */
    getMap() {
      return this.map_;
    }
    /**
     * Render.
     * @abstract
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    renderFrame(e) {
      it();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    scheduleExpireIconCache(e) {
      rs.canExpireCache() && e.postRenderFunctions.push(Xte);
    }
  }
  function Xte(t, e) {
    rs.expire();
  }
  class Zte extends Kte {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(e) {
      super(e), this.fontChangeListenerKey_ = nt(
        mo,
        qu.PROPERTYCHANGE,
        e.redrawText,
        e
      ), this.element_ = document.createElement("div");
      const i = this.element_.style;
      i.position = "absolute", i.width = "100%", i.height = "100%", i.zIndex = "0", this.element_.className = df + " ol-layers";
      const r = e.getViewport();
      r.insertBefore(this.element_, r.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
    }
    /**
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @override
     */
    dispatchRenderEvent(e, i) {
      const r = this.getMap();
      if (r.hasListener(e)) {
        const n = new Lh(e, void 0, i);
        r.dispatchEvent(n);
      }
    }
    /**
     * @override
     */
    disposeInternal() {
      Pt(this.fontChangeListenerKey_), this.element_.remove(), super.disposeInternal();
    }
    /**
     * Render.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderFrame(e) {
      if (!e) {
        this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
        return;
      }
      this.calculateMatrices2D(e), this.dispatchRenderEvent(dr.PRECOMPOSE, e);
      const i = e.layerStatesArray.sort(
        (a, A) => a.zIndex - A.zIndex
      );
      i.some(
        (a) => a.layer instanceof gf && a.layer.getDeclutter()
      ) && (e.declutter = {});
      const n = e.viewState;
      this.children_.length = 0;
      const s = [];
      let o = null;
      for (let a = 0, A = i.length; a < A; ++a) {
        const l = i[a];
        e.layerIndex = a;
        const c = l.layer, u = c.getSourceState();
        if (!Kv(l, n) || u != "ready" && u != "undefined") {
          c.unrender();
          continue;
        }
        const d = c.render(e, o);
        d && (d !== o && (this.children_.push(d), o = d), s.push(l));
      }
      this.declutter(e, s), iee(this.element_, this.children_), this.dispatchRenderEvent(dr.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
     */
    declutter(e, i) {
      if (e.declutter) {
        for (let r = i.length - 1; r >= 0; --r) {
          const n = i[r], s = n.layer;
          s.getDeclutter() && s.renderDeclutter(e, n);
        }
        i.forEach(
          (r) => r.layer.renderDeferred(e)
        );
      }
    }
  }
  class sA extends on {
    /**
     * @param {GroupEventType} type The event type.
     * @param {BaseLayer} layer The layer.
     */
    constructor(e, i) {
      super(e), this.layer = i;
    }
  }
  const S0 = {
    LAYERS: "layers"
  };
  class Ud extends YU {
    /**
     * @param {Options} [options] Layer options.
     */
    constructor(e) {
      e = e || {};
      const i = (
        /** @type {Options} */
        Object.assign({}, e)
      );
      delete i.layers;
      let r = e.layers;
      super(i), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(S0.LAYERS, this.handleLayersChanged_), r ? Array.isArray(r) ? r = new Bn(r.slice(), { unique: !0 }) : Mt(
        typeof /** @type {?} */
        r.getArray == "function",
        "Expected `layers` to be an array or a `Collection`"
      ) : r = new Bn(void 0, { unique: !0 }), this.setLayers(r);
    }
    /**
     * @private
     */
    handleLayerChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleLayersChanged_() {
      this.layersListenerKeys_.forEach(Pt), this.layersListenerKeys_.length = 0;
      const e = this.getLayers();
      this.layersListenerKeys_.push(
        nt(e, Ui.ADD, this.handleLayersAdd_, this),
        nt(
          e,
          Ui.REMOVE,
          this.handleLayersRemove_,
          this
        )
      );
      for (const r in this.listenerKeys_)
        this.listenerKeys_[r].forEach(Pt);
      nc(this.listenerKeys_);
      const i = e.getArray();
      for (let r = 0, n = i.length; r < n; r++) {
        const s = i[r];
        this.registerLayerListeners_(s), this.dispatchEvent(new sA("addlayer", s));
      }
      this.changed();
    }
    /**
     * @param {BaseLayer} layer The layer.
     */
    registerLayerListeners_(e) {
      const i = [
        nt(
          e,
          qu.PROPERTYCHANGE,
          this.handleLayerChange_,
          this
        ),
        nt(e, Ge.CHANGE, this.handleLayerChange_, this)
      ];
      e instanceof Ud && i.push(
        nt(e, "addlayer", this.handleLayerGroupAdd_, this),
        nt(e, "removelayer", this.handleLayerGroupRemove_, this)
      ), this.listenerKeys_[ve(e)] = i;
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupAdd_(e) {
      this.dispatchEvent(new sA("addlayer", e.layer));
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupRemove_(e) {
      this.dispatchEvent(new sA("removelayer", e.layer));
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersAdd_(e) {
      const i = e.element;
      this.registerLayerListeners_(i), this.dispatchEvent(new sA("addlayer", i)), this.changed();
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersRemove_(e) {
      const i = e.element, r = ve(i);
      this.listenerKeys_[r].forEach(Pt), delete this.listenerKeys_[r], this.dispatchEvent(new sA("removelayer", i)), this.changed();
    }
    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!Collection<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    getLayers() {
      return (
        /** @type {!Collection<import("./Base.js").default>} */
        this.get(S0.LAYERS)
      );
    }
    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!Collection<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    setLayers(e) {
      const i = this.getLayers();
      if (i) {
        const r = i.getArray();
        for (let n = 0, s = r.length; n < s; ++n)
          this.dispatchEvent(new sA("removelayer", r[n]));
      }
      this.set(S0.LAYERS, e);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     * @override
     */
    getLayersArray(e) {
      return e = e !== void 0 ? e : [], this.getLayers().forEach(function(i) {
        i.getLayersArray(e);
      }), e;
    }
    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If dest is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [dest] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     * @override
     */
    getLayerStatesArray(e) {
      const i = e !== void 0 ? e : [], r = i.length;
      this.getLayers().forEach(function(o) {
        o.getLayerStatesArray(i);
      });
      const n = this.getLayerState();
      let s = n.zIndex;
      !e && n.zIndex === void 0 && (s = 0);
      for (let o = r, a = i.length; o < a; o++) {
        const A = i[o];
        A.opacity *= n.opacity, A.visible = A.visible && n.visible, A.maxResolution = Math.min(
          A.maxResolution,
          n.maxResolution
        ), A.minResolution = Math.max(
          A.minResolution,
          n.minResolution
        ), A.minZoom = Math.max(A.minZoom, n.minZoom), A.maxZoom = Math.min(A.maxZoom, n.maxZoom), n.extent !== void 0 && (A.extent !== void 0 ? A.extent = fr(
          A.extent,
          n.extent
        ) : A.extent = n.extent), A.zIndex === void 0 && (A.zIndex = s);
      }
      return i;
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     * @override
     */
    getSourceState() {
      return "ready";
    }
  }
  class Kc extends on {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {?import("./Map.js").FrameState} [frameState] Frame state.
     */
    constructor(e, i, r) {
      super(e), this.map = i, this.frameState = r !== void 0 ? r : null;
    }
  }
  class qo extends Kc {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [dragging] Is the map currently being dragged?
     * @param {import("./Map.js").FrameState} [frameState] Frame state.
     * @param {Array<PointerEvent>} [activePointers] Active pointers.
     */
    constructor(e, i, r, n, s, o) {
      super(e, i, s), this.originalEvent = r, this.pixel_ = null, this.coordinate_ = null, this.dragging = n !== void 0 ? n : !1, this.activePointers = o;
    }
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get pixel() {
      return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
    }
    set pixel(e) {
      this.pixel_ = e;
    }
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get coordinate() {
      return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
    }
    set coordinate(e) {
      this.coordinate_ = e;
    }
    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     * @override
     */
    preventDefault() {
      super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
    }
    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     * @override
     */
    stopPropagation() {
      super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
    }
  }
  const Yt = {
    /**
     * A true single click with no dragging and no double click. Note that this
     * event is delayed by 250 ms to ensure that it is not a double click.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
     * @api
     */
    SINGLECLICK: "singleclick",
    /**
     * A click with no dragging. A double click will fire two of this.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
     * @api
     */
    CLICK: Ge.CLICK,
    /**
     * A true double click, with no dragging.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
     * @api
     */
    DBLCLICK: Ge.DBLCLICK,
    /**
     * Triggered when a pointer is dragged.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
     * @api
     */
    POINTERDRAG: "pointerdrag",
    /**
     * Triggered when a pointer is moved. Note that on touch devices this is
     * triggered when the map is panned, so is not the same as mousemove.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
     * @api
     */
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
  }, Cb = {
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown"
  };
  class qte extends Rd {
    /**
     * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */
    constructor(e, i) {
      super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = i === void 0 ? 1 : i, this.down_ = null;
      const r = this.map_.getViewport();
      this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = r, this.pointerdownListenerKey_ = nt(
        r,
        Cb.POINTERDOWN,
        this.handlePointerDown_,
        this
      ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = nt(
        r,
        Cb.POINTERMOVE,
        this.relayMoveEvent_,
        this
      ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
        Ge.TOUCHMOVE,
        this.boundHandleTouchMove_,
        IU ? { passive: !1 } : !1
      );
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    emulateClick_(e) {
      let i = new qo(
        Yt.CLICK,
        this.map_,
        e
      );
      this.dispatchEvent(i), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, i = new qo(
        Yt.DBLCLICK,
        this.map_,
        e
      ), this.dispatchEvent(i)) : this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const r = new qo(
          Yt.SINGLECLICK,
          this.map_,
          e
        );
        this.dispatchEvent(r);
      }, 250);
    }
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    updateActivePointers_(e) {
      const i = e, r = i.pointerId;
      if (i.type == Yt.POINTERUP || i.type == Yt.POINTERCANCEL) {
        delete this.trackedTouches_[r];
        for (const n in this.trackedTouches_)
          if (this.trackedTouches_[n].target !== i.target) {
            delete this.trackedTouches_[n];
            break;
          }
      } else (i.type == Yt.POINTERDOWN || i.type == Yt.POINTERMOVE) && (this.trackedTouches_[r] = i);
      this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerUp_(e) {
      this.updateActivePointers_(e);
      const i = new qo(
        Yt.POINTERUP,
        this.map_,
        e,
        void 0,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(i), this.emulateClicks_ && !i.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(Pt), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */
    isMouseActionButton_(e) {
      return e.button === 0;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerDown_(e) {
      this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
      const i = new qo(
        Yt.POINTERDOWN,
        this.map_,
        e,
        void 0,
        void 0,
        this.activePointers_
      );
      if (this.dispatchEvent(i), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
        writable: !1,
        value: e.target
      }), this.dragListenerKeys_.length === 0) {
        const r = this.map_.getOwnerDocument();
        this.dragListenerKeys_.push(
          nt(
            r,
            Yt.POINTERMOVE,
            this.handlePointerMove_,
            this
          ),
          nt(r, Yt.POINTERUP, this.handlePointerUp_, this),
          /* Note that the listener for `pointercancel is set up on
           * `pointerEventHandler_` and not `documentPointerEventHandler_` like
           * the `pointerup` and `pointermove` listeners.
           *
           * The reason for this is the following: `TouchSource.vacuumTouches_()`
           * issues `pointercancel` events, when there was no `touchend` for a
           * `touchstart`. Now, let's say a first `touchstart` is registered on
           * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
           * But `documentPointerEventHandler_` doesn't know about the first
           * `touchstart`. If there is no `touchend` for the `touchstart`, we can
           * only receive a `touchcancel` from `pointerEventHandler_`, because it is
           * only registered there.
           */
          nt(
            this.element_,
            Yt.POINTERCANCEL,
            this.handlePointerUp_,
            this
          )
        ), this.element_.getRootNode && this.element_.getRootNode() !== r && this.dragListenerKeys_.push(
          nt(
            this.element_.getRootNode(),
            Yt.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerMove_(e) {
      if (this.isMoving_(e)) {
        this.updateActivePointers_(e), this.dragging_ = !0;
        const i = new qo(
          Yt.POINTERDRAG,
          this.map_,
          e,
          this.dragging_,
          void 0,
          this.activePointers_
        );
        this.dispatchEvent(i);
      }
    }
    /**
     * Wrap and relay a pointermove event.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    relayMoveEvent_(e) {
      this.originalPointerMoveEvent_ = e;
      const i = !!(this.down_ && this.isMoving_(e));
      this.dispatchEvent(
        new qo(
          Yt.POINTERMOVE,
          this.map_,
          e,
          i
        )
      );
    }
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */
    handleTouchMove_(e) {
      const i = this.originalPointerMoveEvent_;
      (!i || i.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */
    isMoving_(e) {
      return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.relayedListenerKey_ && (Pt(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
        Ge.TOUCHMOVE,
        this.boundHandleTouchMove_
      ), this.pointerdownListenerKey_ && (Pt(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(Pt), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
    }
  }
  const $o = {
    /**
     * Triggered after a map frame is rendered.
     * @event module:ol/MapEvent~MapEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered when the map starts moving.
     * @event module:ol/MapEvent~MapEvent#movestart
     * @api
     */
    MOVESTART: "movestart",
    /**
     * Triggered after the map is moved.
     * @event module:ol/MapEvent~MapEvent#moveend
     * @api
     */
    MOVEEND: "moveend",
    /**
     * Triggered when loading of additional map data (tiles, images, features) starts.
     * @event module:ol/MapEvent~MapEvent#loadstart
     * @api
     */
    LOADSTART: "loadstart",
    /**
     * Triggered when loading of additional map data has completed.
     * @event module:ol/MapEvent~MapEvent#loadend
     * @api
     */
    LOADEND: "loadend"
  }, Rr = {
    LAYERGROUP: "layergroup",
    SIZE: "size",
    TARGET: "target",
    VIEW: "view"
  }, TE = 1 / 0;
  class $te {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */
    constructor(e, i) {
      this.priorityFunction_ = e, this.keyFunction_ = i, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.elements_.length = 0, this.priorities_.length = 0, nc(this.queuedElements_);
    }
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
    dequeue() {
      const e = this.elements_, i = this.priorities_, r = e[0];
      e.length == 1 ? (e.length = 0, i.length = 0) : (e[0] = /** @type {T} */
      e.pop(), i[0] = /** @type {number} */
      i.pop(), this.siftUp_(0));
      const n = this.keyFunction_(r);
      return delete this.queuedElements_[n], r;
    }
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
    enqueue(e) {
      Mt(
        !(this.keyFunction_(e) in this.queuedElements_),
        "Tried to enqueue an `element` that was already added to the queue"
      );
      const i = this.priorityFunction_(e);
      return i != TE ? (this.elements_.push(e), this.priorities_.push(i), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
    }
    /**
     * @return {number} Count.
     */
    getCount() {
      return this.elements_.length;
    }
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
    getLeftChildIndex_(e) {
      return e * 2 + 1;
    }
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
    getRightChildIndex_(e) {
      return e * 2 + 2;
    }
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
    getParentIndex_(e) {
      return e - 1 >> 1;
    }
    /**
     * Make this a heap. O(N).
     * @private
     */
    heapify_() {
      let e;
      for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
        this.siftUp_(e);
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.elements_.length === 0;
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
    isKeyQueued(e) {
      return e in this.queuedElements_;
    }
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
    isQueued(e) {
      return this.isKeyQueued(this.keyFunction_(e));
    }
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
    siftUp_(e) {
      const i = this.elements_, r = this.priorities_, n = i.length, s = i[e], o = r[e], a = e;
      for (; e < n >> 1; ) {
        const A = this.getLeftChildIndex_(e), l = this.getRightChildIndex_(e), c = l < n && r[l] < r[A] ? l : A;
        i[e] = i[c], r[e] = r[c], e = c;
      }
      i[e] = s, r[e] = o, this.siftDown_(a, e);
    }
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
    siftDown_(e, i) {
      const r = this.elements_, n = this.priorities_, s = r[i], o = n[i];
      for (; i > e; ) {
        const a = this.getParentIndex_(i);
        if (n[a] > o)
          r[i] = r[a], n[i] = n[a], i = a;
        else
          break;
      }
      r[i] = s, n[i] = o;
    }
    /**
     * FIXME empty description for jsdoc
     */
    reprioritize() {
      const e = this.priorityFunction_, i = this.elements_, r = this.priorities_;
      let n = 0;
      const s = i.length;
      let o, a, A;
      for (a = 0; a < s; ++a)
        o = i[a], A = e(o), A == TE ? delete this.queuedElements_[this.keyFunction_(o)] : (r[n] = A, i[n++] = o);
      i.length = n, r.length = n, this.heapify_();
    }
  }
  class nL extends $te {
    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */
    constructor(e, i) {
      super(
        /**
         * @param {Array} element Element.
         * @return {number} Priority.
         */
        function(r) {
          return e.apply(null, r);
        },
        /**
         * @param {Array} element Element.
         * @return {string} Key.
         */
        function(r) {
          return (
            /** @type {import("./Tile.js").default} */
            r[0].getKey()
          );
        }
      ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = i, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
    }
    /**
     * @param {Array} element Element.
     * @return {boolean} The element was added to the queue.
     * @override
     */
    enqueue(e) {
      const i = super.enqueue(e);
      return i && e[0].addEventListener(Ge.CHANGE, this.boundHandleTileChange_), i;
    }
    /**
     * @return {number} Number of tiles loading.
     */
    getTilesLoading() {
      return this.tilesLoading_;
    }
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */
    handleTileChange(e) {
      const i = (
        /** @type {import("./Tile.js").default} */
        e.target
      ), r = i.getState();
      if (r === pe.LOADED || r === pe.ERROR || r === pe.EMPTY) {
        r !== pe.ERROR && i.removeEventListener(Ge.CHANGE, this.boundHandleTileChange_);
        const n = i.getKey();
        n in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[n], --this.tilesLoading_), this.tileChangeCallback_();
      }
    }
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */
    loadMoreTiles(e, i) {
      let r = 0;
      for (; this.tilesLoading_ < e && r < i && this.getCount() > 0; ) {
        const n = this.dequeue()[0], s = n.getKey();
        n.getState() === pe.IDLE && !(s in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[s] = !0, ++this.tilesLoading_, ++r, n.load());
      }
    }
  }
  function eie(t, e, i, r, n) {
    if (!t || !(i in t.wantedTiles) || !t.wantedTiles[i][e.getKey()])
      return TE;
    const s = t.viewState.center, o = r[0] - s[0], a = r[1] - s[1];
    return 65536 * Math.log(n) + Math.sqrt(o * o + a * a) / n;
  }
  class mf extends no {
    /**
     * @param {Options} options Control options.
     */
    constructor(e) {
      super();
      const i = e.element;
      i && !e.target && !i.style.pointerEvents && (i.style.pointerEvents = "auto"), this.element = i || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      var e;
      (e = this.element) == null || e.remove(), super.disposeInternal();
    }
    /**
     * Get the map associated with this control.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(e) {
      var i;
      this.map_ && ((i = this.element) == null || i.remove());
      for (let r = 0, n = this.listenerKeys.length; r < n; ++r)
        Pt(this.listenerKeys[r]);
      if (this.listenerKeys.length = 0, this.map_ = e, e) {
        const r = this.target_ ?? e.getOverlayContainerStopEvent();
        this.element && r.appendChild(this.element), this.render !== $u && this.listenerKeys.push(
          nt(e, $o.POSTRENDER, this.render, this)
        ), e.render();
      }
    }
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */
    render(e) {
    }
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */
    setTarget(e) {
      this.target_ = typeof e == "string" ? document.getElementById(e) : e;
    }
  }
  class tie extends mf {
    /**
     * @param {Options} [options] Attribution options.
     */
    constructor(e) {
      e = e || {}, super({
        element: document.createElement("div"),
        render: e.render,
        target: e.target
      }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.attributions_ = e.attributions;
      const i = e.className !== void 0 ? e.className : "ol-attribution", r = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", n = e.expandClassName !== void 0 ? e.expandClassName : i + "-expand", s = e.collapseLabel !== void 0 ? e.collapseLabel : "›", o = e.collapseClassName !== void 0 ? e.collapseClassName : i + "-collapse";
      typeof s == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = s, this.collapseLabel_.className = o) : this.collapseLabel_ = s;
      const a = e.label !== void 0 ? e.label : "i";
      typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a, this.label_.className = n) : this.label_ = a;
      const A = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
      this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = r, this.toggleButton_.appendChild(A), this.toggleButton_.addEventListener(
        Ge.CLICK,
        this.handleClick_.bind(this),
        !1
      );
      const l = i + " " + df + " " + Gv + (this.collapsed_ && this.collapsible_ ? " " + bD : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
      c.className = l, c.appendChild(this.toggleButton_), c.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
    }
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */
    collectSourceAttributions_(e) {
      const i = this.getMap().getAllLayers(), r = new Set(
        i.flatMap((n) => n.getAttributions(e))
      );
      if (this.attributions_ !== void 0 && (Array.isArray(this.attributions_) ? this.attributions_.forEach((n) => r.add(n)) : r.add(this.attributions_)), !this.overrideCollapsible_) {
        const n = !i.some(
          (s) => {
            var o;
            return ((o = s.getSource()) == null ? void 0 : o.getAttributionsCollapsible()) === !1;
          }
        );
        this.setCollapsible(n);
      }
      return Array.from(r);
    }
    /**
     * @private
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    async updateElement_(e) {
      if (!e) {
        this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
        return;
      }
      const i = await Promise.all(
        this.collectSourceAttributions_(e).map(
          (n) => ed(() => n)
        )
      ), r = i.length > 0;
      if (this.renderedVisible_ != r && (this.element.style.display = r ? "" : "none", this.renderedVisible_ = r), !jo(i, this.renderedAttributions_)) {
        vU(this.ulElement_);
        for (let n = 0, s = i.length; n < s; ++n) {
          const o = document.createElement("li");
          o.innerHTML = i[n], this.ulElement_.appendChild(o);
        }
        this.renderedAttributions_ = i;
      }
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(e) {
      e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
    }
    /**
     * @private
     */
    handleToggle_() {
      this.element.classList.toggle(bD), this.collapsed_ ? wD(this.collapseLabel_, this.label_) : wD(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    }
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
    getCollapsible() {
      return this.collapsible_;
    }
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
    setCollapsible(e) {
      this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
    }
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
    setCollapsed(e) {
      this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
    }
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */
    getCollapsed() {
      return this.collapsed_;
    }
    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(e) {
      this.updateElement_(e.frameState);
    }
  }
  class iie extends mf {
    /**
     * @param {Options} [options] Rotate options.
     */
    constructor(e) {
      e = e || {}, super({
        element: document.createElement("div"),
        render: e.render,
        target: e.target
      });
      const i = e.className !== void 0 ? e.className : "ol-rotate", r = e.label !== void 0 ? e.label : "⇧", n = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
      this.label_ = null, typeof r == "string" ? (this.label_ = document.createElement("span"), this.label_.className = n, this.label_.textContent = r) : (this.label_ = r, this.label_.classList.add(n));
      const s = e.tipLabel ? e.tipLabel : "Reset rotation", o = document.createElement("button");
      o.className = i + "-reset", o.setAttribute("type", "button"), o.title = s, o.appendChild(this.label_), o.addEventListener(
        Ge.CLICK,
        this.handleClick_.bind(this),
        !1
      );
      const a = i + " " + df + " " + Gv, A = this.element;
      A.className = a, A.appendChild(o), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(np);
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(e) {
      e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
    }
    /**
     * @private
     */
    resetNorth_() {
      const i = this.getMap().getView();
      if (!i)
        return;
      const r = i.getRotation();
      r !== void 0 && (this.duration_ > 0 && r % (2 * Math.PI) !== 0 ? i.animate({
        rotation: 0,
        duration: this.duration_,
        easing: Yd
      }) : i.setRotation(0));
    }
    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(e) {
      const i = e.frameState;
      if (!i)
        return;
      const r = i.viewState.rotation;
      if (r != this.rotation_) {
        const n = "rotate(" + r + "rad)";
        if (this.autoHide_) {
          const s = this.element.classList.contains(np);
          !s && r === 0 ? this.element.classList.add(np) : s && r !== 0 && this.element.classList.remove(np);
        }
        this.label_.style.transform = n;
      }
      this.rotation_ = r;
    }
  }
  class sL extends mf {
    /**
     * @param {Options} [options] Zoom options.
     */
    constructor(e) {
      e = e || {}, super({
        element: document.createElement("div"),
        target: e.target
      });
      const i = e.className !== void 0 ? e.className : "ol-zoom", r = e.delta !== void 0 ? e.delta : 1, n = e.zoomInClassName !== void 0 ? e.zoomInClassName : i + "-in", s = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : i + "-out", o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", a = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–", A = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", l = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", c = document.createElement("button");
      c.className = n, c.setAttribute("type", "button"), c.title = A, c.appendChild(
        typeof o == "string" ? document.createTextNode(o) : o
      ), c.addEventListener(
        Ge.CLICK,
        this.handleClick_.bind(this, r),
        !1
      );
      const u = document.createElement("button");
      u.className = s, u.setAttribute("type", "button"), u.title = l, u.appendChild(
        typeof a == "string" ? document.createTextNode(a) : a
      ), u.addEventListener(
        Ge.CLICK,
        this.handleClick_.bind(this, -r),
        !1
      );
      const d = i + " " + df + " " + Gv, h = this.element;
      h.className = d, h.appendChild(c), h.appendChild(u), this.duration_ = e.duration !== void 0 ? e.duration : 250;
    }
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(e, i) {
      i.preventDefault(), this.zoomByDelta_(e);
    }
    /**
     * @param {number} delta Zoom delta.
     * @private
     */
    zoomByDelta_(e) {
      const r = this.getMap().getView();
      if (!r)
        return;
      const n = r.getZoom();
      if (n !== void 0) {
        const s = r.getConstrainedZoom(n + e);
        this.duration_ > 0 ? (r.getAnimating() && r.cancelAnimations(), r.animate({
          zoom: s,
          duration: this.duration_,
          easing: Yd
        })) : r.setZoom(s);
      }
    }
  }
  function rie(t) {
    t = t || {};
    const e = new Bn();
    return (t.zoom !== void 0 ? t.zoom : !0) && e.push(new sL(t.zoomOptions)), (t.rotate !== void 0 ? t.rotate : !0) && e.push(new iie(t.rotateOptions)), (t.attribution !== void 0 ? t.attribution : !0) && e.push(new tie(t.attributionOptions)), e;
  }
  const bb = {
    ACTIVE: "active"
  };
  class cc extends no {
    /**
     * @param {InteractionOptions} [options] Options.
     */
    constructor(e) {
      super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
    }
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */
    getActive() {
      return (
        /** @type {boolean} */
        this.get(bb.ACTIVE)
      );
    }
    /**
     * Get the map associated with this interaction.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    handleEvent(e) {
      return !0;
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
    setActive(e) {
      this.set(bb.ACTIVE, e);
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(e) {
      this.map_ = e;
    }
  }
  function nie(t, e, i) {
    const r = t.getCenterInternal();
    if (r) {
      const n = [r[0] + e[0], r[1] + e[1]];
      t.animateInternal({
        duration: i !== void 0 ? i : 250,
        easing: bee,
        center: t.getConstrainedCenter(n)
      });
    }
  }
  function rx(t, e, i, r) {
    const n = t.getZoom();
    if (n === void 0)
      return;
    const s = t.getConstrainedZoom(n + e), o = t.getResolutionForZoom(s);
    t.getAnimating() && t.cancelAnimations(), t.animate({
      resolution: o,
      anchor: i,
      duration: r !== void 0 ? r : 250,
      easing: Yd
    });
  }
  class sie extends cc {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(e) {
      let i = !1;
      if (e.type == Yt.DBLCLICK) {
        const r = (
          /** @type {MouseEvent} */
          e.originalEvent
        ), n = e.map, s = e.coordinate, o = r.shiftKey ? -this.delta_ : this.delta_, a = n.getView();
        rx(a, o, s, this.duration_), r.preventDefault(), i = !0;
      }
      return !i;
    }
  }
  class JA extends cc {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {}, super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        e
      ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
    }
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */
    getPointerCount() {
      return this.targetPointers.length;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleDownEvent(e) {
      return !1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleDragEvent(e) {
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     * @override
     */
    handleEvent(e) {
      if (!e.originalEvent)
        return !0;
      let i = !1;
      if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
        if (e.type == Yt.POINTERDRAG)
          this.handleDragEvent(e), e.originalEvent.preventDefault();
        else if (e.type == Yt.POINTERUP) {
          const r = this.handleUpEvent(e);
          this.handlingDownUpSequence = r && this.targetPointers.length > 0;
        }
      } else if (e.type == Yt.POINTERDOWN) {
        const r = this.handleDownEvent(e);
        this.handlingDownUpSequence = r, i = this.stopDown(r);
      } else e.type == Yt.POINTERMOVE && this.handleMoveEvent(e);
      return !i;
    }
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleMoveEvent(e) {
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleUpEvent(e) {
      return !1;
    }
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    stopDown(e) {
      return e;
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
    updateTrackedPointers_(e) {
      e.activePointers && (this.targetPointers = e.activePointers);
    }
  }
  function nx(t) {
    const e = t.length;
    let i = 0, r = 0;
    for (let n = 0; n < e; n++)
      i += t[n].clientX, r += t[n].clientY;
    return { clientX: i / e, clientY: r / e };
  }
  function Mb(t) {
    const e = arguments;
    return function(i) {
      let r = !0;
      for (let n = 0, s = e.length; n < s && (r = r && e[n](i), !!r); ++n)
        ;
      return r;
    };
  }
  const oie = function(t) {
    const e = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      t.originalEvent
    );
    return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
  }, aie = function(t) {
    const e = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      t.originalEvent
    );
    return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
  }, Aie = function(t) {
    const e = t.map.getTargetElement(), i = e.getRootNode(), r = t.map.getOwnerDocument().activeElement;
    return i instanceof ShadowRoot ? i.host.contains(r) : e.contains(r);
  }, oL = function(t) {
    const e = t.map.getTargetElement(), i = e.getRootNode();
    return (i instanceof ShadowRoot ? i.host : e).hasAttribute("tabindex") ? Aie(t) : !0;
  }, RE = Qa, lie = function(t) {
    return t.type == Yt.CLICK;
  }, aL = function(t) {
    const e = (
      /** @type {MouseEvent} */
      t.originalEvent
    );
    return e.button == 0 && !(q$ && MU && e.ctrlKey);
  }, Ib = rc, AL = function(t) {
    return t.type == Yt.SINGLECLICK;
  }, sx = function(t) {
    const e = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      t.originalEvent
    );
    return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
  }, lL = function(t) {
    const e = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      t.originalEvent
    );
    return MU ? e.metaKey : e.ctrlKey;
  }, ox = function(t) {
    const e = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      t.originalEvent
    );
    return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
  }, cL = function(t) {
    const e = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      t.originalEvent
    ), i = (
      /** @type {Element} */
      e.target.tagName
    );
    return i !== "INPUT" && i !== "SELECT" && i !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !e.target.isContentEditable;
  }, D0 = function(t) {
    const e = (
      /** @type {import("../MapBrowserEvent").default} */
      t.originalEvent
    );
    return Mt(
      e !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    ), e.pointerType == "mouse";
  }, uL = function(t) {
    const e = (
      /** @type {import("../MapBrowserEvent").default} */
      t.originalEvent
    );
    return Mt(
      e !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    ), e.isPrimary && e.button === 0;
  };
  class dL extends JA {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      super({
        stopDown: rc
      }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
      const i = e.condition ? e.condition : Mb(sx, uL);
      this.condition_ = e.onFocusOnly ? Mb(oL, i) : i, this.noKinetic_ = !1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(e) {
      const i = e.map;
      this.panning_ || (this.panning_ = !0, i.getView().beginInteraction());
      const r = this.targetPointers, n = i.getEventPixel(nx(r));
      if (r.length == this.lastPointersCount_) {
        if (this.kinetic_ && this.kinetic_.update(n[0], n[1]), this.lastCentroid) {
          const s = [
            this.lastCentroid[0] - n[0],
            n[1] - this.lastCentroid[1]
          ], a = e.map.getView();
          tU(s, a.getResolution()), pv(s, a.getRotation()), a.adjustCenterInternal(s);
        }
      } else this.kinetic_ && this.kinetic_.begin();
      this.lastCentroid = n, this.lastPointersCount_ = r.length, e.originalEvent.preventDefault();
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      const i = e.map, r = i.getView();
      if (this.targetPointers.length === 0) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          const n = this.kinetic_.getDistance(), s = this.kinetic_.getAngle(), o = r.getCenterInternal(), a = i.getPixelFromCoordinateInternal(o), A = i.getCoordinateFromPixelInternal([
            a[0] - n * Math.cos(s),
            a[1] - n * Math.sin(s)
          ]);
          r.animateInternal({
            center: r.getConstrainedCenter(A),
            duration: 500,
            easing: Yd
          });
        }
        return this.panning_ && (this.panning_ = !1, r.endInteraction()), !1;
      }
      return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(e) {
      if (this.targetPointers.length > 0 && this.condition_(e)) {
        const r = e.map.getView();
        return this.lastCentroid = null, r.getAnimating() && r.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
      }
      return !1;
    }
  }
  class cie extends JA {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {}, super({
        stopDown: rc
      }), this.condition_ = e.condition ? e.condition : aie, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(e) {
      if (!D0(e))
        return;
      const i = e.map, r = i.getView();
      if (r.getConstraints().rotation === Wv)
        return;
      const n = i.getSize(), s = e.pixel, o = Math.atan2(n[1] / 2 - s[1], s[0] - n[0] / 2);
      if (this.lastAngle_ !== void 0) {
        const a = o - this.lastAngle_;
        r.adjustRotationInternal(-a);
      }
      this.lastAngle_ = o;
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      return D0(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(e) {
      return D0(e) && aL(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
    }
  }
  class uie extends Td {
    /**
     * @param {string} className CSS class name.
     */
    constructor(e) {
      super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.setMap(null);
    }
    /**
     * @private
     */
    render_() {
      const e = this.startPixel_, i = this.endPixel_, r = "px", n = this.element_.style;
      n.left = Math.min(e[0], i[0]) + r, n.top = Math.min(e[1], i[1]) + r, n.width = Math.abs(i[0] - e[0]) + r, n.height = Math.abs(i[1] - e[1]) + r;
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(e) {
      if (this.map_) {
        this.map_.getOverlayContainer().removeChild(this.element_);
        const i = this.element_.style;
        i.left = "inherit", i.top = "inherit", i.width = "inherit", i.height = "inherit";
      }
      this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
    }
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */
    setPixels(e, i) {
      this.startPixel_ = e, this.endPixel_ = i, this.createOrUpdateGeometry(), this.render_();
    }
    /**
     * Creates or updates the cached geometry.
     */
    createOrUpdateGeometry() {
      if (!this.map_)
        return;
      const e = this.startPixel_, i = this.endPixel_, n = [
        e,
        [e[0], i[1]],
        i,
        [i[0], e[1]]
      ].map(
        this.map_.getCoordinateFromPixelInternal,
        this.map_
      );
      n[4] = n[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([n]) : this.geometry_ = new en([n]);
    }
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */
    getGeometry() {
      return this.geometry_;
    }
  }
  const xc = {
    /**
     * Triggered upon drag box start.
     * @event DragBoxEvent#boxstart
     * @api
     */
    BOXSTART: "boxstart",
    /**
     * Triggered on drag when box is active.
     * @event DragBoxEvent#boxdrag
     * @api
     */
    BOXDRAG: "boxdrag",
    /**
     * Triggered upon drag box end.
     * @event DragBoxEvent#boxend
     * @api
     */
    BOXEND: "boxend",
    /**
     * Triggered upon drag box canceled.
     * @event DragBoxEvent#boxcancel
     * @api
     */
    BOXCANCEL: "boxcancel"
  };
  class nh extends on {
    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */
    constructor(e, i, r) {
      super(e), this.coordinate = i, this.mapBrowserEvent = r;
    }
  }
  class hL extends JA {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      super(), this.on, this.once, this.un, e = e ?? {}, this.box_ = new uie(e.className || "ol-dragbox"), this.minArea_ = e.minArea ?? 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ?? aL, this.boxEndCondition_ = e.boxEndCondition ?? this.defaultBoxEndCondition;
    }
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */
    defaultBoxEndCondition(e, i, r) {
      const n = r[0] - i[0], s = r[1] - i[1];
      return n * n + s * s >= this.minArea_;
    }
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */
    getGeometry() {
      return this.box_.getGeometry();
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(e) {
      this.startPixel_ && (this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
        new nh(
          xc.BOXDRAG,
          e.coordinate,
          e
        )
      ));
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      if (!this.startPixel_)
        return !1;
      const i = this.boxEndCondition_(
        e,
        this.startPixel_,
        e.pixel
      );
      return i && this.onBoxEnd(e), this.dispatchEvent(
        new nh(
          i ? xc.BOXEND : xc.BOXCANCEL,
          e.coordinate,
          e
        )
      ), this.box_.setMap(null), this.startPixel_ = null, !1;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(e) {
      return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
        new nh(
          xc.BOXSTART,
          e.coordinate,
          e
        )
      ), !0) : !1;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    onBoxEnd(e) {
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     * @override
     */
    setActive(e) {
      e || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
        new nh(xc.BOXCANCEL, this.startPixel_, null)
      ), this.startPixel_ = null)), super.setActive(e);
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     * @override
     */
    setMap(e) {
      this.getMap() && (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
        new nh(xc.BOXCANCEL, this.startPixel_, null)
      ), this.startPixel_ = null)), super.setMap(e);
    }
  }
  class die extends hL {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {};
      const i = e.condition ? e.condition : ox;
      super({
        condition: i,
        className: e.className || "ol-dragzoom",
        minArea: e.minArea
      }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @override
     */
    onBoxEnd(e) {
      const r = (
        /** @type {!import("../View.js").default} */
        this.getMap().getView()
      );
      let n = this.getGeometry();
      if (this.out_) {
        const s = r.rotatedExtentForGeometry(n), o = r.getResolutionForExtentInternal(s), a = r.getResolution() / o;
        n = n.clone(), n.scale(a * a);
      }
      r.fitInternal(n, {
        duration: this.duration_,
        easing: Yd
      });
    }
  }
  const tl = {
    LEFT: "ArrowLeft",
    UP: "ArrowUp",
    RIGHT: "ArrowRight",
    DOWN: "ArrowDown"
  };
  class hie extends cc {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      super(), e = e || {}, this.defaultCondition_ = function(i) {
        return sx(i) && cL(i);
      }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(e) {
      let i = !1;
      if (e.type == Ge.KEYDOWN) {
        const r = (
          /** @type {KeyboardEvent} */
          e.originalEvent
        ), n = r.key;
        if (this.condition_(e) && (n == tl.DOWN || n == tl.LEFT || n == tl.RIGHT || n == tl.UP)) {
          const o = e.map.getView(), a = o.getResolution() * this.pixelDelta_;
          let A = 0, l = 0;
          n == tl.DOWN ? l = -a : n == tl.LEFT ? A = -a : n == tl.RIGHT ? A = a : l = a;
          const c = [A, l];
          pv(c, o.getRotation()), nie(o, c, this.duration_), r.preventDefault(), i = !0;
        }
      }
      return !i;
    }
  }
  class gie extends cc {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      super(), e = e || {}, this.condition_ = e.condition ? e.condition : function(i) {
        return !lL(i) && cL(i);
      }, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(e) {
      let i = !1;
      if (e.type == Ge.KEYDOWN || e.type == Ge.KEYPRESS) {
        const r = (
          /** @type {KeyboardEvent} */
          e.originalEvent
        ), n = r.key;
        if (this.condition_(e) && (n === "+" || n === "-")) {
          const s = e.map, o = n === "+" ? this.delta_ : -this.delta_, a = s.getView();
          rx(a, o, void 0, this.duration_), r.preventDefault(), i = !0;
        }
      }
      return !i;
    }
  }
  class fie extends cc {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {}, super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        e
      ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
      const i = e.condition ? e.condition : RE;
      this.condition_ = e.onFocusOnly ? Mb(oL, i) : i, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
    }
    /**
     * @private
     */
    endInteraction_() {
      this.trackpadTimeoutId_ = void 0;
      const e = this.getMap();
      if (!e)
        return;
      e.getView().endInteraction(
        void 0,
        this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
        this.lastAnchor_ ? e.getCoordinateFromPixel(this.lastAnchor_) : null
      );
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(e) {
      if (!this.condition_(e) || e.type !== Ge.WHEEL)
        return !0;
      const r = e.map, n = (
        /** @type {WheelEvent} */
        e.originalEvent
      );
      n.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.pixel);
      let s;
      if (e.type == Ge.WHEEL && (s = n.deltaY, K$ && n.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (s /= Uv), n.deltaMode === WheelEvent.DOM_DELTA_LINE && (s *= 40)), s === 0)
        return !1;
      this.lastDelta_ = s;
      const o = Date.now();
      this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(s) < 4 ? "trackpad" : "wheel");
      const a = r.getView();
      if (this.mode_ === "trackpad" && !(a.getConstrainResolution() || this.constrainResolution_))
        return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (a.getAnimating() && a.cancelAnimations(), a.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
          this.endInteraction_.bind(this),
          this.timeout_
        ), a.adjustZoom(
          -s / this.deltaPerZoom_,
          this.lastAnchor_ ? r.getCoordinateFromPixel(this.lastAnchor_) : null
        ), this.startTime_ = o, !1;
      this.totalDelta_ += s;
      const A = Math.max(this.timeout_ - (o - this.startTime_), 0);
      return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
        this.handleWheelZoom_.bind(this, r),
        A
      ), !1;
    }
    /**
     * @private
     * @param {import("../Map.js").default} map Map.
     */
    handleWheelZoom_(e) {
      const i = e.getView();
      i.getAnimating() && i.cancelAnimations();
      let r = -yi(
        this.totalDelta_,
        -this.maxDelta_ * this.deltaPerZoom_,
        this.maxDelta_ * this.deltaPerZoom_
      ) / this.deltaPerZoom_;
      (i.getConstrainResolution() || this.constrainResolution_) && (r = r ? r > 0 ? 1 : -1 : 0), rx(
        i,
        r,
        this.lastAnchor_ ? e.getCoordinateFromPixel(this.lastAnchor_) : null,
        this.duration_
      ), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
    }
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */
    setMouseAnchor(e) {
      this.useAnchor_ = e, e || (this.lastAnchor_ = null);
    }
  }
  class pie extends JA {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {};
      const i = (
        /** @type {import("./Pointer.js").Options} */
        e
      );
      i.stopDown || (i.stopDown = rc), super(i), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(e) {
      let i = 0;
      const r = this.targetPointers[0], n = this.targetPointers[1], s = Math.atan2(
        n.clientY - r.clientY,
        n.clientX - r.clientX
      );
      if (this.lastAngle_ !== void 0) {
        const A = s - this.lastAngle_;
        this.rotationDelta_ += A, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), i = A;
      }
      this.lastAngle_ = s;
      const o = e.map, a = o.getView();
      a.getConstraints().rotation !== Wv && (this.anchor_ = o.getCoordinateFromPixelInternal(
        o.getEventPixel(nx(this.targetPointers))
      ), this.rotating_ && (o.render(), a.adjustRotationInternal(i, this.anchor_)));
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(e) {
      if (this.targetPointers.length >= 2) {
        const i = e.map;
        return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || i.getView().beginInteraction(), !0;
      }
      return !1;
    }
  }
  class mie extends JA {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {};
      const i = (
        /** @type {import("./Pointer.js").Options} */
        e
      );
      i.stopDown || (i.stopDown = rc), super(i), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @override
     */
    handleDragEvent(e) {
      let i = 1;
      const r = this.targetPointers[0], n = this.targetPointers[1], s = r.clientX - n.clientX, o = r.clientY - n.clientY, a = Math.sqrt(s * s + o * o);
      this.lastDistance_ !== void 0 && (i = this.lastDistance_ / a), this.lastDistance_ = a;
      const A = e.map, l = A.getView();
      i != 1 && (this.lastScaleDelta_ = i), this.anchor_ = A.getCoordinateFromPixelInternal(
        A.getEventPixel(nx(this.targetPointers))
      ), A.render(), l.adjustResolutionInternal(i, this.anchor_);
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      if (this.targetPointers.length < 2) {
        const r = e.map.getView(), n = this.lastScaleDelta_ > 1 ? 1 : -1;
        return r.endInteraction(this.duration_, n), !1;
      }
      return !0;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(e) {
      if (this.targetPointers.length >= 2) {
        const i = e.map;
        return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || i.getView().beginInteraction(), !0;
      }
      return !1;
    }
  }
  function gL(t) {
    t = t || {};
    const e = new Bn(), i = new Wte(-5e-3, 0.05, 100);
    return (t.altShiftDragRotate !== void 0 ? t.altShiftDragRotate : !0) && e.push(new cie()), (t.doubleClickZoom !== void 0 ? t.doubleClickZoom : !0) && e.push(
      new sie({
        delta: t.zoomDelta,
        duration: t.zoomDuration
      })
    ), (t.dragPan !== void 0 ? t.dragPan : !0) && e.push(
      new dL({
        onFocusOnly: t.onFocusOnly,
        kinetic: i
      })
    ), (t.pinchRotate !== void 0 ? t.pinchRotate : !0) && e.push(new pie()), (t.pinchZoom !== void 0 ? t.pinchZoom : !0) && e.push(
      new mie({
        duration: t.zoomDuration
      })
    ), (t.keyboard !== void 0 ? t.keyboard : !0) && (e.push(new hie()), e.push(
      new gie({
        delta: t.zoomDelta,
        duration: t.zoomDuration
      })
    )), (t.mouseWheelZoom !== void 0 ? t.mouseWheelZoom : !0) && e.push(
      new fie({
        onFocusOnly: t.onFocusOnly,
        duration: t.zoomDuration
      })
    ), (t.shiftDragZoom !== void 0 ? t.shiftDragZoom : !0) && e.push(
      new die({
        duration: t.zoomDuration
      })
    ), e;
  }
  function fL(t) {
    if (t instanceof HA) {
      t.setMapInternal(null);
      return;
    }
    t instanceof Ud && t.getLayers().forEach(fL);
  }
  function pL(t, e) {
    if (t instanceof HA) {
      t.setMapInternal(e);
      return;
    }
    if (t instanceof Ud) {
      const i = t.getLayers().getArray();
      for (let r = 0, n = i.length; r < n; ++r)
        pL(i[r], e);
    }
  }
  let Ef = class extends no {
    /**
     * @param {MapOptions} [options] Map options.
     */
    constructor(e) {
      super(), e = e || {}, this.on, this.once, this.un;
      const i = Eie(e);
      this.renderComplete_ = !1, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : Uv, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = ri(), this.pixelToCoordinateTransform_ = ri(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = i.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = i.controls || rie(), this.interactions = i.interactions || gL({
        onFocusOnly: !0
      }), this.overlays_ = i.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new nL(
        this.getTilePriority.bind(this),
        this.handleTileChange_.bind(this)
      ), this.addChangeListener(
        Rr.LAYERGROUP,
        this.handleLayerGroupChanged_
      ), this.addChangeListener(Rr.VIEW, this.handleViewChanged_), this.addChangeListener(Rr.SIZE, this.handleSizeChanged_), this.addChangeListener(Rr.TARGET, this.handleTargetChanged_), this.setProperties(i.values);
      const r = this;
      e.view && !(e.view instanceof Ds) && e.view.then(function(n) {
        r.setView(new Ds(n));
      }), this.controls.addEventListener(
        Ui.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
         */
        (n) => {
          n.element.setMap(this);
        }
      ), this.controls.addEventListener(
        Ui.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
         */
        (n) => {
          n.element.setMap(null);
        }
      ), this.interactions.addEventListener(
        Ui.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (n) => {
          n.element.setMap(this);
        }
      ), this.interactions.addEventListener(
        Ui.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (n) => {
          n.element.setMap(null);
        }
      ), this.overlays_.addEventListener(
        Ui.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (n) => {
          this.addOverlayInternal_(n.element);
        }
      ), this.overlays_.addEventListener(
        Ui.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (n) => {
          const s = n.element.getId();
          s !== void 0 && delete this.overlayIdIndex_[s.toString()], n.element.setMap(null);
        }
      ), this.controls.forEach(
        /**
         * @param {import("./control/Control.js").default} control Control.
         */
        (n) => {
          n.setMap(this);
        }
      ), this.interactions.forEach(
        /**
         * @param {import("./interaction/Interaction.js").default} interaction Interaction.
         */
        (n) => {
          n.setMap(this);
        }
      ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */
    addControl(e) {
      this.getControls().push(e);
    }
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteractions()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */
    addInteraction(e) {
      this.getInteractions().push(e);
    }
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */
    addLayer(e) {
      this.getLayerGroup().getLayers().push(e);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */
    handleLayerAdd_(e) {
      pL(e.layer, this);
    }
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */
    addOverlay(e) {
      this.getOverlays().push(e);
    }
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */
    addOverlayInternal_(e) {
      const i = e.getId();
      i !== void 0 && (this.overlayIdIndex_[i.toString()] = e), e.setMap(this);
    }
    /**
     *
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
    }
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */
    forEachFeatureAtPixel(e, i, r) {
      if (!this.frameState_ || !this.renderer_)
        return;
      const n = this.getCoordinateFromPixelInternal(e);
      r = r !== void 0 ? r : {};
      const s = r.hitTolerance !== void 0 ? r.hitTolerance : 0, o = r.layerFilter !== void 0 ? r.layerFilter : Qa, a = r.checkWrapped !== !1;
      return this.renderer_.forEachFeatureAtCoordinate(
        n,
        this.frameState_,
        s,
        a,
        i,
        null,
        o,
        null
      );
    }
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */
    getFeaturesAtPixel(e, i) {
      const r = [];
      return this.forEachFeatureAtPixel(
        e,
        function(n) {
          r.push(n);
        },
        i
      ), r;
    }
    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */
    getAllLayers() {
      const e = [];
      function i(r) {
        r.forEach(function(n) {
          n instanceof Ud ? i(n.getLayers()) : e.push(n);
        });
      }
      return i(this.getLayers()), e;
    }
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through the `layerFilter` option.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */
    hasFeatureAtPixel(e, i) {
      if (!this.frameState_ || !this.renderer_)
        return !1;
      const r = this.getCoordinateFromPixelInternal(e);
      i = i !== void 0 ? i : {};
      const n = i.layerFilter !== void 0 ? i.layerFilter : Qa, s = i.hitTolerance !== void 0 ? i.hitTolerance : 0, o = i.checkWrapped !== !1;
      return this.renderer_.hasFeatureAtCoordinate(
        r,
        this.frameState_,
        s,
        o,
        n,
        null
      );
    }
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
    getEventCoordinate(e) {
      return this.getCoordinateFromPixel(this.getEventPixel(e));
    }
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */
    getEventCoordinateInternal(e) {
      return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
    }
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent|{clientX: number, clientY: number}} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */
    getEventPixel(e) {
      const r = this.viewport_.getBoundingClientRect(), n = this.getSize(), s = r.width / n[0], o = r.height / n[1], a = (
        //FIXME Are we really calling this with a TouchEvent anywhere?
        "changedTouches" in e ? (
          /** @type {TouchEvent} */
          e.changedTouches[0]
        ) : (
          /** @type {MouseEvent} */
          e
        )
      );
      return [
        (a.clientX - r.left) / s,
        (a.clientY - r.top) / o
      ];
    }
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */
    getTarget() {
      return (
        /** @type {HTMLElement|string|undefined} */
        this.get(Rr.TARGET)
      );
    }
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */
    getTargetElement() {
      return this.targetElement_;
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */
    getCoordinateFromPixel(e) {
      return QA(
        this.getCoordinateFromPixelInternal(e),
        this.getView().getProjection()
      );
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */
    getCoordinateFromPixelInternal(e) {
      const i = this.frameState_;
      return i ? Ei(i.pixelToCoordinateTransform, e.slice()) : null;
    }
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */
    getControls() {
      return this.controls;
    }
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */
    getOverlays() {
      return this.overlays_;
    }
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default|null} Overlay.
     * @api
     */
    getOverlayById(e) {
      const i = this.overlayIdIndex_[e.toString()];
      return i !== void 0 ? i : null;
    }
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */
    getInteractions() {
      return this.interactions;
    }
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */
    getLayerGroup() {
      return (
        /** @type {LayerGroup} */
        this.get(Rr.LAYERGROUP)
      );
    }
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */
    setLayers(e) {
      const i = this.getLayerGroup();
      if (e instanceof Bn) {
        i.setLayers(e);
        return;
      }
      const r = i.getLayers();
      r.clear(), r.extend(e);
    }
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */
    getLayers() {
      return this.getLayerGroup().getLayers();
    }
    /**
     * @return {boolean} Layers have sources that are still loading.
     */
    getLoadingOrNotReady() {
      const e = this.getLayerGroup().getLayerStatesArray();
      for (let i = 0, r = e.length; i < r; ++i) {
        const n = e[i];
        if (!n.visible)
          continue;
        const s = n.layer.getRenderer();
        if (s && !s.ready)
          return !0;
        const o = n.layer.getSource();
        if (o && o.loading)
          return !0;
      }
      return !1;
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */
    getPixelFromCoordinate(e) {
      const i = di(
        e,
        this.getView().getProjection()
      );
      return this.getPixelFromCoordinateInternal(i);
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */
    getPixelFromCoordinateInternal(e) {
      const i = this.frameState_;
      return i ? Ei(
        i.coordinateToPixelTransform,
        e.slice(0, 2)
      ) : null;
    }
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default|null} Renderer
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    getSize() {
      return (
        /** @type {import("./size.js").Size|undefined} */
        this.get(Rr.SIZE)
      );
    }
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */
    getView() {
      return (
        /** @type {View} */
        this.get(Rr.VIEW)
      );
    }
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */
    getViewport() {
      return this.viewport_;
    }
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */
    getOverlayContainer() {
      return this.overlayContainer_;
    }
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */
    getOverlayContainerStopEvent() {
      return this.overlayContainerStopEvent_;
    }
    /**
     * @return {!Document} The document where the map is displayed.
     */
    getOwnerDocument() {
      const e = this.getTargetElement();
      return e ? e.ownerDocument : document;
    }
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
    getTilePriority(e, i, r, n) {
      return eie(
        this.frameState_,
        e,
        i,
        r,
        n
      );
    }
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [type] Type.
     */
    handleBrowserEvent(e, i) {
      i = i || e.type;
      const r = new qo(i, this, e);
      this.handleMapBrowserEvent(r);
    }
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */
    handleMapBrowserEvent(e) {
      if (!this.frameState_)
        return;
      const i = (
        /** @type {PointerEvent} */
        e.originalEvent
      ), r = i.type;
      if (r === Cb.POINTERDOWN || r === Ge.WHEEL || r === Ge.KEYDOWN) {
        const n = this.getOwnerDocument(), s = this.viewport_.getRootNode ? this.viewport_.getRootNode() : n, o = (
          /** @type {Node} */
          i.target
        ), a = s instanceof ShadowRoot ? s.host === o ? s.host.ownerDocument : s : s === n ? n.documentElement : s;
        if (
          // Abort if the target is a child of the container for elements whose events are not meant
          // to be handled by map interactions.
          this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
          // It's possible for the target to no longer be in the page if it has been removed in an
          // event listener, this might happen in a Control that recreates it's content based on
          // user interaction either manually or via a render in something like https://reactjs.org/
          !a.contains(o)
        )
          return;
      }
      if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
        const n = this.getInteractions().getArray().slice();
        for (let s = n.length - 1; s >= 0; s--) {
          const o = n[s];
          if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
            continue;
          if (!o.handleEvent(e) || e.propagationStopped)
            break;
        }
      }
    }
    /**
     * @protected
     */
    handlePostRender() {
      const e = this.frameState_, i = this.tileQueue_;
      if (!i.isEmpty()) {
        let n = this.maxTilesLoading_, s = n;
        if (e) {
          const o = e.viewHints;
          if (o[Ai.ANIMATING] || o[Ai.INTERACTING]) {
            const a = Date.now() - e.time > 8;
            n = a ? 0 : 8, s = a ? 0 : 2;
          }
        }
        i.getTilesLoading() < n && (i.reprioritize(), i.loadMoreTiles(n, s));
      }
      e && this.renderer_ && !e.animate && (this.renderComplete_ ? (this.hasListener(dr.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
        dr.RENDERCOMPLETE,
        e
      ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
        new Kc($o.LOADEND, this, e)
      ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
        new Kc($o.LOADSTART, this, e)
      )));
      const r = this.postRenderFunctions_;
      if (e)
        for (let n = 0, s = r.length; n < s; ++n)
          r[n](this, e);
      r.length = 0;
    }
    /**
     * @private
     */
    handleSizeChanged_() {
      this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
    }
    /**
     * @private
     */
    handleTargetChanged_() {
      if (this.mapBrowserEventHandler_) {
        for (let r = 0, n = this.targetChangeHandlerKeys_.length; r < n; ++r)
          Pt(this.targetChangeHandlerKeys_[r]);
        this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
          Ge.CONTEXTMENU,
          this.boundHandleBrowserEvent_
        ), this.viewport_.removeEventListener(
          Ge.WHEEL,
          this.boundHandleBrowserEvent_
        ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, this.viewport_.remove();
      }
      if (this.targetElement_) {
        this.resizeObserver_.unobserve(this.targetElement_);
        const r = this.targetElement_.getRootNode();
        r instanceof ShadowRoot && this.resizeObserver_.unobserve(r.host), this.setSize(void 0);
      }
      const e = this.getTarget(), i = typeof e == "string" ? document.getElementById(e) : e;
      if (this.targetElement_ = i, !i)
        this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
      else {
        i.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new Zte(this)), this.mapBrowserEventHandler_ = new qte(
          this,
          this.moveTolerance_
        );
        for (const s in Yt)
          this.mapBrowserEventHandler_.addEventListener(
            Yt[s],
            this.handleMapBrowserEvent.bind(this)
          );
        this.viewport_.addEventListener(
          Ge.CONTEXTMENU,
          this.boundHandleBrowserEvent_,
          !1
        ), this.viewport_.addEventListener(
          Ge.WHEEL,
          this.boundHandleBrowserEvent_,
          IU ? { passive: !1 } : !1
        );
        let r;
        if (this.keyboardEventTarget_)
          r = this.keyboardEventTarget_;
        else {
          const s = i.getRootNode();
          r = s instanceof ShadowRoot ? s.host : i;
        }
        this.targetChangeHandlerKeys_ = [
          nt(
            r,
            Ge.KEYDOWN,
            this.handleBrowserEvent,
            this
          ),
          nt(
            r,
            Ge.KEYPRESS,
            this.handleBrowserEvent,
            this
          )
        ];
        const n = i.getRootNode();
        n instanceof ShadowRoot && this.resizeObserver_.observe(n.host), this.resizeObserver_.observe(i);
      }
      this.updateSize();
    }
    /**
     * @private
     */
    handleTileChange_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewPropertyChanged_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewChanged_() {
      this.viewPropertyListenerKey_ && (Pt(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (Pt(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
      const e = this.getView();
      e && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = nt(
        e,
        qu.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      ), this.viewChangeListenerKey_ = nt(
        e,
        Ge.CHANGE,
        this.handleViewPropertyChanged_,
        this
      ), e.resolveConstraints(0)), this.render();
    }
    /**
     * @private
     */
    handleLayerGroupChanged_() {
      this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(Pt), this.layerGroupPropertyListenerKeys_ = null);
      const e = this.getLayerGroup();
      e && (this.handleLayerAdd_(new sA("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
        nt(e, qu.PROPERTYCHANGE, this.render, this),
        nt(e, Ge.CHANGE, this.render, this),
        nt(e, "addlayer", this.handleLayerAdd_, this),
        nt(e, "removelayer", this.handleLayerRemove_, this)
      ]), this.render();
    }
    /**
     * @return {boolean} Is rendered.
     */
    isRendered() {
      return !!this.frameState_;
    }
    /**
     * @private
     */
    animationDelay_() {
      this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
    }
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */
    renderSync() {
      this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
    }
    /**
     * Redraws all text after new fonts have loaded
     */
    redrawText() {
      const e = this.getLayerGroup().getLayerStatesArray();
      for (let i = 0, r = e.length; i < r; ++i) {
        const n = e[i].layer;
        n.hasRenderer() && n.getRenderer().handleFontsChanged();
      }
    }
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */
    render() {
      this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
    }
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */
    removeControl(e) {
      return this.getControls().remove(e);
    }
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */
    removeInteraction(e) {
      return this.getInteractions().remove(e);
    }
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */
    removeLayer(e) {
      return this.getLayerGroup().getLayers().remove(e);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */
    handleLayerRemove_(e) {
      fL(e.layer);
    }
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */
    removeOverlay(e) {
      return this.getOverlays().remove(e);
    }
    /**
     * @param {number} time Time.
     * @private
     */
    renderFrame_(e) {
      const i = this.getSize(), r = this.getView(), n = this.frameState_;
      let s = null;
      if (i !== void 0 && CD(i) && r && r.isDef()) {
        const o = r.getHints(
          this.frameState_ ? this.frameState_.viewHints : void 0
        ), a = r.getState();
        if (s = {
          animate: !1,
          coordinateToPixelTransform: this.coordinateToPixelTransform_,
          declutter: null,
          extent: ag(
            a.center,
            a.resolution,
            a.rotation,
            i
          ),
          index: this.frameIndex_++,
          layerIndex: 0,
          layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
          pixelRatio: this.pixelRatio_,
          pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
          postRenderFunctions: [],
          size: i,
          tileQueue: this.tileQueue_,
          time: e,
          usedTiles: {},
          viewState: a,
          viewHints: o,
          wantedTiles: {},
          mapId: ve(this),
          renderTargets: {}
        }, a.nextCenter && a.nextResolution) {
          const A = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
          s.nextExtent = ag(
            a.nextCenter,
            a.nextResolution,
            A,
            i
          );
        }
      }
      this.frameState_ = s, this.renderer_.renderFrame(s), s && (s.animate && this.render(), Array.prototype.push.apply(
        this.postRenderFunctions_,
        s.postRenderFunctions
      ), n && (!this.previousExtent_ || !GA(this.previousExtent_) && !Zs(s.extent, this.previousExtent_)) && (this.dispatchEvent(
        new Kc($o.MOVESTART, this, n)
      ), this.previousExtent_ = _d(this.previousExtent_)), this.previousExtent_ && !s.viewHints[Ai.ANIMATING] && !s.viewHints[Ai.INTERACTING] && !Zs(s.extent, this.previousExtent_) && (this.dispatchEvent(
        new Kc($o.MOVEEND, this, s)
      ), XN(s.extent, this.previousExtent_))), this.dispatchEvent(new Kc($o.POSTRENDER, this, s)), this.renderComplete_ = (this.hasListener($o.LOADSTART) || this.hasListener($o.LOADEND) || this.hasListener(dr.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady(), this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
      }, 0));
    }
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */
    setLayerGroup(e) {
      const i = this.getLayerGroup();
      i && this.handleLayerRemove_(new sA("removelayer", i)), this.set(Rr.LAYERGROUP, e);
    }
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    setSize(e) {
      this.set(Rr.SIZE, e);
    }
    /**
     * Set the target element to render this map into.
     * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
     *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
     *  `tabindex` atribute must be set on the custom element's host element.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */
    setTarget(e) {
      this.set(Rr.TARGET, e);
    }
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */
    setView(e) {
      if (!e || e instanceof Ds) {
        this.set(Rr.VIEW, e);
        return;
      }
      this.set(Rr.VIEW, new Ds());
      const i = this;
      e.then(function(r) {
        i.setView(new Ds(r));
      });
    }
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */
    updateSize() {
      const e = this.getTargetElement();
      let i;
      if (e) {
        const n = getComputedStyle(e), s = e.offsetWidth - parseFloat(n.borderLeftWidth) - parseFloat(n.paddingLeft) - parseFloat(n.paddingRight) - parseFloat(n.borderRightWidth), o = e.offsetHeight - parseFloat(n.borderTopWidth) - parseFloat(n.paddingTop) - parseFloat(n.paddingBottom) - parseFloat(n.borderBottomWidth);
        !isNaN(s) && !isNaN(o) && (i = [Math.max(0, s), Math.max(0, o)], !CD(i) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && AU(
          "No map visible because the map container's width or height are 0."
        ));
      }
      const r = this.getSize();
      i && (!r || !jo(i, r)) && (this.setSize(i), this.updateViewportSize_(i));
    }
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @param {import("./size.js").Size|undefined} size The size.
     * @private
     */
    updateViewportSize_(e) {
      const i = this.getView();
      i && i.setViewportSize(e);
    }
  };
  function Eie(t) {
    let e = null;
    t.keyboardEventTarget !== void 0 && (e = typeof t.keyboardEventTarget == "string" ? document.getElementById(t.keyboardEventTarget) : t.keyboardEventTarget);
    const i = {}, r = t.layers && typeof /** @type {?} */
    t.layers.getLayers == "function" ? (
      /** @type {LayerGroup} */
      t.layers
    ) : new Ud({
      layers: (
        /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
        t.layers
      )
    });
    i[Rr.LAYERGROUP] = r, i[Rr.TARGET] = t.target, i[Rr.VIEW] = t.view instanceof Ds ? t.view : new Ds();
    let n;
    t.controls !== void 0 && (Array.isArray(t.controls) ? n = new Bn(t.controls.slice()) : (Mt(
      typeof /** @type {?} */
      t.controls.getArray == "function",
      "Expected `controls` to be an array or an `ol/Collection.js`"
    ), n = t.controls));
    let s;
    t.interactions !== void 0 && (Array.isArray(t.interactions) ? s = new Bn(t.interactions.slice()) : (Mt(
      typeof /** @type {?} */
      t.interactions.getArray == "function",
      "Expected `interactions` to be an array or an `ol/Collection.js`"
    ), s = t.interactions));
    let o;
    return t.overlays !== void 0 ? Array.isArray(t.overlays) ? o = new Bn(t.overlays.slice()) : (Mt(
      typeof /** @type {?} */
      t.overlays.getArray == "function",
      "Expected `overlays` to be an array or an `ol/Collection.js`"
    ), o = t.overlays) : o = new Bn(), {
      controls: n,
      interactions: s,
      keyboardEventTarget: e,
      overlays: o,
      values: i
    };
  }
  const Sr = {
    ELEMENT: "element",
    MAP: "map",
    OFFSET: "offset",
    POSITION: "position",
    POSITIONING: "positioning"
  };
  class yie extends no {
    /**
     * @param {Options} options Overlay options.
     */
    constructor(e) {
      super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + lee, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
        transform_: "",
        visible: !0
      }, this.mapPostrenderListenerKey = null, this.addChangeListener(Sr.ELEMENT, this.handleElementChanged), this.addChangeListener(Sr.MAP, this.handleMapChanged), this.addChangeListener(Sr.OFFSET, this.handleOffsetChanged), this.addChangeListener(Sr.POSITION, this.handlePositionChanged), this.addChangeListener(Sr.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
    }
    /**
     * Get the DOM element of this overlay.
     * @return {HTMLElement|undefined} The Element containing the overlay.
     * @observable
     * @api
     */
    getElement() {
      return (
        /** @type {HTMLElement|undefined} */
        this.get(Sr.ELEMENT)
      );
    }
    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id;
    }
    /**
     * Get the map associated with this overlay.
     * @return {import("./Map.js").default|null} The map that the
     * overlay is part of.
     * @observable
     * @api
     */
    getMap() {
      return (
        /** @type {import("./Map.js").default|null} */
        this.get(Sr.MAP) || null
      );
    }
    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */
    getOffset() {
      return (
        /** @type {Array<number>} */
        this.get(Sr.OFFSET)
      );
    }
    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */
    getPosition() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(Sr.POSITION)
      );
    }
    /**
     * Get the current positioning of this overlay.
     * @return {Positioning} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */
    getPositioning() {
      return (
        /** @type {Positioning} */
        this.get(Sr.POSITIONING)
      );
    }
    /**
     * @protected
     */
    handleElementChanged() {
      vU(this.element);
      const e = this.getElement();
      e && this.element.appendChild(e);
    }
    /**
     * @protected
     */
    handleMapChanged() {
      var i;
      this.mapPostrenderListenerKey && ((i = this.element) == null || i.remove(), Pt(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
      const e = this.getMap();
      if (e) {
        this.mapPostrenderListenerKey = nt(
          e,
          $o.POSTRENDER,
          this.render,
          this
        ), this.updatePixelPosition();
        const r = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
        this.insertFirst ? r.insertBefore(this.element, r.childNodes[0] || null) : r.appendChild(this.element), this.performAutoPan();
      }
    }
    /**
     * @protected
     */
    render() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */
    handleOffsetChanged() {
      this.updatePixelPosition();
    }
    /**
     * @protected
     */
    handlePositionChanged() {
      this.updatePixelPosition(), this.performAutoPan();
    }
    /**
     * @protected
     */
    handlePositioningChanged() {
      this.updatePixelPosition();
    }
    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */
    setElement(e) {
      this.set(Sr.ELEMENT, e);
    }
    /**
     * Set the map to be associated with this overlay.
     * @param {import("./Map.js").default|null} map The map that the
     * overlay is part of. Pass `null` to just remove the overlay from the current map.
     * @observable
     * @api
     */
    setMap(e) {
      this.set(Sr.MAP, e);
    }
    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */
    setOffset(e) {
      this.set(Sr.OFFSET, e);
    }
    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */
    setPosition(e) {
      this.set(Sr.POSITION, e);
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */
    performAutoPan() {
      this.autoPan && this.panIntoView(this.autoPan);
    }
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
     * @api
     */
    panIntoView(e) {
      const i = this.getMap();
      if (!i || !i.getTargetElement() || !this.get(Sr.POSITION))
        return;
      const r = this.getRect(i.getTargetElement(), i.getSize()), n = this.getElement(), s = this.getRect(n, [
        eee(n),
        tee(n)
      ]);
      e = e || {};
      const o = e.margin === void 0 ? 20 : e.margin;
      if (!ts(r, s)) {
        const a = s[0] - r[0], A = r[2] - s[2], l = s[1] - r[1], c = r[3] - s[3], u = [0, 0];
        if (a < 0 ? u[0] = a - o : A < 0 && (u[0] = Math.abs(A) + o), l < 0 ? u[1] = l - o : c < 0 && (u[1] = Math.abs(c) + o), u[0] !== 0 || u[1] !== 0) {
          const d = (
            /** @type {import("./coordinate.js").Coordinate} */
            i.getView().getCenterInternal()
          ), h = i.getPixelFromCoordinateInternal(d);
          if (!h)
            return;
          const g = [h[0] + u[0], h[1] + u[1]], f = e.animation || {};
          i.getView().animateInternal({
            center: i.getCoordinateFromPixelInternal(g),
            duration: f.duration,
            easing: f.easing
          });
        }
      }
    }
    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */
    getRect(e, i) {
      const r = e.getBoundingClientRect(), n = r.left + window.pageXOffset, s = r.top + window.pageYOffset;
      return [n, s, n + i[0], s + i[1]];
    }
    /**
     * Set the positioning for this overlay.
     * @param {Positioning} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */
    setPositioning(e) {
      this.set(Sr.POSITIONING, e);
    }
    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */
    setVisible(e) {
      this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
    }
    /**
     * Update pixel position.
     * @protected
     */
    updatePixelPosition() {
      const e = this.getMap(), i = this.getPosition();
      if (!e || !e.isRendered() || !i) {
        this.setVisible(!1);
        return;
      }
      const r = e.getPixelFromCoordinate(i), n = e.getSize();
      this.updateRenderedPosition(r, n);
    }
    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */
    updateRenderedPosition(e, i) {
      const r = this.element.style, n = this.getOffset(), s = this.getPositioning();
      this.setVisible(!0);
      const o = Math.round(e[0] + n[0]) + "px", a = Math.round(e[1] + n[1]) + "px";
      let A = "0%", l = "0%";
      s == "bottom-right" || s == "center-right" || s == "top-right" ? A = "-100%" : (s == "bottom-center" || s == "center-center" || s == "top-center") && (A = "-50%"), s == "bottom-left" || s == "bottom-center" || s == "bottom-right" ? l = "-100%" : (s == "center-left" || s == "center-center" || s == "center-right") && (l = "-50%");
      const c = `translate(${A}, ${l}) translate(${o}, ${a})`;
      this.rendered.transform_ != c && (this.rendered.transform_ = c, r.transform = c);
    }
    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */
    getOptions() {
      return this.options;
    }
  }
  class mL {
    /**
     * @param {number} [highWaterMark] High water mark.
     */
    constructor(e) {
      this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
    }
    deleteOldest() {
      const e = this.pop();
      e instanceof Td && e.dispose();
    }
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache() {
      return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }
    /**
     * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
     * the entry will be disposed.
     * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
     */
    expireCache(e) {
      for (; this.canExpireCache(); )
        this.deleteOldest();
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      for (; this.oldest_; )
        this.deleteOldest();
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */
    containsKey(e) {
      return this.entries_.hasOwnProperty(e);
    }
    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */
    forEach(e) {
      let i = this.oldest_;
      for (; i; )
        e(i.value_, i.key_, this), i = i.newer;
    }
    /**
     * @param {string} key Key.
     * @param {*} [options] Options (reserved for subclasses).
     * @return {T} Value.
     */
    get(e, i) {
      const r = this.entries_[e];
      return Mt(
        r !== void 0,
        "Tried to get a value for a key that does not exist in the cache"
      ), r === this.newest_ || (r === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
      this.oldest_.newer, this.oldest_.older = null) : (r.newer.older = r.older, r.older.newer = r.newer), r.newer = null, r.older = this.newest_, this.newest_.newer = r, this.newest_ = r), r.value_;
    }
    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */
    remove(e) {
      const i = this.entries_[e];
      return Mt(
        i !== void 0,
        "Tried to get a value for a key that does not exist in the cache"
      ), i === this.newest_ ? (this.newest_ = /** @type {Entry} */
      i.older, this.newest_ && (this.newest_.newer = null)) : i === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
      i.newer, this.oldest_ && (this.oldest_.older = null)) : (i.newer.older = i.older, i.older.newer = i.newer), delete this.entries_[e], --this.count_, i.value_;
    }
    /**
     * @return {number} Count.
     */
    getCount() {
      return this.count_;
    }
    /**
     * @return {Array<string>} Keys.
     */
    getKeys() {
      const e = new Array(this.count_);
      let i = 0, r;
      for (r = this.newest_; r; r = r.older)
        e[i++] = r.key_;
      return e;
    }
    /**
     * @return {Array<T>} Values.
     */
    getValues() {
      const e = new Array(this.count_);
      let i = 0, r;
      for (r = this.newest_; r; r = r.older)
        e[i++] = r.value_;
      return e;
    }
    /**
     * @return {T} Last value.
     */
    peekLast() {
      return this.oldest_.value_;
    }
    /**
     * @return {string} Last key.
     */
    peekLastKey() {
      return this.oldest_.key_;
    }
    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */
    peekFirstKey() {
      return this.newest_.key_;
    }
    /**
     * Return an entry without updating least recently used time.
     * @param {string} key Key.
     * @return {T|undefined} Value.
     */
    peek(e) {
      var i;
      return (i = this.entries_[e]) == null ? void 0 : i.value_;
    }
    /**
     * @return {T} value Value.
     */
    pop() {
      const e = this.oldest_;
      return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
      e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    replace(e, i) {
      this.get(e), this.entries_[e].value_ = i;
    }
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */
    set(e, i) {
      Mt(
        !(e in this.entries_),
        "Tried to set a value for a key that is used already"
      );
      const r = {
        key_: e,
        newer: null,
        older: this.newest_,
        value_: i
      };
      this.newest_ ? this.newest_.newer = r : this.oldest_ = r, this.newest_ = r, this.entries_[e] = r, ++this.count_;
    }
    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */
    setSize(e) {
      this.highWaterMark = e;
    }
  }
  function ad(t, e, i, r) {
    return r !== void 0 ? (r[0] = t, r[1] = e, r[2] = i, r) : [t, e, i];
  }
  function EL(t, e, i) {
    return t + "/" + e + "/" + i;
  }
  function Xc(t) {
    return EL(t[0], t[1], t[2]);
  }
  function yL(t) {
    return Bie(t[0], t[1], t[2]);
  }
  function Bie(t, e, i) {
    return (e << t) + i;
  }
  function wie(t, e) {
    const i = t[0], r = t[1], n = t[2];
    if (e.getMinZoom() > i || i > e.getMaxZoom())
      return !1;
    const s = e.getFullTileRange(i);
    return s ? s.containsXY(r, n) : !0;
  }
  class yB {
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     */
    constructor(e, i, r, n) {
      this.minX = e, this.maxX = i, this.minY = r, this.maxY = n;
    }
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */
    contains(e) {
      return this.containsXY(e[1], e[2]);
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */
    containsTileRange(e) {
      return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
    }
    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */
    containsXY(e, i) {
      return this.minX <= e && e <= this.maxX && this.minY <= i && i <= this.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */
    equals(e) {
      return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     */
    extend(e) {
      e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
    }
    /**
     * @return {number} Height.
     */
    getHeight() {
      return this.maxY - this.minY + 1;
    }
    /**
     * @return {import("./size.js").Size} Size.
     */
    getSize() {
      return [this.getWidth(), this.getHeight()];
    }
    /**
     * @return {number} Width.
     */
    getWidth() {
      return this.maxX - this.minX + 1;
    }
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */
    intersects(e) {
      return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
    }
  }
  function Qc(t, e, i, r, n) {
    return n !== void 0 ? (n.minX = t, n.maxX = e, n.minY = i, n.maxY = r, n) : new yB(t, e, i, r);
  }
  const WD = [];
  class Cie extends pf {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
     * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function.
     * @param {function(VectorRenderTile):void} removeSourceTiles Function.
     */
    constructor(e, i, r, n, s) {
      super(e, i, { transition: 0 }), this.context_ = null, this.executorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = n.bind(void 0, this), this.removeSourceTiles_ = s, this.wrappedTileCoord = r;
    }
    /**
     * @return {CanvasRenderingContext2D} The rendering context.
     */
    getContext() {
      return this.context_ || (this.context_ = Di(1, 1, WD)), this.context_;
    }
    /**
     * @return {boolean} Tile has a rendering context.
     */
    hasContext() {
      return !!this.context_;
    }
    /**
     * Get the Canvas for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */
    getImage() {
      return this.hasContext() ? this.getContext().canvas : null;
    }
    /**
     * @param {import("./layer/Layer.js").default} layer Layer.
     * @return {ReplayState} The replay state.
     */
    getReplayState(e) {
      const i = ve(e);
      return i in this.replayState_ || (this.replayState_[i] = {
        dirty: !1,
        renderedRenderOrder: null,
        renderedResolution: NaN,
        renderedRevision: -1,
        renderedTileResolution: NaN,
        renderedTileRevision: -1,
        renderedTileZ: -1
      }), this.replayState_[i];
    }
    /**
     * Load the tile.
     * @override
     */
    load() {
      this.getSourceTiles();
    }
    /**
     * Remove from the cache due to expiry
     * @override
     */
    release() {
      this.context_ && (uf(this.context_), WD.push(this.context_.canvas), this.context_ = null), this.removeSourceTiles_(this), this.sourceTiles.length = 0, super.release();
    }
  }
  let BL = class extends pf {
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Data source url.
     * @param {import("./format/Feature.js").default<FeatureType>} format Feature format.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [options] Tile options.
     */
    constructor(e, i, r, n, s, o) {
      super(e, i, o), this.extent = null, this.format_ = n, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = s, this.url_ = r, this.key = r;
    }
    /**
     * @return {string} Tile url.
     */
    getTileUrl() {
      return this.url_;
    }
    /**
     * Get the feature format assigned for reading this tile's features.
     * @return {import("./format/Feature.js").default<FeatureType>} Feature format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * Get the features for this tile. Geometries will be in the view projection.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeatures() {
      return this.features_;
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      this.state == pe.IDLE && (this.setState(pe.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
    }
    /**
     * Handler for successful tile load.
     * @param {Array<FeatureType>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data projection.
     */
    onLoad(e, i) {
      this.setFeatures(e);
    }
    /**
     * Handler for tile load errors.
     */
    onError() {
      this.setState(pe.ERROR);
    }
    /**
     * Function for use in a {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
     * Sets the features for the tile.
     * @param {Array<FeatureType>} features Features.
     * @api
     */
    setFeatures(e) {
      this.features_ = e, this.setState(pe.LOADED);
    }
    /**
     * Set the feature loader for reading this tile's features.
     * @param {import("./featureloader.js").FeatureLoader<FeatureType>} loader Feature loader.
     * @api
     */
    setLoader(e) {
      this.loader_ = e;
    }
  };
  var wL;
  (function() {
    var t = [255, 255, 255, 1], e = [0, 153, 255, 1], i = 3, r = [
      new hi({
        stroke: new pr({ color: t, width: i + 2 })
      }),
      new hi({
        image: new Sa({
          radius: i * 2,
          fill: new vr({ color: e }),
          stroke: new pr({ color: t, width: i / 2 })
        }),
        stroke: new pr({ color: e, width: i }),
        fill: new vr({
          color: [255, 255, 255, 0.5]
        })
      })
    ];
    wL = function(n) {
      if (n === !0)
        return r;
      n = n || {};
      var s = new vr({
        color: n.fillColor || "rgba(255,255,255,0.4)"
      }), o = new pr({
        color: n.color || "#3399CC",
        width: 1.25
      }), a = new hi({
        image: new Sa({
          fill: s,
          stroke: o,
          radius: 5
        }),
        fill: s,
        stroke: o
      });
      return [a];
    };
  })();
  const bie = wL;
  var CL = class extends cc {
    constructor(e) {
      e = e || {}, super({
        handleEvent: function(n) {
          return i.handleEvent_(n);
        }
      });
      var i = this;
      this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.maxCircleCoordinates_ = e.maxCircleCoordinates || 100, this.features_ = e.features, this.source_ = e.source, this.conditionFn_ = e.condition, this.squareFn_ = e.squareCondition, this.centeredFn_ = e.centerCondition, this.canRotate_ = e.canRotate !== !1, this.geometryName_ = e.geometryName || "geometry", this.setSides(e.sides);
      var r = bie(!0);
      this.sketch_ = new Bn(), this.overlayLayer_ = new Bs({
        source: new Do({
          features: this.sketch_,
          useSpatialIndex: !1
        }),
        name: "DrawRegular overlay",
        displayInLayerSwitcher: !1,
        style: e.style || r
      });
    }
    /**
     * Remove the interaction from its current map, if any,  and attach it to a new
     * map, if any. Pass `null` to just remove the interaction from the current map.
     * @param {ol.Map} map Map.
     * @api stable
     */
    setMap(e) {
      this.getMap() && this.getMap().removeLayer(this.overlayLayer_), super.setMap(e), this.overlayLayer_.setMap(e);
    }
    /**
     * Activate/deactivate the interaction
     * @param {boolean}
     * @api stable
     */
    setActive(e) {
      this.reset(), super.setActive(e);
    }
    /**
     * Reset the interaction
     * @api stable
     */
    reset() {
      this.overlayLayer_ && this.overlayLayer_.getSource().clear(), this.started_ = !1;
    }
    /**
     * Set the number of sides.
     * @param {int} number of sides.
     * @api stable
     */
    setSides(e) {
      e = parseInt(e), this.sides_ = e > 2 ? e : 0;
    }
    /**
     * Allow rotation when centered + square
     * @param {bool}
     * @api stable
     */
    canRotate(e) {
      return (e === !0 || e === !1) && (this.canRotate_ = e), this.canRotate_;
    }
    /**
     * Get the number of sides.
     * @return {int} number of sides.
     * @api stable
     */
    getSides() {
      return this.sides_;
    }
    /** Get geom of the current drawing
    * @return {ol.geom.Polygon | ol.geom.Point}
    */
    getGeom_() {
      if (this.overlayLayer_.getSource().clear(), !this.center_)
        return !1;
      var e;
      if (this.coord_) {
        var i = this.center_, r = this.coord_, n, s, o, a, A;
        if (!this.sides_ && this.square_ && !this.centered_)
          return i = [(r[0] + i[0]) / 2, (r[1] + i[1]) / 2], n = [r[0] - i[0], r[1] - i[1]], o = Math.sqrt(n[0] * n[0] + n[1] * n[1]), a = new od(i, o, "XY"), A = this.getMap().getPixelFromCoordinate(i), s = Math.max(100, Math.abs(A[0] - this.coordPx_[0]), Math.abs(A[1] - this.coordPx_[1])), s = Math.min(this.maxCircleCoordinates_, Math.round(s / 3)), nm(a, s, 0);
        var l = this.canRotate_ && this.centered_ && this.square_;
        if (n = [r[0] - i[0], r[1] - i[1]], this.square_ && !l) {
          var c = Math.max(Math.abs(n[0]), Math.abs(n[1]));
          r = [
            i[0] + (n[0] > 0 ? c : -c),
            i[1] + (n[1] > 0 ? c : -c)
          ];
        }
        if (o = Math.sqrt(n[0] * n[0] + n[1] * n[1]), o > 0) {
          a = new od(i, o, "XY");
          var u;
          if (l ? u = Math.atan2(n[1], n[0]) : u = this.startAngle[this.sides_] || this.startAngle.default, this.sides_ ? e = nm(a, this.sides_, u) : (A = this.getMap().getPixelFromCoordinate(this.center_), s = Math.max(100, Math.abs(A[0] - this.coordPx_[0]), Math.abs(A[1] - this.coordPx_[1])), s = Math.min(this.maxCircleCoordinates_, Math.round(s / (this.centered_ ? 3 : 5))), e = nm(a, s, 0)), l)
            return e;
          var d = e.getExtent();
          this.centered_ ? i = [2 * this.center_[0] - this.coord_[0], 2 * this.center_[1] - this.coord_[1]] : i = this.center_;
          var h = (i[0] - r[0]) / (d[0] - d[2]), g = (i[1] - r[1]) / (d[1] - d[3]);
          if (this.square_) {
            var f = Math.min(Math.abs(h), Math.abs(g));
            h = Math.sign(h) * f, g = Math.sign(g) * f;
          }
          var p = [i[0] - d[0] * h, i[1] - d[1] * g];
          return e.applyTransform(function(m, E, y) {
            for (var C = 0; C < m.length; C += y)
              E[C] = m[C] * h + p[0], E[C + 1] = m[C + 1] * g + p[1];
            return E;
          }), e;
        }
      }
      return new Cn(this.center_);
    }
    /** Draw sketch
    * @return {ol.Feature} The feature being drawn.
    */
    drawSketch_(e) {
      if (this.overlayLayer_.getSource().clear(), e) {
        this.square_ = this.squareFn_ ? this.squareFn_(e) : e.originalEvent.shiftKey, this.centered_ = this.centeredFn_ ? this.centeredFn_(e) : e.originalEvent.metaKey || e.originalEvent.ctrlKey;
        var i = this.getGeom_();
        if (i) {
          var r = this.feature_;
          return i.getType() === "Polygon" && r.getGeometry().setCoordinates(i.getCoordinates()), this.overlayLayer_.getSource().addFeature(r), this.coord_ && this.square_ && (this.canRotate_ && this.centered_ && this.coord_ || !this.sides_ && !this.centered_) && this.overlayLayer_.getSource().addFeature(new hr(new bn([this.center_, this.coord_]))), r;
        }
      }
    }
    /** Draw sketch (Point)
    */
    drawPoint_(e, i) {
      i || this.overlayLayer_.getSource().clear(), this.overlayLayer_.getSource().addFeature(new hr(new Cn(e)));
    }
    /**
     * @param {ol.MapBrowserEvent} evt Map browser event.
     */
    handleEvent_(e) {
      var i, r;
      switch (this._eventTime = /* @__PURE__ */ new Date(), e.type) {
        case "pointerdown": {
          if (this.conditionFn_ && !this.conditionFn_(e)) break;
          this.downPx_ = e.pixel, this.start_(e);
          var n = 500;
          this._longTouch = !1, setTimeout((function() {
            this._longTouch = /* @__PURE__ */ new Date() - this._eventTime > 0.9 * n, this._longTouch && this.handleMoveEvent_(e);
          }).bind(this), n), this.lastEvent = e.type;
          break;
        }
        case "pointerup": {
          this.started_ && this.coord_ && (i = this.downPx_[0] - e.pixel[0], r = this.downPx_[1] - e.pixel[1], i * i + r * r <= this.squaredClickTolerance_ && (this.lastEvent == "pointerdown" || this.lastEvent == "pointermove" || this.lastEvent == "keydown" ? this.end_(e) : (i = this.upPx_[0] - e.pixel[0], r = this.upPx_[1] - e.pixel[1], i * i + r * r <= this.squaredClickTolerance_ ? this.end_(e) : (this.handleMoveEvent_(e), this.drawPoint_(e.coordinate, !0))))), this.upPx_ = e.pixel;
          break;
        }
        case "pointerdrag": {
          if (this.started_) {
            var s = this.getMap().getPixelFromCoordinate(this.center_);
            i = s[0] - e.pixel[0], r = s[1] - e.pixel[1], i * i + r * r <= this.squaredClickTolerance_ && this.reset();
          }
          return !this._longTouch;
        }
        case "pointermove": {
          this.started_ ? (i = this.downPx_[0] - e.pixel[0], r = this.downPx_[1] - e.pixel[1], i * i + r * r > this.squaredClickTolerance_ && (this.handleMoveEvent_(e), this.lastEvent = e.type)) : this.drawPoint_(e.coordinate);
          break;
        }
        default: {
          if (this.started_ && (e.type === "click" || e.type === "singleclick" || e.type === "dblclick"))
            return !1;
          this.lastEvent = e.type;
          break;
        }
      }
      return !0;
    }
    /** Stop drawing.
     */
    finishDrawing() {
      this.started_ && this.coord_ && this.end_({ pixel: this.upPx_, coordinate: this.coord_ });
    }
    /**
     * @param {ol.MapBrowserEvent} evt Event.
     */
    handleMoveEvent_(e) {
      if (this.started_) {
        this.coord_ = e.coordinate, this.coordPx_ = e.pixel;
        var i = this.drawSketch_(e);
        this.dispatchEvent({
          type: "drawing",
          feature: i,
          pixel: e.pixel,
          startCoordinate: this.center_,
          coordinate: e.coordinate,
          square: this.square_,
          centered: this.centered_
        });
      } else
        this.drawPoint_(e.coordinate);
    }
    /** Start an new draw
     * @param {ol.MapBrowserEvent} evt Map browser event.
     * @return {boolean} `false` to stop the drag sequence.
     */
    start_(e) {
      if (this.started_)
        this.coord_ = e.coordinate;
      else {
        this.started_ = !0, this.center_ = e.coordinate, this.coord_ = null;
        var i = this.feature_ = new hr({});
        i.setGeometryName(this.geometryName_ || "geometry"), i.setGeometry(new en([[e.coordinate, e.coordinate, e.coordinate]])), this.drawSketch_(e), this.dispatchEvent({ type: "drawstart", feature: i, pixel: e.pixel, coordinate: e.coordinate });
      }
    }
    /** End drawing
     * @param {ol.MapBrowserEvent} evt Map browser event.
     * @return {boolean} `false` to stop the drag sequence.
     */
    end_(e) {
      if (this.coord_ = e.coordinate, this.started_ = !1, this.coord_ && (this.center_[0] !== this.coord_[0] || this.center_[1] !== this.coord_[1])) {
        var i = this.feature_;
        i.setGeometry(this.getGeom_()), this.source_ ? this.source_.addFeature(i) : this.features_ && this.features_.push(i), this.dispatchEvent({ type: "drawend", feature: i, pixel: e.pixel, coordinate: e.coordinate, square: this.square_, centered: this.centered_ });
      } else
        this.dispatchEvent({ type: "drawcancel", feature: null, pixel: e.pixel, coordinate: e.coordinate, square: this.square_, centered: this.centered_ });
      this.center_ = this.coord_ = null, this.drawSketch_();
    }
  };
  CL.prototype.startAngle = {
    default: Math.PI / 2,
    3: -Math.PI / 2,
    4: Math.PI / 4
  };
  const cp = {
    /**
     * Triggered upon feature draw start
     * @event DrawEvent#drawstart
     * @api
     */
    DRAWSTART: "drawstart",
    /**
     * Triggered upon feature draw end
     * @event DrawEvent#drawend
     * @api
     */
    DRAWEND: "drawend",
    /**
     * Triggered upon feature draw abortion
     * @event DrawEvent#drawabort
     * @api
     */
    DRAWABORT: "drawabort"
  };
  class up extends on {
    /**
     * @param {DrawEventType} type Type.
     * @param {Feature} feature The feature drawn.
     */
    constructor(e, i) {
      super(e), this.feature = i;
    }
  }
  function Mie(t, e) {
    const i = [];
    for (let r = 0; r < e.length; ++r) {
      const s = e[r].getGeometry();
      bL(t, s, i);
    }
    return i;
  }
  function dp(t, e) {
    return fa(t[0], t[1], e[0], e[1]);
  }
  function hu(t, e) {
    const i = t.length;
    return e < 0 ? t[e + i] : e >= i ? t[e - i] : t[e];
  }
  function hp(t, e, i) {
    let r, n;
    e < i ? (r = e, n = i) : (r = i, n = e);
    const s = Math.ceil(r), o = Math.floor(n);
    if (s > o) {
      const A = gu(t, r), l = gu(t, n);
      return dp(A, l);
    }
    let a = 0;
    if (r < s) {
      const A = gu(t, r), l = hu(t, s);
      a += dp(A, l);
    }
    if (o < n) {
      const A = hu(t, o), l = gu(t, n);
      a += dp(A, l);
    }
    for (let A = s; A < o - 1; ++A) {
      const l = hu(t, A), c = hu(t, A + 1);
      a += dp(l, c);
    }
    return a;
  }
  function bL(t, e, i) {
    if (e instanceof bn) {
      gp(t, e.getCoordinates(), !1, i);
      return;
    }
    if (e instanceof Da) {
      const r = e.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n)
        gp(t, r[n], !1, i);
      return;
    }
    if (e instanceof en) {
      const r = e.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n)
        gp(t, r[n], !0, i);
      return;
    }
    if (e instanceof Ta) {
      const r = e.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n];
        for (let a = 0, A = o.length; a < A; ++a)
          gp(t, o[a], !0, i);
      }
      return;
    }
    if (e instanceof Eg) {
      const r = e.getGeometries();
      for (let n = 0; n < r.length; ++n)
        bL(t, r[n], i);
      return;
    }
  }
  const T0 = { index: -1, endIndex: NaN };
  function Iie(t, e, i, r) {
    const n = t[0], s = t[1];
    let o = 1 / 0, a = -1, A = NaN;
    for (let u = 0; u < e.targets.length; ++u) {
      const d = e.targets[u], h = d.coordinates;
      let g = 1 / 0, f;
      for (let p = 0; p < h.length - 1; ++p) {
        const m = h[p], E = h[p + 1], y = ML(n, s, m, E);
        y.squaredDistance < g && (g = y.squaredDistance, f = p + y.along);
      }
      g < o && (o = g, d.ring && e.targetIndex === u && (d.endIndex > d.startIndex ? f < d.startIndex && (f += h.length) : d.endIndex < d.startIndex && f > d.startIndex && (f -= h.length)), A = f, a = u);
    }
    const l = e.targets[a];
    let c = l.ring;
    if (e.targetIndex === a && c) {
      const u = gu(
        l.coordinates,
        A
      ), d = i.getPixelFromCoordinate(u);
      pE(d, e.startPx) > r && (c = !1);
    }
    if (c) {
      const u = l.coordinates, d = u.length, h = l.startIndex, g = A;
      if (h < g) {
        const f = hp(
          u,
          h,
          g
        );
        hp(
          u,
          h,
          g - d
        ) < f && (A -= d);
      } else {
        const f = hp(
          u,
          h,
          g
        );
        hp(
          u,
          h,
          g + d
        ) < f && (A += d);
      }
    }
    return T0.index = a, T0.endIndex = A, T0;
  }
  function gp(t, e, i, r) {
    const n = t[0], s = t[1];
    for (let o = 0, a = e.length - 1; o < a; ++o) {
      const A = e[o], l = e[o + 1], c = ML(n, s, A, l);
      if (c.squaredDistance === 0) {
        const u = o + c.along;
        r.push({
          coordinates: e,
          ring: i,
          startIndex: u,
          endIndex: u
        });
        return;
      }
    }
  }
  const R0 = { along: 0, squaredDistance: 0 };
  function ML(t, e, i, r) {
    const n = i[0], s = i[1], o = r[0], a = r[1], A = o - n, l = a - s;
    let c = 0, u = n, d = s;
    return (A !== 0 || l !== 0) && (c = yi(((t - n) * A + (e - s) * l) / (A * A + l * l), 0, 1), u += A * c, d += l * c), R0.along = c, R0.squaredDistance = af(fa(t, e, u, d), 10), R0;
  }
  function gu(t, e) {
    const i = t.length;
    let r = Math.floor(e);
    const n = e - r;
    r >= i ? r -= i : r < 0 && (r += i);
    let s = r + 1;
    s >= i && (s -= i);
    const o = t[r], a = o[0], A = o[1], l = t[s], c = l[0] - a, u = l[1] - A;
    return [a + c * n, A + u * n];
  }
  class KD extends JA {
    /**
     * @param {Options} options Options.
     */
    constructor(e) {
      const i = (
        /** @type {import("./Pointer.js").Options} */
        e
      );
      i.stopDown || (i.stopDown = rc), super(i), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = e.source ? e.source : null, this.features_ = e.features ? e.features : null, this.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
      e.type, this.mode_ = xie(this.type_), this.stopClick_ = !!e.stopClick, this.minPoints_ = e.minPoints ? e.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : e.maxPoints ? e.maxPoints : 1 / 0, this.finishCondition_ = e.finishCondition ? e.finishCondition : Qa, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
      let r = e.geometryFunction;
      if (!r) {
        const n = this.mode_;
        if (n === "Circle")
          r = (s, o, a) => {
            const A = o || new od([NaN, NaN]), l = di(s[0]), c = ma(
              l,
              di(s[s.length - 1])
            );
            return A.setCenterAndRadius(
              l,
              Math.sqrt(c),
              this.geometryLayout_
            ), A;
          };
        else {
          let s;
          n === "Point" ? s = Cn : n === "LineString" ? s = bn : n === "Polygon" && (s = en), r = (o, a, A) => (a ? n === "Polygon" ? o[0].length ? a.setCoordinates(
            [o[0].concat([o[0][0]])],
            this.geometryLayout_
          ) : a.setCoordinates([], this.geometryLayout_) : a.setCoordinates(o, this.geometryLayout_) : a = new s(o, this.geometryLayout_), a);
        }
      }
      this.geometryFunction_ = r, this.dragVertexDelay_ = e.dragVertexDelay !== void 0 ? e.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.overlay_ = new Bs({
        source: new Do({
          useSpatialIndex: !1,
          wrapX: e.wrapX ? e.wrapX : !1
        }),
        style: e.style ? e.style : vie(),
        updateWhileInteracting: !0
      }), this.geometryName_ = e.geometryName, this.condition_ = e.condition ? e.condition : sx, this.freehandCondition_, e.freehand ? this.freehandCondition_ = RE : this.freehandCondition_ = e.freehandCondition ? e.freehandCondition : ox, this.traceCondition_, this.setTrace(e.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = e.traceSource || e.source || null, this.addChangeListener(bb.ACTIVE, this.updateState_);
    }
    /**
     * Toggle tracing mode or set a tracing condition.
     *
     * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
     *     condition that will be checked when a feature is clicked to determine if tracing should be active.
     */
    setTrace(e) {
      let i;
      e ? e === !0 ? i = RE : i = e : i = Ib, this.traceCondition_ = i;
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    setMap(e) {
      super.setMap(e), this.updateState_();
    }
    /**
     * Get the overlay layer that this interaction renders sketch features to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */
    getOverlay() {
      return this.overlay_;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
     * @param {import("../MapBrowserEvent.js").default} event Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     * @override
     */
    handleEvent(e) {
      e.originalEvent.type === Ge.CONTEXTMENU && e.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(e);
      let i = e.type === Yt.POINTERMOVE, r = !0;
      return !this.freehand_ && this.lastDragTime_ && e.type === Yt.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, i = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && e.type === Yt.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(e.coordinate), r = !1) : this.freehand_ && e.type === Yt.POINTERDOWN ? r = !1 : i && this.getPointerCount() < 2 ? (r = e.type === Yt.POINTERMOVE, r && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.originalEvent.preventDefault()) : (e.originalEvent.pointerType === "mouse" || e.type === Yt.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(e)) : e.type === Yt.DBLCLICK && (r = !1), super.handleEvent(e) && r;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(e) {
      return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = e.pixel, this.finishCoordinate_ || this.startDrawing_(e.coordinate), !0) : this.condition_(e) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
        this.handlePointerMove_(
          new qo(
            Yt.POINTERMOVE,
            e.map,
            e.originalEvent,
            !1,
            e.frameState
          )
        );
      }, this.dragVertexDelay_), this.downPx_ = e.pixel, !0) : (this.lastDragTime_ = void 0, !1);
    }
    /**
     * @private
     */
    deactivateTrace_() {
      this.traceState_ = { active: !1 };
    }
    /**
     * Activate or deactivate trace state based on a browser event.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @private
     */
    toggleTraceState_(e) {
      if (!this.traceSource_ || !this.traceCondition_(e))
        return;
      if (this.traceState_.active) {
        this.deactivateTrace_();
        return;
      }
      const i = this.getMap(), r = i.getCoordinateFromPixel([
        e.pixel[0] - this.snapTolerance_,
        e.pixel[1] + this.snapTolerance_
      ]), n = i.getCoordinateFromPixel([
        e.pixel[0] + this.snapTolerance_,
        e.pixel[1] - this.snapTolerance_
      ]), s = $i([r, n]), o = this.traceSource_.getFeaturesInExtent(s);
      if (o.length === 0)
        return;
      const a = Mie(e.coordinate, o);
      a.length && (this.traceState_ = {
        active: !0,
        startPx: e.pixel.slice(),
        targets: a,
        targetIndex: -1
      });
    }
    /**
     * @param {TraceTarget} target The trace target.
     * @param {number} endIndex The new end index of the trace.
     * @private
     */
    addOrRemoveTracedCoordinates_(e, i) {
      const r = e.startIndex <= e.endIndex, n = e.startIndex <= i;
      r === n ? r && i > e.endIndex || !r && i < e.endIndex ? this.addTracedCoordinates_(e, e.endIndex, i) : (r && i < e.endIndex || !r && i > e.endIndex) && this.removeTracedCoordinates_(i, e.endIndex) : (this.removeTracedCoordinates_(e.startIndex, e.endIndex), this.addTracedCoordinates_(e, e.startIndex, i));
    }
    /**
     * @param {number} fromIndex The start index.
     * @param {number} toIndex The end index.
     * @private
     */
    removeTracedCoordinates_(e, i) {
      if (e === i)
        return;
      let r = 0;
      if (e < i) {
        const n = Math.ceil(e);
        let s = Math.floor(i);
        s === i && (s -= 1), r = s - n + 1;
      } else {
        const n = Math.floor(e);
        let s = Math.ceil(i);
        s === i && (s += 1), r = n - s + 1;
      }
      r > 0 && this.removeLastPoints_(r);
    }
    /**
     * @param {TraceTarget} target The trace target.
     * @param {number} fromIndex The start index.
     * @param {number} toIndex The end index.
     * @private
     */
    addTracedCoordinates_(e, i, r) {
      if (i === r)
        return;
      const n = [];
      if (i < r) {
        const s = Math.ceil(i);
        let o = Math.floor(r);
        o === r && (o -= 1);
        for (let a = s; a <= o; ++a)
          n.push(hu(e.coordinates, a));
      } else {
        const s = Math.floor(i);
        let o = Math.ceil(r);
        o === r && (o += 1);
        for (let a = s; a >= o; --a)
          n.push(hu(e.coordinates, a));
      }
      n.length && this.appendCoordinates(n);
    }
    /**
     * Update the trace.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @private
     */
    updateTrace_(e) {
      const i = this.traceState_;
      if (!i.active || i.targetIndex === -1 && pE(i.startPx, e.pixel) < this.snapTolerance_)
        return;
      const r = Iie(
        e.coordinate,
        i,
        this.getMap(),
        this.snapTolerance_
      );
      if (i.targetIndex !== r.index) {
        if (i.targetIndex !== -1) {
          const A = i.targets[i.targetIndex];
          this.removeTracedCoordinates_(A.startIndex, A.endIndex);
        }
        const a = i.targets[r.index];
        this.addTracedCoordinates_(
          a,
          a.startIndex,
          r.endIndex
        );
      } else {
        const a = i.targets[i.targetIndex];
        this.addOrRemoveTracedCoordinates_(a, r.endIndex);
      }
      i.targetIndex = r.index;
      const n = i.targets[i.targetIndex];
      n.endIndex = r.endIndex;
      const s = gu(
        n.coordinates,
        n.endIndex
      ), o = this.getMap().getPixelFromCoordinate(s);
      e.coordinate = s, e.pixel = [Math.round(o[0]), Math.round(o[1])];
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      let i = !0;
      if (this.getPointerCount() === 0) {
        this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(e);
        const r = this.traceState_.active;
        if (this.toggleTraceState_(e), this.shouldHandle_) {
          const n = !this.finishCoordinate_;
          n && this.startDrawing_(e.coordinate), !n && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!n || this.mode_ === "Point") && (this.atFinish_(e.pixel, r) ? this.finishCondition_(e) && this.finishDrawing() : this.addToDrawing_(e.coordinate)), i = !1;
        } else this.freehand_ && this.abortDrawing();
      }
      return !i && this.stopClick_ && e.preventDefault(), i;
    }
    /**
     * Handle move events.
     * @param {import("../MapBrowserEvent.js").default} event A move event.
     * @private
     */
    handlePointerMove_(e) {
      if (this.pointerType_ = e.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
        const i = this.downPx_, r = e.pixel, n = i[0] - r[0], s = i[1] - r[1], o = n * n + s * s;
        if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_)
          return;
      }
      if (!this.finishCoordinate_) {
        this.createOrUpdateSketchPoint_(e.coordinate.slice());
        return;
      }
      this.updateTrace_(e), this.modifyDrawing_(e.coordinate);
    }
    /**
     * Determine if an event is within the snapping tolerance of the start coord.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
     * @return {boolean} The event is within the snapping tolerance of the start.
     * @private
     */
    atFinish_(e, i) {
      let r = !1;
      if (this.sketchFeature_) {
        let n = !1, s = [this.finishCoordinate_];
        const o = this.mode_;
        if (o === "Point")
          r = !0;
        else if (o === "Circle")
          r = this.sketchCoords_.length === 2;
        else if (o === "LineString")
          n = !i && this.sketchCoords_.length > this.minPoints_;
        else if (o === "Polygon") {
          const a = (
            /** @type {PolyCoordType} */
            this.sketchCoords_
          );
          n = a[0].length > this.minPoints_, s = [
            a[0][0],
            a[0][a[0].length - 2]
          ], i ? s = [a[0][0]] : s = [
            a[0][0],
            a[0][a[0].length - 2]
          ];
        }
        if (n) {
          const a = this.getMap();
          for (let A = 0, l = s.length; A < l; A++) {
            const c = s[A], u = a.getPixelFromCoordinate(c), d = e[0] - u[0], h = e[1] - u[1], g = this.freehand_ ? 1 : this.snapTolerance_;
            if (r = Math.sqrt(d * d + h * h) <= g, r) {
              this.finishCoordinate_ = c;
              break;
            }
          }
        }
      }
      return r;
    }
    /**
     * @param {import("../coordinate").Coordinate} coordinates Coordinate.
     * @private
     */
    createOrUpdateSketchPoint_(e) {
      this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new hr(new Cn(e)), this.updateSketchFeatures_());
    }
    /**
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @private
     */
    createOrUpdateCustomSketchLine_(e) {
      this.sketchLine_ || (this.sketchLine_ = new hr());
      const i = e.getLinearRing(0);
      let r = this.sketchLine_.getGeometry();
      r ? (r.setFlatCoordinates(
        i.getLayout(),
        i.getFlatCoordinates()
      ), r.changed()) : (r = new bn(
        i.getFlatCoordinates(),
        i.getLayout()
      ), this.sketchLine_.setGeometry(r));
    }
    /**
     * Start the drawing.
     * @param {import("../coordinate.js").Coordinate} start Start coordinate.
     * @private
     */
    startDrawing_(e) {
      const i = this.getMap().getView().getProjection(), r = BE(this.geometryLayout_);
      for (; e.length < r; )
        e.push(0);
      this.finishCoordinate_ = e, this.mode_ === "Point" ? this.sketchCoords_ = e.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new hr(new bn(this.sketchLineCoords_)));
      const n = this.geometryFunction_(
        this.sketchCoords_,
        void 0,
        i
      );
      this.sketchFeature_ = new hr(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(n), this.updateSketchFeatures_(), this.dispatchEvent(
        new up(cp.DRAWSTART, this.sketchFeature_)
      );
    }
    /**
     * Modify the drawing.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @private
     */
    modifyDrawing_(e) {
      const i = this.getMap(), r = this.sketchFeature_.getGeometry(), n = i.getView().getProjection(), s = BE(this.geometryLayout_);
      let o, a;
      for (; e.length < s; )
        e.push(0);
      this.mode_ === "Point" ? a = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = /** @type {PolyCoordType} */
      this.sketchCoords_[0], a = o[o.length - 1], this.atFinish_(i.getPixelFromCoordinate(e)) && (e = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, a = o[o.length - 1]), a[0] = e[0], a[1] = e[1], this.geometryFunction_(
        /** @type {!LineCoordType} */
        this.sketchCoords_,
        r,
        n
      ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(e), r.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
        /** @type {Polygon} */
        r
      ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
    }
    /**
     * Add a new coordinate to the drawing.
     * @param {!PointCoordType} coordinate Coordinate
     * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
     * @private
     */
    addToDrawing_(e) {
      const i = this.sketchFeature_.getGeometry(), r = this.getMap().getView().getProjection();
      let n, s;
      const o = this.mode_;
      return o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = e.slice(), s = /** @type {LineCoordType} */
      this.sketchCoords_, s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : n = !0), s.push(e.slice()), this.geometryFunction_(s, i, r)) : o === "Polygon" && (s = /** @type {PolyCoordType} */
      this.sketchCoords_[0], s.length >= this.maxPoints_ && (this.freehand_ ? s.pop() : n = !0), s.push(e.slice()), n && (this.finishCoordinate_ = s[0]), this.geometryFunction_(this.sketchCoords_, i, r)), this.createOrUpdateSketchPoint_(e.slice()), this.updateSketchFeatures_(), n ? this.finishDrawing() : this.sketchFeature_;
    }
    /**
     * @param {number} n The number of points to remove.
     */
    removeLastPoints_(e) {
      if (!this.sketchFeature_)
        return;
      const i = this.sketchFeature_.getGeometry(), r = this.getMap().getView().getProjection(), n = this.mode_;
      for (let s = 0; s < e; ++s) {
        let o;
        if (n === "LineString" || n === "Circle") {
          if (o = /** @type {LineCoordType} */
          this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
            this.finishCoordinate_ = o[o.length - 2].slice();
            const a = this.finishCoordinate_.slice();
            o[o.length - 1] = a, this.createOrUpdateSketchPoint_(a);
          }
          this.geometryFunction_(o, i, r), i.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
            /** @type {Polygon} */
            i
          );
        } else if (n === "Polygon") {
          o = /** @type {PolyCoordType} */
          this.sketchCoords_[0], o.splice(-2, 1);
          const a = this.sketchLine_.getGeometry();
          if (o.length >= 2) {
            const A = o[o.length - 2].slice();
            o[o.length - 1] = A, this.createOrUpdateSketchPoint_(A);
          }
          a.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, i, r);
        }
        if (o.length === 1) {
          this.abortDrawing();
          break;
        }
      }
      this.updateSketchFeatures_();
    }
    /**
     * Remove last point of the feature currently being drawn. Does not do anything when
     * drawing POINT or MULTI_POINT geometries.
     * @api
     */
    removeLastPoint() {
      this.removeLastPoints_(1);
    }
    /**
     * Stop drawing and add the sketch feature to the target layer.
     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
     * dispatched before inserting the feature.
     * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
     * @api
     */
    finishDrawing() {
      const e = this.abortDrawing_();
      if (!e)
        return null;
      let i = this.sketchCoords_;
      const r = e.getGeometry(), n = this.getMap().getView().getProjection();
      return this.mode_ === "LineString" ? (i.pop(), this.geometryFunction_(i, r, n)) : this.mode_ === "Polygon" && (i[0].pop(), this.geometryFunction_(i, r, n), i = r.getCoordinates()), this.type_ === "MultiPoint" ? e.setGeometry(
        new lc([
          /** @type {PointCoordType} */
          i
        ])
      ) : this.type_ === "MultiLineString" ? e.setGeometry(
        new Da([
          /** @type {LineCoordType} */
          i
        ])
      ) : this.type_ === "MultiPolygon" && e.setGeometry(
        new Ta([
          /** @type {PolyCoordType} */
          i
        ])
      ), this.dispatchEvent(new up(cp.DRAWEND, e)), this.features_ && this.features_.push(e), this.source_ && this.source_.addFeature(e), e;
    }
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
     * @private
     */
    abortDrawing_() {
      this.finishCoordinate_ = null;
      const e = this.sketchFeature_;
      return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), e;
    }
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @api
     */
    abortDrawing() {
      const e = this.abortDrawing_();
      e && this.dispatchEvent(new up(cp.DRAWABORT, e));
    }
    /**
     * Append coordinates to the end of the geometry that is currently being drawn.
     * This can be used when drawing LineStrings or Polygons. Coordinates will
     * either be appended to the current LineString or the outer ring of the current
     * Polygon. If no geometry is being drawn, a new one will be created.
     * @param {!LineCoordType} coordinates Linear coordinates to be appended to
     * the coordinate array.
     * @api
     */
    appendCoordinates(e) {
      const i = this.mode_, r = !this.sketchFeature_;
      r && this.startDrawing_(e[0]);
      let n;
      if (i === "LineString" || i === "Circle")
        n = /** @type {LineCoordType} */
        this.sketchCoords_;
      else if (i === "Polygon")
        n = this.sketchCoords_ && this.sketchCoords_.length ? (
          /** @type {PolyCoordType} */
          this.sketchCoords_[0]
        ) : [];
      else
        return;
      r && n.shift(), n.pop();
      for (let o = 0; o < e.length; o++)
        this.addToDrawing_(e[o]);
      const s = e[e.length - 1];
      this.sketchFeature_ = this.addToDrawing_(s), this.modifyDrawing_(s);
    }
    /**
     * Initiate draw mode by starting from an existing geometry which will
     * receive new additional points. This only works on features with
     * `LineString` geometries, where the interaction will extend lines by adding
     * points to the end of the coordinates array.
     * This will change the original feature, instead of drawing a copy.
     *
     * The function will dispatch a `drawstart` event.
     *
     * @param {!Feature<LineString>} feature Feature to be extended.
     * @api
     */
    extend(e) {
      const r = e.getGeometry();
      this.sketchFeature_ = e, this.sketchCoords_ = r.getCoordinates();
      const n = this.sketchCoords_[this.sketchCoords_.length - 1];
      this.finishCoordinate_ = n.slice(), this.sketchCoords_.push(n.slice()), this.sketchPoint_ = new hr(new Cn(n)), this.updateSketchFeatures_(), this.dispatchEvent(
        new up(cp.DRAWSTART, this.sketchFeature_)
      );
    }
    /**
     * Redraw the sketch features.
     * @private
     */
    updateSketchFeatures_() {
      const e = [];
      this.sketchFeature_ && e.push(this.sketchFeature_), this.sketchLine_ && e.push(this.sketchLine_), this.sketchPoint_ && e.push(this.sketchPoint_);
      const i = this.overlay_.getSource();
      i.clear(!0), i.addFeatures(e);
    }
    /**
     * @private
     */
    updateState_() {
      const e = this.getMap(), i = this.getActive();
      (!e || !i) && this.abortDrawing(), this.overlay_.setMap(i ? e : null);
    }
  }
  function vie() {
    const t = jv();
    return function(e, i) {
      return t[e.getGeometry().getType()];
    };
  }
  function xie(t) {
    switch (t) {
      case "Point":
      case "MultiPoint":
        return "Point";
      case "LineString":
      case "MultiLineString":
        return "LineString";
      case "Polygon":
      case "MultiPolygon":
        return "Polygon";
      case "Circle":
        return "Circle";
      default:
        throw new Error("Invalid type: " + t);
    }
  }
  const XD = 0, zh = 1, ZD = [0, 0, 0, 0], Tu = [], _0 = {
    /**
     * Triggered upon feature modification start
     * @event ModifyEvent#modifystart
     * @api
     */
    MODIFYSTART: "modifystart",
    /**
     * Triggered upon feature modification end
     * @event ModifyEvent#modifyend
     * @api
     */
    MODIFYEND: "modifyend"
  };
  class k0 extends on {
    /**
     * @param {ModifyEventType} type Type.
     * @param {Collection<Feature>} features
     * The features modified.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     */
    constructor(e, i, r) {
      super(e), this.features = i, this.mapBrowserEvent = r;
    }
  }
  class Qie extends JA {
    /**
     * @param {Options} options Options.
     */
    constructor(e) {
      super(
        /** @type {import("./Pointer.js").Options} */
        e
      ), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = e.condition ? e.condition : uL, this.defaultDeleteCondition_ = function(r) {
        return oie(r) && AL(r);
      }, this.deleteCondition_ = e.deleteCondition ? e.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : RE, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new DE(), this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new Bs({
        source: new Do({
          useSpatialIndex: !1,
          wrapX: !!e.wrapX
        }),
        style: e.style ? e.style : Sie(),
        updateWhileAnimating: !0,
        updateWhileInteracting: !0
      }), this.SEGMENT_WRITERS_ = {
        Point: this.writePointGeometry_.bind(this),
        LineString: this.writeLineStringGeometry_.bind(this),
        LinearRing: this.writeLineStringGeometry_.bind(this),
        Polygon: this.writePolygonGeometry_.bind(this),
        MultiPoint: this.writeMultiPointGeometry_.bind(this),
        MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
        MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
        Circle: this.writeCircleGeometry_.bind(this),
        GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
      }, this.source_ = null, this.hitDetection_ = null;
      let i;
      if (e.features ? i = e.features : e.source && (this.source_ = e.source, i = new Bn(this.source_.getFeatures()), this.source_.addEventListener(
        Ii.ADDFEATURE,
        this.handleSourceAdd_.bind(this)
      ), this.source_.addEventListener(
        Ii.REMOVEFEATURE,
        this.handleSourceRemove_.bind(this)
      )), !i)
        throw new Error(
          "The modify interaction requires features, a source or a layer"
        );
      e.hitDetection && (this.hitDetection_ = e.hitDetection), this.features_ = i, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(
        Ui.ADD,
        this.handleFeatureAdd_.bind(this)
      ), this.features_.addEventListener(
        Ui.REMOVE,
        this.handleFeatureRemove_.bind(this)
      ), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = e.snapToPointer === void 0 ? !this.hitDetection_ : e.snapToPointer;
    }
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    addFeature_(e) {
      const i = e.getGeometry();
      if (i) {
        const n = this.SEGMENT_WRITERS_[i.getType()];
        n && n(e, i);
      }
      const r = this.getMap();
      r && r.isRendered() && this.getActive() && this.handlePointerAtPixel_(r.getCoordinateFromPixel(this.lastPixel_)), e.addEventListener(Ge.CHANGE, this.boundHandleFeatureChange_);
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
     * @param {Array<SegmentData>} segments The segments subject to modification.
     * @private
     */
    willModifyFeatures_(e, i) {
      if (!this.featuresBeingModified_) {
        this.featuresBeingModified_ = new Bn();
        const r = this.featuresBeingModified_.getArray();
        for (let n = 0, s = i.length; n < s; ++n) {
          const o = i[n].feature;
          o && !r.includes(o) && this.featuresBeingModified_.push(o);
        }
        this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(
          new k0(
            _0.MODIFYSTART,
            this.featuresBeingModified_,
            e
          )
        );
      }
    }
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    removeFeature_(e) {
      this.removeFeatureSegmentData_(e), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.removeEventListener(
        Ge.CHANGE,
        this.boundHandleFeatureChange_
      );
    }
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    removeFeatureSegmentData_(e) {
      const i = this.rBush_, r = [];
      i.forEach(
        /**
         * @param {SegmentData} node RTree node.
         */
        function(n) {
          e === n.feature && r.push(n);
        }
      );
      for (let n = r.length - 1; n >= 0; --n) {
        const s = r[n];
        for (let o = this.dragSegments_.length - 1; o >= 0; --o)
          this.dragSegments_[o][0] === s && this.dragSegments_.splice(o, 1);
        i.remove(s);
      }
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     * @override
     */
    setActive(e) {
      this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(e);
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    setMap(e) {
      this.overlay_.setMap(e), super.setMap(e);
    }
    /**
     * Get the overlay layer that this interaction renders the modification point or vertex to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */
    getOverlay() {
      return this.overlay_;
    }
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceAdd_(e) {
      e.feature && this.features_.push(e.feature);
    }
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceRemove_(e) {
      e.feature && this.features_.remove(e.feature);
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    handleFeatureAdd_(e) {
      this.addFeature_(e.element);
    }
    /**
     * @param {import("../events/Event.js").default} evt Event.
     * @private
     */
    handleFeatureChange_(e) {
      if (!this.changingFeature_) {
        const i = (
          /** @type {Feature} */
          e.target
        );
        this.removeFeature_(i), this.addFeature_(i);
      }
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    handleFeatureRemove_(e) {
      this.removeFeature_(e.element);
    }
    /**
     * @param {Feature} feature Feature
     * @param {Point} geometry Geometry.
     * @private
     */
    writePointGeometry_(e, i) {
      const r = i.getCoordinates(), n = {
        feature: e,
        geometry: i,
        segment: [r, r]
      };
      this.rBush_.insert(i.getExtent(), n);
    }
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
     * @private
     */
    writeMultiPointGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n], a = {
          feature: e,
          geometry: i,
          depth: [n],
          index: n,
          segment: [o, o]
        };
        this.rBush_.insert(i.getExtent(), a);
      }
    }
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/LineString.js").default} geometry Geometry.
     * @private
     */
    writeLineStringGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length - 1; n < s; ++n) {
        const o = r.slice(n, n + 2), a = {
          feature: e,
          geometry: i,
          index: n,
          segment: o
        };
        this.rBush_.insert($i(o), a);
      }
    }
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
     * @private
     */
    writeMultiLineStringGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n];
        for (let a = 0, A = o.length - 1; a < A; ++a) {
          const l = o.slice(a, a + 2), c = {
            feature: e,
            geometry: i,
            depth: [n],
            index: a,
            segment: l
          };
          this.rBush_.insert($i(l), c);
        }
      }
    }
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/Polygon.js").default} geometry Geometry.
     * @private
     */
    writePolygonGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n];
        for (let a = 0, A = o.length - 1; a < A; ++a) {
          const l = o.slice(a, a + 2), c = {
            feature: e,
            geometry: i,
            depth: [n],
            index: a,
            segment: l
          };
          this.rBush_.insert($i(l), c);
        }
      }
    }
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @private
     */
    writeMultiPolygonGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n];
        for (let a = 0, A = o.length; a < A; ++a) {
          const l = o[a];
          for (let c = 0, u = l.length - 1; c < u; ++c) {
            const d = l.slice(c, c + 2), h = {
              feature: e,
              geometry: i,
              depth: [a, n],
              index: c,
              segment: d
            };
            this.rBush_.insert($i(d), h);
          }
        }
      }
    }
    /**
     * We convert a circle into two segments.  The segment at index
     * {@link CIRCLE_CENTER_INDEX} is the
     * circle's center (a point).  The segment at index
     * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
     * the circumference, and is not a line segment.
     *
     * @param {Feature} feature Feature.
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @private
     */
    writeCircleGeometry_(e, i) {
      const r = i.getCenter(), n = {
        feature: e,
        geometry: i,
        index: XD,
        segment: [r, r]
      }, s = {
        feature: e,
        geometry: i,
        index: zh,
        segment: [r, r]
      }, o = [n, s];
      n.featureSegments = o, s.featureSegments = o, this.rBush_.insert(Qu(r), n);
      let a = (
        /** @type {import("../geom/Geometry.js").default} */
        i
      );
      this.rBush_.insert(a.getExtent(), s);
    }
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @private
     */
    writeGeometryCollectionGeometry_(e, i) {
      const r = i.getGeometriesArray();
      for (let n = 0; n < r.length; ++n) {
        const s = r[n], o = this.SEGMENT_WRITERS_[s.getType()];
        o(e, s);
      }
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {Array<Feature>} features The features being modified.
     * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
     * @param {boolean} existing The vertex represents an existing vertex.
     * @return {Feature} Vertex feature.
     * @private
     */
    createOrUpdateVertexFeature_(e, i, r, n) {
      let s = this.vertexFeature_;
      return s ? s.getGeometry().setCoordinates(e) : (s = new hr(new Cn(e)), this.vertexFeature_ = s, this.overlay_.getSource().addFeature(s)), s.set("features", i), s.set("geometries", r), s.set("existing", n), s;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(e) {
      if (!e.originalEvent)
        return !0;
      this.lastPointerEvent_ = e;
      let i;
      return !e.map.getView().getInteracting() && e.type == Yt.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (e.type != Yt.SINGLECLICK || !this.ignoreNextSingleClick_ ? i = this.removePoint() : i = !0), e.type == Yt.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(e) && !i;
    }
    findInsertVerticesAndUpdateDragSegments_(e) {
      this.handlePointerAtPixel_(e), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
      const i = this.vertexFeature_;
      if (!i)
        return;
      this.getMap().getView().getProjection();
      const r = [], n = i.getGeometry().getCoordinates(), s = $i([n]), o = this.rBush_.getInExtent(s), a = {};
      o.sort(Fie);
      for (let A = 0, l = o.length; A < l; ++A) {
        const c = o[A], u = c.segment;
        let d = ve(c.geometry);
        const h = c.depth;
        if (h && (d += "-" + h.join("-")), a[d] || (a[d] = new Array(2)), c.geometry.getType() === "Circle" && c.index === zh) {
          const g = $D(
            e,
            c
          );
          Hr(g, n) && !a[d][0] && (this.dragSegments_.push([c, 0]), a[d][0] = c);
          continue;
        }
        if (Hr(u[0], n) && !a[d][0]) {
          this.dragSegments_.push([c, 0]), a[d][0] = c;
          continue;
        }
        if (Hr(u[1], n) && !a[d][1]) {
          if (a[d][0] && a[d][0].index === 0) {
            let g = c.geometry.getCoordinates();
            switch (c.geometry.getType()) {
              // prevent dragging closed linestrings by the connecting node
              case "LineString":
              case "MultiLineString":
                continue;
              // if dragging the first vertex of a polygon, ensure the other segment
              // belongs to the closing vertex of the linear ring
              case "MultiPolygon":
                g = g[h[1]];
              /* falls through */
              case "Polygon":
                if (c.index !== g[h[0]].length - 2)
                  continue;
                break;
            }
          }
          this.dragSegments_.push([c, 1]), a[d][1] = c;
          continue;
        }
        ve(u) in this.vertexSegments_ && !a[d][0] && !a[d][1] && r.push(c);
      }
      return r;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @override
     */
    handleDragEvent(e) {
      this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(
        e,
        this.dragSegments_.map(([s]) => s)
      );
      const i = [
        e.coordinate[0] + this.delta_[0],
        e.coordinate[1] + this.delta_[1]
      ], r = [], n = [];
      for (let s = 0, o = this.dragSegments_.length; s < o; ++s) {
        const a = this.dragSegments_[s], A = a[0], l = A.feature;
        r.includes(l) || r.push(l);
        const c = A.geometry;
        n.includes(c) || n.push(c);
        const u = A.depth;
        let d;
        const h = A.segment, g = a[1];
        for (; i.length < c.getStride(); )
          i.push(h[g][i.length]);
        switch (c.getType()) {
          case "Point":
            d = i, h[0] = i, h[1] = i;
            break;
          case "MultiPoint":
            d = c.getCoordinates(), d[A.index] = i, h[0] = i, h[1] = i;
            break;
          case "LineString":
            d = c.getCoordinates(), d[A.index + g] = i, h[g] = i;
            break;
          case "MultiLineString":
            d = c.getCoordinates(), d[u[0]][A.index + g] = i, h[g] = i;
            break;
          case "Polygon":
            d = c.getCoordinates(), d[u[0]][A.index + g] = i, h[g] = i;
            break;
          case "MultiPolygon":
            d = c.getCoordinates(), d[u[1]][u[0]][A.index + g] = i, h[g] = i;
            break;
          case "Circle":
            const f = (
              /** @type {import("../geom/Circle.js").default} */
              c
            );
            if (h[0] = i, h[1] = i, A.index === XD)
              this.changingFeature_ = !0, f.setCenter(i), this.changingFeature_ = !1;
            else {
              this.changingFeature_ = !0, e.map.getView().getProjection();
              let p = pE(
                di(f.getCenter()),
                di(i)
              );
              f.setRadius(p), this.changingFeature_ = !1;
            }
            break;
        }
        d && this.setGeometryCoordinates_(c, d);
      }
      this.createOrUpdateVertexFeature_(i, r, n, !0);
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleDownEvent(e) {
      if (!this.condition_(e))
        return !1;
      const i = e.coordinate, r = this.findInsertVerticesAndUpdateDragSegments_(i);
      if (r != null && r.length && this.insertVertexCondition_(e) && (this.willModifyFeatures_(e, r), this.vertexFeature_)) {
        const n = this.vertexFeature_.getGeometry().getCoordinates();
        for (let s = r.length - 1; s >= 0; --s)
          this.insertVertex_(r[s], n);
        this.ignoreNextSingleClick_ = !0;
      }
      return !!this.vertexFeature_;
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      for (let i = this.dragSegments_.length - 1; i >= 0; --i) {
        const r = this.dragSegments_[i][0], n = r.geometry;
        if (n.getType() === "Circle") {
          const s = (
            /** @type {import("../geom/Circle.js").default} */
            n
          ), o = s.getCenter(), a = r.featureSegments[0], A = r.featureSegments[1];
          a.segment[0] = o, a.segment[1] = o, A.segment[0] = o, A.segment[1] = o, this.rBush_.update(Qu(o), a);
          let l = s;
          this.rBush_.update(
            l.getExtent(),
            A
          );
        } else
          this.rBush_.update($i(r.segment), r);
      }
      return this.featuresBeingModified_ && (this.dispatchEvent(
        new k0(
          _0.MODIFYEND,
          this.featuresBeingModified_,
          e
        )
      ), this.featuresBeingModified_ = null), !1;
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @private
     */
    handlePointerMove_(e) {
      this.lastPixel_ = e.pixel, this.handlePointerAtPixel_(e.coordinate);
    }
    /**
     * @param {import("../coordinate.js").Coordinate} pixelCoordinate The pixel Coordinate.
     * @private
     */
    handlePointerAtPixel_(e) {
      const i = this.getMap(), r = i.getPixelFromCoordinate(e);
      i.getView().getProjection();
      const n = function(a, A) {
        return qD(e, a) - qD(e, A);
      };
      let s, o;
      if (this.hitDetection_) {
        const a = typeof this.hitDetection_ == "object" ? (A) => A === this.hitDetection_ : void 0;
        i.forEachFeatureAtPixel(
          r,
          (A, l, c) => {
            c && c.getType() === "Point" && (c = new Cn(
              QA(c.getCoordinates())
            ));
            const u = c || A.getGeometry();
            if (u && u.getType() === "Point" && A instanceof hr && this.features_.getArray().includes(A)) {
              o = /** @type {Point} */
              u;
              const d = (
                /** @type {Point} */
                A.getGeometry().getFlatCoordinates().slice(0, 2)
              );
              s = [
                {
                  feature: A,
                  geometry: o,
                  segment: [d, d]
                }
              ];
            }
            return !0;
          },
          { layerFilter: a }
        );
      }
      if (!s) {
        const a = is(
          Qu(e, ZD)
        ), A = i.getView().getResolution() * this.pixelTolerance_, l = lf(
          $r(a, A, ZD)
        );
        s = this.rBush_.getInExtent(l);
      }
      if (s && s.length > 0) {
        const a = s.sort(n)[0], A = a.segment;
        let l = $D(e, a);
        const c = i.getPixelFromCoordinate(l);
        let u = pE(r, c);
        if (o || u <= this.pixelTolerance_) {
          const d = {};
          if (d[ve(A)] = !0, this.snapToPointer_ || (this.delta_[0] = l[0] - e[0], this.delta_[1] = l[1] - e[1]), a.geometry.getType() === "Circle" && a.index === zh)
            this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(
              l,
              [a.feature],
              [a.geometry],
              this.snappedToVertex_
            );
          else {
            const h = i.getPixelFromCoordinate(A[0]), g = i.getPixelFromCoordinate(A[1]), f = ma(c, h), p = ma(c, g);
            u = Math.sqrt(Math.min(f, p)), this.snappedToVertex_ = u <= this.pixelTolerance_, this.snappedToVertex_ && (l = f > p ? A[1] : A[0]), this.createOrUpdateVertexFeature_(
              l,
              [a.feature],
              [a.geometry],
              this.snappedToVertex_
            );
            const m = {};
            m[ve(a.geometry)] = !0;
            for (let E = 1, y = s.length; E < y; ++E) {
              const C = s[E].segment;
              if (Hr(A[0], C[0]) && Hr(A[1], C[1]) || Hr(A[0], C[1]) && Hr(A[1], C[0])) {
                const w = ve(s[E].geometry);
                w in m || (m[w] = !0, d[ve(C)] = !0);
              } else
                break;
            }
          }
          this.vertexSegments_ = d;
          return;
        }
      }
      this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
    }
    /**
     * @param {SegmentData} segmentData Segment data.
     * @param {import("../coordinate.js").Coordinate} vertex Vertex.
     * @return {boolean} A vertex was inserted.
     * @private
     */
    insertVertex_(e, i) {
      const r = e.segment, n = e.feature, s = e.geometry, o = e.depth, a = e.index;
      let A;
      for (; i.length < s.getStride(); )
        i.push(0);
      switch (s.getType()) {
        case "MultiLineString":
          A = s.getCoordinates(), A[o[0]].splice(a + 1, 0, i);
          break;
        case "Polygon":
          A = s.getCoordinates(), A[o[0]].splice(a + 1, 0, i);
          break;
        case "MultiPolygon":
          A = s.getCoordinates(), A[o[1]][o[0]].splice(a + 1, 0, i);
          break;
        case "LineString":
          A = s.getCoordinates(), A.splice(a + 1, 0, i);
          break;
        default:
          return !1;
      }
      this.setGeometryCoordinates_(s, A);
      const l = this.rBush_;
      l.remove(e), this.updateSegmentIndices_(s, a, o, 1);
      const c = {
        segment: [r[0], i],
        feature: n,
        geometry: s,
        depth: o,
        index: a
      };
      l.insert($i(c.segment), c), this.dragSegments_.push([c, 1]);
      const u = {
        segment: [i, r[1]],
        feature: n,
        geometry: s,
        depth: o,
        index: a + 1
      };
      return l.insert($i(u.segment), u), this.dragSegments_.push([u, 0]), !0;
    }
    updatePointer_(e) {
      var i;
      return e && this.findInsertVerticesAndUpdateDragSegments_(e), (i = this.vertexFeature_) == null ? void 0 : i.getGeometry().getCoordinates();
    }
    /**
     * Get the current pointer position.
     * @return {import("../coordinate.js").Coordinate | null} The current pointer coordinate.
     */
    getPoint() {
      var i;
      const e = (i = this.vertexFeature_) == null ? void 0 : i.getGeometry().getCoordinates();
      return e ? QA(
        e,
        this.getMap().getView().getProjection()
      ) : null;
    }
    /**
     * Check if a point can be removed from the current linestring or polygon at the current
     * pointer position.
     * @return {boolean} A point can be deleted at the current pointer position.
     * @api
     */
    canRemovePoint() {
      if (!this.vertexFeature_ || this.vertexFeature_.get("geometries").every(
        (r) => r.getType() === "Circle" || r.getType().endsWith("Point")
      ))
        return !1;
      const e = this.vertexFeature_.getGeometry().getCoordinates();
      return this.rBush_.getInExtent($i([e])).some(
        ({ segment: r }) => Hr(r[0], e) || Hr(r[1], e)
      );
    }
    /**
     * Removes the vertex currently being pointed from the current linestring or polygon.
     * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
     * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
     * @return {boolean} True when a vertex was removed.
     * @api
     */
    removePoint(e) {
      if (e && (e = di(
        e,
        this.getMap().getView().getProjection()
      ), this.updatePointer_(e)), !this.lastPointerEvent_ || this.lastPointerEvent_ && this.lastPointerEvent_.type != Yt.POINTERDRAG) {
        const i = this.lastPointerEvent_;
        this.willModifyFeatures_(
          i,
          this.dragSegments_.map(([n]) => n)
        );
        const r = this.removeVertex_();
        return this.featuresBeingModified_ && this.dispatchEvent(
          new k0(
            _0.MODIFYEND,
            this.featuresBeingModified_,
            i
          )
        ), this.featuresBeingModified_ = null, r;
      }
      return !1;
    }
    /**
     * Removes a vertex from all matching features.
     * @return {boolean} True when a vertex was removed.
     * @private
     */
    removeVertex_() {
      const e = this.dragSegments_, i = {};
      let r = !1, n, s, o, a, A, l, c, u, d, h, g;
      for (A = e.length - 1; A >= 0; --A)
        o = e[A], h = o[0], g = ve(h.feature), h.depth && (g += "-" + h.depth.join("-")), g in i || (i[g] = {}), o[1] === 0 ? (i[g].right = h, i[g].index = h.index) : o[1] == 1 && (i[g].left = h, i[g].index = h.index + 1);
      for (g in i) {
        switch (d = i[g].right, c = i[g].left, l = i[g].index, u = l - 1, c !== void 0 ? h = c : h = d, u < 0 && (u = 0), a = h.geometry, s = a.getCoordinates(), n = s, r = !1, a.getType()) {
          case "MultiLineString":
            s[h.depth[0]].length > 2 && (s[h.depth[0]].splice(l, 1), r = !0);
            break;
          case "LineString":
            s.length > 2 && (s.splice(l, 1), r = !0);
            break;
          case "MultiPolygon":
            n = n[h.depth[1]];
          /* falls through */
          case "Polygon":
            n = n[h.depth[0]], n.length > 4 && (l == n.length - 1 && (l = 0), n.splice(l, 1), r = !0, l === 0 && (n.pop(), n.push(n[0]), u = n.length - 1));
            break;
        }
        if (r) {
          this.setGeometryCoordinates_(a, s);
          const f = [];
          if (c !== void 0 && (this.rBush_.remove(c), f.push(c.segment[0])), d !== void 0 && (this.rBush_.remove(d), f.push(d.segment[1])), c !== void 0 && d !== void 0) {
            const p = {
              depth: h.depth,
              feature: h.feature,
              geometry: h.geometry,
              index: u,
              segment: f
            };
            this.rBush_.insert(
              $i(p.segment),
              p
            );
          }
          this.updateSegmentIndices_(a, l, h.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.length = 0;
        }
      }
      return r;
    }
    /**
     * Check if a point can be inserted to the current linestring or polygon at the current
     * pointer position.
     * @return {boolean} A point can be inserted at the current pointer position.
     * @api
     */
    canInsertPoint() {
      if (!this.vertexFeature_ || this.vertexFeature_.get("geometries").every(
        (r) => r.getType() === "Circle" || r.getType().endsWith("Point")
      ))
        return !1;
      const e = this.vertexFeature_.getGeometry().getCoordinates();
      return this.rBush_.getInExtent($i([e])).some(
        ({ segment: r }) => !(Hr(r[0], e) || Hr(r[1], e))
      );
    }
    /**
     * Inserts the vertex currently being pointed to the current linestring or polygon.
     * @param {import('../coordinate.js').Coordinate} [coordinate] If provided, the pointer
     * will be set to the provided coordinate. If not, the current pointer coordinate will be used.
     * @return {boolean} A vertex was inserted.
     * @api
     */
    insertPoint(e) {
      var n;
      const i = e ? di(e, this.getMap().getView().getProjection()) : (n = this.vertexFeature_) == null ? void 0 : n.getGeometry().getCoordinates();
      return i ? this.findInsertVerticesAndUpdateDragSegments_(i).reduce(
        (s, o) => s || this.insertVertex_(o, i),
        !1
      ) : !1;
    }
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {Array} coordinates Coordinates.
     * @private
     */
    setGeometryCoordinates_(e, i) {
      this.changingFeature_ = !0, e.setCoordinates(i), this.changingFeature_ = !1;
    }
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} index Index.
     * @param {Array<number>|undefined} depth Depth.
     * @param {number} delta Delta (1 or -1).
     * @private
     */
    updateSegmentIndices_(e, i, r, n) {
      this.rBush_.forEachInExtent(
        e.getExtent(),
        function(s) {
          s.geometry === e && (r === void 0 || s.depth === void 0 || jo(s.depth, r)) && s.index > i && (s.index += n);
        }
      );
    }
  }
  function Fie(t, e) {
    return t.index - e.index;
  }
  function qD(t, e, i) {
    const r = e.geometry;
    if (r.getType() === "Circle") {
      let s = (
        /** @type {import("../geom/Circle.js").default} */
        r
      );
      if (e.index === zh) {
        const o = ma(
          s.getCenter(),
          di(t)
        ), a = Math.sqrt(o) - s.getRadius();
        return a * a;
      }
    }
    const n = di(t);
    return Tu[0] = di(e.segment[0]), Tu[1] = di(e.segment[1]), n$(n, Tu);
  }
  function $D(t, e, i) {
    const r = e.geometry;
    if (r.getType() === "Circle" && e.index === zh)
      return QA(
        /** @type {import("../geom/Circle.js").default} */
        r.getClosestPoint(
          di(t)
        )
      );
    const n = di(t);
    return Tu[0] = di(e.segment[0]), Tu[1] = di(e.segment[1]), QA(
      fv(n, Tu)
    );
  }
  function Sie() {
    const t = jv();
    return function(e, i) {
      return t.Point;
    };
  }
  const Die = {
    /**
     * Triggered when feature(s) has been (de)selected.
     * @event SelectEvent#select
     * @api
     */
    SELECT: "select"
  };
  class Tie extends on {
    /**
     * @param {SelectEventType} type The event type.
     * @param {Array<import("../Feature.js").default>} selected Selected features.
     * @param {Array<import("../Feature.js").default>} deselected Deselected features.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
     *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     */
    constructor(e, i, r, n) {
      super(e), this.selected = i, this.deselected = r, this.mapBrowserEvent = n;
    }
  }
  const fp = {};
  class ax extends cc {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      super(), this.on, this.once, this.un, e = e || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = e.condition ? e.condition : AL, this.addCondition_ = e.addCondition ? e.addCondition : Ib, this.removeCondition_ = e.removeCondition ? e.removeCondition : Ib, this.toggleCondition_ = e.toggleCondition ? e.toggleCondition : ox, this.multi_ = e.multi ? e.multi : !1, this.filter_ = e.filter ? e.filter : Qa, this.hitTolerance_ = e.hitTolerance ? e.hitTolerance : 0, this.style_ = e.style !== void 0 ? e.style : Rie(), this.features_ = e.features || new Bn();
      let i;
      if (e.layers)
        if (typeof e.layers == "function")
          i = e.layers;
        else {
          const r = e.layers;
          i = function(n) {
            return r.includes(n);
          };
        }
      else
        i = Qa;
      this.layerFilter_ = i, this.featureLayerAssociation_ = {};
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @private
     */
    addFeatureLayerAssociation_(e, i) {
      this.featureLayerAssociation_[ve(e)] = i;
    }
    /**
     * Get the selected features.
     * @return {Collection<Feature>} Features collection.
     * @api
     */
    getFeatures() {
      return this.features_;
    }
    /**
     * Returns the Hit-detection tolerance.
     * @return {number} Hit tolerance in pixels.
     * @api
     */
    getHitTolerance() {
      return this.hitTolerance_;
    }
    /**
     * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
     * a selected feature.
     * @param {import("../Feature.js").default} feature Feature
     * @return {import('../layer/Vector.js').default} Layer.
     * @api
     */
    getLayer(e) {
      return (
        /** @type {import('../layer/Vector.js').default} */
        this.featureLayerAssociation_[ve(e)]
      );
    }
    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position
     * will be checked for features.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @api
     */
    setHitTolerance(e) {
      this.hitTolerance_ = e;
    }
    /**
     * Remove the interaction from its current map, if any,  and attach it to a new
     * map, if any. Pass `null` to just remove the interaction from the current map.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     * @override
     */
    setMap(e) {
      this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(e), e ? (this.features_.addEventListener(
        Ui.ADD,
        this.boundAddFeature_
      ), this.features_.addEventListener(
        Ui.REMOVE,
        this.boundRemoveFeature_
      ), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(
        Ui.ADD,
        this.boundAddFeature_
      ), this.features_.removeEventListener(
        Ui.REMOVE,
        this.boundRemoveFeature_
      ));
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    addFeature_(e) {
      const i = e.element;
      if (this.style_ && this.applySelectedStyle_(i), !this.getLayer(i)) {
        const r = (
          /** @type {VectorLayer} */
          this.getMap().getAllLayers().find(function(n) {
            if (n instanceof Bs && n.getSource() && n.getSource().hasFeature(i))
              return n;
          })
        );
        r && this.addFeatureLayerAssociation_(i, r);
      }
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
     * @private
     */
    removeFeature_(e) {
      this.style_ && this.restorePreviousStyle_(e.element);
    }
    /**
     * @return {import("../style/Style.js").StyleLike|null} Select style.
     */
    getStyle() {
      return this.style_;
    }
    /**
     * @param {Feature} feature Feature
     * @private
     */
    applySelectedStyle_(e) {
      const i = ve(e);
      i in fp || (fp[i] = e.getStyle()), e.setStyle(this.style_);
    }
    /**
     * @param {Feature} feature Feature
     * @private
     */
    restorePreviousStyle_(e) {
      const i = this.getMap().getInteractions().getArray();
      for (let n = i.length - 1; n >= 0; --n) {
        const s = i[n];
        if (s !== this && s instanceof ax && s.getStyle() && s.getFeatures().getArray().lastIndexOf(e) !== -1) {
          e.setStyle(s.getStyle());
          return;
        }
      }
      const r = ve(e);
      e.setStyle(fp[r]), delete fp[r];
    }
    /**
     * @param {Feature} feature Feature.
     * @private
     */
    removeFeatureLayerAssociation_(e) {
      delete this.featureLayerAssociation_[ve(e)];
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
     * selected state of features.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @override
     */
    handleEvent(e) {
      if (!this.condition_(e))
        return !0;
      const i = this.addCondition_(e), r = this.removeCondition_(e), n = this.toggleCondition_(e), s = !i && !r && !n, o = e.map, a = this.getFeatures(), A = [], l = [];
      if (s) {
        nc(this.featureLayerAssociation_), o.forEachFeatureAtPixel(
          e.pixel,
          /**
           * @param {import("../Feature.js").FeatureLike} feature Feature.
           * @param {import("../layer/Layer.js").default} layer Layer.
           * @return {boolean|undefined} Continue to iterate over the features.
           */
          (c, u) => {
            if (!(!(c instanceof hr) || !this.filter_(c, u)))
              return this.addFeatureLayerAssociation_(c, u), l.push(c), !this.multi_;
          },
          {
            layerFilter: this.layerFilter_,
            hitTolerance: this.hitTolerance_
          }
        );
        for (let c = a.getLength() - 1; c >= 0; --c) {
          const u = a.item(c), d = l.indexOf(u);
          d > -1 ? l.splice(d, 1) : (a.remove(u), A.push(u));
        }
        l.length !== 0 && a.extend(l);
      } else {
        o.forEachFeatureAtPixel(
          e.pixel,
          /**
           * @param {import("../Feature.js").FeatureLike} feature Feature.
           * @param {import("../layer/Layer.js").default} layer Layer.
           * @return {boolean|undefined} Continue to iterate over the features.
           */
          (c, u) => {
            if (!(!(c instanceof hr) || !this.filter_(c, u)))
              return (i || n) && !a.getArray().includes(c) ? (this.addFeatureLayerAssociation_(c, u), l.push(c)) : (r || n) && a.getArray().includes(c) && (A.push(c), this.removeFeatureLayerAssociation_(c)), !this.multi_;
          },
          {
            layerFilter: this.layerFilter_,
            hitTolerance: this.hitTolerance_
          }
        );
        for (let c = A.length - 1; c >= 0; --c)
          a.remove(A[c]);
        a.extend(l);
      }
      return (l.length > 0 || A.length > 0) && this.dispatchEvent(
        new Tie(
          Die.SELECT,
          l,
          A,
          e
        )
      ), !0;
    }
  }
  function Rie() {
    const t = jv();
    return xr(t.Polygon, t.LineString), xr(t.GeometryCollection, t.LineString), function(e) {
      return e.getGeometry() ? t[e.getGeometry().getType()] : null;
    };
  }
  const _ie = {
    /**
     * Triggered upon snapping to vertex or edge
     * @event SnapEvent#snap
     * @api
     */
    SNAP: "snap"
  };
  class kie extends on {
    /**
     * @param {SnapEventType} type Type.
     * @param {Object} options Options.
     * @param {import("../coordinate.js").Coordinate} options.vertex The snapped vertex.
     * @param {import("../coordinate.js").Coordinate} options.vertexPixel The pixel of the snapped vertex.
     * @param {import("../Feature.js").default} options.feature The feature being snapped.
     * @param {Array<import("../coordinate.js").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.
     */
    constructor(e, i) {
      super(e), this.vertex = i.vertex, this.vertexPixel = i.vertexPixel, this.feature = i.feature, this.segment = i.segment;
    }
  }
  function eT(t) {
    return (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */
      t.feature ? (
        /** @type {import("../source/Vector.js").VectorSourceEvent} */
        t.feature
      ) : (
        /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
        t.element ? (
          /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
          t.element
        ) : null
      )
    );
  }
  const Y0 = [];
  class Yie extends JA {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      e = e || {};
      const i = (
        /** @type {import("./Pointer.js").Options} */
        e
      );
      i.handleDownEvent || (i.handleDownEvent = Qa), i.stopDown || (i.stopDown = rc), super(i), this.on, this.once, this.un, this.source_ = e.source ? e.source : null, this.vertex_ = e.vertex !== void 0 ? e.vertex : !0, this.edge_ = e.edge !== void 0 ? e.edge : !0, this.features_ = e.features ? e.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.rBush_ = new DE(), this.GEOMETRY_SEGMENTERS_ = {
        Point: this.segmentPointGeometry_.bind(this),
        LineString: this.segmentLineStringGeometry_.bind(this),
        LinearRing: this.segmentLineStringGeometry_.bind(this),
        Polygon: this.segmentPolygonGeometry_.bind(this),
        MultiPoint: this.segmentMultiPointGeometry_.bind(this),
        MultiLineString: this.segmentMultiLineStringGeometry_.bind(this),
        MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this),
        GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this),
        Circle: this.segmentCircleGeometry_.bind(this)
      };
    }
    /**
     * Add a feature to the collection of features that we may snap to.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {boolean} [register] Whether to listen to the feature change or not
     *     Defaults to `true`.
     * @api
     */
    addFeature(e, i) {
      i = i !== void 0 ? i : !0;
      const r = ve(e), n = e.getGeometry();
      if (n) {
        const s = this.GEOMETRY_SEGMENTERS_[n.getType()];
        if (s) {
          this.indexedFeaturesExtents_[r] = n.getExtent(yr());
          const o = (
            /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
            []
          );
          if (s(o, n), o.length === 1)
            this.rBush_.insert($i(o[0]), {
              feature: e,
              segment: o[0]
            });
          else if (o.length > 1) {
            const a = o.map((l) => $i(l)), A = o.map((l) => ({
              feature: e,
              segment: l
            }));
            this.rBush_.load(a, A);
          }
        }
      }
      i && (this.featureChangeListenerKeys_[r] = nt(
        e,
        Ge.CHANGE,
        this.handleFeatureChange_,
        this
      ));
    }
    /**
     * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
     * @private
     */
    getFeatures_() {
      let e;
      return this.features_ ? e = this.features_ : this.source_ && (e = this.source_.getFeatures()), e;
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     * @override
     */
    handleEvent(e) {
      const i = this.snapTo(e.pixel, e.coordinate, e.map);
      return i && (e.coordinate = i.vertex.slice(0, 2), e.pixel = i.vertexPixel, this.dispatchEvent(
        new kie(_ie.SNAP, {
          vertex: e.coordinate,
          vertexPixel: e.pixel,
          feature: i.feature,
          segment: i.segment
        })
      )), super.handleEvent(e);
    }
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
     * @private
     */
    handleFeatureAdd_(e) {
      const i = eT(e);
      i && this.addFeature(i);
    }
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
     * @private
     */
    handleFeatureRemove_(e) {
      const i = eT(e);
      i && this.removeFeature(i);
    }
    /**
     * @param {import("../events/Event.js").default} evt Event.
     * @private
     */
    handleFeatureChange_(e) {
      const i = (
        /** @type {import("../Feature.js").default} */
        e.target
      );
      if (this.handlingDownUpSequence) {
        const r = ve(i);
        r in this.pendingFeatures_ || (this.pendingFeatures_[r] = i);
      } else
        this.updateFeature_(i);
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     * @override
     */
    handleUpEvent(e) {
      const i = Object.values(this.pendingFeatures_);
      return i.length && (i.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1;
    }
    /**
     * Remove a feature from the collection of features that we may snap to.
     * @param {import("../Feature.js").default} feature Feature
     * @param {boolean} [unlisten] Whether to unlisten to the feature change
     *     or not. Defaults to `true`.
     * @api
     */
    removeFeature(e, i) {
      const r = i !== void 0 ? i : !0, n = ve(e), s = this.indexedFeaturesExtents_[n];
      if (s) {
        const o = this.rBush_, a = [];
        o.forEachInExtent(s, function(A) {
          e === A.feature && a.push(A);
        });
        for (let A = a.length - 1; A >= 0; --A)
          o.remove(a[A]);
      }
      r && (Pt(this.featureChangeListenerKeys_[n]), delete this.featureChangeListenerKeys_[n]);
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default} map Map.
     * @override
     */
    setMap(e) {
      const i = this.getMap(), r = this.featuresListenerKeys_, n = (
        /** @type {Array<import("../Feature.js").default>} */
        this.getFeatures_()
      );
      i && (r.forEach(Pt), r.length = 0, this.rBush_.clear(), Object.values(this.featureChangeListenerKeys_).forEach(Pt), this.featureChangeListenerKeys_ = {}), super.setMap(e), e && (this.features_ ? r.push(
        nt(
          this.features_,
          Ui.ADD,
          this.handleFeatureAdd_,
          this
        ),
        nt(
          this.features_,
          Ui.REMOVE,
          this.handleFeatureRemove_,
          this
        )
      ) : this.source_ && r.push(
        nt(
          this.source_,
          Ii.ADDFEATURE,
          this.handleFeatureAdd_,
          this
        ),
        nt(
          this.source_,
          Ii.REMOVEFEATURE,
          this.handleFeatureRemove_,
          this
        )
      ), n.forEach((s) => this.addFeature(s)));
    }
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel
     * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
     * @param {import("../Map.js").default} map Map.
     * @return {Result|null} Snap result
     */
    snapTo(e, i, r) {
      r.getView().getProjection();
      const n = di(i), s = lf(
        $r(
          $i([n]),
          r.getView().getResolution() * this.pixelTolerance_
        )
      ), o = this.rBush_.getInExtent(s), a = o.length;
      if (a === 0)
        return null;
      let A, l = 1 / 0, c, u = null;
      const d = this.pixelTolerance_ * this.pixelTolerance_, h = () => {
        if (A) {
          const g = r.getPixelFromCoordinate(A);
          if (ma(e, g) <= d)
            return {
              vertex: A,
              vertexPixel: [
                Math.round(g[0]),
                Math.round(g[1])
              ],
              feature: c,
              segment: u
            };
        }
        return null;
      };
      if (this.vertex_) {
        for (let f = 0; f < a; ++f) {
          const p = o[f];
          p.feature.getGeometry().getType() !== "Circle" && p.segment.forEach((m) => {
            const E = di(m), y = ma(n, E);
            y < l && (A = m, l = y, c = p.feature);
          });
        }
        const g = h();
        if (g)
          return g;
      }
      if (this.edge_) {
        for (let f = 0; f < a; ++f) {
          let p = null;
          const m = o[f];
          if (m.feature.getGeometry().getType() === "Circle") {
            let E = m.feature.getGeometry();
            p = r$(
              n,
              /** @type {import("../geom/Circle.js").default} */
              E
            );
          } else {
            const [E, y] = m.segment;
            y && (Y0[0] = di(E), Y0[1] = di(y), p = fv(n, Y0));
          }
          if (p) {
            const E = ma(n, p);
            E < l && (A = QA(p), u = m.feature.getGeometry().getType() === "Circle" ? null : m.segment, l = E, c = m.feature);
          }
        }
        const g = h();
        if (g)
          return g;
      }
      return null;
    }
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @private
     */
    updateFeature_(e) {
      this.removeFeature(e, !1), this.addFeature(e, !1);
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @private
     */
    segmentCircleGeometry_(e, i) {
      this.getMap().getView().getProjection();
      const s = nm(i).getCoordinates()[0];
      for (let o = 0, a = s.length - 1; o < a; ++o)
        e.push(s.slice(o, o + 2));
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @private
     */
    segmentGeometryCollectionGeometry_(e, i) {
      const r = i.getGeometriesArray();
      for (let n = 0; n < r.length; ++n) {
        const s = this.GEOMETRY_SEGMENTERS_[r[n].getType()];
        s && s(e, r[n]);
      }
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/LineString.js").default} geometry Geometry.
     * @private
     */
    segmentLineStringGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length - 1; n < s; ++n)
        e.push(r.slice(n, n + 2));
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
     * @private
     */
    segmentMultiLineStringGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n];
        for (let a = 0, A = o.length - 1; a < A; ++a)
          e.push(o.slice(a, a + 2));
      }
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
     * @private
     */
    segmentMultiPointGeometry_(e, i) {
      i.getCoordinates().forEach((r) => {
        e.push([r]);
      });
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @private
     */
    segmentMultiPolygonGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n];
        for (let a = 0, A = o.length; a < A; ++a) {
          const l = o[a];
          for (let c = 0, u = l.length - 1; c < u; ++c)
            e.push(l.slice(c, c + 2));
        }
      }
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/Point.js").default} geometry Geometry.
     * @private
     */
    segmentPointGeometry_(e, i) {
      e.push([i.getCoordinates()]);
    }
    /**
     * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
     * @param {import("../geom/Polygon.js").default} geometry Geometry.
     * @private
     */
    segmentPolygonGeometry_(e, i) {
      const r = i.getCoordinates();
      for (let n = 0, s = r.length; n < s; ++n) {
        const o = r[n];
        for (let a = 0, A = o.length - 1; a < A; ++a)
          e.push(o.slice(a, a + 2));
      }
    }
  }
  var Dn = 63710088e-1, Nie = {
    centimeters: Dn * 100,
    centimetres: Dn * 100,
    degrees: 360 / (2 * Math.PI),
    feet: Dn * 3.28084,
    inches: Dn * 39.37,
    kilometers: Dn / 1e3,
    kilometres: Dn / 1e3,
    meters: Dn,
    metres: Dn,
    miles: Dn / 1609.344,
    millimeters: Dn * 1e3,
    millimetres: Dn * 1e3,
    nauticalmiles: Dn / 1852,
    radians: 1,
    yards: Dn * 1.0936
  };
  function eo(t, e, i = {}) {
    const r = { type: "Feature" };
    return (i.id === 0 || i.id) && (r.id = i.id), i.bbox && (r.bbox = i.bbox), r.properties = e || {}, r.geometry = t, r;
  }
  function Ad(t, e, i = {}) {
    if (!t)
      throw new Error("coordinates is required");
    if (!Array.isArray(t))
      throw new Error("coordinates must be an Array");
    if (t.length < 2)
      throw new Error("coordinates must be at least 2 numbers long");
    if (!tT(t[0]) || !tT(t[1]))
      throw new Error("coordinates must contain numbers");
    return eo({
      type: "Point",
      coordinates: t
    }, e, i);
  }
  function Ts(t, e, i = {}) {
    for (const n of t) {
      if (n.length < 4)
        throw new Error(
          "Each LinearRing of a Polygon must have 4 or more Positions."
        );
      if (n[n.length - 1].length !== n[0].length)
        throw new Error("First and last Position are not equivalent.");
      for (let s = 0; s < n[n.length - 1].length; s++)
        if (n[n.length - 1][s] !== n[0][s])
          throw new Error("First and last Position are not equivalent.");
    }
    return eo({
      type: "Polygon",
      coordinates: t
    }, e, i);
  }
  function SA(t, e, i = {}) {
    if (t.length < 2)
      throw new Error("coordinates must be an array of two or more positions");
    return eo({
      type: "LineString",
      coordinates: t
    }, e, i);
  }
  function ps(t, e = {}) {
    const i = { type: "FeatureCollection" };
    return e.id && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.features = t, i;
  }
  function Uie(t, e, i = {}) {
    return eo({
      type: "MultiLineString",
      coordinates: t
    }, e, i);
  }
  function js(t, e, i = {}) {
    return eo({
      type: "MultiPolygon",
      coordinates: t
    }, e, i);
  }
  function Lie(t, e, i = {}) {
    return eo({
      type: "GeometryCollection",
      geometries: t
    }, e, i);
  }
  function zie(t, e = "kilometers") {
    const i = Nie[e];
    if (!i)
      throw new Error(e + " units is invalid");
    return t * i;
  }
  function pp(t) {
    return t % 360 * Math.PI / 180;
  }
  function tT(t) {
    return !isNaN(t) && t !== null && !Array.isArray(t);
  }
  function IL(t) {
    return t !== null && typeof t == "object" && !Array.isArray(t);
  }
  function yg(t) {
    if (!t)
      throw new Error("coord is required");
    if (!Array.isArray(t)) {
      if (t.type === "Feature" && t.geometry !== null && t.geometry.type === "Point")
        return [...t.geometry.coordinates];
      if (t.type === "Point")
        return [...t.coordinates];
    }
    if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1]))
      return [...t];
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function iT(t) {
    if (Array.isArray(t))
      return t;
    if (t.type === "Feature") {
      if (t.geometry !== null)
        return t.geometry.coordinates;
    } else if (t.coordinates)
      return t.coordinates;
    throw new Error(
      "coords must be GeoJSON Feature, Geometry Object or an Array"
    );
  }
  function to(t) {
    return t.type === "Feature" ? t.geometry : t;
  }
  function Ax(t, e) {
    return t.type === "FeatureCollection" ? "FeatureCollection" : t.type === "GeometryCollection" ? "GeometryCollection" : t.type === "Feature" && t.geometry !== null ? t.geometry.type : t.type;
  }
  function N0(t, e, i = {}) {
    var r = yg(t), n = yg(e), s = pp(n[1] - r[1]), o = pp(n[0] - r[0]), a = pp(r[1]), A = pp(n[1]), l = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(a) * Math.cos(A);
    return zie(
      2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)),
      i.units
    );
  }
  function vL(t, e, i) {
    if (t !== null)
      for (var r, n, s, o, a, A, l, c = 0, u = 0, d, h = t.type, g = h === "FeatureCollection", f = h === "Feature", p = g ? t.features.length : 1, m = 0; m < p; m++) {
        l = g ? t.features[m].geometry : f ? t.geometry : t, d = l ? l.type === "GeometryCollection" : !1, a = d ? l.geometries.length : 1;
        for (var E = 0; E < a; E++) {
          var y = 0, C = 0;
          if (o = d ? l.geometries[E] : l, o !== null) {
            A = o.coordinates;
            var w = o.type;
            switch (c = 0, w) {
              case null:
                break;
              case "Point":
                if (e(
                  A,
                  u,
                  m,
                  y,
                  C
                ) === !1)
                  return !1;
                u++, y++;
                break;
              case "LineString":
              case "MultiPoint":
                for (r = 0; r < A.length; r++) {
                  if (e(
                    A[r],
                    u,
                    m,
                    y,
                    C
                  ) === !1)
                    return !1;
                  u++, w === "MultiPoint" && y++;
                }
                w === "LineString" && y++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (r = 0; r < A.length; r++) {
                  for (n = 0; n < A[r].length - c; n++) {
                    if (e(
                      A[r][n],
                      u,
                      m,
                      y,
                      C
                    ) === !1)
                      return !1;
                    u++;
                  }
                  w === "MultiLineString" && y++, w === "Polygon" && C++;
                }
                w === "Polygon" && y++;
                break;
              case "MultiPolygon":
                for (r = 0; r < A.length; r++) {
                  for (C = 0, n = 0; n < A[r].length; n++) {
                    for (s = 0; s < A[r][n].length - c; s++) {
                      if (e(
                        A[r][n][s],
                        u,
                        m,
                        y,
                        C
                      ) === !1)
                        return !1;
                      u++;
                    }
                    C++;
                  }
                  y++;
                }
                break;
              case "GeometryCollection":
                for (r = 0; r < o.geometries.length; r++)
                  if (vL(o.geometries[r], e) === !1)
                    return !1;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
  }
  function Pie(t, e) {
    if (t.type === "Feature")
      e(t, 0);
    else if (t.type === "FeatureCollection")
      for (var i = 0; i < t.features.length && e(t.features[i], i) !== !1; i++)
        ;
  }
  function lx(t) {
    var e = [];
    return vL(t, function(i) {
      e.push(i);
    }), e;
  }
  function BB(t, e) {
    var i, r, n, s, o, a, A, l, c, u, d = 0, h = t.type === "FeatureCollection", g = t.type === "Feature", f = h ? t.features.length : 1;
    for (i = 0; i < f; i++) {
      for (a = h ? t.features[i].geometry : g ? t.geometry : t, l = h ? t.features[i].properties : g ? t.properties : {}, c = h ? t.features[i].bbox : g ? t.bbox : void 0, u = h ? t.features[i].id : g ? t.id : void 0, A = a ? a.type === "GeometryCollection" : !1, o = A ? a.geometries.length : 1, n = 0; n < o; n++) {
        if (s = A ? a.geometries[n] : a, s === null) {
          if (e(
            null,
            d,
            l,
            c,
            u
          ) === !1)
            return !1;
          continue;
        }
        switch (s.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (e(
              s,
              d,
              l,
              c,
              u
            ) === !1)
              return !1;
            break;
          }
          case "GeometryCollection": {
            for (r = 0; r < s.geometries.length; r++)
              if (e(
                s.geometries[r],
                d,
                l,
                c,
                u
              ) === !1)
                return !1;
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      d++;
    }
  }
  function wB(t, e) {
    BB(t, function(i, r, n, s, o) {
      var a = i === null ? null : i.type;
      switch (a) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          return e(
            eo(i, n, { bbox: s, id: o }),
            r,
            0
          ) === !1 ? !1 : void 0;
      }
      var A;
      switch (a) {
        case "MultiPoint":
          A = "Point";
          break;
        case "MultiLineString":
          A = "LineString";
          break;
        case "MultiPolygon":
          A = "Polygon";
          break;
      }
      for (var l = 0; l < i.coordinates.length; l++) {
        var c = i.coordinates[l], u = {
          type: A,
          coordinates: c
        };
        if (e(eo(u, n), r, l) === !1)
          return !1;
      }
    });
  }
  function Oie(t, e) {
    if (!t) throw new Error("geojson is required");
    wB(t, function(i, r, n) {
      if (i.geometry !== null) {
        var s = i.geometry.type, o = i.geometry.coordinates;
        switch (s) {
          case "LineString":
            if (e(i, r, n, 0, 0) === !1)
              return !1;
            break;
          case "Polygon":
            for (var a = 0; a < o.length; a++)
              if (e(
                SA(o[a], i.properties),
                r,
                n,
                a
              ) === !1)
                return !1;
            break;
        }
      }
    });
  }
  function Gie(t, e, i) {
    var r = i;
    return Oie(
      t,
      function(n, s, o, a) {
        s === 0 && i === void 0 ? r = n : r = e(
          r,
          n,
          s,
          o,
          a
        );
      }
    ), r;
  }
  const Ba = 11102230246251565e-32, Dr = 134217729, jie = (3 + 8 * Ba) * Ba;
  function U0(t, e, i, r, n) {
    let s, o, a, A, l = e[0], c = r[0], u = 0, d = 0;
    c > l == c > -l ? (s = l, l = e[++u]) : (s = c, c = r[++d]);
    let h = 0;
    if (u < t && d < i)
      for (c > l == c > -l ? (o = l + s, a = s - (o - l), l = e[++u]) : (o = c + s, a = s - (o - c), c = r[++d]), s = o, a !== 0 && (n[h++] = a); u < t && d < i; )
        c > l == c > -l ? (o = s + l, A = o - s, a = s - (o - A) + (l - A), l = e[++u]) : (o = s + c, A = o - s, a = s - (o - A) + (c - A), c = r[++d]), s = o, a !== 0 && (n[h++] = a);
    for (; u < t; )
      o = s + l, A = o - s, a = s - (o - A) + (l - A), l = e[++u], s = o, a !== 0 && (n[h++] = a);
    for (; d < i; )
      o = s + c, A = o - s, a = s - (o - A) + (c - A), c = r[++d], s = o, a !== 0 && (n[h++] = a);
    return (s !== 0 || h === 0) && (n[h++] = s), h;
  }
  function Hie(t, e) {
    let i = e[0];
    for (let r = 1; r < t; r++) i += e[r];
    return i;
  }
  function yf(t) {
    return new Float64Array(t);
  }
  const Jie = (3 + 16 * Ba) * Ba, Vie = (2 + 12 * Ba) * Ba, Wie = (9 + 64 * Ba) * Ba * Ba, Fc = yf(4), rT = yf(8), nT = yf(12), sT = yf(16), jr = yf(4);
  function Kie(t, e, i, r, n, s, o) {
    let a, A, l, c, u, d, h, g, f, p, m, E, y, C, w, M, I, b;
    const B = t - n, x = i - n, Q = e - s, v = r - s;
    C = B * v, d = Dr * B, h = d - (d - B), g = B - h, d = Dr * v, f = d - (d - v), p = v - f, w = g * p - (C - h * f - g * f - h * p), M = Q * x, d = Dr * Q, h = d - (d - Q), g = Q - h, d = Dr * x, f = d - (d - x), p = x - f, I = g * p - (M - h * f - g * f - h * p), m = w - I, u = w - m, Fc[0] = w - (m + u) + (u - I), E = C + m, u = E - C, y = C - (E - u) + (m - u), m = y - M, u = y - m, Fc[1] = y - (m + u) + (u - M), b = E + m, u = b - E, Fc[2] = E - (b - u) + (m - u), Fc[3] = b;
    let T = Hie(4, Fc), S = Vie * o;
    if (T >= S || -T >= S || (u = t - B, a = t - (B + u) + (u - n), u = i - x, l = i - (x + u) + (u - n), u = e - Q, A = e - (Q + u) + (u - s), u = r - v, c = r - (v + u) + (u - s), a === 0 && A === 0 && l === 0 && c === 0) || (S = Wie * o + jie * Math.abs(T), T += B * c + v * a - (Q * l + x * A), T >= S || -T >= S)) return T;
    C = a * v, d = Dr * a, h = d - (d - a), g = a - h, d = Dr * v, f = d - (d - v), p = v - f, w = g * p - (C - h * f - g * f - h * p), M = A * x, d = Dr * A, h = d - (d - A), g = A - h, d = Dr * x, f = d - (d - x), p = x - f, I = g * p - (M - h * f - g * f - h * p), m = w - I, u = w - m, jr[0] = w - (m + u) + (u - I), E = C + m, u = E - C, y = C - (E - u) + (m - u), m = y - M, u = y - m, jr[1] = y - (m + u) + (u - M), b = E + m, u = b - E, jr[2] = E - (b - u) + (m - u), jr[3] = b;
    const D = U0(4, Fc, 4, jr, rT);
    C = B * c, d = Dr * B, h = d - (d - B), g = B - h, d = Dr * c, f = d - (d - c), p = c - f, w = g * p - (C - h * f - g * f - h * p), M = Q * l, d = Dr * Q, h = d - (d - Q), g = Q - h, d = Dr * l, f = d - (d - l), p = l - f, I = g * p - (M - h * f - g * f - h * p), m = w - I, u = w - m, jr[0] = w - (m + u) + (u - I), E = C + m, u = E - C, y = C - (E - u) + (m - u), m = y - M, u = y - m, jr[1] = y - (m + u) + (u - M), b = E + m, u = b - E, jr[2] = E - (b - u) + (m - u), jr[3] = b;
    const F = U0(D, rT, 4, jr, nT);
    C = a * c, d = Dr * a, h = d - (d - a), g = a - h, d = Dr * c, f = d - (d - c), p = c - f, w = g * p - (C - h * f - g * f - h * p), M = A * l, d = Dr * A, h = d - (d - A), g = A - h, d = Dr * l, f = d - (d - l), p = l - f, I = g * p - (M - h * f - g * f - h * p), m = w - I, u = w - m, jr[0] = w - (m + u) + (u - I), E = C + m, u = E - C, y = C - (E - u) + (m - u), m = y - M, u = y - m, jr[1] = y - (m + u) + (u - M), b = E + m, u = b - E, jr[2] = E - (b - u) + (m - u), jr[3] = b;
    const R = U0(F, nT, 4, jr, sT);
    return sT[R - 1];
  }
  function Xie(t, e, i, r, n, s) {
    const o = (e - s) * (i - n), a = (t - n) * (r - s), A = o - a, l = Math.abs(o + a);
    return Math.abs(A) >= Jie * l ? A : -Kie(t, e, i, r, n, s, l);
  }
  function Zie(t, e) {
    var i, r, n = 0, s, o, a, A, l, c, u, d = t[0], h = t[1], g = e.length;
    for (i = 0; i < g; i++) {
      r = 0;
      var f = e[i], p = f.length - 1;
      if (c = f[0], c[0] !== f[p][0] && c[1] !== f[p][1])
        throw new Error("First and last coordinates in a ring must be the same");
      for (o = c[0] - d, a = c[1] - h, r; r < p; r++) {
        if (u = f[r + 1], A = u[0] - d, l = u[1] - h, a === 0 && l === 0) {
          if (A <= 0 && o >= 0 || o <= 0 && A >= 0)
            return 0;
        } else if (l >= 0 && a <= 0 || l <= 0 && a >= 0) {
          if (s = Xie(o, A, a, l, 0, 0), s === 0)
            return 0;
          (s > 0 && l > 0 && a <= 0 || s < 0 && l <= 0 && a > 0) && n++;
        }
        c = u, a = l, o = A;
      }
    }
    return n % 2 !== 0;
  }
  function qie(t, e, i = {}) {
    if (!t)
      throw new Error("point is required");
    if (!e)
      throw new Error("polygon is required");
    const r = yg(t), n = to(e), s = n.type, o = e.bbox;
    let a = n.coordinates;
    if (o && $ie(r, o) === !1)
      return !1;
    s === "Polygon" && (a = [a]);
    let A = !1;
    for (var l = 0; l < a.length; ++l) {
      const c = Zie(r, a[l]);
      if (c === 0) return !i.ignoreBoundary;
      c && (A = !0);
    }
    return A;
  }
  function $ie(t, e) {
    return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1];
  }
  let xL = class {
    constructor(e = [], i = ere) {
      if (this.data = e, this.length = this.data.length, this.compare = i, this.length > 0)
        for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
    }
    push(e) {
      this.data.push(e), this.length++, this._up(this.length - 1);
    }
    pop() {
      if (this.length === 0) return;
      const e = this.data[0], i = this.data.pop();
      return this.length--, this.length > 0 && (this.data[0] = i, this._down(0)), e;
    }
    peek() {
      return this.data[0];
    }
    _up(e) {
      const { data: i, compare: r } = this, n = i[e];
      for (; e > 0; ) {
        const s = e - 1 >> 1, o = i[s];
        if (r(n, o) >= 0) break;
        i[e] = o, e = s;
      }
      i[e] = n;
    }
    _down(e) {
      const { data: i, compare: r } = this, n = this.length >> 1, s = i[e];
      for (; e < n; ) {
        let o = (e << 1) + 1, a = i[o];
        const A = o + 1;
        if (A < this.length && r(i[A], a) < 0 && (o = A, a = i[A]), r(a, s) >= 0) break;
        i[e] = a, e = o;
      }
      i[e] = s;
    }
  };
  function ere(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  function QL(t, e) {
    return t.p.x > e.p.x ? 1 : t.p.x < e.p.x ? -1 : t.p.y !== e.p.y ? t.p.y > e.p.y ? 1 : -1 : 1;
  }
  function tre(t, e) {
    return t.rightSweepEvent.p.x > e.rightSweepEvent.p.x ? 1 : t.rightSweepEvent.p.x < e.rightSweepEvent.p.x ? -1 : t.rightSweepEvent.p.y !== e.rightSweepEvent.p.y ? t.rightSweepEvent.p.y < e.rightSweepEvent.p.y ? 1 : -1 : 1;
  }
  let oT = class {
    constructor(e, i, r, n) {
      this.p = {
        x: e[0],
        y: e[1]
      }, this.featureId = i, this.ringId = r, this.eventId = n, this.otherEvent = null, this.isLeftEndpoint = null;
    }
    isSamePoint(e) {
      return this.p.x === e.p.x && this.p.y === e.p.y;
    }
  };
  function ire(t, e) {
    if (t.type === "FeatureCollection") {
      const i = t.features;
      for (let r = 0; r < i.length; r++)
        aT(i[r], e);
    } else
      aT(t, e);
  }
  let mp = 0, Ep = 0, yp = 0;
  function aT(t, e) {
    const i = t.type === "Feature" ? t.geometry : t;
    let r = i.coordinates;
    (i.type === "Polygon" || i.type === "MultiLineString") && (r = [r]), i.type === "LineString" && (r = [[r]]);
    for (let n = 0; n < r.length; n++)
      for (let s = 0; s < r[n].length; s++) {
        let o = r[n][s][0], a = null;
        Ep = Ep + 1;
        for (let A = 0; A < r[n][s].length - 1; A++) {
          a = r[n][s][A + 1];
          const l = new oT(o, mp, Ep, yp), c = new oT(a, mp, Ep, yp + 1);
          l.otherEvent = c, c.otherEvent = l, QL(l, c) > 0 ? (c.isLeftEndpoint = !0, l.isLeftEndpoint = !1) : (l.isLeftEndpoint = !0, c.isLeftEndpoint = !1), e.push(l), e.push(c), o = a, yp = yp + 1;
        }
      }
    mp = mp + 1;
  }
  let rre = class {
    constructor(e) {
      this.leftSweepEvent = e, this.rightSweepEvent = e.otherEvent;
    }
  };
  function nre(t, e) {
    if (t === null || e === null || t.leftSweepEvent.ringId === e.leftSweepEvent.ringId && (t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.rightSweepEvent) || t.leftSweepEvent.isSamePoint(e.leftSweepEvent) || t.leftSweepEvent.isSamePoint(e.rightSweepEvent))) return !1;
    const i = t.leftSweepEvent.p.x, r = t.leftSweepEvent.p.y, n = t.rightSweepEvent.p.x, s = t.rightSweepEvent.p.y, o = e.leftSweepEvent.p.x, a = e.leftSweepEvent.p.y, A = e.rightSweepEvent.p.x, l = e.rightSweepEvent.p.y, c = (l - a) * (n - i) - (A - o) * (s - r), u = (A - o) * (r - a) - (l - a) * (i - o), d = (n - i) * (r - a) - (s - r) * (i - o);
    if (c === 0)
      return !1;
    const h = u / c, g = d / c;
    if (h >= 0 && h <= 1 && g >= 0 && g <= 1) {
      const f = i + h * (n - i), p = r + h * (s - r);
      return [f, p];
    }
    return !1;
  }
  function sre(t, e) {
    e = e || !1;
    const i = [], r = new xL([], tre);
    for (; t.length; ) {
      const n = t.pop();
      if (n.isLeftEndpoint) {
        const s = new rre(n);
        for (let o = 0; o < r.data.length; o++) {
          const a = r.data[o];
          if (e && a.leftSweepEvent.featureId === n.featureId)
            continue;
          const A = nre(s, a);
          A !== !1 && i.push(A);
        }
        r.push(s);
      } else n.isLeftEndpoint === !1 && r.pop();
    }
    return i;
  }
  function ore(t, e) {
    const i = new xL([], QL);
    return ire(t, i), sre(i, e);
  }
  var are = ore;
  function Are(t, e, i = {}) {
    const { removeDuplicates: r = !0, ignoreSelfIntersections: n = !0 } = i;
    let s = [];
    t.type === "FeatureCollection" ? s = s.concat(t.features) : t.type === "Feature" ? s.push(t) : (t.type === "LineString" || t.type === "Polygon" || t.type === "MultiLineString" || t.type === "MultiPolygon") && s.push(eo(t)), e.type === "FeatureCollection" ? s = s.concat(e.features) : e.type === "Feature" ? s.push(e) : (e.type === "LineString" || e.type === "Polygon" || e.type === "MultiLineString" || e.type === "MultiPolygon") && s.push(eo(e));
    const o = are(
      ps(s),
      n
    );
    let a = [];
    if (r) {
      const A = {};
      o.forEach((l) => {
        const c = l.join(",");
        A[c] || (A[c] = !0, a.push(l));
      });
    } else
      a = o;
    return ps(a.map((A) => Ad(A)));
  }
  function Bf(t) {
    if (!t)
      throw new Error("geojson is required");
    const e = [];
    return wB(t, (i) => {
      lre(i, e);
    }), ps(e);
  }
  function lre(t, e) {
    let i = [];
    const r = t.geometry;
    if (r !== null) {
      switch (r.type) {
        case "Polygon":
          i = iT(r);
          break;
        case "LineString":
          i = [iT(r)];
      }
      i.forEach((n) => {
        cre(n, t.properties).forEach((o) => {
          o.id = e.length, e.push(o);
        });
      });
    }
  }
  function cre(t, e) {
    const i = [];
    return t.reduce((r, n) => {
      const s = SA([r, n], e);
      return s.bbox = ure(r, n), i.push(s), n;
    }), i;
  }
  function ure(t, e) {
    const i = t[0], r = t[1], n = e[0], s = e[1], o = i < n ? i : n, a = r < s ? r : s, A = i > n ? i : n, l = r > s ? r : s;
    return [o, a, A, l];
  }
  function dre(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  function hre(t) {
    if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
    var e = t.default;
    if (typeof e == "function") {
      var i = function r() {
        return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
      };
      i.prototype = e.prototype;
    } else i = {};
    return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
      var n = Object.getOwnPropertyDescriptor(t, r);
      Object.defineProperty(i, r, n.get ? n : {
        enumerable: !0,
        get: function() {
          return t[r];
        }
      });
    }), i;
  }
  function cx(t) {
    if (!t)
      throw new Error("geojson is required");
    switch (t.type) {
      case "Feature":
        return FL(t);
      case "FeatureCollection":
        return gre(t);
      case "Point":
      case "LineString":
      case "Polygon":
      case "MultiPoint":
      case "MultiLineString":
      case "MultiPolygon":
      case "GeometryCollection":
        return ux(t);
      default:
        throw new Error("unknown GeoJSON type");
    }
  }
  function FL(t) {
    const e = { type: "Feature" };
    return Object.keys(t).forEach((i) => {
      switch (i) {
        case "type":
        case "properties":
        case "geometry":
          return;
        default:
          e[i] = t[i];
      }
    }), e.properties = SL(t.properties), t.geometry == null ? e.geometry = null : e.geometry = ux(t.geometry), e;
  }
  function SL(t) {
    const e = {};
    return t && Object.keys(t).forEach((i) => {
      const r = t[i];
      typeof r == "object" ? r === null ? e[i] = null : Array.isArray(r) ? e[i] = r.map((n) => n) : e[i] = SL(r) : e[i] = r;
    }), e;
  }
  function gre(t) {
    const e = { type: "FeatureCollection" };
    return Object.keys(t).forEach((i) => {
      switch (i) {
        case "type":
        case "features":
          return;
        default:
          e[i] = t[i];
      }
    }), e.features = t.features.map((i) => FL(i)), e;
  }
  function ux(t) {
    const e = { type: t.type };
    return t.bbox && (e.bbox = t.bbox), t.type === "GeometryCollection" ? (e.geometries = t.geometries.map((i) => ux(i)), e) : (e.coordinates = DL(t.coordinates), e);
  }
  function DL(t) {
    const e = t;
    return typeof e[0] != "object" ? e.slice() : e.map((i) => DL(i));
  }
  function fre(t, e) {
    let i = !1;
    return ps(
      Ere(
        t.features.map((r) => {
          const n = {
            x: r.geometry.coordinates[0],
            y: r.geometry.coordinates[1]
          };
          return e ? n.z = r.properties[e] : r.geometry.coordinates.length === 3 && (i = !0, n.z = r.geometry.coordinates[2]), n;
        })
      ).map((r) => {
        const n = [r.a.x, r.a.y], s = [r.b.x, r.b.y], o = [r.c.x, r.c.y];
        let a = {};
        return i ? (n.push(r.a.z), s.push(r.b.z), o.push(r.c.z)) : a = {
          a: r.a.z,
          b: r.b.z,
          c: r.c.z
        }, Ts([[n, s, o, n]], a);
      })
    );
  }
  var AT = class {
    constructor(t, e, i) {
      this.a = t, this.b = e, this.c = i;
      const r = e.x - t.x, n = e.y - t.y, s = i.x - t.x, o = i.y - t.y, a = r * (t.x + e.x) + n * (t.y + e.y), A = s * (t.x + i.x) + o * (t.y + i.y), l = 2 * (r * (i.y - e.y) - n * (i.x - e.x));
      let c, u;
      this.x = (o * a - n * A) / l, this.y = (r * A - s * a) / l, c = this.x - t.x, u = this.y - t.y, this.r = c * c + u * u;
    }
  };
  function pre(t, e) {
    return e.x - t.x;
  }
  function mre(t) {
    let e = t.length, i, r, n, s, o;
    e: for (; e; )
      for (r = t[--e], i = t[--e], n = e; n; )
        if (o = t[--n], s = t[--n], i === s && r === o || i === o && r === s) {
          t.splice(e, 2), t.splice(n, 2), e -= 2;
          continue e;
        }
  }
  function Ere(t) {
    if (t.length < 3)
      return [];
    t.sort(pre);
    let e = t.length - 1;
    const i = t[e].x, r = t[0].x;
    let n = t[e].y, s = n;
    const o = 1e-12;
    let a, A, l, c, u, d;
    for (; e--; )
      t[e].y < n && (n = t[e].y), t[e].y > s && (s = t[e].y);
    let h = r - i, g = s - n;
    const f = h > g ? h : g, p = (r + i) * 0.5, m = (s + n) * 0.5, E = [
      new AT(
        {
          __sentinel: !0,
          x: p - 20 * f,
          y: m - f
        },
        {
          __sentinel: !0,
          x: p,
          y: m + 20 * f
        },
        {
          __sentinel: !0,
          x: p + 20 * f,
          y: m - f
        }
      )
    ], y = [], C = [];
    let w;
    for (e = t.length; e--; ) {
      for (C.length = 0, w = E.length; w--; ) {
        if (h = t[e].x - E[w].x, h > 0 && h * h > E[w].r) {
          y.push(E[w]), E.splice(w, 1);
          continue;
        }
        g = t[e].y - E[w].y, !(h * h + g * g > E[w].r) && (C.push(
          E[w].a,
          E[w].b,
          E[w].b,
          E[w].c,
          E[w].c,
          E[w].a
        ), E.splice(w, 1));
      }
      for (mre(C), w = C.length; w; )
        A = C[--w], a = C[--w], l = t[e], c = A.x - a.x, u = A.y - a.y, d = 2 * (c * (l.y - A.y) - u * (l.x - A.x)), Math.abs(d) > o && E.push(new AT(a, A, l));
    }
    for (Array.prototype.push.apply(y, E), e = y.length; e--; )
      (y[e].a.__sentinel || y[e].b.__sentinel || y[e].c.__sentinel) && y.splice(e, 1);
    return y;
  }
  function yre(t) {
    return t;
  }
  function Bre(t) {
    if (t == null) return yre;
    var e, i, r = t.scale[0], n = t.scale[1], s = t.translate[0], o = t.translate[1];
    return function(a, A) {
      A || (e = i = 0);
      var l = 2, c = a.length, u = new Array(c);
      for (u[0] = (e += a[0]) * r + s, u[1] = (i += a[1]) * n + o; l < c; ) u[l] = a[l], ++l;
      return u;
    };
  }
  function wre(t, e) {
    for (var i, r = t.length, n = r - e; n < --r; ) i = t[n], t[n++] = t[r], t[r] = i;
  }
  function TL(t, e) {
    var i = Bre(t.transform), r = t.arcs;
    function n(c, u) {
      u.length && u.pop();
      for (var d = r[c < 0 ? ~c : c], h = 0, g = d.length; h < g; ++h)
        u.push(i(d[h], h));
      c < 0 && wre(u, g);
    }
    function s(c) {
      return i(c);
    }
    function o(c) {
      for (var u = [], d = 0, h = c.length; d < h; ++d) n(c[d], u);
      return u.length < 2 && u.push(u[0]), u;
    }
    function a(c) {
      for (var u = o(c); u.length < 4; ) u.push(u[0]);
      return u;
    }
    function A(c) {
      return c.map(a);
    }
    function l(c) {
      var u = c.type, d;
      switch (u) {
        case "GeometryCollection":
          return { type: u, geometries: c.geometries.map(l) };
        case "Point":
          d = s(c.coordinates);
          break;
        case "MultiPoint":
          d = c.coordinates.map(s);
          break;
        case "LineString":
          d = o(c.arcs);
          break;
        case "MultiLineString":
          d = c.arcs.map(o);
          break;
        case "Polygon":
          d = A(c.arcs);
          break;
        case "MultiPolygon":
          d = c.arcs.map(A);
          break;
        default:
          return null;
      }
      return { type: u, coordinates: d };
    }
    return l(e);
  }
  function Cre(t, e) {
    var i = {}, r = {}, n = {}, s = [], o = -1;
    e.forEach(function(l, c) {
      var u = t.arcs[l < 0 ? ~l : l], d;
      u.length < 3 && !u[1][0] && !u[1][1] && (d = e[++o], e[o] = l, e[c] = d);
    }), e.forEach(function(l) {
      var c = a(l), u = c[0], d = c[1], h, g;
      if (h = n[u])
        if (delete n[h.end], h.push(l), h.end = d, g = r[d]) {
          delete r[g.start];
          var f = g === h ? h : h.concat(g);
          r[f.start = h.start] = n[f.end = g.end] = f;
        } else
          r[h.start] = n[h.end] = h;
      else if (h = r[d])
        if (delete r[h.start], h.unshift(l), h.start = u, g = n[u]) {
          delete n[g.end];
          var p = g === h ? h : g.concat(h);
          r[p.start = g.start] = n[p.end = h.end] = p;
        } else
          r[h.start] = n[h.end] = h;
      else
        h = [l], r[h.start = u] = n[h.end = d] = h;
    });
    function a(l) {
      var c = t.arcs[l < 0 ? ~l : l], u = c[0], d;
      return t.transform ? (d = [0, 0], c.forEach(function(h) {
        d[0] += h[0], d[1] += h[1];
      })) : d = c[c.length - 1], l < 0 ? [d, u] : [u, d];
    }
    function A(l, c) {
      for (var u in l) {
        var d = l[u];
        delete c[d.start], delete d.start, delete d.end, d.forEach(function(h) {
          i[h < 0 ? ~h : h] = 1;
        }), s.push(d);
      }
    }
    return A(n, r), A(r, n), e.forEach(function(l) {
      i[l < 0 ? ~l : l] || s.push([l]);
    }), s;
  }
  function bre(t) {
    for (var e = -1, i = t.length, r, n = t[i - 1], s = 0; ++e < i; ) r = n, n = t[e], s += r[0] * n[1] - r[1] * n[0];
    return Math.abs(s);
  }
  function Mre(t) {
    return TL(t, Ire.apply(this, arguments));
  }
  function Ire(t, e) {
    var i = {}, r = [], n = [];
    e.forEach(s);
    function s(A) {
      switch (A.type) {
        case "GeometryCollection":
          A.geometries.forEach(s);
          break;
        case "Polygon":
          o(A.arcs);
          break;
        case "MultiPolygon":
          A.arcs.forEach(o);
          break;
      }
    }
    function o(A) {
      A.forEach(function(l) {
        l.forEach(function(c) {
          (i[c = c < 0 ? ~c : c] || (i[c] = [])).push(A);
        });
      }), r.push(A);
    }
    function a(A) {
      return bre(TL(t, { type: "Polygon", arcs: [A] }).coordinates[0]);
    }
    return r.forEach(function(A) {
      if (!A._) {
        var l = [], c = [A];
        for (A._ = 1, n.push(l); A = c.pop(); )
          l.push(A), A.forEach(function(u) {
            u.forEach(function(d) {
              i[d < 0 ? ~d : d].forEach(function(h) {
                h._ || (h._ = 1, c.push(h));
              });
            });
          });
      }
    }), r.forEach(function(A) {
      delete A._;
    }), {
      type: "MultiPolygon",
      arcs: n.map(function(A) {
        var l = [], c;
        if (A.forEach(function(f) {
          f.forEach(function(p) {
            p.forEach(function(m) {
              i[m < 0 ? ~m : m].length < 2 && l.push(m);
            });
          });
        }), l = Cre(t, l), (c = l.length) > 1)
          for (var u = 1, d = a(l[0]), h, g; u < c; ++u)
            (h = a(l[u])) > d && (g = l[0], l[0] = l[u], l[u] = g, d = h);
        return l;
      }).filter(function(A) {
        return A.length > 0;
      })
    };
  }
  var dx = Object.prototype.hasOwnProperty;
  function vre(t) {
    var e = 1 / 0, i = 1 / 0, r = -1 / 0, n = -1 / 0;
    function s(u) {
      u != null && dx.call(o, u.type) && o[u.type](u);
    }
    var o = {
      GeometryCollection: function(u) {
        u.geometries.forEach(s);
      },
      Point: function(u) {
        a(u.coordinates);
      },
      MultiPoint: function(u) {
        u.coordinates.forEach(a);
      },
      LineString: function(u) {
        A(u.arcs);
      },
      MultiLineString: function(u) {
        u.arcs.forEach(A);
      },
      Polygon: function(u) {
        u.arcs.forEach(A);
      },
      MultiPolygon: function(u) {
        u.arcs.forEach(l);
      }
    };
    function a(u) {
      var d = u[0], h = u[1];
      d < e && (e = d), d > r && (r = d), h < i && (i = h), h > n && (n = h);
    }
    function A(u) {
      u.forEach(a);
    }
    function l(u) {
      u.forEach(A);
    }
    for (var c in t)
      s(t[c]);
    return r >= e && n >= i ? [e, i, r, n] : void 0;
  }
  function xre(t, e, i, r, n) {
    arguments.length === 3 && (r = Array, n = null);
    for (var s = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), o = t - 1, a = 0; a < t; ++a)
      s[a] = n;
    function A(u) {
      for (var d = e(u) & o, h = s[d], g = 0; h != n; ) {
        if (i(h, u)) return !0;
        if (++g >= t) throw new Error("full hashset");
        h = s[d = d + 1 & o];
      }
      return s[d] = u, !0;
    }
    function l(u) {
      for (var d = e(u) & o, h = s[d], g = 0; h != n; ) {
        if (i(h, u)) return !0;
        if (++g >= t) break;
        h = s[d = d + 1 & o];
      }
      return !1;
    }
    function c() {
      for (var u = [], d = 0, h = s.length; d < h; ++d) {
        var g = s[d];
        g != n && u.push(g);
      }
      return u;
    }
    return {
      add: A,
      has: l,
      values: c
    };
  }
  function hx(t, e, i, r, n, s) {
    arguments.length === 3 && (r = s = Array, n = null);
    for (var o = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), a = new s(t), A = t - 1, l = 0; l < t; ++l)
      o[l] = n;
    function c(g, f) {
      for (var p = e(g) & A, m = o[p], E = 0; m != n; ) {
        if (i(m, g)) return a[p] = f;
        if (++E >= t) throw new Error("full hashmap");
        m = o[p = p + 1 & A];
      }
      return o[p] = g, a[p] = f, f;
    }
    function u(g, f) {
      for (var p = e(g) & A, m = o[p], E = 0; m != n; ) {
        if (i(m, g)) return a[p];
        if (++E >= t) throw new Error("full hashmap");
        m = o[p = p + 1 & A];
      }
      return o[p] = g, a[p] = f, f;
    }
    function d(g, f) {
      for (var p = e(g) & A, m = o[p], E = 0; m != n; ) {
        if (i(m, g)) return a[p];
        if (++E >= t) break;
        m = o[p = p + 1 & A];
      }
      return f;
    }
    function h() {
      for (var g = [], f = 0, p = o.length; f < p; ++f) {
        var m = o[f];
        m != n && g.push(m);
      }
      return g;
    }
    return {
      set: c,
      maybeSet: u,
      // set if unset
      get: d,
      keys: h
    };
  }
  function Al(t, e) {
    return t[0] === e[0] && t[1] === e[1];
  }
  var RL = new ArrayBuffer(16), lT = new Float64Array(RL), Bp = new Uint32Array(RL);
  function vb(t) {
    lT[0] = t[0], lT[1] = t[1];
    var e = Bp[0] ^ Bp[1];
    return e = e << 5 ^ e >> 7 ^ Bp[2] ^ Bp[3], e & 2147483647;
  }
  function Qre(t) {
    var e = t.coordinates, i = t.lines, r = t.rings, n = M(), s = new Int32Array(e.length), o = new Int32Array(e.length), a = new Int32Array(e.length), A = new Int8Array(e.length), l = 0, c, u, d, h, g;
    for (c = 0, u = e.length; c < u; ++c)
      s[c] = o[c] = a[c] = -1;
    for (c = 0, u = i.length; c < u; ++c) {
      var f = i[c], p = f[0], m = f[1];
      for (h = n[p], g = n[++p], ++l, A[h] = 1; ++p <= m; )
        w(c, d = h, h = g, g = n[p]);
      ++l, A[g] = 1;
    }
    for (c = 0, u = e.length; c < u; ++c)
      s[c] = -1;
    for (c = 0, u = r.length; c < u; ++c) {
      var E = r[c], y = E[0] + 1, C = E[1];
      for (d = n[C - 1], h = n[y - 1], g = n[y], w(c, d, h, g); ++y <= C; )
        w(c, d = h, h = g, g = n[y]);
    }
    function w(Q, v, T, S) {
      if (s[T] !== Q) {
        s[T] = Q;
        var D = o[T];
        if (D >= 0) {
          var F = a[T];
          (D !== v || F !== S) && (D !== S || F !== v) && (++l, A[T] = 1);
        } else
          o[T] = v, a[T] = S;
      }
    }
    function M() {
      for (var Q = hx(e.length * 1.4, I, b, Int32Array, -1, Int32Array), v = new Int32Array(e.length), T = 0, S = e.length; T < S; ++T)
        v[T] = Q.maybeSet(T, T);
      return v;
    }
    function I(Q) {
      return vb(e[Q]);
    }
    function b(Q, v) {
      return Al(e[Q], e[v]);
    }
    s = o = a = null;
    var B = xre(l * 1.4, vb, Al), x;
    for (c = 0, u = e.length; c < u; ++c)
      A[x = n[c]] && B.add(e[x]);
    return B;
  }
  function Fre(t) {
    var e = Qre(t), i = t.coordinates, r = t.lines, n = t.rings, s, o, a;
    for (o = 0, a = r.length; o < a; ++o)
      for (var A = r[o], l = A[0], c = A[1]; ++l < c; )
        e.has(i[l]) && (s = { 0: l, 1: A[1] }, A[1] = l, A = A.next = s);
    for (o = 0, a = n.length; o < a; ++o)
      for (var u = n[o], d = u[0], h = d, g = u[1], f = e.has(i[d]); ++h < g; )
        e.has(i[h]) && (f ? (s = { 0: h, 1: u[1] }, u[1] = h, u = u.next = s) : (Sre(i, d, g, g - h), i[g] = i[d], f = !0, h = d));
    return t;
  }
  function Sre(t, e, i, r) {
    L0(t, e, i), L0(t, e, e + r), L0(t, e + r, i);
  }
  function L0(t, e, i) {
    for (var r = e + (i-- - e >> 1), n; e < r; ++e, --i)
      n = t[e], t[e] = t[i], t[i] = n;
  }
  function Dre(t) {
    var e = t.coordinates, i = t.lines, r, n = t.rings, s, o = i.length + n.length, a, A;
    for (delete t.lines, delete t.rings, a = 0, A = i.length; a < A; ++a)
      for (r = i[a]; r = r.next; ) ++o;
    for (a = 0, A = n.length; a < A; ++a)
      for (s = n[a]; s = s.next; ) ++o;
    var l = hx(o * 2 * 1.4, vb, Al), c = t.arcs = [];
    for (a = 0, A = i.length; a < A; ++a) {
      r = i[a];
      do
        u(r);
      while (r = r.next);
    }
    for (a = 0, A = n.length; a < A; ++a)
      if (s = n[a], s.next)
        do
          u(s);
        while (s = s.next);
      else
        d(s);
    function u(E) {
      var y, C, w, M, I, b, B, x;
      if (w = l.get(y = e[E[0]])) {
        for (B = 0, x = w.length; B < x; ++B)
          if (M = w[B], h(M, E)) {
            E[0] = M[0], E[1] = M[1];
            return;
          }
      }
      if (I = l.get(C = e[E[1]])) {
        for (B = 0, x = I.length; B < x; ++B)
          if (b = I[B], g(b, E)) {
            E[1] = b[0], E[0] = b[1];
            return;
          }
      }
      w ? w.push(E) : l.set(y, [E]), I ? I.push(E) : l.set(C, [E]), c.push(E);
    }
    function d(E) {
      var y, C, w, M, I;
      if (C = l.get(y = e[E[0]]))
        for (M = 0, I = C.length; M < I; ++M) {
          if (w = C[M], f(w, E)) {
            E[0] = w[0], E[1] = w[1];
            return;
          }
          if (p(w, E)) {
            E[0] = w[1], E[1] = w[0];
            return;
          }
        }
      if (C = l.get(y = e[E[0] + m(E)]))
        for (M = 0, I = C.length; M < I; ++M) {
          if (w = C[M], f(w, E)) {
            E[0] = w[0], E[1] = w[1];
            return;
          }
          if (p(w, E)) {
            E[0] = w[1], E[1] = w[0];
            return;
          }
        }
      C ? C.push(E) : l.set(y, [E]), c.push(E);
    }
    function h(E, y) {
      var C = E[0], w = y[0], M = E[1], I = y[1];
      if (C - M !== w - I) return !1;
      for (; C <= M; ++C, ++w) if (!Al(e[C], e[w])) return !1;
      return !0;
    }
    function g(E, y) {
      var C = E[0], w = y[0], M = E[1], I = y[1];
      if (C - M !== w - I) return !1;
      for (; C <= M; ++C, --I) if (!Al(e[C], e[I])) return !1;
      return !0;
    }
    function f(E, y) {
      var C = E[0], w = y[0], M = E[1], I = y[1], b = M - C;
      if (b !== I - w) return !1;
      for (var B = m(E), x = m(y), Q = 0; Q < b; ++Q)
        if (!Al(e[C + (Q + B) % b], e[w + (Q + x) % b])) return !1;
      return !0;
    }
    function p(E, y) {
      var C = E[0], w = y[0], M = E[1], I = y[1], b = M - C;
      if (b !== I - w) return !1;
      for (var B = m(E), x = b - m(y), Q = 0; Q < b; ++Q)
        if (!Al(e[C + (Q + B) % b], e[I - (Q + x) % b])) return !1;
      return !0;
    }
    function m(E) {
      for (var y = E[0], C = E[1], w = y, M = w, I = e[w]; ++w < C; ) {
        var b = e[w];
        (b[0] < I[0] || b[0] === I[0] && b[1] < I[1]) && (M = w, I = b);
      }
      return M - y;
    }
    return t;
  }
  function Tre(t) {
    var e = -1, i = [], r = [], n = [];
    function s(u) {
      u && dx.call(o, u.type) && o[u.type](u);
    }
    var o = {
      GeometryCollection: function(u) {
        u.geometries.forEach(s);
      },
      LineString: function(u) {
        u.arcs = a(u.arcs);
      },
      MultiLineString: function(u) {
        u.arcs = u.arcs.map(a);
      },
      Polygon: function(u) {
        u.arcs = u.arcs.map(A);
      },
      MultiPolygon: function(u) {
        u.arcs = u.arcs.map(l);
      }
    };
    function a(u) {
      for (var d = 0, h = u.length; d < h; ++d) n[++e] = u[d];
      var g = { 0: e - h + 1, 1: e };
      return i.push(g), g;
    }
    function A(u) {
      for (var d = 0, h = u.length; d < h; ++d) n[++e] = u[d];
      var g = { 0: e - h + 1, 1: e };
      return r.push(g), g;
    }
    function l(u) {
      return u.map(A);
    }
    for (var c in t)
      s(t[c]);
    return {
      type: "Topology",
      coordinates: n,
      lines: i,
      rings: r,
      objects: t
    };
  }
  function Rre(t) {
    var e = {}, i;
    for (i in t) e[i] = _re(t[i]);
    return e;
  }
  function _re(t) {
    return t == null ? { type: null } : (t.type === "FeatureCollection" ? kre : t.type === "Feature" ? _L : gx)(t);
  }
  function kre(t) {
    var e = { type: "GeometryCollection", geometries: t.features.map(_L) };
    return t.bbox != null && (e.bbox = t.bbox), e;
  }
  function _L(t) {
    var e = gx(t.geometry), i;
    t.id != null && (e.id = t.id), t.bbox != null && (e.bbox = t.bbox);
    for (i in t.properties) {
      e.properties = t.properties;
      break;
    }
    return e;
  }
  function gx(t) {
    if (t == null) return { type: null };
    var e = t.type === "GeometryCollection" ? { type: "GeometryCollection", geometries: t.geometries.map(gx) } : t.type === "Point" || t.type === "MultiPoint" ? { type: t.type, coordinates: t.coordinates } : { type: t.type, arcs: t.coordinates };
    return t.bbox != null && (e.bbox = t.bbox), e;
  }
  function Yre(t, e) {
    var i = vre(t = Rre(t)), r = Dre(Fre(Tre(t))), n = r.coordinates, s = hx(r.arcs.length * 1.4, Nre, Ure);
    t = r.objects, r.bbox = i, r.arcs = r.arcs.map(function(u, d) {
      return s.set(u, d), n.slice(u[0], u[1] + 1);
    }), delete r.coordinates, n = null;
    function o(u) {
      u && dx.call(a, u.type) && a[u.type](u);
    }
    var a = {
      GeometryCollection: function(u) {
        u.geometries.forEach(o);
      },
      LineString: function(u) {
        u.arcs = A(u.arcs);
      },
      MultiLineString: function(u) {
        u.arcs = u.arcs.map(A);
      },
      Polygon: function(u) {
        u.arcs = u.arcs.map(A);
      },
      MultiPolygon: function(u) {
        u.arcs = u.arcs.map(l);
      }
    };
    function A(u) {
      var d = [];
      do {
        var h = s.get(u);
        d.push(u[0] < u[1] ? h : ~h);
      } while (u = u.next);
      return d;
    }
    function l(u) {
      return u.map(A);
    }
    for (var c in t)
      o(t[c]);
    return r;
  }
  function Nre(t) {
    var e = t[0], i = t[1], r;
    return i < e && (r = e, e = i, i = r), e + 31 * i;
  }
  function Ure(t, e) {
    var i = t[0], r = t[1], n = e[0], s = e[1], o;
    return r < i && (o = i, i = r, r = o), s < n && (o = n, n = s, s = o), i === n && r === s;
  }
  function Lre(t, e = {}) {
    if (e = e || {}, !IL(e))
      throw new Error("options is invalid");
    const i = e.mutate;
    if (Ax(t) !== "FeatureCollection")
      throw new Error("geojson must be a FeatureCollection");
    if (!t.features.length)
      throw new Error("geojson is empty");
    (i === !1 || i === void 0) && (t = cx(t));
    const r = [], n = Gie(
      t,
      (s, o) => {
        const a = zre(s, o);
        return a || (r.push(s), o);
      }
    );
    return n && r.push(n), r.length ? r.length === 1 ? r[0] : Uie(
      r.map((s) => s.coordinates)
    ) : null;
  }
  function wp(t) {
    return t[0].toString() + "," + t[1].toString();
  }
  function zre(t, e) {
    const i = t.geometry.coordinates, r = e.geometry.coordinates, n = wp(i[0]), s = wp(i[i.length - 1]), o = wp(r[0]), a = wp(r[r.length - 1]);
    let A;
    if (n === a)
      A = r.concat(i.slice(1));
    else if (o === s)
      A = i.concat(r.slice(1));
    else if (n === o)
      A = i.slice(1).reverse().concat(r);
    else if (s === a)
      A = i.concat(r.reverse().slice(1));
    else
      return null;
    return SA(A);
  }
  function Pre(t, e = {}) {
    if (Ax(t) !== "FeatureCollection")
      throw new Error("geojson must be a FeatureCollection");
    if (!t.features.length)
      throw new Error("geojson is empty");
    (e.mutate === !1 || e.mutate === void 0) && (t = cx(t));
    const i = [];
    wB(t, (s) => {
      i.push(s.geometry);
    });
    const r = Yre({ geoms: Lie(i).geometry });
    return Mre(r, r.objects.geoms.geometries);
  }
  function Ore(t, e = {}) {
    if (e = e || {}, !IL(e))
      throw new Error("options is invalid");
    const i = e.mutate;
    if (Ax(t) !== "FeatureCollection")
      throw new Error("geojson must be a FeatureCollection");
    if (!t.features.length)
      throw new Error("geojson is empty");
    (i === !1 || i === void 0) && (t = cx(t));
    const r = Gre(t);
    if (!r)
      throw new Error("geojson must be homogenous");
    const n = t;
    switch (r) {
      case "LineString":
        return Lre(n, e);
      case "Polygon":
        return Pre(n, e);
      default:
        throw new Error(r + " is not supported");
    }
  }
  function Gre(t) {
    const e = {};
    wB(t, (r) => {
      e[r.geometry.type] = !0;
    });
    const i = Object.keys(e);
    return i.length === 1 ? i[0] : null;
  }
  function jre(t, e = {}) {
    const i = e.maxEdge || 1 / 0, r = Hre(t), n = fre(r);
    if (n.features = n.features.filter((o) => {
      const a = o.geometry.coordinates[0][0], A = o.geometry.coordinates[0][1], l = o.geometry.coordinates[0][2], c = N0(a, A, e), u = N0(A, l, e), d = N0(a, l, e);
      return c <= i && u <= i && d <= i;
    }), n.features.length < 1)
      return null;
    const s = Ore(n);
    return s.coordinates.length === 1 && (s.coordinates = s.coordinates[0], s.type = "Polygon"), eo(s);
  }
  function Hre(t) {
    const e = [], i = {};
    return Pie(t, (r) => {
      if (!r.geometry)
        return;
      const n = r.geometry.coordinates.join("-");
      Object.prototype.hasOwnProperty.call(i, n) || (e.push(r), i[n] = !0);
    }), ps(e);
  }
  var Jre = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, z0 = Math.ceil, Zn = Math.floor, un = "[BigNumber Error] ", cT = un + "Number primitive has more than 15 significant digits: ", xs = 1e14, pt = 14, uT = 9007199254740991, P0 = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], Za = 1e7, Tn = 1e9;
  function kL(t) {
    var e, i, r, n = E.prototype = { constructor: E, toString: null, valueOf: null }, s = new E(1), o = 20, a = 4, A = -7, l = 21, c = -1e7, u = 1e7, d = !1, h = 1, g = 0, f = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: " ",
      // non-breaking space
      suffix: ""
    }, p = "0123456789abcdefghijklmnopqrstuvwxyz", m = !0;
    function E(b, B) {
      var x, Q, v, T, S, D, F, R, Y = this;
      if (!(Y instanceof E)) return new E(b, B);
      if (B == null) {
        if (b && b._isBigNumber === !0) {
          Y.s = b.s, !b.c || b.e > u ? Y.c = Y.e = null : b.e < c ? Y.c = [Y.e = 0] : (Y.e = b.e, Y.c = b.c.slice());
          return;
        }
        if ((D = typeof b == "number") && b * 0 == 0) {
          if (Y.s = 1 / b < 0 ? (b = -b, -1) : 1, b === ~~b) {
            for (T = 0, S = b; S >= 10; S /= 10, T++) ;
            T > u ? Y.c = Y.e = null : (Y.e = T, Y.c = [b]);
            return;
          }
          R = String(b);
        } else {
          if (!Jre.test(R = String(b))) return r(Y, R, D);
          Y.s = R.charCodeAt(0) == 45 ? (R = R.slice(1), -1) : 1;
        }
        (T = R.indexOf(".")) > -1 && (R = R.replace(".", "")), (S = R.search(/e/i)) > 0 ? (T < 0 && (T = S), T += +R.slice(S + 1), R = R.substring(0, S)) : T < 0 && (T = R.length);
      } else {
        if (_i(B, 2, p.length, "Base"), B == 10 && m)
          return Y = new E(b), M(Y, o + Y.e + 1, a);
        if (R = String(b), D = typeof b == "number") {
          if (b * 0 != 0) return r(Y, R, D, B);
          if (Y.s = 1 / b < 0 ? (R = R.slice(1), -1) : 1, E.DEBUG && R.replace(/^0\.0*|\./, "").length > 15)
            throw Error(cT + b);
        } else
          Y.s = R.charCodeAt(0) === 45 ? (R = R.slice(1), -1) : 1;
        for (x = p.slice(0, B), T = S = 0, F = R.length; S < F; S++)
          if (x.indexOf(Q = R.charAt(S)) < 0) {
            if (Q == ".") {
              if (S > T) {
                T = F;
                continue;
              }
            } else if (!v && (R == R.toUpperCase() && (R = R.toLowerCase()) || R == R.toLowerCase() && (R = R.toUpperCase()))) {
              v = !0, S = -1, T = 0;
              continue;
            }
            return r(Y, String(b), D, B);
          }
        D = !1, R = i(R, B, 10, Y.s), (T = R.indexOf(".")) > -1 ? R = R.replace(".", "") : T = R.length;
      }
      for (S = 0; R.charCodeAt(S) === 48; S++) ;
      for (F = R.length; R.charCodeAt(--F) === 48; ) ;
      if (R = R.slice(S, ++F)) {
        if (F -= S, D && E.DEBUG && F > 15 && (b > uT || b !== Zn(b)))
          throw Error(cT + Y.s * b);
        if ((T = T - S - 1) > u)
          Y.c = Y.e = null;
        else if (T < c)
          Y.c = [Y.e = 0];
        else {
          if (Y.e = T, Y.c = [], S = (T + 1) % pt, T < 0 && (S += pt), S < F) {
            for (S && Y.c.push(+R.slice(0, S)), F -= pt; S < F; )
              Y.c.push(+R.slice(S, S += pt));
            S = pt - (R = R.slice(S)).length;
          } else
            S -= F;
          for (; S--; R += "0") ;
          Y.c.push(+R);
        }
      } else
        Y.c = [Y.e = 0];
    }
    E.clone = kL, E.ROUND_UP = 0, E.ROUND_DOWN = 1, E.ROUND_CEIL = 2, E.ROUND_FLOOR = 3, E.ROUND_HALF_UP = 4, E.ROUND_HALF_DOWN = 5, E.ROUND_HALF_EVEN = 6, E.ROUND_HALF_CEIL = 7, E.ROUND_HALF_FLOOR = 8, E.EUCLID = 9, E.config = E.set = function(b) {
      var B, x;
      if (b != null)
        if (typeof b == "object") {
          if (b.hasOwnProperty(B = "DECIMAL_PLACES") && (x = b[B], _i(x, 0, Tn, B), o = x), b.hasOwnProperty(B = "ROUNDING_MODE") && (x = b[B], _i(x, 0, 8, B), a = x), b.hasOwnProperty(B = "EXPONENTIAL_AT") && (x = b[B], x && x.pop ? (_i(x[0], -1e9, 0, B), _i(x[1], 0, Tn, B), A = x[0], l = x[1]) : (_i(x, -1e9, Tn, B), A = -(l = x < 0 ? -x : x))), b.hasOwnProperty(B = "RANGE"))
            if (x = b[B], x && x.pop)
              _i(x[0], -1e9, -1, B), _i(x[1], 1, Tn, B), c = x[0], u = x[1];
            else if (_i(x, -1e9, Tn, B), x)
              c = -(u = x < 0 ? -x : x);
            else
              throw Error(un + B + " cannot be zero: " + x);
          if (b.hasOwnProperty(B = "CRYPTO"))
            if (x = b[B], x === !!x)
              if (x)
                if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                  d = x;
                else
                  throw d = !x, Error(un + "crypto unavailable");
              else
                d = x;
            else
              throw Error(un + B + " not true or false: " + x);
          if (b.hasOwnProperty(B = "MODULO_MODE") && (x = b[B], _i(x, 0, 9, B), h = x), b.hasOwnProperty(B = "POW_PRECISION") && (x = b[B], _i(x, 0, Tn, B), g = x), b.hasOwnProperty(B = "FORMAT"))
            if (x = b[B], typeof x == "object") f = x;
            else throw Error(un + B + " not an object: " + x);
          if (b.hasOwnProperty(B = "ALPHABET"))
            if (x = b[B], typeof x == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(x))
              m = x.slice(0, 10) == "0123456789", p = x;
            else
              throw Error(un + B + " invalid: " + x);
        } else
          throw Error(un + "Object expected: " + b);
      return {
        DECIMAL_PLACES: o,
        ROUNDING_MODE: a,
        EXPONENTIAL_AT: [A, l],
        RANGE: [c, u],
        CRYPTO: d,
        MODULO_MODE: h,
        POW_PRECISION: g,
        FORMAT: f,
        ALPHABET: p
      };
    }, E.isBigNumber = function(b) {
      if (!b || b._isBigNumber !== !0) return !1;
      if (!E.DEBUG) return !0;
      var B, x, Q = b.c, v = b.e, T = b.s;
      e: if ({}.toString.call(Q) == "[object Array]") {
        if ((T === 1 || T === -1) && v >= -1e9 && v <= Tn && v === Zn(v)) {
          if (Q[0] === 0) {
            if (v === 0 && Q.length === 1) return !0;
            break e;
          }
          if (B = (v + 1) % pt, B < 1 && (B += pt), String(Q[0]).length == B) {
            for (B = 0; B < Q.length; B++)
              if (x = Q[B], x < 0 || x >= xs || x !== Zn(x)) break e;
            if (x !== 0) return !0;
          }
        }
      } else if (Q === null && v === null && (T === null || T === 1 || T === -1))
        return !0;
      throw Error(un + "Invalid BigNumber: " + b);
    }, E.maximum = E.max = function() {
      return C(arguments, -1);
    }, E.minimum = E.min = function() {
      return C(arguments, 1);
    }, E.random = function() {
      var b = 9007199254740992, B = Math.random() * b & 2097151 ? function() {
        return Zn(Math.random() * b);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(x) {
        var Q, v, T, S, D, F = 0, R = [], Y = new E(s);
        if (x == null ? x = o : _i(x, 0, Tn), S = z0(x / pt), d)
          if (crypto.getRandomValues) {
            for (Q = crypto.getRandomValues(new Uint32Array(S *= 2)); F < S; )
              D = Q[F] * 131072 + (Q[F + 1] >>> 11), D >= 9e15 ? (v = crypto.getRandomValues(new Uint32Array(2)), Q[F] = v[0], Q[F + 1] = v[1]) : (R.push(D % 1e14), F += 2);
            F = S / 2;
          } else if (crypto.randomBytes) {
            for (Q = crypto.randomBytes(S *= 7); F < S; )
              D = (Q[F] & 31) * 281474976710656 + Q[F + 1] * 1099511627776 + Q[F + 2] * 4294967296 + Q[F + 3] * 16777216 + (Q[F + 4] << 16) + (Q[F + 5] << 8) + Q[F + 6], D >= 9e15 ? crypto.randomBytes(7).copy(Q, F) : (R.push(D % 1e14), F += 7);
            F = S / 7;
          } else
            throw d = !1, Error(un + "crypto unavailable");
        if (!d)
          for (; F < S; )
            D = B(), D < 9e15 && (R[F++] = D % 1e14);
        for (S = R[--F], x %= pt, S && x && (D = P0[pt - x], R[F] = Zn(S / D) * D); R[F] === 0; R.pop(), F--) ;
        if (F < 0)
          R = [T = 0];
        else {
          for (T = -1; R[0] === 0; R.splice(0, 1), T -= pt) ;
          for (F = 1, D = R[0]; D >= 10; D /= 10, F++) ;
          F < pt && (T -= pt - F);
        }
        return Y.e = T, Y.c = R, Y;
      };
    }(), E.sum = function() {
      for (var b = 1, B = arguments, x = new E(B[0]); b < B.length; ) x = x.plus(B[b++]);
      return x;
    }, i = /* @__PURE__ */ function() {
      var b = "0123456789";
      function B(x, Q, v, T) {
        for (var S, D = [0], F, R = 0, Y = x.length; R < Y; ) {
          for (F = D.length; F--; D[F] *= Q) ;
          for (D[0] += T.indexOf(x.charAt(R++)), S = 0; S < D.length; S++)
            D[S] > v - 1 && (D[S + 1] == null && (D[S + 1] = 0), D[S + 1] += D[S] / v | 0, D[S] %= v);
        }
        return D.reverse();
      }
      return function(x, Q, v, T, S) {
        var D, F, R, Y, L, N, H, P, ie = x.indexOf("."), V = o, Z = a;
        for (ie >= 0 && (Y = g, g = 0, x = x.replace(".", ""), P = new E(Q), N = P.pow(x.length - ie), g = Y, P.c = B(
          Xo(Kn(N.c), N.e, "0"),
          10,
          v,
          b
        ), P.e = P.c.length), H = B(x, Q, v, S ? (D = p, b) : (D = b, p)), R = Y = H.length; H[--Y] == 0; H.pop()) ;
        if (!H[0]) return D.charAt(0);
        if (ie < 0 ? --R : (N.c = H, N.e = R, N.s = T, N = e(N, P, V, Z, v), H = N.c, L = N.r, R = N.e), F = R + V + 1, ie = H[F], Y = v / 2, L = L || F < 0 || H[F + 1] != null, L = Z < 4 ? (ie != null || L) && (Z == 0 || Z == (N.s < 0 ? 3 : 2)) : ie > Y || ie == Y && (Z == 4 || L || Z == 6 && H[F - 1] & 1 || Z == (N.s < 0 ? 8 : 7)), F < 1 || !H[0])
          x = L ? Xo(D.charAt(1), -V, D.charAt(0)) : D.charAt(0);
        else {
          if (H.length = F, L)
            for (--v; ++H[--F] > v; )
              H[F] = 0, F || (++R, H = [1].concat(H));
          for (Y = H.length; !H[--Y]; ) ;
          for (ie = 0, x = ""; ie <= Y; x += D.charAt(H[ie++])) ;
          x = Xo(x, R, D.charAt(0));
        }
        return x;
      };
    }(), e = /* @__PURE__ */ function() {
      function b(Q, v, T) {
        var S, D, F, R, Y = 0, L = Q.length, N = v % Za, H = v / Za | 0;
        for (Q = Q.slice(); L--; )
          F = Q[L] % Za, R = Q[L] / Za | 0, S = H * F + R * N, D = N * F + S % Za * Za + Y, Y = (D / T | 0) + (S / Za | 0) + H * R, Q[L] = D % T;
        return Y && (Q = [Y].concat(Q)), Q;
      }
      function B(Q, v, T, S) {
        var D, F;
        if (T != S)
          F = T > S ? 1 : -1;
        else
          for (D = F = 0; D < T; D++)
            if (Q[D] != v[D]) {
              F = Q[D] > v[D] ? 1 : -1;
              break;
            }
        return F;
      }
      function x(Q, v, T, S) {
        for (var D = 0; T--; )
          Q[T] -= D, D = Q[T] < v[T] ? 1 : 0, Q[T] = D * S + Q[T] - v[T];
        for (; !Q[0] && Q.length > 1; Q.splice(0, 1)) ;
      }
      return function(Q, v, T, S, D) {
        var F, R, Y, L, N, H, P, ie, V, Z, se, k, _, q, U, J, ae, $ = Q.s == v.s ? 1 : -1, Ce = Q.c, Re = v.c;
        if (!Ce || !Ce[0] || !Re || !Re[0])
          return new E(
            // Return NaN if either NaN, or both Infinity or 0.
            !Q.s || !v.s || (Ce ? Re && Ce[0] == Re[0] : !Re) ? NaN : (
              // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
              Ce && Ce[0] == 0 || !Re ? $ * 0 : $ / 0
            )
          );
        for (ie = new E($), V = ie.c = [], R = Q.e - v.e, $ = T + R + 1, D || (D = xs, R = qn(Q.e / pt) - qn(v.e / pt), $ = $ / pt | 0), Y = 0; Re[Y] == (Ce[Y] || 0); Y++) ;
        if (Re[Y] > (Ce[Y] || 0) && R--, $ < 0)
          V.push(1), L = !0;
        else {
          for (q = Ce.length, J = Re.length, Y = 0, $ += 2, N = Zn(D / (Re[0] + 1)), N > 1 && (Re = b(Re, N, D), Ce = b(Ce, N, D), J = Re.length, q = Ce.length), _ = J, Z = Ce.slice(0, J), se = Z.length; se < J; Z[se++] = 0) ;
          ae = Re.slice(), ae = [0].concat(ae), U = Re[0], Re[1] >= D / 2 && U++;
          do {
            if (N = 0, F = B(Re, Z, J, se), F < 0) {
              if (k = Z[0], J != se && (k = k * D + (Z[1] || 0)), N = Zn(k / U), N > 1)
                for (N >= D && (N = D - 1), H = b(Re, N, D), P = H.length, se = Z.length; B(H, Z, P, se) == 1; )
                  N--, x(H, J < P ? ae : Re, P, D), P = H.length, F = 1;
              else
                N == 0 && (F = N = 1), H = Re.slice(), P = H.length;
              if (P < se && (H = [0].concat(H)), x(Z, H, se, D), se = Z.length, F == -1)
                for (; B(Re, Z, J, se) < 1; )
                  N++, x(Z, J < se ? ae : Re, se, D), se = Z.length;
            } else F === 0 && (N++, Z = [0]);
            V[Y++] = N, Z[0] ? Z[se++] = Ce[_] || 0 : (Z = [Ce[_]], se = 1);
          } while ((_++ < q || Z[0] != null) && $--);
          L = Z[0] != null, V[0] || V.splice(0, 1);
        }
        if (D == xs) {
          for (Y = 1, $ = V[0]; $ >= 10; $ /= 10, Y++) ;
          M(ie, T + (ie.e = Y + R * pt - 1) + 1, S, L);
        } else
          ie.e = R, ie.r = +L;
        return ie;
      };
    }();
    function y(b, B, x, Q) {
      var v, T, S, D, F;
      if (x == null ? x = a : _i(x, 0, 8), !b.c) return b.toString();
      if (v = b.c[0], S = b.e, B == null)
        F = Kn(b.c), F = Q == 1 || Q == 2 && (S <= A || S >= l) ? bp(F, S) : Xo(F, S, "0");
      else if (b = M(new E(b), B, x), T = b.e, F = Kn(b.c), D = F.length, Q == 1 || Q == 2 && (B <= T || T <= A)) {
        for (; D < B; F += "0", D++) ;
        F = bp(F, T);
      } else if (B -= S, F = Xo(F, T, "0"), T + 1 > D) {
        if (--B > 0) for (F += "."; B--; F += "0") ;
      } else if (B += T - D, B > 0)
        for (T + 1 == D && (F += "."); B--; F += "0") ;
      return b.s < 0 && v ? "-" + F : F;
    }
    function C(b, B) {
      for (var x, Q, v = 1, T = new E(b[0]); v < b.length; v++)
        Q = new E(b[v]), (!Q.s || (x = il(T, Q)) === B || x === 0 && T.s === B) && (T = Q);
      return T;
    }
    function w(b, B, x) {
      for (var Q = 1, v = B.length; !B[--v]; B.pop()) ;
      for (v = B[0]; v >= 10; v /= 10, Q++) ;
      return (x = Q + x * pt - 1) > u ? b.c = b.e = null : x < c ? b.c = [b.e = 0] : (b.e = x, b.c = B), b;
    }
    r = /* @__PURE__ */ function() {
      var b = /^(-?)0([xbo])(?=\w[\w.]*$)/i, B = /^([^.]+)\.$/, x = /^\.([^.]+)$/, Q = /^-?(Infinity|NaN)$/, v = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(T, S, D, F) {
        var R, Y = D ? S : S.replace(v, "");
        if (Q.test(Y))
          T.s = isNaN(Y) ? null : Y < 0 ? -1 : 1;
        else {
          if (!D && (Y = Y.replace(b, function(L, N, H) {
            return R = (H = H.toLowerCase()) == "x" ? 16 : H == "b" ? 2 : 8, !F || F == R ? N : L;
          }), F && (R = F, Y = Y.replace(B, "$1").replace(x, "0.$1")), S != Y))
            return new E(Y, R);
          if (E.DEBUG)
            throw Error(un + "Not a" + (F ? " base " + F : "") + " number: " + S);
          T.s = null;
        }
        T.c = T.e = null;
      };
    }();
    function M(b, B, x, Q) {
      var v, T, S, D, F, R, Y, L = b.c, N = P0;
      if (L) {
        e: {
          for (v = 1, D = L[0]; D >= 10; D /= 10, v++) ;
          if (T = B - v, T < 0)
            T += pt, S = B, F = L[R = 0], Y = Zn(F / N[v - S - 1] % 10);
          else if (R = z0((T + 1) / pt), R >= L.length)
            if (Q) {
              for (; L.length <= R; L.push(0)) ;
              F = Y = 0, v = 1, T %= pt, S = T - pt + 1;
            } else
              break e;
          else {
            for (F = D = L[R], v = 1; D >= 10; D /= 10, v++) ;
            T %= pt, S = T - pt + v, Y = S < 0 ? 0 : Zn(F / N[v - S - 1] % 10);
          }
          if (Q = Q || B < 0 || // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          L[R + 1] != null || (S < 0 ? F : F % N[v - S - 1]), Q = x < 4 ? (Y || Q) && (x == 0 || x == (b.s < 0 ? 3 : 2)) : Y > 5 || Y == 5 && (x == 4 || Q || x == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (T > 0 ? S > 0 ? F / N[v - S] : 0 : L[R - 1]) % 10 & 1 || x == (b.s < 0 ? 8 : 7)), B < 1 || !L[0])
            return L.length = 0, Q ? (B -= b.e + 1, L[0] = N[(pt - B % pt) % pt], b.e = -B || 0) : L[0] = b.e = 0, b;
          if (T == 0 ? (L.length = R, D = 1, R--) : (L.length = R + 1, D = N[pt - T], L[R] = S > 0 ? Zn(F / N[v - S] % N[S]) * D : 0), Q)
            for (; ; )
              if (R == 0) {
                for (T = 1, S = L[0]; S >= 10; S /= 10, T++) ;
                for (S = L[0] += D, D = 1; S >= 10; S /= 10, D++) ;
                T != D && (b.e++, L[0] == xs && (L[0] = 1));
                break;
              } else {
                if (L[R] += D, L[R] != xs) break;
                L[R--] = 0, D = 1;
              }
          for (T = L.length; L[--T] === 0; L.pop()) ;
        }
        b.e > u ? b.c = b.e = null : b.e < c && (b.c = [b.e = 0]);
      }
      return b;
    }
    function I(b) {
      var B, x = b.e;
      return x === null ? b.toString() : (B = Kn(b.c), B = x <= A || x >= l ? bp(B, x) : Xo(B, x, "0"), b.s < 0 ? "-" + B : B);
    }
    return n.absoluteValue = n.abs = function() {
      var b = new E(this);
      return b.s < 0 && (b.s = 1), b;
    }, n.comparedTo = function(b, B) {
      return il(this, new E(b, B));
    }, n.decimalPlaces = n.dp = function(b, B) {
      var x, Q, v, T = this;
      if (b != null)
        return _i(b, 0, Tn), B == null ? B = a : _i(B, 0, 8), M(new E(T), b + T.e + 1, B);
      if (!(x = T.c)) return null;
      if (Q = ((v = x.length - 1) - qn(this.e / pt)) * pt, v = x[v]) for (; v % 10 == 0; v /= 10, Q--) ;
      return Q < 0 && (Q = 0), Q;
    }, n.dividedBy = n.div = function(b, B) {
      return e(this, new E(b, B), o, a);
    }, n.dividedToIntegerBy = n.idiv = function(b, B) {
      return e(this, new E(b, B), 0, 1);
    }, n.exponentiatedBy = n.pow = function(b, B) {
      var x, Q, v, T, S, D, F, R, Y, L = this;
      if (b = new E(b), b.c && !b.isInteger())
        throw Error(un + "Exponent not an integer: " + I(b));
      if (B != null && (B = new E(B)), D = b.e > 14, !L.c || !L.c[0] || L.c[0] == 1 && !L.e && L.c.length == 1 || !b.c || !b.c[0])
        return Y = new E(Math.pow(+I(L), D ? b.s * (2 - Cp(b)) : +I(b))), B ? Y.mod(B) : Y;
      if (F = b.s < 0, B) {
        if (B.c ? !B.c[0] : !B.s) return new E(NaN);
        Q = !F && L.isInteger() && B.isInteger(), Q && (L = L.mod(B));
      } else {
        if (b.e > 9 && (L.e > 0 || L.e < -1 || (L.e == 0 ? L.c[0] > 1 || D && L.c[1] >= 24e7 : L.c[0] < 8e13 || D && L.c[0] <= 9999975e7)))
          return T = L.s < 0 && Cp(b) ? -0 : 0, L.e > -1 && (T = 1 / T), new E(F ? 1 / T : T);
        g && (T = z0(g / pt + 2));
      }
      for (D ? (x = new E(0.5), F && (b.s = 1), R = Cp(b)) : (v = Math.abs(+I(b)), R = v % 2), Y = new E(s); ; ) {
        if (R) {
          if (Y = Y.times(L), !Y.c) break;
          T ? Y.c.length > T && (Y.c.length = T) : Q && (Y = Y.mod(B));
        }
        if (v) {
          if (v = Zn(v / 2), v === 0) break;
          R = v % 2;
        } else if (b = b.times(x), M(b, b.e + 1, 1), b.e > 14)
          R = Cp(b);
        else {
          if (v = +I(b), v === 0) break;
          R = v % 2;
        }
        L = L.times(L), T ? L.c && L.c.length > T && (L.c.length = T) : Q && (L = L.mod(B));
      }
      return Q ? Y : (F && (Y = s.div(Y)), B ? Y.mod(B) : T ? M(Y, g, a, S) : Y);
    }, n.integerValue = function(b) {
      var B = new E(this);
      return b == null ? b = a : _i(b, 0, 8), M(B, B.e + 1, b);
    }, n.isEqualTo = n.eq = function(b, B) {
      return il(this, new E(b, B)) === 0;
    }, n.isFinite = function() {
      return !!this.c;
    }, n.isGreaterThan = n.gt = function(b, B) {
      return il(this, new E(b, B)) > 0;
    }, n.isGreaterThanOrEqualTo = n.gte = function(b, B) {
      return (B = il(this, new E(b, B))) === 1 || B === 0;
    }, n.isInteger = function() {
      return !!this.c && qn(this.e / pt) > this.c.length - 2;
    }, n.isLessThan = n.lt = function(b, B) {
      return il(this, new E(b, B)) < 0;
    }, n.isLessThanOrEqualTo = n.lte = function(b, B) {
      return (B = il(this, new E(b, B))) === -1 || B === 0;
    }, n.isNaN = function() {
      return !this.s;
    }, n.isNegative = function() {
      return this.s < 0;
    }, n.isPositive = function() {
      return this.s > 0;
    }, n.isZero = function() {
      return !!this.c && this.c[0] == 0;
    }, n.minus = function(b, B) {
      var x, Q, v, T, S = this, D = S.s;
      if (b = new E(b, B), B = b.s, !D || !B) return new E(NaN);
      if (D != B)
        return b.s = -B, S.plus(b);
      var F = S.e / pt, R = b.e / pt, Y = S.c, L = b.c;
      if (!F || !R) {
        if (!Y || !L) return Y ? (b.s = -B, b) : new E(L ? S : NaN);
        if (!Y[0] || !L[0])
          return L[0] ? (b.s = -B, b) : new E(Y[0] ? S : (
            // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            a == 3 ? -0 : 0
          ));
      }
      if (F = qn(F), R = qn(R), Y = Y.slice(), D = F - R) {
        for ((T = D < 0) ? (D = -D, v = Y) : (R = F, v = L), v.reverse(), B = D; B--; v.push(0)) ;
        v.reverse();
      } else
        for (Q = (T = (D = Y.length) < (B = L.length)) ? D : B, D = B = 0; B < Q; B++)
          if (Y[B] != L[B]) {
            T = Y[B] < L[B];
            break;
          }
      if (T && (v = Y, Y = L, L = v, b.s = -b.s), B = (Q = L.length) - (x = Y.length), B > 0) for (; B--; Y[x++] = 0) ;
      for (B = xs - 1; Q > D; ) {
        if (Y[--Q] < L[Q]) {
          for (x = Q; x && !Y[--x]; Y[x] = B) ;
          --Y[x], Y[Q] += xs;
        }
        Y[Q] -= L[Q];
      }
      for (; Y[0] == 0; Y.splice(0, 1), --R) ;
      return Y[0] ? w(b, Y, R) : (b.s = a == 3 ? -1 : 1, b.c = [b.e = 0], b);
    }, n.modulo = n.mod = function(b, B) {
      var x, Q, v = this;
      return b = new E(b, B), !v.c || !b.s || b.c && !b.c[0] ? new E(NaN) : !b.c || v.c && !v.c[0] ? new E(v) : (h == 9 ? (Q = b.s, b.s = 1, x = e(v, b, 0, 3), b.s = Q, x.s *= Q) : x = e(v, b, 0, h), b = v.minus(x.times(b)), !b.c[0] && h == 1 && (b.s = v.s), b);
    }, n.multipliedBy = n.times = function(b, B) {
      var x, Q, v, T, S, D, F, R, Y, L, N, H, P, ie, V, Z = this, se = Z.c, k = (b = new E(b, B)).c;
      if (!se || !k || !se[0] || !k[0])
        return !Z.s || !b.s || se && !se[0] && !k || k && !k[0] && !se ? b.c = b.e = b.s = null : (b.s *= Z.s, !se || !k ? b.c = b.e = null : (b.c = [0], b.e = 0)), b;
      for (Q = qn(Z.e / pt) + qn(b.e / pt), b.s *= Z.s, F = se.length, L = k.length, F < L && (P = se, se = k, k = P, v = F, F = L, L = v), v = F + L, P = []; v--; P.push(0)) ;
      for (ie = xs, V = Za, v = L; --v >= 0; ) {
        for (x = 0, N = k[v] % V, H = k[v] / V | 0, S = F, T = v + S; T > v; )
          R = se[--S] % V, Y = se[S] / V | 0, D = H * R + Y * N, R = N * R + D % V * V + P[T] + x, x = (R / ie | 0) + (D / V | 0) + H * Y, P[T--] = R % ie;
        P[T] = x;
      }
      return x ? ++Q : P.splice(0, 1), w(b, P, Q);
    }, n.negated = function() {
      var b = new E(this);
      return b.s = -b.s || null, b;
    }, n.plus = function(b, B) {
      var x, Q = this, v = Q.s;
      if (b = new E(b, B), B = b.s, !v || !B) return new E(NaN);
      if (v != B)
        return b.s = -B, Q.minus(b);
      var T = Q.e / pt, S = b.e / pt, D = Q.c, F = b.c;
      if (!T || !S) {
        if (!D || !F) return new E(v / 0);
        if (!D[0] || !F[0]) return F[0] ? b : new E(D[0] ? Q : v * 0);
      }
      if (T = qn(T), S = qn(S), D = D.slice(), v = T - S) {
        for (v > 0 ? (S = T, x = F) : (v = -v, x = D), x.reverse(); v--; x.push(0)) ;
        x.reverse();
      }
      for (v = D.length, B = F.length, v - B < 0 && (x = F, F = D, D = x, B = v), v = 0; B; )
        v = (D[--B] = D[B] + F[B] + v) / xs | 0, D[B] = xs === D[B] ? 0 : D[B] % xs;
      return v && (D = [v].concat(D), ++S), w(b, D, S);
    }, n.precision = n.sd = function(b, B) {
      var x, Q, v, T = this;
      if (b != null && b !== !!b)
        return _i(b, 1, Tn), B == null ? B = a : _i(B, 0, 8), M(new E(T), b, B);
      if (!(x = T.c)) return null;
      if (v = x.length - 1, Q = v * pt + 1, v = x[v]) {
        for (; v % 10 == 0; v /= 10, Q--) ;
        for (v = x[0]; v >= 10; v /= 10, Q++) ;
      }
      return b && T.e + 1 > Q && (Q = T.e + 1), Q;
    }, n.shiftedBy = function(b) {
      return _i(b, -9007199254740991, uT), this.times("1e" + b);
    }, n.squareRoot = n.sqrt = function() {
      var b, B, x, Q, v, T = this, S = T.c, D = T.s, F = T.e, R = o + 4, Y = new E("0.5");
      if (D !== 1 || !S || !S[0])
        return new E(!D || D < 0 && (!S || S[0]) ? NaN : S ? T : 1 / 0);
      if (D = Math.sqrt(+I(T)), D == 0 || D == 1 / 0 ? (B = Kn(S), (B.length + F) % 2 == 0 && (B += "0"), D = Math.sqrt(+B), F = qn((F + 1) / 2) - (F < 0 || F % 2), D == 1 / 0 ? B = "5e" + F : (B = D.toExponential(), B = B.slice(0, B.indexOf("e") + 1) + F), x = new E(B)) : x = new E(D + ""), x.c[0]) {
        for (F = x.e, D = F + R, D < 3 && (D = 0); ; )
          if (v = x, x = Y.times(v.plus(e(T, v, R, 1))), Kn(v.c).slice(0, D) === (B = Kn(x.c)).slice(0, D))
            if (x.e < F && --D, B = B.slice(D - 3, D + 1), B == "9999" || !Q && B == "4999") {
              if (!Q && (M(v, v.e + o + 2, 0), v.times(v).eq(T))) {
                x = v;
                break;
              }
              R += 4, D += 4, Q = 1;
            } else {
              (!+B || !+B.slice(1) && B.charAt(0) == "5") && (M(x, x.e + o + 2, 1), b = !x.times(x).eq(T));
              break;
            }
      }
      return M(x, x.e + o + 1, a, b);
    }, n.toExponential = function(b, B) {
      return b != null && (_i(b, 0, Tn), b++), y(this, b, B, 1);
    }, n.toFixed = function(b, B) {
      return b != null && (_i(b, 0, Tn), b = b + this.e + 1), y(this, b, B);
    }, n.toFormat = function(b, B, x) {
      var Q, v = this;
      if (x == null)
        b != null && B && typeof B == "object" ? (x = B, B = null) : b && typeof b == "object" ? (x = b, b = B = null) : x = f;
      else if (typeof x != "object")
        throw Error(un + "Argument not an object: " + x);
      if (Q = v.toFixed(b, B), v.c) {
        var T, S = Q.split("."), D = +x.groupSize, F = +x.secondaryGroupSize, R = x.groupSeparator || "", Y = S[0], L = S[1], N = v.s < 0, H = N ? Y.slice(1) : Y, P = H.length;
        if (F && (T = D, D = F, F = T, P -= T), D > 0 && P > 0) {
          for (T = P % D || D, Y = H.substr(0, T); T < P; T += D) Y += R + H.substr(T, D);
          F > 0 && (Y += R + H.slice(T)), N && (Y = "-" + Y);
        }
        Q = L ? Y + (x.decimalSeparator || "") + ((F = +x.fractionGroupSize) ? L.replace(
          new RegExp("\\d{" + F + "}\\B", "g"),
          "$&" + (x.fractionGroupSeparator || "")
        ) : L) : Y;
      }
      return (x.prefix || "") + Q + (x.suffix || "");
    }, n.toFraction = function(b) {
      var B, x, Q, v, T, S, D, F, R, Y, L, N, H = this, P = H.c;
      if (b != null && (D = new E(b), !D.isInteger() && (D.c || D.s !== 1) || D.lt(s)))
        throw Error(un + "Argument " + (D.isInteger() ? "out of range: " : "not an integer: ") + I(D));
      if (!P) return new E(H);
      for (B = new E(s), R = x = new E(s), Q = F = new E(s), N = Kn(P), T = B.e = N.length - H.e - 1, B.c[0] = P0[(S = T % pt) < 0 ? pt + S : S], b = !b || D.comparedTo(B) > 0 ? T > 0 ? B : R : D, S = u, u = 1 / 0, D = new E(N), F.c[0] = 0; Y = e(D, B, 0, 1), v = x.plus(Y.times(Q)), v.comparedTo(b) != 1; )
        x = Q, Q = v, R = F.plus(Y.times(v = R)), F = v, B = D.minus(Y.times(v = B)), D = v;
      return v = e(b.minus(x), Q, 0, 1), F = F.plus(v.times(R)), x = x.plus(v.times(Q)), F.s = R.s = H.s, T = T * 2, L = e(R, Q, T, a).minus(H).abs().comparedTo(
        e(F, x, T, a).minus(H).abs()
      ) < 1 ? [R, Q] : [F, x], u = S, L;
    }, n.toNumber = function() {
      return +I(this);
    }, n.toPrecision = function(b, B) {
      return b != null && _i(b, 1, Tn), y(this, b, B, 2);
    }, n.toString = function(b) {
      var B, x = this, Q = x.s, v = x.e;
      return v === null ? Q ? (B = "Infinity", Q < 0 && (B = "-" + B)) : B = "NaN" : (b == null ? B = v <= A || v >= l ? bp(Kn(x.c), v) : Xo(Kn(x.c), v, "0") : b === 10 && m ? (x = M(new E(x), o + v + 1, a), B = Xo(Kn(x.c), x.e, "0")) : (_i(b, 2, p.length, "Base"), B = i(Xo(Kn(x.c), v, "0"), 10, b, Q, !0)), Q < 0 && x.c[0] && (B = "-" + B)), B;
    }, n.valueOf = n.toJSON = function() {
      return I(this);
    }, n._isBigNumber = !0, n[Symbol.toStringTag] = "BigNumber", n[Symbol.for("nodejs.util.inspect.custom")] = n.valueOf, t != null && E.set(t), E;
  }
  function qn(t) {
    var e = t | 0;
    return t > 0 || t === e ? e : e - 1;
  }
  function Kn(t) {
    for (var e, i, r = 1, n = t.length, s = t[0] + ""; r < n; ) {
      for (e = t[r++] + "", i = pt - e.length; i--; e = "0" + e) ;
      s += e;
    }
    for (n = s.length; s.charCodeAt(--n) === 48; ) ;
    return s.slice(0, n + 1 || 1);
  }
  function il(t, e) {
    var i, r, n = t.c, s = e.c, o = t.s, a = e.s, A = t.e, l = e.e;
    if (!o || !a) return null;
    if (i = n && !n[0], r = s && !s[0], i || r) return i ? r ? 0 : -a : o;
    if (o != a) return o;
    if (i = o < 0, r = A == l, !n || !s) return r ? 0 : !n ^ i ? 1 : -1;
    if (!r) return A > l ^ i ? 1 : -1;
    for (a = (A = n.length) < (l = s.length) ? A : l, o = 0; o < a; o++) if (n[o] != s[o]) return n[o] > s[o] ^ i ? 1 : -1;
    return A == l ? 0 : A > l ^ i ? 1 : -1;
  }
  function _i(t, e, i, r) {
    if (t < e || t > i || t !== Zn(t))
      throw Error(un + (r || "Argument") + (typeof t == "number" ? t < e || t > i ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t));
  }
  function Cp(t) {
    var e = t.c.length - 1;
    return qn(t.e / pt) == e && t.c[e] % 2 != 0;
  }
  function bp(t, e) {
    return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (e < 0 ? "e" : "e+") + e;
  }
  function Xo(t, e, i) {
    var r, n;
    if (e < 0) {
      for (n = i + "."; ++e; n += i) ;
      t = n + t;
    } else if (r = t.length, ++e > r) {
      for (n = i, e -= r; --e; n += i) ;
      t += n;
    } else e < r && (t = t.slice(0, e) + "." + t.slice(e));
    return t;
  }
  var Io = kL(), Vre = class {
    constructor(t) {
      Ne(this, "key");
      Ne(this, "left", null);
      Ne(this, "right", null);
      this.key = t;
    }
  }, sh = class extends Vre {
    constructor(t) {
      super(t);
    }
  }, Wre = class {
    constructor() {
      Ne(this, "size", 0);
      Ne(this, "modificationCount", 0);
      Ne(this, "splayCount", 0);
    }
    splay(t) {
      const e = this.root;
      if (e == null)
        return this.compare(t, t), -1;
      let i = null, r = null, n = null, s = null, o = e;
      const a = this.compare;
      let A;
      for (; ; )
        if (A = a(o.key, t), A > 0) {
          let l = o.left;
          if (l == null || (A = a(l.key, t), A > 0 && (o.left = l.right, l.right = o, o = l, l = o.left, l == null)))
            break;
          i == null ? r = o : i.left = o, i = o, o = l;
        } else if (A < 0) {
          let l = o.right;
          if (l == null || (A = a(l.key, t), A < 0 && (o.right = l.left, l.left = o, o = l, l = o.right, l == null)))
            break;
          n == null ? s = o : n.right = o, n = o, o = l;
        } else
          break;
      return n != null && (n.right = o.left, o.left = s), i != null && (i.left = o.right, o.right = r), this.root !== o && (this.root = o, this.splayCount++), A;
    }
    splayMin(t) {
      let e = t, i = e.left;
      for (; i != null; ) {
        const r = i;
        e.left = r.right, r.right = e, e = r, i = e.left;
      }
      return e;
    }
    splayMax(t) {
      let e = t, i = e.right;
      for (; i != null; ) {
        const r = i;
        e.right = r.left, r.left = e, e = r, i = e.right;
      }
      return e;
    }
    _delete(t) {
      if (this.root == null || this.splay(t) != 0) return null;
      let i = this.root;
      const r = i, n = i.left;
      if (this.size--, n == null)
        this.root = i.right;
      else {
        const s = i.right;
        i = this.splayMax(n), i.right = s, this.root = i;
      }
      return this.modificationCount++, r;
    }
    addNewRoot(t, e) {
      this.size++, this.modificationCount++;
      const i = this.root;
      if (i == null) {
        this.root = t;
        return;
      }
      e < 0 ? (t.left = i, t.right = i.right, i.right = null) : (t.right = i, t.left = i.left, i.left = null), this.root = t;
    }
    _first() {
      const t = this.root;
      return t == null ? null : (this.root = this.splayMin(t), this.root);
    }
    _last() {
      const t = this.root;
      return t == null ? null : (this.root = this.splayMax(t), this.root);
    }
    clear() {
      this.root = null, this.size = 0, this.modificationCount++;
    }
    has(t) {
      return this.validKey(t) && this.splay(t) == 0;
    }
    defaultCompare() {
      return (t, e) => t < e ? -1 : t > e ? 1 : 0;
    }
    wrap() {
      return {
        getRoot: () => this.root,
        setRoot: (t) => {
          this.root = t;
        },
        getSize: () => this.size,
        getModificationCount: () => this.modificationCount,
        getSplayCount: () => this.splayCount,
        setSplayCount: (t) => {
          this.splayCount = t;
        },
        splay: (t) => this.splay(t),
        has: (t) => this.has(t)
      };
    }
  }, rk, nk, _E = class yh extends Wre {
    constructor(i, r) {
      super();
      Ne(this, "root", null);
      Ne(this, "compare");
      Ne(this, "validKey");
      Ne(this, rk, "[object Set]");
      this.compare = i ?? this.defaultCompare(), this.validKey = r ?? ((n) => n != null && n != null);
    }
    delete(i) {
      return this.validKey(i) ? this._delete(i) != null : !1;
    }
    deleteAll(i) {
      for (const r of i)
        this.delete(r);
    }
    forEach(i) {
      const r = this[Symbol.iterator]();
      let n;
      for (; n = r.next(), !n.done; )
        i(n.value, n.value, this);
    }
    add(i) {
      const r = this.splay(i);
      return r != 0 && this.addNewRoot(new sh(i), r), this;
    }
    addAndReturn(i) {
      const r = this.splay(i);
      return r != 0 && this.addNewRoot(new sh(i), r), this.root.key;
    }
    addAll(i) {
      for (const r of i)
        this.add(r);
    }
    isEmpty() {
      return this.root == null;
    }
    isNotEmpty() {
      return this.root != null;
    }
    single() {
      if (this.size == 0) throw "Bad state: No element";
      if (this.size > 1) throw "Bad state: Too many element";
      return this.root.key;
    }
    first() {
      if (this.size == 0) throw "Bad state: No element";
      return this._first().key;
    }
    last() {
      if (this.size == 0) throw "Bad state: No element";
      return this._last().key;
    }
    lastBefore(i) {
      if (i == null) throw "Invalid arguments(s)";
      if (this.root == null) return null;
      if (this.splay(i) < 0) return this.root.key;
      let n = this.root.left;
      if (n == null) return null;
      let s = n.right;
      for (; s != null; )
        n = s, s = n.right;
      return n.key;
    }
    firstAfter(i) {
      if (i == null) throw "Invalid arguments(s)";
      if (this.root == null) return null;
      if (this.splay(i) > 0) return this.root.key;
      let n = this.root.right;
      if (n == null) return null;
      let s = n.left;
      for (; s != null; )
        n = s, s = n.left;
      return n.key;
    }
    retainAll(i) {
      const r = new yh(this.compare, this.validKey), n = this.modificationCount;
      for (const s of i) {
        if (n != this.modificationCount)
          throw "Concurrent modification during iteration.";
        this.validKey(s) && this.splay(s) == 0 && r.add(this.root.key);
      }
      r.size != this.size && (this.root = r.root, this.size = r.size, this.modificationCount++);
    }
    lookup(i) {
      return !this.validKey(i) || this.splay(i) != 0 ? null : this.root.key;
    }
    intersection(i) {
      const r = new yh(this.compare, this.validKey);
      for (const n of this)
        i.has(n) && r.add(n);
      return r;
    }
    difference(i) {
      const r = new yh(this.compare, this.validKey);
      for (const n of this)
        i.has(n) || r.add(n);
      return r;
    }
    union(i) {
      const r = this.clone();
      return r.addAll(i), r;
    }
    clone() {
      const i = new yh(this.compare, this.validKey);
      return i.size = this.size, i.root = this.copyNode(this.root), i;
    }
    copyNode(i) {
      if (i == null) return null;
      function r(s, o) {
        let a, A;
        do {
          if (a = s.left, A = s.right, a != null) {
            const l = new sh(a.key);
            o.left = l, r(a, l);
          }
          if (A != null) {
            const l = new sh(A.key);
            o.right = l, s = A, o = l;
          }
        } while (A != null);
      }
      const n = new sh(i.key);
      return r(i, n), n;
    }
    toSet() {
      return this.clone();
    }
    entries() {
      return new Xre(this.wrap());
    }
    keys() {
      return this[Symbol.iterator]();
    }
    values() {
      return this[Symbol.iterator]();
    }
    [(nk = Symbol.iterator, rk = Symbol.toStringTag, nk)]() {
      return new Kre(this.wrap());
    }
  }, YL = class {
    constructor(t) {
      Ne(this, "tree");
      Ne(this, "path", new Array());
      Ne(this, "modificationCount", null);
      Ne(this, "splayCount");
      this.tree = t, this.splayCount = t.getSplayCount();
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null };
    }
    current() {
      if (!this.path.length) return null;
      const t = this.path[this.path.length - 1];
      return this.getValue(t);
    }
    rebuildPath(t) {
      this.path.splice(0, this.path.length), this.tree.splay(t), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
    }
    findLeftMostDescendent(t) {
      for (; t != null; )
        this.path.push(t), t = t.left;
    }
    moveNext() {
      if (this.modificationCount != this.tree.getModificationCount()) {
        if (this.modificationCount == null) {
          this.modificationCount = this.tree.getModificationCount();
          let i = this.tree.getRoot();
          for (; i != null; )
            this.path.push(i), i = i.left;
          return this.path.length > 0;
        }
        throw "Concurrent modification during iteration.";
      }
      if (!this.path.length) return !1;
      this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
      let t = this.path[this.path.length - 1], e = t.right;
      if (e != null) {
        for (; e != null; )
          this.path.push(e), e = e.left;
        return !0;
      }
      for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === t; )
        t = this.path.pop();
      return this.path.length > 0;
    }
  }, Kre = class extends YL {
    getValue(t) {
      return t.key;
    }
  }, Xre = class extends YL {
    getValue(t) {
      return [t.key, t.key];
    }
  }, NL = (t) => () => t, xb = (t) => {
    const e = t ? (i, r) => r.minus(i).abs().isLessThanOrEqualTo(t) : NL(!1);
    return (i, r) => e(i, r) ? 0 : i.comparedTo(r);
  };
  function Zre(t) {
    const e = t ? (i, r, n, s, o) => i.exponentiatedBy(2).isLessThanOrEqualTo(
      s.minus(r).exponentiatedBy(2).plus(o.minus(n).exponentiatedBy(2)).times(t)
    ) : NL(!1);
    return (i, r, n) => {
      const s = i.x, o = i.y, a = n.x, A = n.y, l = o.minus(A).times(r.x.minus(a)).minus(s.minus(a).times(r.y.minus(A)));
      return e(l, s, o, a, A) ? 0 : l.comparedTo(0);
    };
  }
  var qre = (t) => t, $re = (t) => {
    if (t) {
      const e = new _E(xb(t)), i = new _E(xb(t)), r = (s, o) => o.addAndReturn(s), n = (s) => ({
        x: r(s.x, e),
        y: r(s.y, i)
      });
      return n({ x: new Io(0), y: new Io(0) }), n;
    }
    return qre;
  }, Qb = (t) => ({
    set: (e) => {
      Ra = Qb(e);
    },
    reset: () => Qb(t),
    compare: xb(t),
    snap: $re(t),
    orient: Zre(t)
  }), Ra = Qb(), oh = (t, e) => t.ll.x.isLessThanOrEqualTo(e.x) && e.x.isLessThanOrEqualTo(t.ur.x) && t.ll.y.isLessThanOrEqualTo(e.y) && e.y.isLessThanOrEqualTo(t.ur.y), Fb = (t, e) => {
    if (e.ur.x.isLessThan(t.ll.x) || t.ur.x.isLessThan(e.ll.x) || e.ur.y.isLessThan(t.ll.y) || t.ur.y.isLessThan(e.ll.y))
      return null;
    const i = t.ll.x.isLessThan(e.ll.x) ? e.ll.x : t.ll.x, r = t.ur.x.isLessThan(e.ur.x) ? t.ur.x : e.ur.x, n = t.ll.y.isLessThan(e.ll.y) ? e.ll.y : t.ll.y, s = t.ur.y.isLessThan(e.ur.y) ? t.ur.y : e.ur.y;
    return { ll: { x: i, y: n }, ur: { x: r, y: s } };
  }, sm = (t, e) => t.x.times(e.y).minus(t.y.times(e.x)), UL = (t, e) => t.x.times(e.x).plus(t.y.times(e.y)), kE = (t) => UL(t, t).sqrt(), ene = (t, e, i) => {
    const r = { x: e.x.minus(t.x), y: e.y.minus(t.y) }, n = { x: i.x.minus(t.x), y: i.y.minus(t.y) };
    return sm(n, r).div(kE(n)).div(kE(r));
  }, tne = (t, e, i) => {
    const r = { x: e.x.minus(t.x), y: e.y.minus(t.y) }, n = { x: i.x.minus(t.x), y: i.y.minus(t.y) };
    return UL(n, r).div(kE(n)).div(kE(r));
  }, dT = (t, e, i) => e.y.isZero() ? null : { x: t.x.plus(e.x.div(e.y).times(i.minus(t.y))), y: i }, hT = (t, e, i) => e.x.isZero() ? null : { x: i, y: t.y.plus(e.y.div(e.x).times(i.minus(t.x))) }, ine = (t, e, i, r) => {
    if (e.x.isZero()) return hT(i, r, t.x);
    if (r.x.isZero()) return hT(t, e, i.x);
    if (e.y.isZero()) return dT(i, r, t.y);
    if (r.y.isZero()) return dT(t, e, i.y);
    const n = sm(e, r);
    if (n.isZero()) return null;
    const s = { x: i.x.minus(t.x), y: i.y.minus(t.y) }, o = sm(s, e).div(n), a = sm(s, r).div(n), A = t.x.plus(a.times(e.x)), l = i.x.plus(o.times(r.x)), c = t.y.plus(a.times(e.y)), u = i.y.plus(o.times(r.y)), d = A.plus(l).div(2), h = c.plus(u).div(2);
    return { x: d, y: h };
  }, Bo = class LL {
    // Warning: 'point' input will be modified and re-used (for performance)
    constructor(e, i) {
      Ne(this, "point");
      Ne(this, "isLeft");
      Ne(this, "segment");
      Ne(this, "otherSE");
      Ne(this, "consumedBy");
      e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = i;
    }
    // for ordering sweep events in the sweep event queue
    static compare(e, i) {
      const r = LL.comparePoints(e.point, i.point);
      return r !== 0 ? r : (e.point !== i.point && e.link(i), e.isLeft !== i.isLeft ? e.isLeft ? 1 : -1 : YE.compare(e.segment, i.segment));
    }
    // for ordering points in sweep line order
    static comparePoints(e, i) {
      return e.x.isLessThan(i.x) ? -1 : e.x.isGreaterThan(i.x) ? 1 : e.y.isLessThan(i.y) ? -1 : e.y.isGreaterThan(i.y) ? 1 : 0;
    }
    link(e) {
      if (e.point === this.point)
        throw new Error("Tried to link already linked events");
      const i = e.point.events;
      for (let r = 0, n = i.length; r < n; r++) {
        const s = i[r];
        this.point.events.push(s), s.point = this.point;
      }
      this.checkForConsuming();
    }
    /* Do a pass over our linked events and check to see if any pair
     * of segments match, and should be consumed. */
    checkForConsuming() {
      const e = this.point.events.length;
      for (let i = 0; i < e; i++) {
        const r = this.point.events[i];
        if (r.segment.consumedBy === void 0)
          for (let n = i + 1; n < e; n++) {
            const s = this.point.events[n];
            s.consumedBy === void 0 && r.otherSE.point.events === s.otherSE.point.events && r.segment.consume(s.segment);
          }
      }
    }
    getAvailableLinkedEvents() {
      const e = [];
      for (let i = 0, r = this.point.events.length; i < r; i++) {
        const n = this.point.events[i];
        n !== this && !n.segment.ringOut && n.segment.isInResult() && e.push(n);
      }
      return e;
    }
    /**
     * Returns a comparator function for sorting linked events that will
     * favor the event that will give us the smallest left-side angle.
     * All ring construction starts as low as possible heading to the right,
     * so by always turning left as sharp as possible we'll get polygons
     * without uncessary loops & holes.
     *
     * The comparator function has a compute cache such that it avoids
     * re-computing already-computed values.
     */
    getLeftmostComparator(e) {
      const i = /* @__PURE__ */ new Map(), r = (n) => {
        const s = n.otherSE;
        i.set(n, {
          sine: ene(this.point, e.point, s.point),
          cosine: tne(this.point, e.point, s.point)
        });
      };
      return (n, s) => {
        i.has(n) || r(n), i.has(s) || r(s);
        const { sine: o, cosine: a } = i.get(n), { sine: A, cosine: l } = i.get(s);
        return o.isGreaterThanOrEqualTo(0) && A.isGreaterThanOrEqualTo(0) ? a.isLessThan(l) ? 1 : a.isGreaterThan(l) ? -1 : 0 : o.isLessThan(0) && A.isLessThan(0) ? a.isLessThan(l) ? -1 : a.isGreaterThan(l) ? 1 : 0 : A.isLessThan(o) ? -1 : A.isGreaterThan(o) ? 1 : 0;
      };
    }
  }, rne = class Sb {
    constructor(e) {
      Ne(this, "events");
      Ne(this, "poly");
      Ne(this, "_isExteriorRing");
      Ne(this, "_enclosingRing");
      this.events = e;
      for (let i = 0, r = e.length; i < r; i++)
        e[i].segment.ringOut = this;
      this.poly = null;
    }
    /* Given the segments from the sweep line pass, compute & return a series
     * of closed rings from all the segments marked to be part of the result */
    static factory(e) {
      const i = [];
      for (let r = 0, n = e.length; r < n; r++) {
        const s = e[r];
        if (!s.isInResult() || s.ringOut) continue;
        let o = null, a = s.leftSE, A = s.rightSE;
        const l = [a], c = a.point, u = [];
        for (; o = a, a = A, l.push(a), a.point !== c; )
          for (; ; ) {
            const d = a.getAvailableLinkedEvents();
            if (d.length === 0) {
              const f = l[0].point, p = l[l.length - 1].point;
              throw new Error(
                `Unable to complete output ring starting at [${f.x}, ${f.y}]. Last matching segment found ends at [${p.x}, ${p.y}].`
              );
            }
            if (d.length === 1) {
              A = d[0].otherSE;
              break;
            }
            let h = null;
            for (let f = 0, p = u.length; f < p; f++)
              if (u[f].point === a.point) {
                h = f;
                break;
              }
            if (h !== null) {
              const f = u.splice(h)[0], p = l.splice(f.index);
              p.unshift(p[0].otherSE), i.push(new Sb(p.reverse()));
              continue;
            }
            u.push({
              index: l.length,
              point: a.point
            });
            const g = a.getLeftmostComparator(o);
            A = d.sort(g)[0].otherSE;
            break;
          }
        i.push(new Sb(l));
      }
      return i;
    }
    getGeom() {
      let e = this.events[0].point;
      const i = [e];
      for (let l = 1, c = this.events.length - 1; l < c; l++) {
        const u = this.events[l].point, d = this.events[l + 1].point;
        Ra.orient(u, e, d) !== 0 && (i.push(u), e = u);
      }
      if (i.length === 1) return null;
      const r = i[0], n = i[1];
      Ra.orient(r, e, n) === 0 && i.shift(), i.push(i[0]);
      const s = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : i.length - 1, a = this.isExteriorRing() ? i.length : -1, A = [];
      for (let l = o; l != a; l += s)
        A.push([i[l].x.toNumber(), i[l].y.toNumber()]);
      return A;
    }
    isExteriorRing() {
      if (this._isExteriorRing === void 0) {
        const e = this.enclosingRing();
        this._isExteriorRing = e ? !e.isExteriorRing() : !0;
      }
      return this._isExteriorRing;
    }
    enclosingRing() {
      return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
    }
    /* Returns the ring that encloses this one, if any */
    _calcEnclosingRing() {
      var n, s;
      let e = this.events[0];
      for (let o = 1, a = this.events.length; o < a; o++) {
        const A = this.events[o];
        Bo.compare(e, A) > 0 && (e = A);
      }
      let i = e.segment.prevInResult(), r = i ? i.prevInResult() : null;
      for (; ; ) {
        if (!i) return null;
        if (!r) return i.ringOut;
        if (r.ringOut !== i.ringOut)
          return ((n = r.ringOut) == null ? void 0 : n.enclosingRing()) !== i.ringOut ? i.ringOut : (s = i.ringOut) == null ? void 0 : s.enclosingRing();
        i = r.prevInResult(), r = i ? i.prevInResult() : null;
      }
    }
  }, gT = class {
    constructor(t) {
      Ne(this, "exteriorRing");
      Ne(this, "interiorRings");
      this.exteriorRing = t, t.poly = this, this.interiorRings = [];
    }
    addInterior(t) {
      this.interiorRings.push(t), t.poly = this;
    }
    getGeom() {
      const t = this.exteriorRing.getGeom();
      if (t === null) return null;
      const e = [t];
      for (let i = 0, r = this.interiorRings.length; i < r; i++) {
        const n = this.interiorRings[i].getGeom();
        n !== null && e.push(n);
      }
      return e;
    }
  }, nne = class {
    constructor(t) {
      Ne(this, "rings");
      Ne(this, "polys");
      this.rings = t, this.polys = this._composePolys(t);
    }
    getGeom() {
      const t = [];
      for (let e = 0, i = this.polys.length; e < i; e++) {
        const r = this.polys[e].getGeom();
        r !== null && t.push(r);
      }
      return t;
    }
    _composePolys(t) {
      var i;
      const e = [];
      for (let r = 0, n = t.length; r < n; r++) {
        const s = t[r];
        if (!s.poly)
          if (s.isExteriorRing()) e.push(new gT(s));
          else {
            const o = s.enclosingRing();
            o != null && o.poly || e.push(new gT(o)), (i = o == null ? void 0 : o.poly) == null || i.addInterior(s);
          }
      }
      return e;
    }
  }, sne = class {
    constructor(t, e = YE.compare) {
      Ne(this, "queue");
      Ne(this, "tree");
      Ne(this, "segments");
      this.queue = t, this.tree = new _E(e), this.segments = [];
    }
    process(t) {
      const e = t.segment, i = [];
      if (t.consumedBy)
        return t.isLeft ? this.queue.delete(t.otherSE) : this.tree.delete(e), i;
      t.isLeft && this.tree.add(e);
      let r = e, n = e;
      do
        r = this.tree.lastBefore(r);
      while (r != null && r.consumedBy != null);
      do
        n = this.tree.firstAfter(n);
      while (n != null && n.consumedBy != null);
      if (t.isLeft) {
        let s = null;
        if (r) {
          const a = r.getIntersection(e);
          if (a !== null && (e.isAnEndpoint(a) || (s = a), !r.isAnEndpoint(a))) {
            const A = this._splitSafely(r, a);
            for (let l = 0, c = A.length; l < c; l++)
              i.push(A[l]);
          }
        }
        let o = null;
        if (n) {
          const a = n.getIntersection(e);
          if (a !== null && (e.isAnEndpoint(a) || (o = a), !n.isAnEndpoint(a))) {
            const A = this._splitSafely(n, a);
            for (let l = 0, c = A.length; l < c; l++)
              i.push(A[l]);
          }
        }
        if (s !== null || o !== null) {
          let a = null;
          s === null ? a = o : o === null ? a = s : a = Bo.comparePoints(
            s,
            o
          ) <= 0 ? s : o, this.queue.delete(e.rightSE), i.push(e.rightSE);
          const A = e.split(a);
          for (let l = 0, c = A.length; l < c; l++)
            i.push(A[l]);
        }
        i.length > 0 ? (this.tree.delete(e), i.push(t)) : (this.segments.push(e), e.prev = r);
      } else {
        if (r && n) {
          const s = r.getIntersection(n);
          if (s !== null) {
            if (!r.isAnEndpoint(s)) {
              const o = this._splitSafely(r, s);
              for (let a = 0, A = o.length; a < A; a++)
                i.push(o[a]);
            }
            if (!n.isAnEndpoint(s)) {
              const o = this._splitSafely(n, s);
              for (let a = 0, A = o.length; a < A; a++)
                i.push(o[a]);
            }
          }
        }
        this.tree.delete(e);
      }
      return i;
    }
    /* Safely split a segment that is currently in the datastructures
     * IE - a segment other than the one that is currently being processed. */
    _splitSafely(t, e) {
      this.tree.delete(t);
      const i = t.rightSE;
      this.queue.delete(i);
      const r = t.split(e);
      return r.push(i), t.consumedBy === void 0 && this.tree.add(t), r;
    }
  }, one = class {
    constructor() {
      Ne(this, "type");
      Ne(this, "numMultiPolys");
    }
    run(t, e, i) {
      Bh.type = t;
      const r = [new pT(e, !0)];
      for (let l = 0, c = i.length; l < c; l++)
        r.push(new pT(i[l], !1));
      if (Bh.numMultiPolys = r.length, Bh.type === "difference") {
        const l = r[0];
        let c = 1;
        for (; c < r.length; )
          Fb(r[c].bbox, l.bbox) !== null ? c++ : r.splice(c, 1);
      }
      if (Bh.type === "intersection")
        for (let l = 0, c = r.length; l < c; l++) {
          const u = r[l];
          for (let d = l + 1, h = r.length; d < h; d++)
            if (Fb(u.bbox, r[d].bbox) === null) return [];
        }
      const n = new _E(Bo.compare);
      for (let l = 0, c = r.length; l < c; l++) {
        const u = r[l].getSweepEvents();
        for (let d = 0, h = u.length; d < h; d++)
          n.add(u[d]);
      }
      const s = new sne(n);
      let o = null;
      for (n.size != 0 && (o = n.first(), n.delete(o)); o; ) {
        const l = s.process(o);
        for (let c = 0, u = l.length; c < u; c++) {
          const d = l[c];
          d.consumedBy === void 0 && n.add(d);
        }
        n.size != 0 ? (o = n.first(), n.delete(o)) : o = null;
      }
      Ra.reset();
      const a = rne.factory(s.segments);
      return new nne(a).getGeom();
    }
  }, Bh = new one(), Bg = Bh, ane = 0, YE = class om {
    /* Warning: a reference to ringWindings input will be stored,
     *  and possibly will be later modified */
    constructor(e, i, r, n) {
      Ne(this, "id");
      Ne(this, "leftSE");
      Ne(this, "rightSE");
      Ne(this, "rings");
      Ne(this, "windings");
      Ne(this, "ringOut");
      Ne(this, "consumedBy");
      Ne(this, "prev");
      Ne(this, "_prevInResult");
      Ne(this, "_beforeState");
      Ne(this, "_afterState");
      Ne(this, "_isInResult");
      this.id = ++ane, this.leftSE = e, e.segment = this, e.otherSE = i, this.rightSE = i, i.segment = this, i.otherSE = e, this.rings = r, this.windings = n;
    }
    /* This compare() function is for ordering segments in the sweep
     * line tree, and does so according to the following criteria:
     *
     * Consider the vertical line that lies an infinestimal step to the
     * right of the right-more of the two left endpoints of the input
     * segments. Imagine slowly moving a point up from negative infinity
     * in the increasing y direction. Which of the two segments will that
     * point intersect first? That segment comes 'before' the other one.
     *
     * If neither segment would be intersected by such a line, (if one
     * or more of the segments are vertical) then the line to be considered
     * is directly on the right-more of the two left inputs.
     */
    static compare(e, i) {
      const r = e.leftSE.point.x, n = i.leftSE.point.x, s = e.rightSE.point.x, o = i.rightSE.point.x;
      if (o.isLessThan(r)) return 1;
      if (s.isLessThan(n)) return -1;
      const a = e.leftSE.point.y, A = i.leftSE.point.y, l = e.rightSE.point.y, c = i.rightSE.point.y;
      if (r.isLessThan(n)) {
        if (A.isLessThan(a) && A.isLessThan(l)) return 1;
        if (A.isGreaterThan(a) && A.isGreaterThan(l)) return -1;
        const u = e.comparePoint(i.leftSE.point);
        if (u < 0) return 1;
        if (u > 0) return -1;
        const d = i.comparePoint(e.rightSE.point);
        return d !== 0 ? d : -1;
      }
      if (r.isGreaterThan(n)) {
        if (a.isLessThan(A) && a.isLessThan(c)) return -1;
        if (a.isGreaterThan(A) && a.isGreaterThan(c)) return 1;
        const u = i.comparePoint(e.leftSE.point);
        if (u !== 0) return u;
        const d = e.comparePoint(i.rightSE.point);
        return d < 0 ? 1 : d > 0 ? -1 : 1;
      }
      if (a.isLessThan(A)) return -1;
      if (a.isGreaterThan(A)) return 1;
      if (s.isLessThan(o)) {
        const u = i.comparePoint(e.rightSE.point);
        if (u !== 0) return u;
      }
      if (s.isGreaterThan(o)) {
        const u = e.comparePoint(i.rightSE.point);
        if (u < 0) return 1;
        if (u > 0) return -1;
      }
      if (!s.eq(o)) {
        const u = l.minus(a), d = s.minus(r), h = c.minus(A), g = o.minus(n);
        if (u.isGreaterThan(d) && h.isLessThan(g)) return 1;
        if (u.isLessThan(d) && h.isGreaterThan(g)) return -1;
      }
      return s.isGreaterThan(o) ? 1 : s.isLessThan(o) || l.isLessThan(c) ? -1 : l.isGreaterThan(c) ? 1 : e.id < i.id ? -1 : e.id > i.id ? 1 : 0;
    }
    static fromRing(e, i, r) {
      let n, s, o;
      const a = Bo.comparePoints(e, i);
      if (a < 0)
        n = e, s = i, o = 1;
      else if (a > 0)
        n = i, s = e, o = -1;
      else
        throw new Error(
          `Tried to create degenerate segment at [${e.x}, ${e.y}]`
        );
      const A = new Bo(n, !0), l = new Bo(s, !1);
      return new om(A, l, [r], [o]);
    }
    /* When a segment is split, the rightSE is replaced with a new sweep event */
    replaceRightSE(e) {
      this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
    }
    bbox() {
      const e = this.leftSE.point.y, i = this.rightSE.point.y;
      return {
        ll: { x: this.leftSE.point.x, y: e.isLessThan(i) ? e : i },
        ur: { x: this.rightSE.point.x, y: e.isGreaterThan(i) ? e : i }
      };
    }
    /* A vector from the left point to the right */
    vector() {
      return {
        x: this.rightSE.point.x.minus(this.leftSE.point.x),
        y: this.rightSE.point.y.minus(this.leftSE.point.y)
      };
    }
    isAnEndpoint(e) {
      return e.x.eq(this.leftSE.point.x) && e.y.eq(this.leftSE.point.y) || e.x.eq(this.rightSE.point.x) && e.y.eq(this.rightSE.point.y);
    }
    /* Compare this segment with a point.
     *
     * A point P is considered to be colinear to a segment if there
     * exists a distance D such that if we travel along the segment
     * from one * endpoint towards the other a distance D, we find
     * ourselves at point P.
     *
     * Return value indicates:
     *
     *   1: point lies above the segment (to the left of vertical)
     *   0: point is colinear to segment
     *  -1: point lies below the segment (to the right of vertical)
     */
    comparePoint(e) {
      return Ra.orient(this.leftSE.point, e, this.rightSE.point);
    }
    /**
     * Given another segment, returns the first non-trivial intersection
     * between the two segments (in terms of sweep line ordering), if it exists.
     *
     * A 'non-trivial' intersection is one that will cause one or both of the
     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
     *
     *   * endpoint of segA with endpoint of segB --> trivial
     *   * endpoint of segA with point along segB --> non-trivial
     *   * endpoint of segB with point along segA --> non-trivial
     *   * point along segA with point along segB --> non-trivial
     *
     * If no non-trivial intersection exists, return null
     * Else, return null.
     */
    getIntersection(e) {
      const i = this.bbox(), r = e.bbox(), n = Fb(i, r);
      if (n === null) return null;
      const s = this.leftSE.point, o = this.rightSE.point, a = e.leftSE.point, A = e.rightSE.point, l = oh(i, a) && this.comparePoint(a) === 0, c = oh(r, s) && e.comparePoint(s) === 0, u = oh(i, A) && this.comparePoint(A) === 0, d = oh(r, o) && e.comparePoint(o) === 0;
      if (c && l)
        return d && !u ? o : !d && u ? A : null;
      if (c)
        return u && s.x.eq(A.x) && s.y.eq(A.y) ? null : s;
      if (l)
        return d && o.x.eq(a.x) && o.y.eq(a.y) ? null : a;
      if (d && u) return null;
      if (d) return o;
      if (u) return A;
      const h = ine(s, this.vector(), a, e.vector());
      return h === null || !oh(n, h) ? null : Ra.snap(h);
    }
    /**
     * Split the given segment into multiple segments on the given points.
     *  * Each existing segment will retain its leftSE and a new rightSE will be
     *    generated for it.
     *  * A new segment will be generated which will adopt the original segment's
     *    rightSE, and a new leftSE will be generated for it.
     *  * If there are more than two points given to split on, new segments
     *    in the middle will be generated with new leftSE and rightSE's.
     *  * An array of the newly generated SweepEvents will be returned.
     *
     * Warning: input array of points is modified
     */
    split(e) {
      const i = [], r = e.events !== void 0, n = new Bo(e, !0), s = new Bo(e, !1), o = this.rightSE;
      this.replaceRightSE(s), i.push(s), i.push(n);
      const a = new om(
        n,
        o,
        this.rings.slice(),
        this.windings.slice()
      );
      return Bo.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), Bo.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (n.checkForConsuming(), s.checkForConsuming()), i;
    }
    /* Swap which event is left and right */
    swapEvents() {
      const e = this.rightSE;
      this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
      for (let i = 0, r = this.windings.length; i < r; i++)
        this.windings[i] *= -1;
    }
    /* Consume another segment. We take their rings under our wing
     * and mark them as consumed. Use for perfectly overlapping segments */
    consume(e) {
      let i = this, r = e;
      for (; i.consumedBy; ) i = i.consumedBy;
      for (; r.consumedBy; ) r = r.consumedBy;
      const n = om.compare(i, r);
      if (n !== 0) {
        if (n > 0) {
          const s = i;
          i = r, r = s;
        }
        if (i.prev === r) {
          const s = i;
          i = r, r = s;
        }
        for (let s = 0, o = r.rings.length; s < o; s++) {
          const a = r.rings[s], A = r.windings[s], l = i.rings.indexOf(a);
          l === -1 ? (i.rings.push(a), i.windings.push(A)) : i.windings[l] += A;
        }
        r.rings = null, r.windings = null, r.consumedBy = i, r.leftSE.consumedBy = i.leftSE, r.rightSE.consumedBy = i.rightSE;
      }
    }
    /* The first segment previous segment chain that is in the result */
    prevInResult() {
      return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
    }
    beforeState() {
      if (this._beforeState !== void 0) return this._beforeState;
      if (!this.prev)
        this._beforeState = {
          rings: [],
          windings: [],
          multiPolys: []
        };
      else {
        const e = this.prev.consumedBy || this.prev;
        this._beforeState = e.afterState();
      }
      return this._beforeState;
    }
    afterState() {
      if (this._afterState !== void 0) return this._afterState;
      const e = this.beforeState();
      this._afterState = {
        rings: e.rings.slice(0),
        windings: e.windings.slice(0),
        multiPolys: []
      };
      const i = this._afterState.rings, r = this._afterState.windings, n = this._afterState.multiPolys;
      for (let a = 0, A = this.rings.length; a < A; a++) {
        const l = this.rings[a], c = this.windings[a], u = i.indexOf(l);
        u === -1 ? (i.push(l), r.push(c)) : r[u] += c;
      }
      const s = [], o = [];
      for (let a = 0, A = i.length; a < A; a++) {
        if (r[a] === 0) continue;
        const l = i[a], c = l.poly;
        if (o.indexOf(c) === -1)
          if (l.isExterior) s.push(c);
          else {
            o.indexOf(c) === -1 && o.push(c);
            const u = s.indexOf(l.poly);
            u !== -1 && s.splice(u, 1);
          }
      }
      for (let a = 0, A = s.length; a < A; a++) {
        const l = s[a].multiPoly;
        n.indexOf(l) === -1 && n.push(l);
      }
      return this._afterState;
    }
    /* Is this segment part of the final result? */
    isInResult() {
      if (this.consumedBy) return !1;
      if (this._isInResult !== void 0) return this._isInResult;
      const e = this.beforeState().multiPolys, i = this.afterState().multiPolys;
      switch (Bg.type) {
        case "union": {
          const r = e.length === 0, n = i.length === 0;
          this._isInResult = r !== n;
          break;
        }
        case "intersection": {
          let r, n;
          e.length < i.length ? (r = e.length, n = i.length) : (r = i.length, n = e.length), this._isInResult = n === Bg.numMultiPolys && r < n;
          break;
        }
        case "xor": {
          const r = Math.abs(e.length - i.length);
          this._isInResult = r % 2 === 1;
          break;
        }
        case "difference": {
          const r = (n) => n.length === 1 && n[0].isSubject;
          this._isInResult = r(e) !== r(i);
          break;
        }
      }
      return this._isInResult;
    }
  }, fT = class {
    constructor(t, e, i) {
      Ne(this, "poly");
      Ne(this, "isExterior");
      Ne(this, "segments");
      Ne(this, "bbox");
      if (!Array.isArray(t) || t.length === 0)
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      if (this.poly = e, this.isExterior = i, this.segments = [], typeof t[0][0] != "number" || typeof t[0][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const r = Ra.snap({ x: new Io(t[0][0]), y: new Io(t[0][1]) });
      this.bbox = {
        ll: { x: r.x, y: r.y },
        ur: { x: r.x, y: r.y }
      };
      let n = r;
      for (let s = 1, o = t.length; s < o; s++) {
        if (typeof t[s][0] != "number" || typeof t[s][1] != "number")
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        const a = Ra.snap({ x: new Io(t[s][0]), y: new Io(t[s][1]) });
        a.x.eq(n.x) && a.y.eq(n.y) || (this.segments.push(YE.fromRing(n, a, this)), a.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = a.x), a.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = a.y), a.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = a.x), a.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = a.y), n = a);
      }
      (!r.x.eq(n.x) || !r.y.eq(n.y)) && this.segments.push(YE.fromRing(n, r, this));
    }
    getSweepEvents() {
      const t = [];
      for (let e = 0, i = this.segments.length; e < i; e++) {
        const r = this.segments[e];
        t.push(r.leftSE), t.push(r.rightSE);
      }
      return t;
    }
  }, Ane = class {
    constructor(t, e) {
      Ne(this, "multiPoly");
      Ne(this, "exteriorRing");
      Ne(this, "interiorRings");
      Ne(this, "bbox");
      if (!Array.isArray(t))
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      this.exteriorRing = new fT(t[0], this, !0), this.bbox = {
        ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
        ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
      }, this.interiorRings = [];
      for (let i = 1, r = t.length; i < r; i++) {
        const n = new fT(t[i], this, !1);
        n.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = n.bbox.ll.x), n.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = n.bbox.ll.y), n.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = n.bbox.ur.x), n.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = n.bbox.ur.y), this.interiorRings.push(n);
      }
      this.multiPoly = e;
    }
    getSweepEvents() {
      const t = this.exteriorRing.getSweepEvents();
      for (let e = 0, i = this.interiorRings.length; e < i; e++) {
        const r = this.interiorRings[e].getSweepEvents();
        for (let n = 0, s = r.length; n < s; n++)
          t.push(r[n]);
      }
      return t;
    }
  }, pT = class {
    constructor(t, e) {
      Ne(this, "isSubject");
      Ne(this, "polys");
      Ne(this, "bbox");
      if (!Array.isArray(t))
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      try {
        typeof t[0][0][0] == "number" && (t = [t]);
      } catch {
      }
      this.polys = [], this.bbox = {
        ll: { x: new Io(Number.POSITIVE_INFINITY), y: new Io(Number.POSITIVE_INFINITY) },
        ur: { x: new Io(Number.NEGATIVE_INFINITY), y: new Io(Number.NEGATIVE_INFINITY) }
      };
      for (let i = 0, r = t.length; i < r; i++) {
        const n = new Ane(t[i], this);
        n.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = n.bbox.ll.x), n.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = n.bbox.ll.y), n.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = n.bbox.ur.x), n.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = n.bbox.ur.y), this.polys.push(n);
      }
      this.isSubject = e;
    }
    getSweepEvents() {
      const t = [];
      for (let e = 0, i = this.polys.length; e < i; e++) {
        const r = this.polys[e].getSweepEvents();
        for (let n = 0, s = r.length; n < s; n++)
          t.push(r[n]);
      }
      return t;
    }
  }, lne = (t, ...e) => Bg.run("union", t, e), cne = (t, ...e) => Bg.run("intersection", t, e), une = (t, ...e) => Bg.run("difference", t, e);
  Ra.set;
  function dne(t) {
    const e = [];
    if (BB(t, (n) => {
      e.push(n.coordinates);
    }), e.length < 2)
      throw new Error("Must have at least two features");
    const i = t.features[0].properties || {}, r = une(e[0], ...e.slice(1));
    return r.length === 0 ? null : r.length === 1 ? Ts(r[0], i) : js(r, i);
  }
  function hne(t, e = {}) {
    const i = [];
    if (BB(t, (n) => {
      i.push(n.coordinates);
    }), i.length < 2)
      throw new Error("Must specify at least 2 geometries");
    const r = cne(i[0], ...i.slice(1));
    return r.length === 0 ? null : r.length === 1 ? Ts(r[0], e.properties) : js(r, e.properties);
  }
  function gne(t) {
    let e, i;
    const r = {
      type: "FeatureCollection",
      features: []
    };
    if (t.type === "Feature" ? i = t.geometry : i = t, i.type === "LineString")
      e = [i.coordinates];
    else if (i.type === "MultiLineString")
      e = i.coordinates;
    else if (i.type === "MultiPolygon")
      e = [].concat(...i.coordinates);
    else if (i.type === "Polygon")
      e = i.coordinates;
    else
      throw new Error(
        "Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry"
      );
    return e.forEach((n) => {
      e.forEach((s) => {
        for (let o = 0; o < n.length - 1; o++)
          for (let a = o; a < s.length - 1; a++) {
            if (n === s && (Math.abs(o - a) === 1 || // segments are first and last segment of lineString
            o === 0 && a === n.length - 2 && // lineString is closed
            n[o][0] === n[n.length - 1][0] && n[o][1] === n[n.length - 1][1]))
              continue;
            const A = fne(
              n[o][0],
              n[o][1],
              n[o + 1][0],
              n[o + 1][1],
              s[a][0],
              s[a][1],
              s[a + 1][0],
              s[a + 1][1]
            );
            A && r.features.push(Ad([A[0], A[1]]));
          }
      });
    }), r;
  }
  function fne(t, e, i, r, n, s, o, a) {
    let A, l, c, u, d;
    const h = {
      x: null,
      y: null,
      onLine1: !1,
      onLine2: !1
    };
    return A = (a - s) * (i - t) - (o - n) * (r - e), A === 0 ? h.x !== null && h.y !== null ? h : !1 : (l = e - s, c = t - n, u = (o - n) * l - (a - s) * c, d = (i - t) * l - (r - e) * c, l = u / A, c = d / A, h.x = t + l * (i - t), h.y = e + l * (r - e), l >= 0 && l <= 1 && (h.onLine1 = !0), c >= 0 && c <= 1 && (h.onLine2 = !0), h.onLine1 && h.onLine2 ? [h.x, h.y] : !1);
  }
  function zL(t, e = {}) {
    const i = [];
    if (BB(t, (n) => {
      i.push(n.coordinates);
    }), i.length < 2)
      throw new Error("Must have at least 2 geometries");
    const r = lne(i[0], ...i.slice(1));
    return r.length === 0 ? null : r.length === 1 ? Ts(r[0], e.properties) : js(r, e.properties);
  }
  class fx {
    constructor() {
      this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */
      hr, this.supportedMediaTypes = null;
    }
    /**
     * Adds the data projection to the read options.
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Options.
     * @return {ReadOptions|undefined} Options.
     * @protected
     */
    getReadOptions(e, i) {
      if (i) {
        let r = i.dataProjection ? Xe(i.dataProjection) : this.readProjection(e);
        i.extent && r && r.getUnits() === "tile-pixels" && (r = Xe(r), r.setWorldExtent(i.extent)), i = {
          dataProjection: r,
          featureProjection: i.featureProjection
        };
      }
      return this.adaptOptions(i);
    }
    /**
     * Sets the `dataProjection` on the options, if no `dataProjection`
     * is set.
     * @param {WriteOptions|ReadOptions|undefined} options
     *     Options.
     * @protected
     * @return {WriteOptions|ReadOptions|undefined}
     *     Updated options.
     */
    adaptOptions(e) {
      return Object.assign(
        {
          dataProjection: this.dataProjection,
          featureProjection: this.defaultFeatureProjection,
          featureClass: this.featureClass
        },
        e
      );
    }
    /**
     * @abstract
     * @return {Type} The format type.
     */
    getType() {
      return it();
    }
    /**
     * Read a single feature from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {FeatureType|Array<FeatureType>} Feature.
     */
    readFeature(e, i) {
      return it();
    }
    /**
     * Read all features from a source.
     *
     * @abstract
     * @param {Document|Element|ArrayBuffer|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {Array<FeatureType>} Features.
     */
    readFeatures(e, i) {
      return it();
    }
    /**
     * Read a single geometry from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometry(e, i) {
      return it();
    }
    /**
     * Read the projection from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     */
    readProjection(e) {
      return it();
    }
    /**
     * Encode a feature in this format.
     *
     * @abstract
     * @param {Feature} feature Feature.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeature(e, i) {
      return it();
    }
    /**
     * Encode an array of features in this format.
     *
     * @abstract
     * @param {Array<Feature>} features Features.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeatures(e, i) {
      return it();
    }
    /**
     * Write a single geometry in this format.
     *
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeGeometry(e, i) {
      return it();
    }
  }
  function uc(t, e, i) {
    const r = i ? Xe(i.featureProjection) : null, n = i ? Xe(i.dataProjection) : null;
    let s = t;
    if (r && n && !Fo(r, n)) {
      e && (s = /** @type {T} */
      t.clone());
      const o = e ? r : n, a = e ? n : r;
      o.getUnits() === "tile-pixels" ? s.transform(o, a) : s.applyTransform(id(o, a));
    }
    if (e && i && /** @type {WriteOptions} */
    i.decimals !== void 0) {
      const o = Math.pow(
        10,
        /** @type {WriteOptions} */
        i.decimals
      ), a = function(A) {
        for (let l = 0, c = A.length; l < c; ++l)
          A[l] = Math.round(A[l] * o) / o;
        return A;
      };
      s === t && (s = /** @type {T} */
      t.clone()), s.applyTransform(a);
    }
    return s;
  }
  function px(t, e) {
    const i = e ? Xe(e.featureProjection) : null, r = e ? Xe(e.dataProjection) : null;
    return i && r && !Fo(i, r) ? cU(t, r, i) : t;
  }
  const pne = {
    Point: Cn,
    LineString: bn,
    Polygon: en,
    MultiPoint: lc,
    MultiLineString: Da,
    MultiPolygon: Ta
  };
  function mne(t, e, i) {
    return Array.isArray(e[0]) ? (wU(t, 0, e, i) || (t = t.slice(), fb(t, 0, e, i)), t) : (Tv(t, 0, e, i) || (t = t.slice(), wE(t, 0, e, i)), t);
  }
  function PL(t, e) {
    var s;
    const i = t.geometry;
    if (!i)
      return [];
    if (Array.isArray(i))
      return i.map((o) => PL({ ...t, geometry: o })).flat();
    const r = i.type === "MultiPolygon" ? "Polygon" : i.type;
    if (r === "GeometryCollection" || r === "Circle")
      throw new Error("Unsupported geometry type: " + r);
    const n = i.layout.length;
    return uc(
      new Ir(
        r,
        r === "Polygon" ? mne(i.flatCoordinates, i.ends, n) : i.flatCoordinates,
        (s = i.ends) == null ? void 0 : s.flat(),
        n,
        t.properties || {},
        t.id
      ).enableSimplifyTransformed(),
      !1,
      e
    );
  }
  function mx(t, e) {
    if (!t)
      return null;
    if (Array.isArray(t)) {
      const r = t.map(
        (n) => mx(n, e)
      );
      return new Eg(r);
    }
    const i = pne[t.type];
    return uc(
      new i(t.flatCoordinates, t.layout, t.ends),
      !1,
      e
    );
  }
  class Ene extends fx {
    constructor() {
      super();
    }
    /**
     * @return {import("./Feature.js").Type} Format.
     * @override
     */
    getType() {
      return "json";
    }
    /**
     * Read a feature.  Only works for a single feature. Use `readFeatures` to
     * read a feature collection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {FeatureType|Array<FeatureType>} Feature.
     * @api
     * @override
     */
    readFeature(e, i) {
      return this.readFeatureFromObject(
        Mp(e),
        this.getReadOptions(e, i)
      );
    }
    /**
     * Read all features.  Works with both a single feature and a feature
     * collection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {Array<FeatureType>} Features.
     * @api
     * @override
     */
    readFeatures(e, i) {
      return this.readFeaturesFromObject(
        Mp(e),
        this.getReadOptions(e, i)
      );
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {FeatureType|Array<FeatureType>} Feature.
     */
    readFeatureFromObject(e, i) {
      return it();
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {Array<FeatureType>} Features.
     */
    readFeaturesFromObject(e, i) {
      return it();
    }
    /**
     * Read a geometry.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @api
     * @override
     */
    readGeometry(e, i) {
      return this.readGeometryFromObject(
        Mp(e),
        this.getReadOptions(e, i)
      );
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromObject(e, i) {
      return it();
    }
    /**
     * Read the projection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    readProjection(e) {
      return this.readProjectionFromObject(Mp(e));
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromObject(e) {
      return it();
    }
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @api
     * @override
     */
    writeFeature(e, i) {
      return JSON.stringify(this.writeFeatureObject(e, i));
    }
    /**
     * @abstract
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeFeatureObject(e, i) {
      return it();
    }
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded features.
     * @api
     * @override
     */
    writeFeatures(e, i) {
      return JSON.stringify(this.writeFeaturesObject(e, i));
    }
    /**
     * @abstract
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeFeaturesObject(e, i) {
      return it();
    }
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded geometry.
     * @api
     * @override
     */
    writeGeometry(e, i) {
      return JSON.stringify(this.writeGeometryObject(e, i));
    }
    /**
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeGeometryObject(e, i) {
      return it();
    }
  }
  function Mp(t) {
    if (typeof t == "string") {
      const e = JSON.parse(t);
      return e || null;
    }
    return t !== null ? t : null;
  }
  class ld extends Ene {
    /**
     * @param {Options<FeatureType>} [options] Options.
     */
    constructor(e) {
      e = e || {}, super(), this.dataProjection = Xe(
        e.dataProjection ? e.dataProjection : "EPSG:4326"
      ), e.featureProjection && (this.defaultFeatureProjection = Xe(e.featureProjection)), e.featureClass && (this.featureClass = e.featureClass), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
        "application/geo+json",
        "application/vnd.geo+json"
      ];
    }
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {FeatureType|Array<FeatureType>} Feature.
     * @override
     */
    readFeatureFromObject(e, i) {
      let r = null;
      e.type === "Feature" ? r = /** @type {GeoJSONFeature} */
      e : r = {
        type: "Feature",
        geometry: (
          /** @type {GeoJSONGeometry} */
          e
        ),
        properties: null
      };
      const n = Ex(r.geometry);
      if (this.featureClass === Ir)
        return (
          /** @type {FeatureType|Array<FeatureType>} */
          PL(
            {
              geometry: n,
              id: r.id,
              properties: r.properties
            },
            i
          )
        );
      const s = new hr();
      return this.geometryName_ ? s.setGeometryName(this.geometryName_) : this.extractGeometryName_ && r.geometry_name && s.setGeometryName(r.geometry_name), s.setGeometry(mx(n, i)), "id" in r && s.setId(r.id), r.properties && s.setProperties(r.properties, !0), /** @type {FeatureType|Array<FeatureType>} */
      s;
    }
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {Array<FeatureType>} Features.
     * @override
     */
    readFeaturesFromObject(e, i) {
      const r = (
        /** @type {GeoJSONObject} */
        e
      );
      let n = null;
      if (r.type === "FeatureCollection") {
        const s = (
          /** @type {GeoJSONFeatureCollection} */
          e
        );
        n = [];
        const o = s.features;
        for (let a = 0, A = o.length; a < A; ++a) {
          const l = this.readFeatureFromObject(
            o[a],
            i
          );
          l && n.push(l);
        }
      } else
        n = [this.readFeatureFromObject(e, i)];
      return (
        /** @type {Array<FeatureType>} */
        n.flat()
      );
    }
    /**
     * @param {GeoJSONGeometry} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    readGeometryFromObject(e, i) {
      return yne(e, i);
    }
    /**
     * @param {Object} object Object.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     * @override
     */
    readProjectionFromObject(e) {
      const i = e.crs;
      let r;
      if (i)
        if (i.type == "name")
          r = Xe(i.properties.name);
        else if (i.type === "EPSG")
          r = Xe("EPSG:" + i.properties.code);
        else
          throw new Error("Unknown SRS type");
      else
        r = this.dataProjection;
      return (
        /** @type {import("../proj/Projection.js").default} */
        r
      );
    }
    /**
     * Encode a feature as a GeoJSON Feature object.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONFeature} Object.
     * @api
     * @override
     */
    writeFeatureObject(e, i) {
      i = this.adaptOptions(i);
      const r = {
        type: "Feature",
        geometry: null,
        properties: null
      }, n = e.getId();
      if (n !== void 0 && (r.id = n), !e.hasProperties())
        return r;
      const s = e.getProperties(), o = e.getGeometry();
      return o && (r.geometry = Db(o, i), delete s[e.getGeometryName()]), vA(s) || (r.properties = s), r;
    }
    /**
     * Encode an array of features as a GeoJSON object.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONFeatureCollection} GeoJSON Object.
     * @api
     * @override
     */
    writeFeaturesObject(e, i) {
      i = this.adaptOptions(i);
      const r = [];
      for (let n = 0, s = e.length; n < s; ++n)
        r.push(this.writeFeatureObject(e[n], i));
      return {
        type: "FeatureCollection",
        features: r
      };
    }
    /**
     * Encode a geometry as a GeoJSON object.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
     * @api
     * @override
     */
    writeGeometryObject(e, i) {
      return Db(e, this.adaptOptions(i));
    }
  }
  function Ex(t, e) {
    if (!t)
      return null;
    let i;
    switch (t.type) {
      case "Point": {
        i = wne(
          /** @type {GeoJSONPoint} */
          t
        );
        break;
      }
      case "LineString": {
        i = Cne(
          /** @type {GeoJSONLineString} */
          t
        );
        break;
      }
      case "Polygon": {
        i = vne(
          /** @type {GeoJSONPolygon} */
          t
        );
        break;
      }
      case "MultiPoint": {
        i = Mne(
          /** @type {GeoJSONMultiPoint} */
          t
        );
        break;
      }
      case "MultiLineString": {
        i = bne(
          /** @type {GeoJSONMultiLineString} */
          t
        );
        break;
      }
      case "MultiPolygon": {
        i = Ine(
          /** @type {GeoJSONMultiPolygon} */
          t
        );
        break;
      }
      case "GeometryCollection": {
        i = Bne(
          /** @type {GeoJSONGeometryCollection} */
          t
        );
        break;
      }
      default:
        throw new Error("Unsupported GeoJSON type: " + t.type);
    }
    return i;
  }
  function yne(t, e) {
    const i = Ex(t);
    return mx(i, e);
  }
  function Bne(t, e) {
    return t.geometries.map(
      /**
       * @param {GeoJSONGeometry} geometry Geometry.
       * @return {import("./Feature.js").GeometryObject} geometry Geometry.
       */
      function(r) {
        return Ex(r);
      }
    );
  }
  function wne(t) {
    const e = t.coordinates;
    return {
      type: "Point",
      flatCoordinates: e,
      layout: ac(e.length)
    };
  }
  function Cne(t) {
    var r;
    const e = t.coordinates, i = e.flat();
    return {
      type: "LineString",
      flatCoordinates: i,
      ends: [i.length],
      layout: ac(((r = e[0]) == null ? void 0 : r.length) || 2)
    };
  }
  function bne(t) {
    var s, o;
    const e = t.coordinates, i = ((o = (s = e[0]) == null ? void 0 : s[0]) == null ? void 0 : o.length) || 2, r = [], n = cf(r, 0, e, i);
    return {
      type: "MultiLineString",
      flatCoordinates: r,
      ends: n,
      layout: ac(i)
    };
  }
  function Mne(t) {
    var i;
    const e = t.coordinates;
    return {
      type: "MultiPoint",
      flatCoordinates: e.flat(),
      layout: ac(((i = e[0]) == null ? void 0 : i.length) || 2)
    };
  }
  function Ine(t) {
    var s, o;
    const e = t.coordinates, i = [], r = ((o = (s = e[0]) == null ? void 0 : s[0]) == null ? void 0 : o[0].length) || 2, n = dU(
      i,
      0,
      e,
      r
    );
    return {
      type: "MultiPolygon",
      flatCoordinates: i,
      ends: n,
      layout: ac(r)
    };
  }
  function vne(t) {
    var s, o;
    const e = t.coordinates, i = [], r = (o = (s = e[0]) == null ? void 0 : s[0]) == null ? void 0 : o.length, n = cf(i, 0, e, r);
    return {
      type: "Polygon",
      flatCoordinates: i,
      ends: n,
      layout: ac(r)
    };
  }
  function Db(t, e) {
    t = uc(t, !0, e);
    const i = t.getType();
    let r;
    switch (i) {
      case "Point": {
        r = Tne(
          /** @type {import("../geom/Point.js").default} */
          t
        );
        break;
      }
      case "LineString": {
        r = Qne(
          /** @type {import("../geom/LineString.js").default} */
          t
        );
        break;
      }
      case "Polygon": {
        r = Rne(
          /** @type {import("../geom/Polygon.js").default} */
          t,
          e
        );
        break;
      }
      case "MultiPoint": {
        r = Sne(
          /** @type {import("../geom/MultiPoint.js").default} */
          t
        );
        break;
      }
      case "MultiLineString": {
        r = Fne(
          /** @type {import("../geom/MultiLineString.js").default} */
          t
        );
        break;
      }
      case "MultiPolygon": {
        r = Dne(
          /** @type {import("../geom/MultiPolygon.js").default} */
          t,
          e
        );
        break;
      }
      case "GeometryCollection": {
        r = xne(
          /** @type {import("../geom/GeometryCollection.js").default} */
          t,
          e
        );
        break;
      }
      case "Circle": {
        r = {
          type: "GeometryCollection",
          geometries: []
        };
        break;
      }
      default:
        throw new Error("Unsupported geometry type: " + i);
    }
    return r;
  }
  function xne(t, e) {
    return e = Object.assign({}, e), delete e.featureProjection, {
      type: "GeometryCollection",
      geometries: t.getGeometriesArray().map(function(r) {
        return Db(r, e);
      })
    };
  }
  function Qne(t, e) {
    return {
      type: "LineString",
      coordinates: t.getCoordinates()
    };
  }
  function Fne(t, e) {
    return {
      type: "MultiLineString",
      coordinates: t.getCoordinates()
    };
  }
  function Sne(t, e) {
    return {
      type: "MultiPoint",
      coordinates: t.getCoordinates()
    };
  }
  function Dne(t, e) {
    let i;
    return e && (i = e.rightHanded), {
      type: "MultiPolygon",
      coordinates: t.getCoordinates(i)
    };
  }
  function Tne(t, e) {
    return {
      type: "Point",
      coordinates: t.getCoordinates()
    };
  }
  function Rne(t, e) {
    let i;
    return e && (i = e.rightHanded), {
      type: "Polygon",
      coordinates: t.getCoordinates(i)
    };
  }
  const CB = new ld();
  function Hs(t) {
    return CB.writeFeatureObject(t);
  }
  function OL(t) {
    return CB.writeFeaturesObject(t);
  }
  function Js(t) {
    return CB.readFeature(t);
  }
  function mT(t) {
    if (!(t != null && t.length)) return [];
    t = t.map(
      (i) => wg(i)
    ).filter((i) => {
      var r, n;
      return (n = (r = i.geometry.coordinates[0]) == null ? void 0 : r[0]) == null ? void 0 : n.length;
    });
    const e = ps(t);
    return CB.readFeatures(e);
  }
  function _ne(t) {
    return {
      type: "Feature",
      properties: null,
      geometry: t
    };
  }
  function kne(t) {
    return t.map(_ne);
  }
  function Yne(t) {
    const e = Hs(t), i = wg(e);
    return Js(i);
  }
  function bB(t) {
    const e = Hs(t);
    return e.geometry.type == "Polygon" ? [e] : e.geometry.type == "MultiPolygon" ? e.geometry.coordinates.flatMap(
      (i) => (
        // create geoJSON Polygon with turf
        Ts(i)
      )
    ) : [e];
  }
  function wg(t) {
    if (!t) return t;
    if (t.geometry.type !== "MultiPolygon") {
      const e = js([t.geometry.coordinates]);
      e.properties = t.properties, e.id = t.id, t = e;
    }
    return t;
  }
  var Nne = typeof window < "u", GL = [
    "__key",
    "__init",
    "__shim",
    "__original",
    "__index",
    "__prevKey"
  ];
  function Ld() {
    return Math.random().toString(36).substring(2, 15);
  }
  function Une(t, e) {
    return [...t instanceof Set ? t : new Set(t)];
  }
  function gt(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  function Lr(t, e, i = !0, r = ["__key"]) {
    if (t === e)
      return !0;
    if (typeof e == "object" && typeof t == "object") {
      if (t instanceof Map || t instanceof Set)
        return !1;
      if (t instanceof Date && e instanceof Date)
        return t.getTime() === e.getTime();
      if (t instanceof RegExp && e instanceof RegExp)
        return Lne(t, e);
      if (t === null || e === null || Object.keys(t).length !== Object.keys(e).length)
        return !1;
      for (const n of r)
        if ((n in t || n in e) && t[n] !== e[n])
          return !1;
      for (const n in t)
        if (!(n in e) || t[n] !== e[n] && !i || i && !Lr(t[n], e[n], i, r))
          return !1;
      return !0;
    }
    return !1;
  }
  function Lne(t, e) {
    return t.source === e.source && t.flags.split("").sort().join("") === e.flags.split("").sort().join("");
  }
  function As(t) {
    const e = typeof t;
    if (e === "number")
      return !1;
    if (t === void 0)
      return !0;
    if (e === "string")
      return t === "";
    if (e === "object") {
      if (t === null)
        return !0;
      for (const i in t)
        return !1;
      return !(t instanceof RegExp || t instanceof Date);
    }
    return !1;
  }
  function zne(t) {
    return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Pne(t) {
    const e = `^${zne(t)}$`, i = {
      MM: "(0[1-9]|1[012])",
      M: "([1-9]|1[012])",
      DD: "([012][0-9]|3[01])",
      D: "([012]?[0-9]|3[01])",
      YYYY: "\\d{4}",
      YY: "\\d{2}"
    }, r = Object.keys(i);
    return new RegExp(
      r.reduce((n, s) => n.replace(s, i[s]), e)
    );
  }
  function NE(t) {
    return Object.prototype.toString.call(t) === "[object Object]";
  }
  function Ph(t) {
    return NE(t) || Array.isArray(t);
  }
  function DA(t) {
    if (NE(t) === !1 || t.__FKNode__ || t.__POJO__ === !1)
      return !1;
    const e = t.constructor;
    if (e === void 0)
      return !0;
    const i = e.prototype;
    return !(NE(i) === !1 || i.hasOwnProperty("isPrototypeOf") === !1);
  }
  var TA = /* @__NO_SIDE_EFFECTS__ */ (t, e, i = !1, r = !1) => {
    if (e === null)
      return null;
    const n = {};
    if (typeof e == "string")
      return e;
    for (const s in t)
      if (gt(e, s) && (e[s] !== void 0 || !r)) {
        if (i && Array.isArray(t[s]) && Array.isArray(e[s])) {
          n[s] = t[s].concat(e[s]);
          continue;
        }
        if (e[s] === void 0)
          continue;
        DA(t[s]) && DA(e[s]) ? n[s] = /* @__PURE__ */ TA(
          t[s],
          e[s],
          i,
          r
        ) : n[s] = e[s];
      } else
        n[s] = t[s];
    for (const s in e)
      !gt(n, s) && e[s] !== void 0 && (n[s] = e[s]);
    return n;
  };
  function One(t) {
    if (t[0] !== '"' && t[0] !== "'" || t[0] !== t[t.length - 1])
      return !1;
    const e = t[0];
    for (let i = 1; i < t.length; i++)
      if (t[i] === e && (i === 1 || t[i - 1] !== "\\") && i !== t.length - 1)
        return !1;
    return !0;
  }
  function Gne(t) {
    if (!t.length)
      return "";
    let e = "", i = "";
    for (let r = 0; r < t.length; r++) {
      const n = t.charAt(r);
      (n !== "\\" || i === "\\") && (e += n), i = n;
    }
    return e;
  }
  function Sc(...t) {
    return t.reduce((e, i) => {
      const { value: r, name: n, modelValue: s, config: o, plugins: a, ...A } = i;
      return Object.assign(e, A);
    }, {});
  }
  function jne(t) {
    const e = [];
    let i = "", r = 0, n = "", s = "";
    for (let o = 0; o < t.length; o++) {
      const a = t.charAt(o);
      a === n && s !== "\\" ? n = "" : (a === "'" || a === '"') && !n && s !== "\\" ? n = a : a === "(" && !n ? r++ : a === ")" && !n && r--, a === "," && !n && r === 0 ? (e.push(i), i = "") : (a !== " " || n) && (i += a), s = a;
    }
    return i && e.push(i), e;
  }
  function ET(t, e) {
    const i = {}, r = e.filter((s) => s instanceof RegExp), n = new Set(e);
    for (const s in t)
      !n.has(s) && !r.some((o) => o.test(s)) && (i[s] = t[s]);
    return i;
  }
  function yT(t, e) {
    const i = {}, r = e.filter((n) => n instanceof RegExp);
    return e.forEach((n) => {
      n instanceof RegExp || (i[n] = t[n]);
    }), Object.keys(t).forEach((n) => {
      r.some((s) => s.test(n)) && (i[n] = t[n]);
    }), i;
  }
  function Ru(t) {
    return t.replace(
      /-([a-z0-9])/gi,
      (e, i) => i.toUpperCase()
    );
  }
  function jL(t) {
    return t.replace(
      /([a-z0-9])([A-Z])/g,
      (e, i, r) => i + "-" + r.toLowerCase()
    ).replace(" ", "-").toLowerCase();
  }
  function Tb(t, e = GL) {
    if (t !== null && typeof t == "object") {
      let i;
      if (Array.isArray(t) ? i = [...t] : DA(t) && (i = { ...t }), i)
        return Jne(t, i, e), i;
    }
    return t;
  }
  function cd(t, e = GL) {
    if (t === null || t instanceof RegExp || t instanceof Date || t instanceof Map || t instanceof Set || typeof File == "function" && t instanceof File)
      return t;
    let i;
    Array.isArray(t) ? i = t.map((r) => typeof r == "object" ? cd(r, e) : r) : i = Object.keys(t).reduce((r, n) => (r[n] = typeof t[n] == "object" ? cd(t[n], e) : t[n], r), {});
    for (const r of e)
      r in t && Object.defineProperty(i, r, {
        enumerable: !1,
        value: t[r]
      });
    return i;
  }
  function Us(t) {
    return typeof t == "object" ? cd(t) : t;
  }
  function Hne(t, e) {
    if (!t || typeof t != "object")
      return null;
    const i = e.split(".");
    let r = t;
    for (const n in i) {
      const s = i[n];
      if (gt(r, s) && (r = r[s]), +n === i.length - 1)
        return r;
      if (!r || typeof r != "object")
        return null;
    }
    return null;
  }
  function ns(t) {
    return t !== void 0 && t !== "false" && t !== !1 ? !0 : void 0;
  }
  function ud(t) {
    return Object.isFrozen(t) ? t : Object.defineProperty(t, "__init", {
      enumerable: !1,
      value: !0
    });
  }
  function yx(t) {
    return t.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, " ").trim().replace(/\s+/g, "-");
  }
  function Jne(t, e, i) {
    for (const r of i)
      r in t && Object.defineProperty(e, r, {
        enumerable: !1,
        value: t[r]
      });
    return e;
  }
  function Rb(t, e, i) {
    if (!Nne)
      return;
    i || (i = document);
    const r = i.getElementById(t);
    if (r)
      return e(r);
    const n = new MutationObserver(() => {
      const s = i == null ? void 0 : i.getElementById(t);
      s && (n == null || n.disconnect(), e(s));
    });
    n.observe(i, { childList: !0, subtree: !0 });
  }
  function Vne(t) {
    let e = !1;
    return (...i) => {
      if (!e)
        return e = !0, queueMicrotask(() => e = !1), t(...i);
    };
  }
  function Wne(t) {
    if (!(t === "false" || t === !1))
      return !0;
  }
  function Kne(t, e) {
    return t.filter((i) => Hs(i).geometry.type == e);
  }
  function Xne(t) {
    var i;
    const e = (i = t.getGeometry()) == null ? void 0 : i.getExtent();
    return e && !e.includes(1 / 0) ? xn(e) : [0, 0];
  }
  function Zne(t) {
    return t.length ? OL(t).features.filter((i) => i.geometry.type != "Point").flatMap(lx).map((i) => Ad(i)).map(Js) : [];
  }
  function HL(t, e) {
    const i = e.getProperties();
    t.setProperties({
      name: i.name,
      status: i.status
    }), t.setId(e.getId());
  }
  function qne(t, e) {
    const i = e.getProperties(), r = t.map((n, s) => {
      const o = js([n.geometry.coordinates]), a = Js(o);
      return a.setProperties({
        status: i.status,
        // create unique name by adding a index indicator
        name: i.name + (t.length > 1 ? ` (${s + 1})` : "")
      }), a;
    });
    return r[0].setId(e.getId()), r;
  }
  function _b(t, e) {
    return t === null && e === void 0 || t === void 0 && e === null ? !1 : t == e ? !0 : DA(t) && DA(e) ? Lr(t, e, !0) : Array.isArray(t) && Array.isArray(e) ? !(t.length !== e.length || !t.every((i, r) => _b(i, e[r]))) : !1;
  }
  function $ne(t, e) {
    const i = e.getProperties(), r = t.map((n, s) => {
      const o = js([n.geometry.coordinates]), a = Js(o);
      return a.setProperties({
        status: i.status,
        // create unique name by adding a index indicator
        name: i.name + (t.length > 1 ? ` (${s + 1})` : "")
      }), a;
    });
    return r[0].setId(e.getId()), r;
  }
  const ese = "#01010100", tse = "33", ise = 50, rse = {
    PRIMARY: "#3375d4",
    // dodger blue -> $dps-color-primary
    SECONDARY: "#7069d1",
    // slate blue -> $dps-color-plan
    green: "#3bb300",
    // green
    deeppink: "#ff38b9",
    // deep pink
    skyblue: "#38b9ff",
    // sky blue
    magenta: "#83049E",
    // magenta
    CADASTRAL: "#2B2B2B",
    // black
    SUPERIORAREA: "#ff5833"
    // orange red
  };
  function nse(t, e) {
    var r;
    const i = WL(t, e);
    return ((r = t.getGeometry()) == null ? void 0 : r.getType()) == "Point" ? VL(i, e.strokeWidth + 2) : JL(ese, i, e.strokeWidth);
  }
  function sse(t, e) {
    var r;
    const i = WL(t, e);
    return ((r = t.getGeometry()) == null ? void 0 : r.getType()) == "Point" ? VL(i, e.strokeWidth + 4) : JL(i + tse, i, e.strokeWidth + 2);
  }
  function JL(t, e, i) {
    return new hi({
      fill: new vr({ color: t }),
      stroke: new pr({ color: e, width: i })
    });
  }
  function VL(t, e) {
    return new hi({
      image: new Sa({
        radius: e,
        fill: new vr({ color: t }),
        stroke: new pr({ color: t, width: e })
      }),
      zIndex: 1 / 0
    });
  }
  function WL(t, e) {
    let i = rse[e.baseColor];
    return e.passive && (i = ose(i, ise)), i;
  }
  function ose(t, e) {
    const i = t.replace("#", "");
    if (i.length === 6) {
      const r = parseInt(i, 16);
      let n = (r >> 16) + e;
      n > 255 && (n = 255), n < 0 && (n = 0);
      let s = (r & 255) + e;
      s > 255 && (s = 255), s < 0 && (s = 0);
      let o = (r >> 8 & 255) + e;
      return o > 255 && (o = 255), o < 0 && (o = 0), `#${(s | o << 8 | n << 16).toString(16)}`;
    } else
      return t;
  }
  function KL(t, e) {
    return function() {
      return t.apply(e, arguments);
    };
  }
  const { toString: ase } = Object.prototype, { getPrototypeOf: Bx } = Object, MB = /* @__PURE__ */ ((t) => (e) => {
    const i = ase.call(e);
    return t[i] || (t[i] = i.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null)), so = (t) => (t = t.toLowerCase(), (e) => MB(e) === t), IB = (t) => (e) => typeof e === t, { isArray: zd } = Array, Cg = IB("undefined");
  function Ase(t) {
    return t !== null && !Cg(t) && t.constructor !== null && !Cg(t.constructor) && Un(t.constructor.isBuffer) && t.constructor.isBuffer(t);
  }
  const XL = so("ArrayBuffer");
  function lse(t) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && XL(t.buffer), e;
  }
  const cse = IB("string"), Un = IB("function"), ZL = IB("number"), vB = (t) => t !== null && typeof t == "object", use = (t) => t === !0 || t === !1, am = (t) => {
    if (MB(t) !== "object")
      return !1;
    const e = Bx(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
  }, dse = so("Date"), hse = so("File"), gse = so("Blob"), fse = so("FileList"), pse = (t) => vB(t) && Un(t.pipe), mse = (t) => {
    let e;
    return t && (typeof FormData == "function" && t instanceof FormData || Un(t.append) && ((e = MB(t)) === "formdata" || // detect form-data instance
    e === "object" && Un(t.toString) && t.toString() === "[object FormData]"));
  }, Ese = so("URLSearchParams"), [yse, Bse, wse, Cse] = ["ReadableStream", "Request", "Response", "Headers"].map(so), bse = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function wf(t, e, { allOwnKeys: i = !1 } = {}) {
    if (t === null || typeof t > "u")
      return;
    let r, n;
    if (typeof t != "object" && (t = [t]), zd(t))
      for (r = 0, n = t.length; r < n; r++)
        e.call(null, t[r], r, t);
    else {
      const s = i ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length;
      let a;
      for (r = 0; r < o; r++)
        a = s[r], e.call(null, t[a], a, t);
    }
  }
  function qL(t, e) {
    e = e.toLowerCase();
    const i = Object.keys(t);
    let r = i.length, n;
    for (; r-- > 0; )
      if (n = i[r], e === n.toLowerCase())
        return n;
    return null;
  }
  const yl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, $L = (t) => !Cg(t) && t !== yl;
  function kb() {
    const { caseless: t } = $L(this) && this || {}, e = {}, i = (r, n) => {
      const s = t && qL(e, n) || n;
      am(e[s]) && am(r) ? e[s] = kb(e[s], r) : am(r) ? e[s] = kb({}, r) : zd(r) ? e[s] = r.slice() : e[s] = r;
    };
    for (let r = 0, n = arguments.length; r < n; r++)
      arguments[r] && wf(arguments[r], i);
    return e;
  }
  const Mse = (t, e, i, { allOwnKeys: r } = {}) => (wf(e, (n, s) => {
    i && Un(n) ? t[s] = KL(n, i) : t[s] = n;
  }, { allOwnKeys: r }), t), Ise = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), vse = (t, e, i, r) => {
    t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
      value: e.prototype
    }), i && Object.assign(t.prototype, i);
  }, xse = (t, e, i, r) => {
    let n, s, o;
    const a = {};
    if (e = e || {}, t == null) return e;
    do {
      for (n = Object.getOwnPropertyNames(t), s = n.length; s-- > 0; )
        o = n[s], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
      t = i !== !1 && Bx(t);
    } while (t && (!i || i(t, e)) && t !== Object.prototype);
    return e;
  }, Qse = (t, e, i) => {
    t = String(t), (i === void 0 || i > t.length) && (i = t.length), i -= e.length;
    const r = t.indexOf(e, i);
    return r !== -1 && r === i;
  }, Fse = (t) => {
    if (!t) return null;
    if (zd(t)) return t;
    let e = t.length;
    if (!ZL(e)) return null;
    const i = new Array(e);
    for (; e-- > 0; )
      i[e] = t[e];
    return i;
  }, Sse = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Bx(Uint8Array)), Dse = (t, e) => {
    const r = (t && t[Symbol.iterator]).call(t);
    let n;
    for (; (n = r.next()) && !n.done; ) {
      const s = n.value;
      e.call(t, s[0], s[1]);
    }
  }, Tse = (t, e) => {
    let i;
    const r = [];
    for (; (i = t.exec(e)) !== null; )
      r.push(i);
    return r;
  }, Rse = so("HTMLFormElement"), _se = (t) => t.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function(i, r, n) {
      return r.toUpperCase() + n;
    }
  ), BT = (({ hasOwnProperty: t }) => (e, i) => t.call(e, i))(Object.prototype), kse = so("RegExp"), ez = (t, e) => {
    const i = Object.getOwnPropertyDescriptors(t), r = {};
    wf(i, (n, s) => {
      let o;
      (o = e(n, s, t)) !== !1 && (r[s] = o || n);
    }), Object.defineProperties(t, r);
  }, Yse = (t) => {
    ez(t, (e, i) => {
      if (Un(t) && ["arguments", "caller", "callee"].indexOf(i) !== -1)
        return !1;
      const r = t[i];
      if (Un(r)) {
        if (e.enumerable = !1, "writable" in e) {
          e.writable = !1;
          return;
        }
        e.set || (e.set = () => {
          throw Error("Can not rewrite read-only method '" + i + "'");
        });
      }
    });
  }, Nse = (t, e) => {
    const i = {}, r = (n) => {
      n.forEach((s) => {
        i[s] = !0;
      });
    };
    return zd(t) ? r(t) : r(String(t).split(e)), i;
  }, Use = () => {
  }, Lse = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;
  function zse(t) {
    return !!(t && Un(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
  }
  const Pse = (t) => {
    const e = new Array(10), i = (r, n) => {
      if (vB(r)) {
        if (e.indexOf(r) >= 0)
          return;
        if (!("toJSON" in r)) {
          e[n] = r;
          const s = zd(r) ? [] : {};
          return wf(r, (o, a) => {
            const A = i(o, n + 1);
            !Cg(A) && (s[a] = A);
          }), e[n] = void 0, s;
        }
      }
      return r;
    };
    return i(t, 0);
  }, Ose = so("AsyncFunction"), Gse = (t) => t && (vB(t) || Un(t)) && Un(t.then) && Un(t.catch), tz = ((t, e) => t ? setImmediate : e ? ((i, r) => (yl.addEventListener("message", ({ source: n, data: s }) => {
    n === yl && s === i && r.length && r.shift()();
  }, !1), (n) => {
    r.push(n), yl.postMessage(i, "*");
  }))(`axios@${Math.random()}`, []) : (i) => setTimeout(i))(
    typeof setImmediate == "function",
    Un(yl.postMessage)
  ), jse = typeof queueMicrotask < "u" ? queueMicrotask.bind(yl) : typeof process < "u" && process.nextTick || tz, ne = {
    isArray: zd,
    isArrayBuffer: XL,
    isBuffer: Ase,
    isFormData: mse,
    isArrayBufferView: lse,
    isString: cse,
    isNumber: ZL,
    isBoolean: use,
    isObject: vB,
    isPlainObject: am,
    isReadableStream: yse,
    isRequest: Bse,
    isResponse: wse,
    isHeaders: Cse,
    isUndefined: Cg,
    isDate: dse,
    isFile: hse,
    isBlob: gse,
    isRegExp: kse,
    isFunction: Un,
    isStream: pse,
    isURLSearchParams: Ese,
    isTypedArray: Sse,
    isFileList: fse,
    forEach: wf,
    merge: kb,
    extend: Mse,
    trim: bse,
    stripBOM: Ise,
    inherits: vse,
    toFlatObject: xse,
    kindOf: MB,
    kindOfTest: so,
    endsWith: Qse,
    toArray: Fse,
    forEachEntry: Dse,
    matchAll: Tse,
    isHTMLForm: Rse,
    hasOwnProperty: BT,
    hasOwnProp: BT,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: ez,
    freezeMethods: Yse,
    toObjectSet: Nse,
    toCamelCase: _se,
    noop: Use,
    toFiniteNumber: Lse,
    findKey: qL,
    global: yl,
    isContextDefined: $L,
    isSpecCompliantForm: zse,
    toJSONObject: Pse,
    isAsyncFn: Ose,
    isThenable: Gse,
    setImmediate: tz,
    asap: jse
  };
  function bt(t, e, i, r, n) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), i && (this.config = i), r && (this.request = r), n && (this.response = n, this.status = n.status ? n.status : null);
  }
  ne.inherits(bt, Error, {
    toJSON: function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: ne.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const iz = bt.prototype, rz = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((t) => {
    rz[t] = { value: t };
  });
  Object.defineProperties(bt, rz);
  Object.defineProperty(iz, "isAxiosError", { value: !0 });
  bt.from = (t, e, i, r, n, s) => {
    const o = Object.create(iz);
    return ne.toFlatObject(t, o, function(A) {
      return A !== Error.prototype;
    }, (a) => a !== "isAxiosError"), bt.call(o, t.message, e, i, r, n), o.cause = t, o.name = t.name, s && Object.assign(o, s), o;
  };
  const Hse = null;
  function Yb(t) {
    return ne.isPlainObject(t) || ne.isArray(t);
  }
  function nz(t) {
    return ne.endsWith(t, "[]") ? t.slice(0, -2) : t;
  }
  function wT(t, e, i) {
    return t ? t.concat(e).map(function(n, s) {
      return n = nz(n), !i && s ? "[" + n + "]" : n;
    }).join(i ? "." : "") : e;
  }
  function Jse(t) {
    return ne.isArray(t) && !t.some(Yb);
  }
  const Vse = ne.toFlatObject(ne, {}, null, function(e) {
    return /^is[A-Z]/.test(e);
  });
  function xB(t, e, i) {
    if (!ne.isObject(t))
      throw new TypeError("target must be an object");
    e = e || new FormData(), i = ne.toFlatObject(i, {
      metaTokens: !0,
      dots: !1,
      indexes: !1
    }, !1, function(f, p) {
      return !ne.isUndefined(p[f]);
    });
    const r = i.metaTokens, n = i.visitor || c, s = i.dots, o = i.indexes, A = (i.Blob || typeof Blob < "u" && Blob) && ne.isSpecCompliantForm(e);
    if (!ne.isFunction(n))
      throw new TypeError("visitor must be a function");
    function l(g) {
      if (g === null) return "";
      if (ne.isDate(g))
        return g.toISOString();
      if (!A && ne.isBlob(g))
        throw new bt("Blob is not supported. Use a Buffer instead.");
      return ne.isArrayBuffer(g) || ne.isTypedArray(g) ? A && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g;
    }
    function c(g, f, p) {
      let m = g;
      if (g && !p && typeof g == "object") {
        if (ne.endsWith(f, "{}"))
          f = r ? f : f.slice(0, -2), g = JSON.stringify(g);
        else if (ne.isArray(g) && Jse(g) || (ne.isFileList(g) || ne.endsWith(f, "[]")) && (m = ne.toArray(g)))
          return f = nz(f), m.forEach(function(y, C) {
            !(ne.isUndefined(y) || y === null) && e.append(
              // eslint-disable-next-line no-nested-ternary
              o === !0 ? wT([f], C, s) : o === null ? f : f + "[]",
              l(y)
            );
          }), !1;
      }
      return Yb(g) ? !0 : (e.append(wT(p, f, s), l(g)), !1);
    }
    const u = [], d = Object.assign(Vse, {
      defaultVisitor: c,
      convertValue: l,
      isVisitable: Yb
    });
    function h(g, f) {
      if (!ne.isUndefined(g)) {
        if (u.indexOf(g) !== -1)
          throw Error("Circular reference detected in " + f.join("."));
        u.push(g), ne.forEach(g, function(m, E) {
          (!(ne.isUndefined(m) || m === null) && n.call(
            e,
            m,
            ne.isString(E) ? E.trim() : E,
            f,
            d
          )) === !0 && h(m, f ? f.concat(E) : [E]);
        }), u.pop();
      }
    }
    if (!ne.isObject(t))
      throw new TypeError("data must be an object");
    return h(t), e;
  }
  function CT(t) {
    const e = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
      return e[r];
    });
  }
  function wx(t, e) {
    this._pairs = [], t && xB(t, this, e);
  }
  const sz = wx.prototype;
  sz.append = function(e, i) {
    this._pairs.push([e, i]);
  };
  sz.toString = function(e) {
    const i = e ? function(r) {
      return e.call(this, r, CT);
    } : CT;
    return this._pairs.map(function(n) {
      return i(n[0]) + "=" + i(n[1]);
    }, "").join("&");
  };
  function Wse(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function oz(t, e, i) {
    if (!e)
      return t;
    const r = i && i.encode || Wse;
    ne.isFunction(i) && (i = {
      serialize: i
    });
    const n = i && i.serialize;
    let s;
    if (n ? s = n(e, i) : s = ne.isURLSearchParams(e) ? e.toString() : new wx(e, i).toString(r), s) {
      const o = t.indexOf("#");
      o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
    }
    return t;
  }
  class bT {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(e, i, r) {
      return this.handlers.push({
        fulfilled: e,
        rejected: i,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null
      }), this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(e) {
      this.handlers[e] && (this.handlers[e] = null);
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      this.handlers && (this.handlers = []);
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(e) {
      ne.forEach(this.handlers, function(r) {
        r !== null && e(r);
      });
    }
  }
  const az = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  }, Kse = typeof URLSearchParams < "u" ? URLSearchParams : wx, Xse = typeof FormData < "u" ? FormData : null, Zse = typeof Blob < "u" ? Blob : null, qse = {
    isBrowser: !0,
    classes: {
      URLSearchParams: Kse,
      FormData: Xse,
      Blob: Zse
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  }, Cx = typeof window < "u" && typeof document < "u", Nb = typeof navigator == "object" && navigator || void 0, $se = Cx && (!Nb || ["ReactNative", "NativeScript", "NS"].indexOf(Nb.product) < 0), eoe = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts == "function", toe = Cx && window.location.href || "http://localhost", ioe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: Cx,
    hasStandardBrowserEnv: $se,
    hasStandardBrowserWebWorkerEnv: eoe,
    navigator: Nb,
    origin: toe
  }, Symbol.toStringTag, { value: "Module" })), kr = {
    ...ioe,
    ...qse
  };
  function roe(t, e) {
    return xB(t, new kr.classes.URLSearchParams(), Object.assign({
      visitor: function(i, r, n, s) {
        return kr.isNode && ne.isBuffer(i) ? (this.append(r, i.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
      }
    }, e));
  }
  function noe(t) {
    return ne.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
  }
  function soe(t) {
    const e = {}, i = Object.keys(t);
    let r;
    const n = i.length;
    let s;
    for (r = 0; r < n; r++)
      s = i[r], e[s] = t[s];
    return e;
  }
  function Az(t) {
    function e(i, r, n, s) {
      let o = i[s++];
      if (o === "__proto__") return !0;
      const a = Number.isFinite(+o), A = s >= i.length;
      return o = !o && ne.isArray(n) ? n.length : o, A ? (ne.hasOwnProp(n, o) ? n[o] = [n[o], r] : n[o] = r, !a) : ((!n[o] || !ne.isObject(n[o])) && (n[o] = []), e(i, r, n[o], s) && ne.isArray(n[o]) && (n[o] = soe(n[o])), !a);
    }
    if (ne.isFormData(t) && ne.isFunction(t.entries)) {
      const i = {};
      return ne.forEachEntry(t, (r, n) => {
        e(noe(r), n, i, 0);
      }), i;
    }
    return null;
  }
  function ooe(t, e, i) {
    if (ne.isString(t))
      try {
        return (e || JSON.parse)(t), ne.trim(t);
      } catch (r) {
        if (r.name !== "SyntaxError")
          throw r;
      }
    return (i || JSON.stringify)(t);
  }
  const Cf = {
    transitional: az,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, i) {
      const r = i.getContentType() || "", n = r.indexOf("application/json") > -1, s = ne.isObject(e);
      if (s && ne.isHTMLForm(e) && (e = new FormData(e)), ne.isFormData(e))
        return n ? JSON.stringify(Az(e)) : e;
      if (ne.isArrayBuffer(e) || ne.isBuffer(e) || ne.isStream(e) || ne.isFile(e) || ne.isBlob(e) || ne.isReadableStream(e))
        return e;
      if (ne.isArrayBufferView(e))
        return e.buffer;
      if (ne.isURLSearchParams(e))
        return i.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
      let a;
      if (s) {
        if (r.indexOf("application/x-www-form-urlencoded") > -1)
          return roe(e, this.formSerializer).toString();
        if ((a = ne.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
          const A = this.env && this.env.FormData;
          return xB(
            a ? { "files[]": e } : e,
            A && new A(),
            this.formSerializer
          );
        }
      }
      return s || n ? (i.setContentType("application/json", !1), ooe(e)) : e;
    }],
    transformResponse: [function(e) {
      const i = this.transitional || Cf.transitional, r = i && i.forcedJSONParsing, n = this.responseType === "json";
      if (ne.isResponse(e) || ne.isReadableStream(e))
        return e;
      if (e && ne.isString(e) && (r && !this.responseType || n)) {
        const o = !(i && i.silentJSONParsing) && n;
        try {
          return JSON.parse(e);
        } catch (a) {
          if (o)
            throw a.name === "SyntaxError" ? bt.from(a, bt.ERR_BAD_RESPONSE, this, null, this.response) : a;
        }
      }
      return e;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: kr.classes.FormData,
      Blob: kr.classes.Blob
    },
    validateStatus: function(e) {
      return e >= 200 && e < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  ne.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
    Cf.headers[t] = {};
  });
  const aoe = ne.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]), Aoe = (t) => {
    const e = {};
    let i, r, n;
    return t && t.split(`
`).forEach(function(o) {
      n = o.indexOf(":"), i = o.substring(0, n).trim().toLowerCase(), r = o.substring(n + 1).trim(), !(!i || e[i] && aoe[i]) && (i === "set-cookie" ? e[i] ? e[i].push(r) : e[i] = [r] : e[i] = e[i] ? e[i] + ", " + r : r);
    }), e;
  }, MT = Symbol("internals");
  function ah(t) {
    return t && String(t).trim().toLowerCase();
  }
  function Am(t) {
    return t === !1 || t == null ? t : ne.isArray(t) ? t.map(Am) : String(t);
  }
  function loe(t) {
    const e = /* @__PURE__ */ Object.create(null), i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = i.exec(t); )
      e[r[1]] = r[2];
    return e;
  }
  const coe = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
  function O0(t, e, i, r, n) {
    if (ne.isFunction(r))
      return r.call(this, e, i);
    if (n && (e = i), !!ne.isString(e)) {
      if (ne.isString(r))
        return e.indexOf(r) !== -1;
      if (ne.isRegExp(r))
        return r.test(e);
    }
  }
  function uoe(t) {
    return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, i, r) => i.toUpperCase() + r);
  }
  function doe(t, e) {
    const i = ne.toCamelCase(" " + e);
    ["get", "set", "has"].forEach((r) => {
      Object.defineProperty(t, r + i, {
        value: function(n, s, o) {
          return this[r].call(this, e, n, s, o);
        },
        configurable: !0
      });
    });
  }
  let Mn = class {
    constructor(e) {
      e && this.set(e);
    }
    set(e, i, r) {
      const n = this;
      function s(a, A, l) {
        const c = ah(A);
        if (!c)
          throw new Error("header name must be a non-empty string");
        const u = ne.findKey(n, c);
        (!u || n[u] === void 0 || l === !0 || l === void 0 && n[u] !== !1) && (n[u || A] = Am(a));
      }
      const o = (a, A) => ne.forEach(a, (l, c) => s(l, c, A));
      if (ne.isPlainObject(e) || e instanceof this.constructor)
        o(e, i);
      else if (ne.isString(e) && (e = e.trim()) && !coe(e))
        o(Aoe(e), i);
      else if (ne.isHeaders(e))
        for (const [a, A] of e.entries())
          s(A, a, r);
      else
        e != null && s(i, e, r);
      return this;
    }
    get(e, i) {
      if (e = ah(e), e) {
        const r = ne.findKey(this, e);
        if (r) {
          const n = this[r];
          if (!i)
            return n;
          if (i === !0)
            return loe(n);
          if (ne.isFunction(i))
            return i.call(this, n, r);
          if (ne.isRegExp(i))
            return i.exec(n);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(e, i) {
      if (e = ah(e), e) {
        const r = ne.findKey(this, e);
        return !!(r && this[r] !== void 0 && (!i || O0(this, this[r], r, i)));
      }
      return !1;
    }
    delete(e, i) {
      const r = this;
      let n = !1;
      function s(o) {
        if (o = ah(o), o) {
          const a = ne.findKey(r, o);
          a && (!i || O0(r, r[a], a, i)) && (delete r[a], n = !0);
        }
      }
      return ne.isArray(e) ? e.forEach(s) : s(e), n;
    }
    clear(e) {
      const i = Object.keys(this);
      let r = i.length, n = !1;
      for (; r--; ) {
        const s = i[r];
        (!e || O0(this, this[s], s, e, !0)) && (delete this[s], n = !0);
      }
      return n;
    }
    normalize(e) {
      const i = this, r = {};
      return ne.forEach(this, (n, s) => {
        const o = ne.findKey(r, s);
        if (o) {
          i[o] = Am(n), delete i[s];
          return;
        }
        const a = e ? uoe(s) : String(s).trim();
        a !== s && delete i[s], i[a] = Am(n), r[a] = !0;
      }), this;
    }
    concat(...e) {
      return this.constructor.concat(this, ...e);
    }
    toJSON(e) {
      const i = /* @__PURE__ */ Object.create(null);
      return ne.forEach(this, (r, n) => {
        r != null && r !== !1 && (i[n] = e && ne.isArray(r) ? r.join(", ") : r);
      }), i;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([e, i]) => e + ": " + i).join(`
`);
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(e) {
      return e instanceof this ? e : new this(e);
    }
    static concat(e, ...i) {
      const r = new this(e);
      return i.forEach((n) => r.set(n)), r;
    }
    static accessor(e) {
      const r = (this[MT] = this[MT] = {
        accessors: {}
      }).accessors, n = this.prototype;
      function s(o) {
        const a = ah(o);
        r[a] || (doe(n, o), r[a] = !0);
      }
      return ne.isArray(e) ? e.forEach(s) : s(e), this;
    }
  };
  Mn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  ne.reduceDescriptors(Mn.prototype, ({ value: t }, e) => {
    let i = e[0].toUpperCase() + e.slice(1);
    return {
      get: () => t,
      set(r) {
        this[i] = r;
      }
    };
  });
  ne.freezeMethods(Mn);
  function G0(t, e) {
    const i = this || Cf, r = e || i, n = Mn.from(r.headers);
    let s = r.data;
    return ne.forEach(t, function(a) {
      s = a.call(i, s, n.normalize(), e ? e.status : void 0);
    }), n.normalize(), s;
  }
  function lz(t) {
    return !!(t && t.__CANCEL__);
  }
  function Pd(t, e, i) {
    bt.call(this, t ?? "canceled", bt.ERR_CANCELED, e, i), this.name = "CanceledError";
  }
  ne.inherits(Pd, bt, {
    __CANCEL__: !0
  });
  function cz(t, e, i) {
    const r = i.config.validateStatus;
    !i.status || !r || r(i.status) ? t(i) : e(new bt(
      "Request failed with status code " + i.status,
      [bt.ERR_BAD_REQUEST, bt.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],
      i.config,
      i.request,
      i
    ));
  }
  function hoe(t) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return e && e[1] || "";
  }
  function goe(t, e) {
    t = t || 10;
    const i = new Array(t), r = new Array(t);
    let n = 0, s = 0, o;
    return e = e !== void 0 ? e : 1e3, function(A) {
      const l = Date.now(), c = r[s];
      o || (o = l), i[n] = A, r[n] = l;
      let u = s, d = 0;
      for (; u !== n; )
        d += i[u++], u = u % t;
      if (n = (n + 1) % t, n === s && (s = (s + 1) % t), l - o < e)
        return;
      const h = c && l - c;
      return h ? Math.round(d * 1e3 / h) : void 0;
    };
  }
  function foe(t, e) {
    let i = 0, r = 1e3 / e, n, s;
    const o = (l, c = Date.now()) => {
      i = c, n = null, s && (clearTimeout(s), s = null), t.apply(null, l);
    };
    return [(...l) => {
      const c = Date.now(), u = c - i;
      u >= r ? o(l, c) : (n = l, s || (s = setTimeout(() => {
        s = null, o(n);
      }, r - u)));
    }, () => n && o(n)];
  }
  const UE = (t, e, i = 3) => {
    let r = 0;
    const n = goe(50, 250);
    return foe((s) => {
      const o = s.loaded, a = s.lengthComputable ? s.total : void 0, A = o - r, l = n(A), c = o <= a;
      r = o;
      const u = {
        loaded: o,
        total: a,
        progress: a ? o / a : void 0,
        bytes: A,
        rate: l || void 0,
        estimated: l && a && c ? (a - o) / l : void 0,
        event: s,
        lengthComputable: a != null,
        [e ? "download" : "upload"]: !0
      };
      t(u);
    }, i);
  }, IT = (t, e) => {
    const i = t != null;
    return [(r) => e[0]({
      lengthComputable: i,
      total: t,
      loaded: r
    }), e[1]];
  }, vT = (t) => (...e) => ne.asap(() => t(...e)), poe = kr.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (i) => (i = new URL(i, kr.origin), t.protocol === i.protocol && t.host === i.host && (e || t.port === i.port)))(
    new URL(kr.origin),
    kr.navigator && /(msie|trident)/i.test(kr.navigator.userAgent)
  ) : () => !0, moe = kr.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(t, e, i, r, n, s) {
        const o = [t + "=" + encodeURIComponent(e)];
        ne.isNumber(i) && o.push("expires=" + new Date(i).toGMTString()), ne.isString(r) && o.push("path=" + r), ne.isString(n) && o.push("domain=" + n), s === !0 && o.push("secure"), document.cookie = o.join("; ");
      },
      read(t) {
        const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
        return e ? decodeURIComponent(e[3]) : null;
      },
      remove(t) {
        this.write(t, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function Eoe(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
  }
  function yoe(t, e) {
    return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
  }
  function uz(t, e, i) {
    let r = !Eoe(e);
    return t && (r || i == !1) ? yoe(t, e) : e;
  }
  const xT = (t) => t instanceof Mn ? { ...t } : t;
  function Gl(t, e) {
    e = e || {};
    const i = {};
    function r(l, c, u, d) {
      return ne.isPlainObject(l) && ne.isPlainObject(c) ? ne.merge.call({ caseless: d }, l, c) : ne.isPlainObject(c) ? ne.merge({}, c) : ne.isArray(c) ? c.slice() : c;
    }
    function n(l, c, u, d) {
      if (ne.isUndefined(c)) {
        if (!ne.isUndefined(l))
          return r(void 0, l, u, d);
      } else return r(l, c, u, d);
    }
    function s(l, c) {
      if (!ne.isUndefined(c))
        return r(void 0, c);
    }
    function o(l, c) {
      if (ne.isUndefined(c)) {
        if (!ne.isUndefined(l))
          return r(void 0, l);
      } else return r(void 0, c);
    }
    function a(l, c, u) {
      if (u in e)
        return r(l, c);
      if (u in t)
        return r(void 0, l);
    }
    const A = {
      url: s,
      method: s,
      data: s,
      baseURL: o,
      transformRequest: o,
      transformResponse: o,
      paramsSerializer: o,
      timeout: o,
      timeoutMessage: o,
      withCredentials: o,
      withXSRFToken: o,
      adapter: o,
      responseType: o,
      xsrfCookieName: o,
      xsrfHeaderName: o,
      onUploadProgress: o,
      onDownloadProgress: o,
      decompress: o,
      maxContentLength: o,
      maxBodyLength: o,
      beforeRedirect: o,
      transport: o,
      httpAgent: o,
      httpsAgent: o,
      cancelToken: o,
      socketPath: o,
      responseEncoding: o,
      validateStatus: a,
      headers: (l, c, u) => n(xT(l), xT(c), u, !0)
    };
    return ne.forEach(Object.keys(Object.assign({}, t, e)), function(c) {
      const u = A[c] || n, d = u(t[c], e[c], c);
      ne.isUndefined(d) && u !== a || (i[c] = d);
    }), i;
  }
  const dz = (t) => {
    const e = Gl({}, t);
    let { data: i, withXSRFToken: r, xsrfHeaderName: n, xsrfCookieName: s, headers: o, auth: a } = e;
    e.headers = o = Mn.from(o), e.url = oz(uz(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), a && o.set(
      "Authorization",
      "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
    );
    let A;
    if (ne.isFormData(i)) {
      if (kr.hasStandardBrowserEnv || kr.hasStandardBrowserWebWorkerEnv)
        o.setContentType(void 0);
      else if ((A = o.getContentType()) !== !1) {
        const [l, ...c] = A ? A.split(";").map((u) => u.trim()).filter(Boolean) : [];
        o.setContentType([l || "multipart/form-data", ...c].join("; "));
      }
    }
    if (kr.hasStandardBrowserEnv && (r && ne.isFunction(r) && (r = r(e)), r || r !== !1 && poe(e.url))) {
      const l = n && s && moe.read(s);
      l && o.set(n, l);
    }
    return e;
  }, Boe = typeof XMLHttpRequest < "u", woe = Boe && function(t) {
    return new Promise(function(i, r) {
      const n = dz(t);
      let s = n.data;
      const o = Mn.from(n.headers).normalize();
      let { responseType: a, onUploadProgress: A, onDownloadProgress: l } = n, c, u, d, h, g;
      function f() {
        h && h(), g && g(), n.cancelToken && n.cancelToken.unsubscribe(c), n.signal && n.signal.removeEventListener("abort", c);
      }
      let p = new XMLHttpRequest();
      p.open(n.method.toUpperCase(), n.url, !0), p.timeout = n.timeout;
      function m() {
        if (!p)
          return;
        const y = Mn.from(
          "getAllResponseHeaders" in p && p.getAllResponseHeaders()
        ), w = {
          data: !a || a === "text" || a === "json" ? p.responseText : p.response,
          status: p.status,
          statusText: p.statusText,
          headers: y,
          config: t,
          request: p
        };
        cz(function(I) {
          i(I), f();
        }, function(I) {
          r(I), f();
        }, w), p = null;
      }
      "onloadend" in p ? p.onloadend = m : p.onreadystatechange = function() {
        !p || p.readyState !== 4 || p.status === 0 && !(p.responseURL && p.responseURL.indexOf("file:") === 0) || setTimeout(m);
      }, p.onabort = function() {
        p && (r(new bt("Request aborted", bt.ECONNABORTED, t, p)), p = null);
      }, p.onerror = function() {
        r(new bt("Network Error", bt.ERR_NETWORK, t, p)), p = null;
      }, p.ontimeout = function() {
        let C = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
        const w = n.transitional || az;
        n.timeoutErrorMessage && (C = n.timeoutErrorMessage), r(new bt(
          C,
          w.clarifyTimeoutError ? bt.ETIMEDOUT : bt.ECONNABORTED,
          t,
          p
        )), p = null;
      }, s === void 0 && o.setContentType(null), "setRequestHeader" in p && ne.forEach(o.toJSON(), function(C, w) {
        p.setRequestHeader(w, C);
      }), ne.isUndefined(n.withCredentials) || (p.withCredentials = !!n.withCredentials), a && a !== "json" && (p.responseType = n.responseType), l && ([d, g] = UE(l, !0), p.addEventListener("progress", d)), A && p.upload && ([u, h] = UE(A), p.upload.addEventListener("progress", u), p.upload.addEventListener("loadend", h)), (n.cancelToken || n.signal) && (c = (y) => {
        p && (r(!y || y.type ? new Pd(null, t, p) : y), p.abort(), p = null);
      }, n.cancelToken && n.cancelToken.subscribe(c), n.signal && (n.signal.aborted ? c() : n.signal.addEventListener("abort", c)));
      const E = hoe(n.url);
      if (E && kr.protocols.indexOf(E) === -1) {
        r(new bt("Unsupported protocol " + E + ":", bt.ERR_BAD_REQUEST, t));
        return;
      }
      p.send(s || null);
    });
  }, Coe = (t, e) => {
    const { length: i } = t = t ? t.filter(Boolean) : [];
    if (e || i) {
      let r = new AbortController(), n;
      const s = function(l) {
        if (!n) {
          n = !0, a();
          const c = l instanceof Error ? l : this.reason;
          r.abort(c instanceof bt ? c : new Pd(c instanceof Error ? c.message : c));
        }
      };
      let o = e && setTimeout(() => {
        o = null, s(new bt(`timeout ${e} of ms exceeded`, bt.ETIMEDOUT));
      }, e);
      const a = () => {
        t && (o && clearTimeout(o), o = null, t.forEach((l) => {
          l.unsubscribe ? l.unsubscribe(s) : l.removeEventListener("abort", s);
        }), t = null);
      };
      t.forEach((l) => l.addEventListener("abort", s));
      const { signal: A } = r;
      return A.unsubscribe = () => ne.asap(a), A;
    }
  }, boe = function* (t, e) {
    let i = t.byteLength;
    if (i < e) {
      yield t;
      return;
    }
    let r = 0, n;
    for (; r < i; )
      n = r + e, yield t.slice(r, n), r = n;
  }, Moe = async function* (t, e) {
    for await (const i of Ioe(t))
      yield* boe(i, e);
  }, Ioe = async function* (t) {
    if (t[Symbol.asyncIterator]) {
      yield* t;
      return;
    }
    const e = t.getReader();
    try {
      for (; ; ) {
        const { done: i, value: r } = await e.read();
        if (i)
          break;
        yield r;
      }
    } finally {
      await e.cancel();
    }
  }, QT = (t, e, i, r) => {
    const n = Moe(t, e);
    let s = 0, o, a = (A) => {
      o || (o = !0, r && r(A));
    };
    return new ReadableStream({
      async pull(A) {
        try {
          const { done: l, value: c } = await n.next();
          if (l) {
            a(), A.close();
            return;
          }
          let u = c.byteLength;
          if (i) {
            let d = s += u;
            i(d);
          }
          A.enqueue(new Uint8Array(c));
        } catch (l) {
          throw a(l), l;
        }
      },
      cancel(A) {
        return a(A), n.return();
      }
    }, {
      highWaterMark: 2
    });
  }, QB = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", hz = QB && typeof ReadableStream == "function", voe = QB && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), gz = (t, ...e) => {
    try {
      return !!t(...e);
    } catch {
      return !1;
    }
  }, xoe = hz && gz(() => {
    let t = !1;
    const e = new Request(kr.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        return t = !0, "half";
      }
    }).headers.has("Content-Type");
    return t && !e;
  }), FT = 64 * 1024, Ub = hz && gz(() => ne.isReadableStream(new Response("").body)), LE = {
    stream: Ub && ((t) => t.body)
  };
  QB && ((t) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
      !LE[e] && (LE[e] = ne.isFunction(t[e]) ? (i) => i[e]() : (i, r) => {
        throw new bt(`Response type '${e}' is not supported`, bt.ERR_NOT_SUPPORT, r);
      });
    });
  })(new Response());
  const Qoe = async (t) => {
    if (t == null)
      return 0;
    if (ne.isBlob(t))
      return t.size;
    if (ne.isSpecCompliantForm(t))
      return (await new Request(kr.origin, {
        method: "POST",
        body: t
      }).arrayBuffer()).byteLength;
    if (ne.isArrayBufferView(t) || ne.isArrayBuffer(t))
      return t.byteLength;
    if (ne.isURLSearchParams(t) && (t = t + ""), ne.isString(t))
      return (await voe(t)).byteLength;
  }, Foe = async (t, e) => {
    const i = ne.toFiniteNumber(t.getContentLength());
    return i ?? Qoe(e);
  }, Soe = QB && (async (t) => {
    let {
      url: e,
      method: i,
      data: r,
      signal: n,
      cancelToken: s,
      timeout: o,
      onDownloadProgress: a,
      onUploadProgress: A,
      responseType: l,
      headers: c,
      withCredentials: u = "same-origin",
      fetchOptions: d
    } = dz(t);
    l = l ? (l + "").toLowerCase() : "text";
    let h = Coe([n, s && s.toAbortSignal()], o), g;
    const f = h && h.unsubscribe && (() => {
      h.unsubscribe();
    });
    let p;
    try {
      if (A && xoe && i !== "get" && i !== "head" && (p = await Foe(c, r)) !== 0) {
        let w = new Request(e, {
          method: "POST",
          body: r,
          duplex: "half"
        }), M;
        if (ne.isFormData(r) && (M = w.headers.get("content-type")) && c.setContentType(M), w.body) {
          const [I, b] = IT(
            p,
            UE(vT(A))
          );
          r = QT(w.body, FT, I, b);
        }
      }
      ne.isString(u) || (u = u ? "include" : "omit");
      const m = "credentials" in Request.prototype;
      g = new Request(e, {
        ...d,
        signal: h,
        method: i.toUpperCase(),
        headers: c.normalize().toJSON(),
        body: r,
        duplex: "half",
        credentials: m ? u : void 0
      });
      let E = await fetch(g);
      const y = Ub && (l === "stream" || l === "response");
      if (Ub && (a || y && f)) {
        const w = {};
        ["status", "statusText", "headers"].forEach((B) => {
          w[B] = E[B];
        });
        const M = ne.toFiniteNumber(E.headers.get("content-length")), [I, b] = a && IT(
          M,
          UE(vT(a), !0)
        ) || [];
        E = new Response(
          QT(E.body, FT, I, () => {
            b && b(), f && f();
          }),
          w
        );
      }
      l = l || "text";
      let C = await LE[ne.findKey(LE, l) || "text"](E, t);
      return !y && f && f(), await new Promise((w, M) => {
        cz(w, M, {
          data: C,
          headers: Mn.from(E.headers),
          status: E.status,
          statusText: E.statusText,
          config: t,
          request: g
        });
      });
    } catch (m) {
      throw f && f(), m && m.name === "TypeError" && /fetch/i.test(m.message) ? Object.assign(
        new bt("Network Error", bt.ERR_NETWORK, t, g),
        {
          cause: m.cause || m
        }
      ) : bt.from(m, m && m.code, t, g);
    }
  }), Lb = {
    http: Hse,
    xhr: woe,
    fetch: Soe
  };
  ne.forEach(Lb, (t, e) => {
    if (t) {
      try {
        Object.defineProperty(t, "name", { value: e });
      } catch {
      }
      Object.defineProperty(t, "adapterName", { value: e });
    }
  });
  const ST = (t) => `- ${t}`, Doe = (t) => ne.isFunction(t) || t === null || t === !1, fz = {
    getAdapter: (t) => {
      t = ne.isArray(t) ? t : [t];
      const { length: e } = t;
      let i, r;
      const n = {};
      for (let s = 0; s < e; s++) {
        i = t[s];
        let o;
        if (r = i, !Doe(i) && (r = Lb[(o = String(i)).toLowerCase()], r === void 0))
          throw new bt(`Unknown adapter '${o}'`);
        if (r)
          break;
        n[o || "#" + s] = r;
      }
      if (!r) {
        const s = Object.entries(n).map(
          ([a, A]) => `adapter ${a} ` + (A === !1 ? "is not supported by the environment" : "is not available in the build")
        );
        let o = e ? s.length > 1 ? `since :
` + s.map(ST).join(`
`) : " " + ST(s[0]) : "as no adapter specified";
        throw new bt(
          "There is no suitable adapter to dispatch the request " + o,
          "ERR_NOT_SUPPORT"
        );
      }
      return r;
    },
    adapters: Lb
  };
  function j0(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
      throw new Pd(null, t);
  }
  function DT(t) {
    return j0(t), t.headers = Mn.from(t.headers), t.data = G0.call(
      t,
      t.transformRequest
    ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), fz.getAdapter(t.adapter || Cf.adapter)(t).then(function(r) {
      return j0(t), r.data = G0.call(
        t,
        t.transformResponse,
        r
      ), r.headers = Mn.from(r.headers), r;
    }, function(r) {
      return lz(r) || (j0(t), r && r.response && (r.response.data = G0.call(
        t,
        t.transformResponse,
        r.response
      ), r.response.headers = Mn.from(r.response.headers))), Promise.reject(r);
    });
  }
  const pz = "1.8.4", FB = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
    FB[t] = function(r) {
      return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
    };
  });
  const TT = {};
  FB.transitional = function(e, i, r) {
    function n(s, o) {
      return "[Axios v" + pz + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "");
    }
    return (s, o, a) => {
      if (e === !1)
        throw new bt(
          n(o, " has been removed" + (i ? " in " + i : "")),
          bt.ERR_DEPRECATED
        );
      return i && !TT[o] && (TT[o] = !0, console.warn(
        n(
          o,
          " has been deprecated since v" + i + " and will be removed in the near future"
        )
      )), e ? e(s, o, a) : !0;
    };
  };
  FB.spelling = function(e) {
    return (i, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0);
  };
  function Toe(t, e, i) {
    if (typeof t != "object")
      throw new bt("options must be an object", bt.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(t);
    let n = r.length;
    for (; n-- > 0; ) {
      const s = r[n], o = e[s];
      if (o) {
        const a = t[s], A = a === void 0 || o(a, s, t);
        if (A !== !0)
          throw new bt("option " + s + " must be " + A, bt.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (i !== !0)
        throw new bt("Unknown option " + s, bt.ERR_BAD_OPTION);
    }
  }
  const lm = {
    assertOptions: Toe,
    validators: FB
  }, Ao = lm.validators;
  let xl = class {
    constructor(e) {
      this.defaults = e, this.interceptors = {
        request: new bT(),
        response: new bT()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(e, i) {
      try {
        return await this._request(e, i);
      } catch (r) {
        if (r instanceof Error) {
          let n = {};
          Error.captureStackTrace ? Error.captureStackTrace(n) : n = new Error();
          const s = n.stack ? n.stack.replace(/^.+\n/, "") : "";
          try {
            r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s;
          } catch {
          }
        }
        throw r;
      }
    }
    _request(e, i) {
      typeof e == "string" ? (i = i || {}, i.url = e) : i = e || {}, i = Gl(this.defaults, i);
      const { transitional: r, paramsSerializer: n, headers: s } = i;
      r !== void 0 && lm.assertOptions(r, {
        silentJSONParsing: Ao.transitional(Ao.boolean),
        forcedJSONParsing: Ao.transitional(Ao.boolean),
        clarifyTimeoutError: Ao.transitional(Ao.boolean)
      }, !1), n != null && (ne.isFunction(n) ? i.paramsSerializer = {
        serialize: n
      } : lm.assertOptions(n, {
        encode: Ao.function,
        serialize: Ao.function
      }, !0)), i.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? i.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : i.allowAbsoluteUrls = !0), lm.assertOptions(i, {
        baseUrl: Ao.spelling("baseURL"),
        withXsrfToken: Ao.spelling("withXSRFToken")
      }, !0), i.method = (i.method || this.defaults.method || "get").toLowerCase();
      let o = s && ne.merge(
        s.common,
        s[i.method]
      );
      s && ne.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (g) => {
          delete s[g];
        }
      ), i.headers = Mn.concat(o, s);
      const a = [];
      let A = !0;
      this.interceptors.request.forEach(function(f) {
        typeof f.runWhen == "function" && f.runWhen(i) === !1 || (A = A && f.synchronous, a.unshift(f.fulfilled, f.rejected));
      });
      const l = [];
      this.interceptors.response.forEach(function(f) {
        l.push(f.fulfilled, f.rejected);
      });
      let c, u = 0, d;
      if (!A) {
        const g = [DT.bind(this), void 0];
        for (g.unshift.apply(g, a), g.push.apply(g, l), d = g.length, c = Promise.resolve(i); u < d; )
          c = c.then(g[u++], g[u++]);
        return c;
      }
      d = a.length;
      let h = i;
      for (u = 0; u < d; ) {
        const g = a[u++], f = a[u++];
        try {
          h = g(h);
        } catch (p) {
          f.call(this, p);
          break;
        }
      }
      try {
        c = DT.call(this, h);
      } catch (g) {
        return Promise.reject(g);
      }
      for (u = 0, d = l.length; u < d; )
        c = c.then(l[u++], l[u++]);
      return c;
    }
    getUri(e) {
      e = Gl(this.defaults, e);
      const i = uz(e.baseURL, e.url, e.allowAbsoluteUrls);
      return oz(i, e.params, e.paramsSerializer);
    }
  };
  ne.forEach(["delete", "get", "head", "options"], function(e) {
    xl.prototype[e] = function(i, r) {
      return this.request(Gl(r || {}, {
        method: e,
        url: i,
        data: (r || {}).data
      }));
    };
  });
  ne.forEach(["post", "put", "patch"], function(e) {
    function i(r) {
      return function(s, o, a) {
        return this.request(Gl(a || {}, {
          method: e,
          headers: r ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: s,
          data: o
        }));
      };
    }
    xl.prototype[e] = i(), xl.prototype[e + "Form"] = i(!0);
  });
  let Roe = class mz {
    constructor(e) {
      if (typeof e != "function")
        throw new TypeError("executor must be a function.");
      let i;
      this.promise = new Promise(function(s) {
        i = s;
      });
      const r = this;
      this.promise.then((n) => {
        if (!r._listeners) return;
        let s = r._listeners.length;
        for (; s-- > 0; )
          r._listeners[s](n);
        r._listeners = null;
      }), this.promise.then = (n) => {
        let s;
        const o = new Promise((a) => {
          r.subscribe(a), s = a;
        }).then(n);
        return o.cancel = function() {
          r.unsubscribe(s);
        }, o;
      }, e(function(s, o, a) {
        r.reason || (r.reason = new Pd(s, o, a), i(r.reason));
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason)
        throw this.reason;
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(e) {
      if (this.reason) {
        e(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(e) : this._listeners = [e];
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(e) {
      if (!this._listeners)
        return;
      const i = this._listeners.indexOf(e);
      i !== -1 && this._listeners.splice(i, 1);
    }
    toAbortSignal() {
      const e = new AbortController(), i = (r) => {
        e.abort(r);
      };
      return this.subscribe(i), e.signal.unsubscribe = () => this.unsubscribe(i), e.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let e;
      return {
        token: new mz(function(n) {
          e = n;
        }),
        cancel: e
      };
    }
  };
  function _oe(t) {
    return function(i) {
      return t.apply(null, i);
    };
  }
  function koe(t) {
    return ne.isObject(t) && t.isAxiosError === !0;
  }
  const zb = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(zb).forEach(([t, e]) => {
    zb[e] = t;
  });
  function Ez(t) {
    const e = new xl(t), i = KL(xl.prototype.request, e);
    return ne.extend(i, xl.prototype, e, { allOwnKeys: !0 }), ne.extend(i, e, null, { allOwnKeys: !0 }), i.create = function(n) {
      return Ez(Gl(t, n));
    }, i;
  }
  const Bi = Ez(Cf);
  Bi.Axios = xl;
  Bi.CanceledError = Pd;
  Bi.CancelToken = Roe;
  Bi.isCancel = lz;
  Bi.VERSION = pz;
  Bi.toFormData = xB;
  Bi.AxiosError = bt;
  Bi.Cancel = Bi.CanceledError;
  Bi.all = function(e) {
    return Promise.all(e);
  };
  Bi.spread = _oe;
  Bi.isAxiosError = koe;
  Bi.mergeConfig = Gl;
  Bi.AxiosHeaders = Mn;
  Bi.formToJSON = (t) => Az(ne.isHTMLForm(t) ? new FormData(t) : t);
  Bi.getAdapter = fz.getAdapter;
  Bi.HttpStatusCode = zb;
  Bi.default = Bi;
  const {
    Axios: p1e,
    AxiosError: m1e,
    CanceledError: E1e,
    isCancel: y1e,
    CancelToken: B1e,
    VERSION: w1e,
    all: C1e,
    Cancel: b1e,
    isAxiosError: M1e,
    spread: I1e,
    toFormData: v1e,
    AxiosHeaders: x1e,
    HttpStatusCode: Q1e,
    formToJSON: F1e,
    getAdapter: S1e,
    mergeConfig: D1e
  } = Bi;
  function Yoe(t) {
    if (!t)
      return;
    const e = t.split("?");
    if (e.length < 2)
      return;
    const i = e[0], r = e[1].split("&"), n = Ah(r, "layers").split(","), s = Ah(r, "service"), o = Ah(r, "version"), a = Ah(r, "format"), A = Ah(r, "transparent");
    if (!Noe(i, s, o).then((d) => d))
      return;
    const c = n.map((d) => ({
      id: h3("xplanLayer_"),
      name: d,
      url: i,
      typ: s === "WMS" ? "WMS" : "WFS",
      layers: Uoe(d),
      format: a,
      version: o,
      singleTile: !0,
      transparent: A === "true",
      transparency: 0,
      urlIsVisible: !0,
      styles: "vollflaechig",
      tilesize: 512,
      gutter: 0,
      minScale: "0",
      maxScale: "10000",
      infoFormat: "text/xml",
      gfiAttributes: "showAll",
      gfiTheme: "default",
      layerAttribution: "nicht vorhanden",
      legendURL: "",
      cache: !1,
      featureCount: 1,
      notSupportedFor3DNeu: !1
    })), u = c.map((d) => ({
      Titel: d.name,
      Ordinal: 1,
      Layer: [
        {
          id: d.id
        }
      ]
    }));
    return {
      layers: c,
      config: { Ordner: u }
    };
  }
  function Noe(t, e, i) {
    const r = t + "?service=" + e + "&version=" + i + "&request=GetCapabilities";
    return Bi.get(r).then((n) => !!n.data.toLowerCase().includes("<Name>WMS</Name>"));
  }
  function Uoe(t) {
    switch (t) {
      case "BP_Planvektor":
        return "bp_objekte";
      case "BP_Planraster":
        return "bp_raster";
      case "SO_Planvektor":
        return "so_objekte";
      case "SO_Planraster":
        return "so_raster";
      case "FP_Planvektor":
        return "fp_objekte";
      case "FP_Planraster":
        return "fp_raster";
      case "LP_Planvektor":
        return "lp_objekte";
      case "LP_Planraster":
        return "lp_raster";
      case "RP_Planvektor":
        return "rp_objekte";
      case "RP_Planraster":
        return "rp_raster";
      default:
        return t;
    }
  }
  function Ah(t, e) {
    const i = t.filter((r) => r.includes(e))[0].split("=");
    return i.length >= 1 ? i[i.length - 1] : "";
  }
  function Loe(t) {
    const e = t.get("strokeWidth"), i = t.get("baseColor"), r = t.get("passive");
    return { strokeWidth: e, baseColor: i, passive: r };
  }
  function zoe(t, e) {
    const i = new Do({ wrapX: !1 }), r = new Bs({
      source: i,
      style: (c) => (
        // get the base styling for the feature
        nse(c, e)
      )
    });
    r.set("key", t), r.set("strokeWidth", e.strokeWidth), r.set("baseColor", e.baseColor), r.set("passive", e.passive);
    const n = (c) => c ? i.getFeatures().filter((u) => {
      var d;
      return c.includes(((d = u.getGeometry()) == null ? void 0 : d.getType()) || "");
    }) : i.getFeatures(), s = (c) => i.addFeatures(c), o = () => i.clear(), a = (c) => i.removeFeature(c), A = {}, l = () => e.onDrawStart();
    if (e.selectOff || e.selectOn) {
      const c = new ax({
        layers: [r],
        condition: lie,
        style: (h) => (
          // get the styling while the feature is selected
          sse(h, e)
        )
      });
      A.select = c;
      const u = (h) => e.selectOn(h.element, [...c.getFeatures().getArray(), h.element]), d = (h) => e.selectOff(
        h.element,
        c.getFeatures().getArray().filter((g) => g != h.element)
      );
      er(() => {
        typeof e.selectOn == "function" && c.getFeatures().on("add", u), typeof e.selectOff == "function" && c.getFeatures().on("remove", d);
      }), Fs(() => {
        c.getFeatures().un("add", u), c.getFeatures().un("remove", d);
      });
    }
    if (e.onPolygonDrawEnd) {
      const c = new KD({
        source: i,
        type: "MultiPolygon"
      });
      A.polygon = c;
      const u = (d) => e.onPolygonDrawEnd(d.feature);
      er(() => {
        typeof e.onPolygonDrawEnd == "function" && c.on("drawend", u), typeof e.onDrawStart == "function" && c.on("drawstart", l);
      }), Fs(() => {
        typeof e.onPolygonDrawEnd == "function" && c.un("drawend", u), typeof e.onDrawStart == "function" && c.un("drawstart", l);
      });
    }
    if (e.onCircleDrawEnd) {
      const c = new CL({
        source: i,
        sides: 2
      });
      A.circle = c;
      const u = (d) => e.onCircleDrawEnd(d.feature);
      er(() => {
        typeof e.onCircleDrawEnd == "function" && c.on("drawend", u), typeof e.onDrawStart == "function" && c.on("drawstart", l);
      }), Fs(() => {
        typeof e.onCircleDrawEnd == "function" && c.un("drawend", u), typeof e.onDrawStart == "function" && c.un("drawstart", l);
      });
    }
    if (e.onLineDrawEnd) {
      const c = new KD({
        source: i,
        type: "LineString"
      });
      A.line = c;
      const u = (d) => e.onLineDrawEnd(d.feature);
      er(() => {
        typeof e.onLineDrawEnd == "function" && c.on("drawend", u), typeof e.onDrawStart == "function" && c.on("drawstart", l);
      }), Fs(() => {
        typeof e.onLineDrawEnd == "function" && c.un("drawend", u), typeof e.onDrawStart == "function" && c.un("drawstart", l);
      });
    }
    if (e.onCircleDrawEnd || e.onPolygonDrawEnd || e.onLineDrawEnd) {
      const c = new Qie({ source: i }), u = new Yie({ source: i });
      if (A.modify = c, A.snap = u, e.onModifyEnd) {
        const d = () => e.onModifyEnd();
        er(() => {
          typeof e.onModifyEnd == "function" && c.on("modifyend", d);
        }), Fs(() => {
          typeof e.onModifyEnd == "function" && c.un("modifyend", d);
        });
      }
    }
    if (e.onDragBox) {
      const c = new hL({
        condition: lL,
        className: "border border-primary border-3"
      });
      A.dragBox = c;
      const u = (d) => e.onDragBox(d.target);
      er(() => {
        typeof e.onDragBox == "function" && c.on("boxend", u);
      }), Fs(() => {
        typeof e.onDragBox == "function" && c.un("boxend", u);
      });
    }
    return {
      key: t,
      ...e,
      source: i,
      layer: r,
      interactions: A,
      getFeatures: n,
      addFeatures: s,
      removeFeature: a,
      clear: o
    };
  }
  const rn = {
    target: "map",
    epsg: "EPSG:25832",
    backgroundImage: "",
    extent: [51e4, 585e4, 625000.4, 6e6],
    options: [
      { resolution: 66.14579761460263, scale: 25e4, zoomLevel: 0 },
      { resolution: 26.458319045841044, scale: 1e5, zoomLevel: 1 },
      { resolution: 15.874991427504629, scale: 6e4, zoomLevel: 2 },
      { resolution: 10.583327618336419, scale: 4e4, zoomLevel: 3 },
      { resolution: 5.2916638091682096, scale: 2e4, zoomLevel: 4 },
      { resolution: 2.6458319045841048, scale: 1e4, zoomLevel: 5 },
      { resolution: 1.3229159522920524, scale: 5e3, zoomLevel: 6 },
      { resolution: 0.6614579761460262, scale: 2500, zoomLevel: 7 },
      { resolution: 0.2645831904584105, scale: 1e3, zoomLevel: 8 },
      { resolution: 0.1322915952292052, scale: 500, zoomLevel: 9 }
    ],
    namedProjections: [
      ["EPSG:25832", "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"]
    ],
    startResolution: 15.874991427504629,
    startCenter: [565874, 5934140],
    layerConf: "https://geodienste.hamburg.de/services-internet.json",
    layers: [
      {
        id: "453",
        visibility: !0
      }
    ],
    gazetteerUrl: "https://geodienste.hamburg.de/HH_WFS_GAGES?service=WFS&request=GetFeature&version=2.0.0",
    showGeographicIdentifier: !1,
    sceneOptions: {
      camera: {
        enableTerrainAdjustmentWhenLoading: !0
      },
      globe: {
        depthTestAgainstTerrain: !1
      },
      highDynamicRange: !1,
      pickTranslucentDepth: !0,
      shadowMap: {
        darkness: 0.6,
        maximumDistance: 5e3,
        size: 2048
      },
      shadows: !1
    }
  };
  function Poe({ backgroundImage: t, target: e } = {}) {
    const i = document.getElementById(e || rn.target);
    if (i) {
      const r = `url(${// keep "" as explicit none
      typeof t == "string" ? t : rn.backgroundImage})`;
      i.style.backgroundImage = r;
    }
  }
  function Ooe(t) {
    return Array.isArray(t.layers) ? t.layers : typeof t.layerConf > "u" || t.layerConf === rn.layerConf ? rn.layers : [];
  }
  const fA = {
    PRELOAD: "preload",
    USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
  };
  class Goe extends HA {
    /**
     * @param {Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(e) {
      e = e || {};
      const i = Object.assign({}, e), r = e.cacheSize;
      delete e.cacheSize, delete i.preload, delete i.useInterimTilesOnError, super(i), this.on, this.once, this.un, this.cacheSize_ = r, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
        e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
      );
    }
    /**
     * @return {number|undefined} The suggested cache size
     * @protected
     */
    getCacheSize() {
      return this.cacheSize_;
    }
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
    getPreload() {
      return (
        /** @type {number} */
        this.get(fA.PRELOAD)
      );
    }
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
    setPreload(e) {
      this.set(fA.PRELOAD, e);
    }
    /**
     * Deprecated.  Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
    getUseInterimTilesOnError() {
      return (
        /** @type {boolean} */
        this.get(fA.USE_INTERIM_TILES_ON_ERROR)
      );
    }
    /**
     * Deprecated.  Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
    setUseInterimTilesOnError(e) {
      this.set(fA.USE_INTERIM_TILES_ON_ERROR, e);
    }
    /**
     * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
     * a four element RGBA array will be returned.  For data tiles, the array length will match the
     * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
     * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     * @override
     */
    getData(e) {
      return super.getData(e);
    }
  }
  function zE(t) {
    return t instanceof Image || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageBitmap ? t : null;
  }
  function joe(t) {
    return t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t instanceof DataView ? t : null;
  }
  const Hoe = new Error("disposed");
  let Dc = null;
  function Joe(t) {
    Dc || (Dc = Di(
      t.width,
      t.height,
      void 0,
      { willReadFrequently: !0 }
    ));
    const e = Dc.canvas, i = t.width;
    e.width !== i && (e.width = i);
    const r = t.height;
    return e.height !== r && (e.height = r), Dc.clearRect(0, 0, i, r), Dc.drawImage(t, 0, 0), Dc.getImageData(0, 0, i, r).data;
  }
  const Voe = [256, 256];
  class Pb extends pf {
    /**
     * @param {Options} options Tile options.
     */
    constructor(e) {
      const i = pe.IDLE;
      super(e.tileCoord, i, {
        transition: e.transition,
        interpolate: e.interpolate
      }), this.loader_ = e.loader, this.data_ = null, this.error_ = null, this.size_ = e.size || null, this.controller_ = e.controller || null;
    }
    /**
     * Get the tile size.
     * @return {import('./size.js').Size} Tile size.
     */
    getSize() {
      if (this.size_)
        return this.size_;
      const e = zE(this.data_);
      return e ? [e.width, e.height] : Voe;
    }
    /**
     * Get the data for the tile.
     * @return {Data} Tile data.
     * @api
     */
    getData() {
      return this.data_;
    }
    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @api
     */
    getError() {
      return this.error_;
    }
    /**
     * Load the tile data.
     * @api
     * @override
     */
    load() {
      if (this.state !== pe.IDLE && this.state !== pe.ERROR)
        return;
      this.state = pe.LOADING, this.changed();
      const e = this;
      this.loader_().then(function(i) {
        e.data_ = i, e.state = pe.LOADED, e.changed();
      }).catch(function(i) {
        e.error_ = i, e.state = pe.ERROR, e.changed();
      });
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.controller_ && (this.controller_.abort(Hoe), this.controller_ = null), super.disposeInternal();
    }
  }
  const bx = 0.5, Woe = 10, RT = 0.25;
  class Mx {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
     * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
     * @param {number} errorThreshold Acceptable error (in source units).
     * @param {?number} destinationResolution The (optional) resolution of the destination.
     * @param {import("../transform.js").Transform} [sourceMatrix] Source transform matrix.
     */
    constructor(e, i, r, n, s, o, a) {
      this.sourceProj_ = e, this.targetProj_ = i;
      let A = {};
      const l = a ? hb(
        (y) => Ei(
          a,
          kd(y, this.targetProj_, this.sourceProj_)
        )
      ) : id(this.targetProj_, this.sourceProj_);
      this.transformInv_ = function(y) {
        const C = y[0] + "/" + y[1];
        return A[C] || (A[C] = l(y)), A[C];
      }, this.maxSourceExtent_ = n, this.errorThresholdSquared_ = s * s, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!n && !!this.sourceProj_.getExtent() && mt(n) >= mt(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? mt(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? mt(this.targetProj_.getExtent()) : null;
      const c = qs(r), u = AB(r), d = aB(r), h = oB(r), g = this.transformInv_(c), f = this.transformInv_(u), p = this.transformInv_(d), m = this.transformInv_(h), E = Woe + (o ? Math.max(
        0,
        Math.ceil(
          Math.log2(
            og(r) / (o * o * 256 * 256)
          )
        )
      ) : 0);
      if (this.addQuad_(
        c,
        u,
        d,
        h,
        g,
        f,
        p,
        m,
        E
      ), this.wrapsXInSource_) {
        let y = 1 / 0;
        this.triangles_.forEach(function(C, w, M) {
          y = Math.min(
            y,
            C.source[0][0],
            C.source[1][0],
            C.source[2][0]
          );
        }), this.triangles_.forEach((C) => {
          if (Math.max(
            C.source[0][0],
            C.source[1][0],
            C.source[2][0]
          ) - y > this.sourceWorldWidth_ / 2) {
            const w = [
              [C.source[0][0], C.source[0][1]],
              [C.source[1][0], C.source[1][1]],
              [C.source[2][0], C.source[2][1]]
            ];
            w[0][0] - y > this.sourceWorldWidth_ / 2 && (w[0][0] -= this.sourceWorldWidth_), w[1][0] - y > this.sourceWorldWidth_ / 2 && (w[1][0] -= this.sourceWorldWidth_), w[2][0] - y > this.sourceWorldWidth_ / 2 && (w[2][0] -= this.sourceWorldWidth_);
            const M = Math.min(
              w[0][0],
              w[1][0],
              w[2][0]
            );
            Math.max(
              w[0][0],
              w[1][0],
              w[2][0]
            ) - M < this.sourceWorldWidth_ / 2 && (C.source = w);
          }
        });
      }
      A = {};
    }
    /**
     * Adds triangle to the triangulation.
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @private
     */
    addTriangle_(e, i, r, n, s, o) {
      this.triangles_.push({
        source: [n, s, o],
        target: [e, i, r]
      });
    }
    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */
    addQuad_(e, i, r, n, s, o, a, A, l) {
      const c = $i([s, o, a, A]), u = this.sourceWorldWidth_ ? mt(c) / this.sourceWorldWidth_ : null, d = (
        /** @type {number} */
        this.sourceWorldWidth_
      ), h = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
      let g = !1;
      if (l > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          const p = $i([e, i, r, n]);
          g = mt(p) / this.targetWorldWidth_ > RT || g;
        }
        !h && this.sourceProj_.isGlobal() && u && (g = u > RT || g);
      }
      if (!g && this.maxSourceExtent_ && isFinite(c[0]) && isFinite(c[1]) && isFinite(c[2]) && isFinite(c[3]) && !Yi(c, this.maxSourceExtent_))
        return;
      let f = 0;
      if (!g && (!isFinite(s[0]) || !isFinite(s[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(A[0]) || !isFinite(A[1]))) {
        if (l > 0)
          g = !0;
        else if (f = (!isFinite(s[0]) || !isFinite(s[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 2 : 0) + (!isFinite(A[0]) || !isFinite(A[1]) ? 1 : 0), f != 1 && f != 2 && f != 4 && f != 8)
          return;
      }
      if (l > 0) {
        if (!g) {
          const p = [(e[0] + r[0]) / 2, (e[1] + r[1]) / 2], m = this.transformInv_(p);
          let E;
          h ? E = (pa(s[0], d) + pa(a[0], d)) / 2 - pa(m[0], d) : E = (s[0] + a[0]) / 2 - m[0];
          const y = (s[1] + a[1]) / 2 - m[1];
          g = E * E + y * y > this.errorThresholdSquared_;
        }
        if (g) {
          if (Math.abs(e[0] - r[0]) <= Math.abs(e[1] - r[1])) {
            const p = [(i[0] + r[0]) / 2, (i[1] + r[1]) / 2], m = this.transformInv_(p), E = [(n[0] + e[0]) / 2, (n[1] + e[1]) / 2], y = this.transformInv_(E);
            this.addQuad_(
              e,
              i,
              p,
              E,
              s,
              o,
              m,
              y,
              l - 1
            ), this.addQuad_(
              E,
              p,
              r,
              n,
              y,
              m,
              a,
              A,
              l - 1
            );
          } else {
            const p = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], m = this.transformInv_(p), E = [(r[0] + n[0]) / 2, (r[1] + n[1]) / 2], y = this.transformInv_(E);
            this.addQuad_(
              e,
              p,
              E,
              n,
              s,
              m,
              y,
              A,
              l - 1
            ), this.addQuad_(
              p,
              i,
              r,
              E,
              m,
              o,
              a,
              y,
              l - 1
            );
          }
          return;
        }
      }
      if (h) {
        if (!this.canWrapXInSource_)
          return;
        this.wrapsXInSource_ = !0;
      }
      (f & 11) == 0 && this.addTriangle_(e, r, n, s, a, A), (f & 14) == 0 && this.addTriangle_(e, r, i, s, a, o), f && ((f & 13) == 0 && this.addTriangle_(i, n, e, o, A, s), (f & 7) == 0 && this.addTriangle_(i, n, r, o, A, a));
    }
    /**
     * Calculates extent of the `source` coordinates from all the triangles.
     *
     * @return {import("../extent.js").Extent} Calculated extent.
     */
    calculateSourceExtent() {
      const e = yr();
      return this.triangles_.forEach(function(i, r, n) {
        const s = i.source;
        Uh(e, s[0]), Uh(e, s[1]), Uh(e, s[2]);
      }), e;
    }
    /**
     * @return {Array<Triangle>} Array of the calculated triangles.
     */
    getTriangles() {
      return this.triangles_;
    }
  }
  let H0;
  const _u = [];
  function _T(t, e, i, r, n) {
    t.beginPath(), t.moveTo(0, 0), t.lineTo(e, i), t.lineTo(r, n), t.closePath(), t.save(), t.clip(), t.fillRect(0, 0, Math.max(e, r) + 1, Math.max(i, n)), t.restore();
  }
  function J0(t, e) {
    return Math.abs(t[e * 4] - 210) > 2 || Math.abs(t[e * 4 + 3] - 0.75 * 255) > 2;
  }
  function Koe() {
    if (H0 === void 0) {
      const t = Di(6, 6, _u);
      t.globalCompositeOperation = "lighter", t.fillStyle = "rgba(210, 0, 0, 0.75)", _T(t, 4, 5, 4, 0), _T(t, 4, 5, 0, 5);
      const e = t.getImageData(0, 0, 3, 3).data;
      H0 = J0(e, 0) || J0(e, 4) || J0(e, 8), uf(t), _u.push(t.canvas);
    }
    return H0;
  }
  function bg(t, e, i, r) {
    const n = kd(i, e, t);
    let s = lg(
      e,
      r,
      i
    );
    const o = e.getMetersPerUnit();
    o !== void 0 && (s *= o);
    const a = t.getMetersPerUnit();
    a !== void 0 && (s /= a);
    const A = t.getExtent();
    if (!A || zl(A, n)) {
      const l = lg(t, s, n) / s;
      isFinite(l) && l > 0 && (s /= l);
    }
    return s;
  }
  function yz(t, e, i, r) {
    const n = xn(i);
    let s = bg(
      t,
      e,
      n,
      r
    );
    return (!isFinite(s) || s <= 0) && dv(i, function(o) {
      return s = bg(
        t,
        e,
        o,
        r
      ), isFinite(s) && s > 0;
    }), s;
  }
  function Bz(t, e, i, r, n, s, o, a, A, l, c, u, d, h) {
    const g = Di(
      Math.round(i * t),
      Math.round(i * e),
      _u
    );
    if (u || (g.imageSmoothingEnabled = !1), A.length === 0)
      return g.canvas;
    g.scale(i, i);
    function f(w) {
      return Math.round(w * i) / i;
    }
    g.globalCompositeOperation = "lighter";
    const p = yr();
    A.forEach(function(w, M, I) {
      uv(p, w.extent);
    });
    let m;
    const E = i / r, y = (u ? 1 : 1 + Math.pow(2, -24)) / E;
    (!d || A.length !== 1 || l !== 0) && (m = Di(
      Math.round(mt(p) * E),
      Math.round(Fi(p) * E),
      _u
    ), u || (m.imageSmoothingEnabled = !1), A.forEach(function(w, M, I) {
      if (w.image.width > 0 && w.image.height > 0) {
        if (w.clipExtent) {
          m.save();
          const v = (w.clipExtent[0] - p[0]) * E, T = -(w.clipExtent[3] - p[3]) * E, S = mt(w.clipExtent) * E, D = Fi(w.clipExtent) * E;
          m.rect(
            u ? v : Math.round(v),
            u ? T : Math.round(T),
            u ? S : Math.round(v + S) - Math.round(v),
            u ? D : Math.round(T + D) - Math.round(T)
          ), m.clip();
        }
        const b = (w.extent[0] - p[0]) * E, B = -(w.extent[3] - p[3]) * E, x = mt(w.extent) * E, Q = Fi(w.extent) * E;
        m.drawImage(
          w.image,
          l,
          l,
          w.image.width - 2 * l,
          w.image.height - 2 * l,
          u ? b : Math.round(b),
          u ? B : Math.round(B),
          u ? x : Math.round(b + x) - Math.round(b),
          u ? Q : Math.round(B + Q) - Math.round(B)
        ), w.clipExtent && m.restore();
      }
    }));
    const C = qs(o);
    return a.getTriangles().forEach(function(w, M, I) {
      const b = w.source, B = w.target;
      let x = b[0][0], Q = b[0][1], v = b[1][0], T = b[1][1], S = b[2][0], D = b[2][1];
      const F = f((B[0][0] - C[0]) / s), R = f(
        -(B[0][1] - C[1]) / s
      ), Y = f((B[1][0] - C[0]) / s), L = f(
        -(B[1][1] - C[1]) / s
      ), N = f((B[2][0] - C[0]) / s), H = f(
        -(B[2][1] - C[1]) / s
      ), P = x, ie = Q;
      x = 0, Q = 0, v -= P, T -= ie, S -= P, D -= ie;
      const V = [
        [v, T, 0, 0, Y - F],
        [S, D, 0, 0, N - F],
        [0, 0, v, T, L - R],
        [0, 0, S, D, H - R]
      ], Z = i$(V);
      if (!Z)
        return;
      if (g.save(), g.beginPath(), Koe() || !u) {
        g.moveTo(Y, L);
        const k = 4, _ = F - Y, q = R - L;
        for (let U = 0; U < k; U++)
          g.lineTo(
            Y + f((U + 1) * _ / k),
            L + f(U * q / (k - 1))
          ), U != k - 1 && g.lineTo(
            Y + f((U + 1) * _ / k),
            L + f((U + 1) * q / (k - 1))
          );
        g.lineTo(N, H);
      } else
        g.moveTo(Y, L), g.lineTo(F, R), g.lineTo(N, H);
      g.clip(), g.transform(
        Z[0],
        Z[2],
        Z[1],
        Z[3],
        F,
        R
      ), g.translate(
        p[0] - P,
        p[3] - ie
      );
      let se;
      if (m)
        se = m.canvas, g.scale(y, -y);
      else {
        const k = A[0], _ = k.extent;
        se = k.image, g.scale(
          mt(_) / se.width,
          -Fi(_) / se.height
        );
      }
      g.drawImage(se, 0, 0), g.restore();
    }), m && (uf(m), _u.push(m.canvas)), c && (g.save(), g.globalCompositeOperation = "source-over", g.strokeStyle = "black", g.lineWidth = 1, a.getTriangles().forEach(function(w, M, I) {
      const b = w.target, B = (b[0][0] - C[0]) / s, x = -(b[0][1] - C[1]) / s, Q = (b[1][0] - C[0]) / s, v = -(b[1][1] - C[1]) / s, T = (b[2][0] - C[0]) / s, S = -(b[2][1] - C[1]) / s;
      g.beginPath(), g.moveTo(Q, v), g.lineTo(B, x), g.lineTo(T, S), g.closePath(), g.stroke();
    }), g.restore()), g.canvas;
  }
  function VA() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function Bl(t, e) {
    return t[0] = e[0], t[1] = e[1], t[4] = e[2], t[5] = e[3], t[12] = e[4], t[13] = e[5], t;
  }
  function Ob(t, e, i, r, n, s, o) {
    o = o ?? VA();
    const a = 1 / (t - e), A = 1 / (i - r), l = 1 / (n - s);
    return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * A, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (r + i) * A, o[14] = (s + n) * l, o[15] = 1, o;
  }
  function kT(t, e, i, r, n) {
    return n = n ?? VA(), n[0] = t[0] * e, n[1] = t[1] * e, n[2] = t[2] * e, n[3] = t[3] * e, n[4] = t[4] * i, n[5] = t[5] * i, n[6] = t[6] * i, n[7] = t[7] * i, n[8] = t[8] * r, n[9] = t[9] * r, n[10] = t[10] * r, n[11] = t[11] * r, n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n;
  }
  function Xoe(t, e, i, r, n) {
    n = n ?? VA();
    let s, o, a, A, l, c, u, d, h, g, f, p;
    return t === n ? (n[12] = t[0] * e + t[4] * i + t[8] * r + t[12], n[13] = t[1] * e + t[5] * i + t[9] * r + t[13], n[14] = t[2] * e + t[6] * i + t[10] * r + t[14], n[15] = t[3] * e + t[7] * i + t[11] * r + t[15]) : (s = t[0], o = t[1], a = t[2], A = t[3], l = t[4], c = t[5], u = t[6], d = t[7], h = t[8], g = t[9], f = t[10], p = t[11], n[0] = s, n[1] = o, n[2] = a, n[3] = A, n[4] = l, n[5] = c, n[6] = u, n[7] = d, n[8] = h, n[9] = g, n[10] = f, n[11] = p, n[12] = s * e + l * i + h * r + t[12], n[13] = o * e + c * i + g * r + t[13], n[14] = a * e + u * i + f * r + t[14], n[15] = A * e + d * i + p * r + t[15]), n;
  }
  function Zoe(t, e, i, r) {
    return r = r ?? VA(), r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = t, r[13] = e, r[14] = i, r[15] = 1, r;
  }
  const qoe = `
  attribute vec4 a_position;
  attribute vec4 a_texcoord;

  uniform mat4 u_matrix;
  uniform mat4 u_textureMatrix;

  varying vec2 v_texcoord;

  void main() {
    gl_Position = u_matrix * a_position;
    vec2 texcoord = (u_textureMatrix * a_texcoord).xy;
    v_texcoord = texcoord;
  }
`, $oe = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (
      v_texcoord.x < 0.0 ||
      v_texcoord.y < 0.0 ||
      v_texcoord.x > 1.0 ||
      v_texcoord.y > 1.0
    ) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
  class eae {
    /**
     * @param {WebGLRenderingContext} gl Context to render in.
     */
    constructor(e) {
      this.gl_ = e, this.program_ = Gb(e, $oe, qoe), this.positionLocation = e.getAttribLocation(this.program_, "a_position"), this.texcoordLocation = e.getAttribLocation(this.program_, "a_texcoord"), this.matrixLocation = e.getUniformLocation(this.program_, "u_matrix"), this.textureMatrixLocation = e.getUniformLocation(
        this.program_,
        "u_textureMatrix"
      ), this.textureLocation = e.getUniformLocation(this.program_, "u_texture"), this.positionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer), this.positions = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], e.bufferData(
        e.ARRAY_BUFFER,
        new Float32Array(this.positions),
        e.STATIC_DRAW
      ), this.texcoordBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.texcoordBuffer), this.texcoords = [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], e.bufferData(
        e.ARRAY_BUFFER,
        new Float32Array(this.texcoords),
        e.STATIC_DRAW
      );
    }
    /**
     * 2dContext drawImage call implemented in webgl.
     * Unlike images, textures do not have a width and height associated
     * with them so we'll pass in the width and height of the texture.
     *
     * @param {WebGLTexture} tex Image to draw.
     * @param {number} texWidth Image width.
     * @param {number} texHeight Image height.
     * @param {number} srcX Top-left x-point to read src image.
     * @param {number} srcY Top-left y-point to read src image.
     * @param {number} [srcWidth] Width of source to read.
     * @param {number} [srcHeight] Height of source to read.
     * @param {number} [dstX] Top-left x-point of destination.
     * @param {number} [dstY] Top-left y-point of destination.
     * @param {number} [dstWidth] Width of written image in destination.
     * @param {number} [dstHeight] Height of written image in destination.
     * @param {number} [width] Width of canvas.
     * @param {number} [height] Height of canvas.
     */
    drawImage(e, i, r, n, s, o, a, A, l, c, u, d, h) {
      const g = this.gl_;
      A === void 0 && (A = n), l === void 0 && (l = s), o === void 0 && (o = i), a === void 0 && (a = r), c === void 0 && (c = o), u === void 0 && (u = a), d === void 0 && (d = g.canvas.width), h === void 0 && (h = g.canvas.height), g.bindTexture(g.TEXTURE_2D, e), g.useProgram(this.program_), g.bindBuffer(g.ARRAY_BUFFER, this.positionBuffer), g.enableVertexAttribArray(this.positionLocation), g.vertexAttribPointer(this.positionLocation, 2, g.FLOAT, !1, 0, 0), g.bindBuffer(g.ARRAY_BUFFER, this.texcoordBuffer), g.enableVertexAttribArray(this.texcoordLocation), g.vertexAttribPointer(this.texcoordLocation, 2, g.FLOAT, !1, 0, 0);
      let f = Ob(0, d, 0, h, -1, 1);
      f = Xoe(f, A, l, 0), f = kT(f, c, u, 1), g.uniformMatrix4fv(this.matrixLocation, !1, f);
      let p = Zoe(n / i, s / r, 0);
      p = kT(
        p,
        o / i,
        a / r,
        1
      ), g.uniformMatrix4fv(this.textureMatrixLocation, !1, p), g.uniform1i(this.textureLocation, 0), g.drawArrays(g.TRIANGLES, 0, this.positions.length / 2);
    }
  }
  function YT(t, e, i) {
    const r = t.createShader(e);
    if (r === null)
      throw new Error("Shader compilation failed");
    if (t.shaderSource(r, i), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS)) {
      const n = t.getShaderInfoLog(r);
      throw n === null ? new Error("Shader info log creation failed") : new Error(n);
    }
    return r;
  }
  function Gb(t, e, i) {
    const r = t.createProgram(), n = YT(t, t.VERTEX_SHADER, i), s = YT(t, t.FRAGMENT_SHADER, e);
    if (r === null)
      throw new Error("Program creation failed");
    if (t.attachShader(r, n), t.attachShader(r, s), t.linkProgram(r), !t.getProgramParameter(r, t.LINK_STATUS))
      throw t.getProgramInfoLog(r) === null ? new Error("Program info log creation failed") : new Error();
    return r;
  }
  const tae = `
  attribute vec4 a_position;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
  }
`, iae = `
  precision mediump float;

  uniform vec4 u_val;
  void main() {
     gl_FragColor = u_val;
  }
`, rae = `
  attribute vec4 a_position;
  attribute vec2 a_texcoord;

  varying vec2 v_texcoord;

  uniform mat4 u_matrix;

  void main() {
     gl_Position = u_matrix * a_position;
     v_texcoord = a_texcoord;
  }
`, nae = `
  precision mediump float;

  varying vec2 v_texcoord;

  uniform sampler2D u_texture;

  void main() {
    if (v_texcoord.x < 0.0 || v_texcoord.x > 1.0 || v_texcoord.y < 0.0 || v_texcoord.y > 1.0) {
      discard;
    }
    gl_FragColor = texture2D(u_texture, v_texcoord);
  }
`;
  function sae(t, e, i, r) {
    let n;
    return i && i.length ? n = /** @type {HTMLCanvasElement} */
    i.shift() : Lv ? n = new OffscreenCanvas(t || 300, e || 300) : n = document.createElement("canvas"), t && (n.width = t), e && (n.height = e), /** @type {WebGLRenderingContext} */
    n.getContext("webgl", r);
  }
  function oae(t) {
    const e = t.canvas;
    e.width = 1, e.height = 1, t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT | t.STENCIL_BUFFER_BIT);
  }
  const NT = [];
  function aae(t, e, i, r, n, s, o, a, A, l, c, u, d, h) {
    const g = Math.round(r * e), f = Math.round(r * i);
    t.canvas.width = g, t.canvas.height = f;
    let p, m;
    if (m = t.createTexture(), t.bindTexture(t.TEXTURE_2D, m), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), d ? (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR)) : (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST)), t.texImage2D(
      t.TEXTURE_2D,
      0,
      t.RGBA,
      g,
      f,
      0,
      t.RGBA,
      c,
      null
    ), p = t.createFramebuffer(), t.bindFramebuffer(t.FRAMEBUFFER, p), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      m,
      0
    ), p === null)
      throw new Error("Could not create framebuffer");
    if (m === null)
      throw new Error("Could not create texture");
    if (A.length === 0)
      return {
        width: g,
        height: f,
        framebuffer: p,
        texture: m
      };
    const E = yr();
    A.forEach(function(x, Q, v) {
      uv(E, x.extent);
    });
    let y, C, w;
    const M = 1 / n;
    {
      if (y = t.createTexture(), m === null)
        throw new Error("Could not create texture");
      C = Math.round(mt(E) * M), w = Math.round(Fi(E) * M);
      const x = t.getParameter(t.MAX_TEXTURE_SIZE), Q = Math.max(C, w), v = Q > x ? x / Q : 1, T = Math.round(C * v), S = Math.round(w * v);
      t.bindTexture(t.TEXTURE_2D, y), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), d ? (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR)) : (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST)), t.texImage2D(
        t.TEXTURE_2D,
        0,
        t.RGBA,
        T,
        S,
        0,
        t.RGBA,
        c,
        null
      );
      const D = t.createFramebuffer();
      t.bindFramebuffer(t.FRAMEBUFFER, D), t.framebufferTexture2D(
        t.FRAMEBUFFER,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        y,
        0
      );
      const F = new eae(t);
      A.forEach(function(R, Y, L) {
        const N = (R.extent[0] - E[0]) * M * v, H = -(R.extent[3] - E[3]) * M * v, P = mt(R.extent) * M * v, ie = Fi(R.extent) * M * v;
        if (t.bindFramebuffer(t.FRAMEBUFFER, D), t.viewport(0, 0, T, S), R.clipExtent) {
          const V = (R.clipExtent[0] - E[0]) * M * v, Z = -(R.clipExtent[3] - E[3]) * M * v, se = mt(R.clipExtent) * M * v, k = Fi(R.clipExtent) * M * v;
          t.enable(t.SCISSOR_TEST), t.scissor(
            d ? V : Math.round(V),
            d ? Z : Math.round(Z),
            d ? se : Math.round(V + se) - Math.round(V),
            d ? k : Math.round(Z + k) - Math.round(Z)
          );
        }
        F.drawImage(
          R.texture,
          R.width,
          R.height,
          l,
          l,
          R.width - 2 * l,
          R.height - 2 * l,
          d ? N : Math.round(N),
          d ? H : Math.round(H),
          d ? P : Math.round(N + P) - Math.round(N),
          d ? ie : Math.round(H + ie) - Math.round(H),
          T,
          S
        ), t.disable(t.SCISSOR_TEST);
      }), t.deleteFramebuffer(D);
    }
    const I = qs(o), b = qs(E), B = (x) => {
      const Q = (x[0][0] - I[0]) / s * r, v = -(x[0][1] - I[1]) / s * r, T = (x[1][0] - I[0]) / s * r, S = -(x[1][1] - I[1]) / s * r, D = (x[2][0] - I[0]) / s * r, F = -(x[2][1] - I[1]) / s * r;
      return { u1: T, v1: S, u0: Q, v0: v, u2: D, v2: F };
    };
    t.bindFramebuffer(t.FRAMEBUFFER, p), t.viewport(0, 0, g, f);
    {
      const x = [], Q = [], v = Gb(
        t,
        nae,
        rae
      );
      t.useProgram(v);
      const T = t.getUniformLocation(v, "u_texture");
      t.bindTexture(t.TEXTURE_2D, y), t.uniform1i(T, 0), a.getTriangles().forEach(function(N, H, P) {
        const ie = N.source, V = N.target, { u1: Z, v1: se, u0: k, v0: _, u2: q, v2: U } = B(V), J = (ie[0][0] - b[0]) / n / C, ae = -(ie[0][1] - b[1]) / n / w, $ = (ie[1][0] - b[0]) / n / C, Ce = -(ie[1][1] - b[1]) / n / w, Re = (ie[2][0] - b[0]) / n / C, Oe = -(ie[2][1] - b[1]) / n / w;
        x.push(Z, se, k, _, q, U), Q.push($, Ce, J, ae, Re, Oe);
      });
      const S = Ob(0, g, f, 0, -1, 1), D = t.getUniformLocation(v, "u_matrix");
      t.uniformMatrix4fv(D, !1, S);
      const F = t.getAttribLocation(v, "a_position"), R = t.createBuffer();
      t.bindBuffer(t.ARRAY_BUFFER, R), t.bufferData(t.ARRAY_BUFFER, new Float32Array(x), t.STATIC_DRAW), t.vertexAttribPointer(F, 2, t.FLOAT, !1, 0, 0), t.enableVertexAttribArray(F);
      const Y = t.getAttribLocation(v, "a_texcoord"), L = t.createBuffer();
      t.bindBuffer(t.ARRAY_BUFFER, L), t.bufferData(t.ARRAY_BUFFER, new Float32Array(Q), t.STATIC_DRAW), t.vertexAttribPointer(Y, 2, t.FLOAT, !1, 0, 0), t.enableVertexAttribArray(Y), t.drawArrays(t.TRIANGLES, 0, x.length / 2);
    }
    if (u) {
      const x = Gb(
        t,
        iae,
        tae
      );
      t.useProgram(x);
      const Q = Ob(0, g, f, 0, -1, 1), v = t.getUniformLocation(x, "u_matrix");
      t.uniformMatrix4fv(v, !1, Q);
      const T = Array.isArray(u) ? u : [0, 0, 0, 255], S = t.getUniformLocation(x, "u_val");
      t.uniform4fv(S, T);
      const D = t.getAttribLocation(x, "a_position"), F = t.createBuffer();
      t.bindBuffer(t.ARRAY_BUFFER, F), t.vertexAttribPointer(D, 2, t.FLOAT, !1, 0, 0), t.enableVertexAttribArray(D);
      const R = a.getTriangles().reduce(function(Y, L) {
        const N = L.target, { u1: H, v1: P, u0: ie, v0: V, u2: Z, v2: se } = B(N);
        return Y.concat([H, P, ie, V, ie, V, Z, se, Z, se, H, P]);
      }, []);
      t.bufferData(t.ARRAY_BUFFER, new Float32Array(R), t.STATIC_DRAW), t.drawArrays(t.LINES, 0, R.length / 2);
    }
    return {
      width: g,
      height: f,
      framebuffer: p,
      texture: m
    };
  }
  class wz extends Pb {
    /**
     * @param {Options} options Tile options.
     */
    constructor(e) {
      super({
        tileCoord: e.tileCoord,
        loader: () => Promise.resolve(new Uint8ClampedArray(4)),
        interpolate: e.interpolate,
        transition: e.transition
      }), this.renderEdges_ = e.renderEdges !== void 0 ? e.renderEdges : !1, this.pixelRatio_ = e.pixelRatio, this.gutter_ = e.gutter, this.reprojData_ = null, this.reprojError_ = null, this.reprojSize_ = void 0, this.sourceTileGrid_ = e.sourceTileGrid, this.targetTileGrid_ = e.targetTileGrid, this.wrappedTileCoord_ = e.wrappedTileCoord || e.tileCoord, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
      const i = e.sourceProj, r = i.getExtent(), n = e.sourceTileGrid.getExtent();
      this.clipExtent_ = i.canWrapX() ? n ? fr(r, n) : r : n;
      const s = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      ), o = this.targetTileGrid_.getExtent();
      let a = this.sourceTileGrid_.getExtent();
      const A = o ? fr(s, o) : s;
      if (og(A) === 0) {
        this.state = pe.EMPTY;
        return;
      }
      r && (a ? a = fr(a, r) : a = r);
      const l = this.targetTileGrid_.getResolution(
        this.wrappedTileCoord_[0]
      ), c = e.targetProj, u = yz(
        i,
        c,
        A,
        l
      );
      if (!isFinite(u) || u <= 0) {
        this.state = pe.EMPTY;
        return;
      }
      const d = e.errorThreshold !== void 0 ? e.errorThreshold : bx;
      if (this.triangulation_ = new Mx(
        i,
        c,
        A,
        a,
        u * d,
        l,
        e.transformMatrix
      ), this.triangulation_.getTriangles().length === 0) {
        this.state = pe.EMPTY;
        return;
      }
      this.sourceZ_ = this.sourceTileGrid_.getZForResolution(u);
      let h = this.triangulation_.calculateSourceExtent();
      if (a && (i.canWrapX() ? (h[1] = yi(
        h[1],
        a[1],
        a[3]
      ), h[3] = yi(
        h[3],
        a[1],
        a[3]
      )) : h = fr(h, a)), !og(h))
        this.state = pe.EMPTY;
      else {
        let g = 0, f = 0;
        i.canWrapX() && (g = mt(r), f = Math.floor(
          (h[0] - r[0]) / g
        )), hv(
          h.slice(),
          i,
          !0
        ).forEach((m) => {
          const E = this.sourceTileGrid_.getTileRangeForExtentAndZ(
            m,
            this.sourceZ_
          ), y = e.getTileFunction;
          for (let C = E.minX; C <= E.maxX; C++)
            for (let w = E.minY; w <= E.maxY; w++) {
              const M = y(this.sourceZ_, C, w, this.pixelRatio_);
              if (M) {
                const I = f * g;
                this.sourceTiles_.push({ tile: M, offset: I });
              }
            }
          ++f;
        }), this.sourceTiles_.length === 0 && (this.state = pe.EMPTY);
      }
    }
    /**
     * Get the tile size.
     * @return {import('../size.js').Size} Tile size.
     * @override
     */
    getSize() {
      return this.reprojSize_;
    }
    /**
     * Get the data for the tile.
     * @return {import("../DataTile.js").Data} Tile data.
     * @override
     */
    getData() {
      return this.reprojData_;
    }
    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @override
     */
    getError() {
      return this.reprojError_;
    }
    /**
     * @private
     */
    reproject_() {
      const e = [];
      let i = !1;
      if (this.sourceTiles_.forEach((C) => {
        var H;
        const w = C.tile;
        if (!w || w.getState() !== pe.LOADED)
          return;
        const M = w.getSize(), I = this.gutter_;
        let b;
        const B = joe(w.getData());
        B ? b = B : (i = !0, b = Joe(zE(w.getData())));
        const x = [M[0] + 2 * I, M[1] + 2 * I], Q = b instanceof Float32Array, v = x[0] * x[1], T = Q ? Float32Array : Uint8ClampedArray, S = new T(b.buffer), D = T.BYTES_PER_ELEMENT, F = D * S.length / v, R = S.byteLength / x[1], Y = Math.floor(
          R / D / x[0]
        ), L = this.sourceTileGrid_.getTileCoordExtent(w.tileCoord);
        L[0] += C.offset, L[2] += C.offset;
        const N = (H = this.clipExtent_) == null ? void 0 : H.slice();
        N && (N[0] += C.offset, N[2] += C.offset), e.push({
          extent: L,
          clipExtent: N,
          data: S,
          dataType: T,
          bytesPerPixel: F,
          pixelSize: x,
          bandCount: Y
        });
      }), this.sourceTiles_.length = 0, e.length === 0) {
        this.state = pe.ERROR, this.changed();
        return;
      }
      const r = this.wrappedTileCoord_[0], n = this.targetTileGrid_.getTileSize(r), s = typeof n == "number" ? n : n[0], o = typeof n == "number" ? n : n[1], a = s * this.pixelRatio_, A = o * this.pixelRatio_, l = this.targetTileGrid_.getResolution(r), c = this.sourceTileGrid_.getResolution(this.sourceZ_), u = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      ), d = e[0].bandCount, h = new e[0].dataType(d * a * A), g = sae(a, A, NT, {
        premultipliedAlpha: !1,
        antialias: !1
      });
      let f;
      const p = g.RGBA;
      let m;
      e[0].dataType == Float32Array ? (m = g.FLOAT, g.getExtension("WEBGL_color_buffer_float"), g.getExtension("OES_texture_float"), g.getExtension("EXT_float_blend"), f = g.getExtension("OES_texture_float_linear") !== null && this.interpolate) : (m = g.UNSIGNED_BYTE, f = this.interpolate);
      const E = 4, y = Math.ceil(d / E);
      for (let C = y - 1; C >= 0; --C) {
        const w = [];
        for (let T = 0, S = e.length; T < S; ++T) {
          const D = e[T], F = D.pixelSize, R = F[0], Y = F[1], L = new D.dataType(E * R * Y), N = D.data;
          let H = C * E;
          for (let ie = 0, V = L.length; ie < V; ie += E)
            L[ie] = N[H], L[ie + 1] = N[H + 1], L[ie + 2] = N[H + 2], L[ie + 3] = N[H + 3], H += d;
          const P = g.createTexture();
          g.bindTexture(g.TEXTURE_2D, P), f ? (g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR)) : (g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.NEAREST), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.NEAREST)), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texImage2D(
            g.TEXTURE_2D,
            0,
            p,
            R,
            Y,
            0,
            p,
            m,
            L
          ), w.push({
            extent: D.extent,
            clipExtent: D.clipExtent,
            texture: P,
            width: R,
            height: Y
          });
        }
        const { framebuffer: M, width: I, height: b } = aae(
          g,
          s,
          o,
          this.pixelRatio_,
          c,
          l,
          u,
          this.triangulation_,
          w,
          this.gutter_,
          m,
          this.renderEdges_,
          f
        ), B = I, x = b * E, Q = new e[0].dataType(B * x);
        g.bindFramebuffer(g.FRAMEBUFFER, M), g.readPixels(0, 0, I, b, g.RGBA, m, Q);
        let v = C * E;
        for (let T = 0, S = Q.length; T < S; T += E) {
          const D = (B - 1 - (T / x | 0)) * x + T % x;
          h[v] = Q[D], h[v + 1] = Q[D + 1], h[v + 2] = Q[D + 2], h[v + 3] = Q[D + 3], v += d;
        }
      }
      if (oae(g), NT.push(g.canvas), i) {
        const C = Di(s, o), w = new ImageData(h, s);
        C.putImageData(w, 0, 0), this.reprojData_ = C.canvas;
      } else
        this.reprojData_ = h;
      this.reprojSize_ = [Math.round(a), Math.round(A)], this.state = pe.LOADED, this.changed();
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      if (this.state !== pe.IDLE && this.state !== pe.ERROR)
        return;
      this.state = pe.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: i }) => {
        const r = i.getState();
        if (r !== pe.IDLE && r !== pe.LOADING)
          return;
        e++;
        const n = nt(i, Ge.CHANGE, () => {
          const s = i.getState();
          (s == pe.LOADED || s == pe.ERROR || s == pe.EMPTY) && (Pt(n), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
        });
        this.sourcesListenerKeys_.push(n);
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: i }) {
        i.getState() == pe.IDLE && i.load();
      });
    }
    /**
     * @private
     */
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(Pt), this.sourcesListenerKeys_ = null;
    }
  }
  class PE extends pf {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
     * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} gutter Gutter of the source tiles.
     * @param {FunctionType} getTileFunction
     *     Function returning source tiles (z, x, y, pixelRatio).
     * @param {number} [errorThreshold] Acceptable reprojection error (in px).
     * @param {boolean} [renderEdges] Render reprojection edges.
     * @param {import("../Tile.js").Options} [options] Tile options.
     */
    constructor(e, i, r, n, s, o, a, A, l, c, u, d) {
      super(s, pe.IDLE, d), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = a, this.gutter_ = A, this.canvas_ = null, this.sourceTileGrid_ = i, this.targetTileGrid_ = n, this.wrappedTileCoord_ = o || s, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = e.canWrapX() ? e.getExtent() : void 0;
      const h = n.getTileCoordExtent(
        this.wrappedTileCoord_
      ), g = this.targetTileGrid_.getExtent();
      let f = this.sourceTileGrid_.getExtent();
      const p = g ? fr(h, g) : h;
      if (og(p) === 0) {
        this.state = pe.EMPTY;
        return;
      }
      const m = e.getExtent();
      m && (f ? f = fr(f, m) : f = m);
      const E = n.getResolution(
        this.wrappedTileCoord_[0]
      ), y = yz(
        e,
        r,
        p,
        E
      );
      if (!isFinite(y) || y <= 0) {
        this.state = pe.EMPTY;
        return;
      }
      const C = c !== void 0 ? c : bx;
      if (this.triangulation_ = new Mx(
        e,
        r,
        p,
        f,
        y * C,
        E
      ), this.triangulation_.getTriangles().length === 0) {
        this.state = pe.EMPTY;
        return;
      }
      this.sourceZ_ = i.getZForResolution(y);
      let w = this.triangulation_.calculateSourceExtent();
      if (f && (e.canWrapX() ? (w[1] = yi(
        w[1],
        f[1],
        f[3]
      ), w[3] = yi(
        w[3],
        f[1],
        f[3]
      )) : w = fr(w, f)), !og(w))
        this.state = pe.EMPTY;
      else {
        let M = 0, I = 0;
        e.canWrapX() && (M = mt(m), I = Math.floor(
          (w[0] - m[0]) / M
        )), hv(
          w.slice(),
          e,
          !0
        ).forEach((B) => {
          const x = i.getTileRangeForExtentAndZ(
            B,
            this.sourceZ_
          );
          for (let Q = x.minX; Q <= x.maxX; Q++)
            for (let v = x.minY; v <= x.maxY; v++) {
              const T = l(this.sourceZ_, Q, v, a);
              if (T) {
                const S = I * M;
                this.sourceTiles_.push({ tile: T, offset: S });
              }
            }
          ++I;
        }), this.sourceTiles_.length === 0 && (this.state = pe.EMPTY);
      }
    }
    /**
     * Get the HTML Canvas element for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */
    getImage() {
      return this.canvas_;
    }
    /**
     * @private
     */
    reproject_() {
      const e = [];
      if (this.sourceTiles_.forEach((i) => {
        var n;
        const r = i.tile;
        if (r && r.getState() == pe.LOADED) {
          const s = this.sourceTileGrid_.getTileCoordExtent(r.tileCoord);
          s[0] += i.offset, s[2] += i.offset;
          const o = (n = this.clipExtent_) == null ? void 0 : n.slice();
          o && (o[0] += i.offset, o[2] += i.offset), e.push({
            extent: s,
            clipExtent: o,
            image: r.getImage()
          });
        }
      }), this.sourceTiles_.length = 0, e.length === 0)
        this.state = pe.ERROR;
      else {
        const i = this.wrappedTileCoord_[0], r = this.targetTileGrid_.getTileSize(i), n = typeof r == "number" ? r : r[0], s = typeof r == "number" ? r : r[1], o = this.targetTileGrid_.getResolution(i), a = this.sourceTileGrid_.getResolution(
          this.sourceZ_
        ), A = this.targetTileGrid_.getTileCoordExtent(
          this.wrappedTileCoord_
        );
        this.canvas_ = Bz(
          n,
          s,
          this.pixelRatio_,
          a,
          this.sourceTileGrid_.getExtent(),
          o,
          A,
          this.triangulation_,
          e,
          this.gutter_,
          this.renderEdges_,
          this.interpolate
        ), this.state = pe.LOADED;
      }
      this.changed();
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      if (this.state == pe.IDLE) {
        this.state = pe.LOADING, this.changed();
        let e = 0;
        this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: i }) => {
          const r = i.getState();
          if (r == pe.IDLE || r == pe.LOADING) {
            e++;
            const n = nt(i, Ge.CHANGE, (s) => {
              const o = i.getState();
              (o == pe.LOADED || o == pe.ERROR || o == pe.EMPTY) && (Pt(n), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
            });
            this.sourcesListenerKeys_.push(n);
          }
        }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: i }, r, n) {
          i.getState() == pe.IDLE && i.load();
        });
      }
    }
    /**
     * @private
     */
    unlistenSources_() {
      this.sourcesListenerKeys_.forEach(Pt), this.sourcesListenerKeys_ = null;
    }
    /**
     * Remove from the cache due to expiry
     * @override
     */
    release() {
      this.canvas_ && (uf(this.canvas_.getContext("2d")), _u.push(this.canvas_), this.canvas_ = null), super.release();
    }
  }
  function V0(t, e, i, r) {
    return `${t},${EL(e, i, r)}`;
  }
  function W0(t, e, i) {
    if (!(i in t))
      return t[i] = /* @__PURE__ */ new Set([e]), !0;
    const r = t[i], n = r.has(e);
    return n || r.add(e), !n;
  }
  function Aae(t, e, i) {
    const r = t[i];
    return r ? r.delete(e) : !1;
  }
  function UT(t, e) {
    const i = t.layerStatesArray[t.layerIndex];
    i.extent && (e = fr(
      e,
      is(i.extent, t.viewState.projection)
    ));
    const r = (
      /** @type {import("../../source/Tile.js").default} */
      i.layer.getRenderSource()
    );
    if (!r.getWrapX()) {
      const n = r.getTileGridForProjection(t.viewState.projection).getExtent();
      n && (e = fr(e, n));
    }
    return e;
  }
  class Cz extends tx {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} [options] Options.
     */
    constructor(e, i) {
      super(e), i = i || {}, this.extentChanged = !0, this.renderComplete = !1, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.renderedSourceKey_, this.renderedSourceRevision_, this.tempExtent = yr(), this.tempTileRange_ = new yB(0, 0, 0, 0), this.tempTileCoord_ = ad(0, 0, 0);
      const r = i.cacheSize !== void 0 ? i.cacheSize : 512;
      this.tileCache_ = new mL(r), this.maxStaleKeys = r * 0.5;
    }
    /**
     * @return {LRUCache} Tile cache.
     */
    getTileCache() {
      return this.tileCache_;
    }
    /**
     * Get a tile from the cache or create one if needed.
     *
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    getOrCreateTile(e, i, r, n) {
      const s = this.tileCache_, a = this.getLayer().getSource(), A = V0(a.getKey(), e, i, r);
      let l;
      if (s.containsKey(A))
        l = s.get(A);
      else {
        if (l = a.getTile(
          e,
          i,
          r,
          n.pixelRatio,
          n.viewState.projection
        ), !l)
          return null;
        s.set(A, l);
      }
      return l;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @protected
     */
    getTile(e, i, r, n) {
      const s = this.getOrCreateTile(e, i, r, n);
      return s || null;
    }
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     * @override
     */
    getData(e) {
      const i = this.frameState;
      if (!i)
        return null;
      const r = this.getLayer(), n = Ei(
        i.pixelToCoordinateTransform,
        e.slice()
      ), s = r.getExtent();
      if (s && !zl(s, n))
        return null;
      const o = i.viewState, a = r.getRenderSource(), A = a.getTileGridForProjection(o.projection), l = a.getTilePixelRatio(i.pixelRatio);
      for (let c = A.getZForResolution(o.resolution); c >= A.getMinZoom(); --c) {
        const u = A.getTileCoordForCoordAndZ(n, c), d = this.getTile(c, u[1], u[2], i);
        if (!d || d.getState() !== pe.LOADED)
          continue;
        const h = A.getOrigin(c), g = mr(A.getTileSize(c)), f = A.getResolution(c);
        let p;
        if (d instanceof ix || d instanceof PE)
          p = d.getImage();
        else if (d instanceof Pb) {
          if (p = zE(d.getData()), !p)
            continue;
        } else
          continue;
        const m = Math.floor(
          l * ((n[0] - h[0]) / f - u[1] * g[0])
        ), E = Math.floor(
          l * ((h[1] - n[1]) / f - u[2] * g[1])
        ), y = Math.round(
          l * a.getGutterForProjection(o.projection)
        );
        return this.getImageData(p, m + y, E + y);
      }
      return null;
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(e) {
      this.renderedProjection ? e.viewState.projection !== this.renderedProjection && (this.tileCache_.clear(), this.renderedProjection = e.viewState.projection) : this.renderedProjection = e.viewState.projection;
      const i = this.getLayer().getSource();
      if (!i)
        return !1;
      const r = i.getRevision();
      return this.renderedRevision_ ? this.renderedRevision_ !== r && (this.renderedRevision_ = r, this.renderedSourceKey_ === i.getKey() && this.tileCache_.clear()) : this.renderedRevision_ = r, !0;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent The extent to be rendered.
     * @param {number} initialZ The zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @param {number} preload Number of additional levels to load.
     */
    enqueueTiles(e, i, r, n, s) {
      const o = e.viewState, a = this.getLayer(), A = a.getRenderSource(), l = A.getTileGridForProjection(o.projection), c = ve(A);
      c in e.wantedTiles || (e.wantedTiles[c] = {});
      const u = e.wantedTiles[c], d = a.getMapInternal(), h = Math.max(
        r - s,
        l.getMinZoom(),
        l.getZForResolution(
          Math.min(
            a.getMaxResolution(),
            d ? d.getView().getResolutionForZoom(Math.max(a.getMinZoom(), 0)) : l.getResolution(0)
          ),
          A.zDirection
        )
      );
      for (let g = r; g >= h; --g) {
        const f = l.getTileRangeForExtentAndZ(
          i,
          g,
          this.tempTileRange_
        ), p = l.getResolution(g);
        for (let m = f.minX; m <= f.maxX; ++m)
          for (let E = f.minY; E <= f.maxY; ++E) {
            const y = this.getTile(g, m, E, e);
            if (!y || !W0(n, y, g))
              continue;
            const w = y.getKey();
            if (u[w] = !0, y.getState() === pe.IDLE && !e.tileQueue.isKeyQueued(w)) {
              const M = ad(g, m, E, this.tempTileCoord_);
              e.tileQueue.enqueue([
                y,
                c,
                l.getTileCoordCenter(M),
                p
              ]);
            }
          }
      }
    }
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    findStaleTile_(e, i) {
      const r = this.tileCache_, n = e[0], s = e[1], o = e[2], a = this.getStaleKeys();
      for (let A = 0; A < a.length; ++A) {
        const l = V0(a[A], n, s, o);
        if (r.containsKey(l)) {
          const c = r.get(l);
          if (c.getState() === pe.LOADED)
            return c.endTransition(ve(this)), W0(i, c, n), !0;
        }
      }
      return !1;
    }
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    findAltTiles_(e, i, r, n) {
      const s = e.getTileRangeForTileCoordAndZ(
        i,
        r,
        this.tempTileRange_
      );
      if (!s)
        return !1;
      let o = !0;
      const a = this.tileCache_, l = this.getLayer().getRenderSource().getKey();
      for (let c = s.minX; c <= s.maxX; ++c)
        for (let u = s.minY; u <= s.maxY; ++u) {
          const d = V0(l, r, c, u);
          let h = !1;
          if (a.containsKey(d)) {
            const g = a.get(d);
            g.getState() === pe.LOADED && (W0(n, g, r), h = !0);
          }
          h || (o = !1);
        }
      return o;
    }
    /**
     * Render the layer.
     *
     * The frame rendering logic has three parts:
     *
     *  1. Enqueue tiles
     *  2. Find alt tiles for those that are not yet loaded
     *  3. Render loaded tiles
     *
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    renderFrame(e, i) {
      let r = !0;
      this.renderComplete = !0;
      const n = e.layerStatesArray[e.layerIndex], s = e.viewState, o = s.projection, a = s.resolution, A = s.center, l = e.pixelRatio, c = this.getLayer(), u = c.getSource(), d = u.getRevision(), h = u.getTileGridForProjection(o), g = h.getZForResolution(a, u.zDirection), f = h.getResolution(g), p = u.getKey();
      this.renderedSourceKey_ ? this.renderedSourceKey_ !== p && (this.prependStaleKey(this.renderedSourceKey_), this.renderedSourceKey_ = p) : this.renderedSourceKey_ = p;
      let m = e.extent;
      const E = u.getTilePixelRatio(l);
      this.prepareContainer(e, i);
      const y = this.context.canvas.width, C = this.context.canvas.height, w = n.extent && is(n.extent);
      w && (m = fr(
        m,
        is(n.extent)
      ));
      const M = f * y / 2 / E, I = f * C / 2 / E, b = [
        A[0] - M,
        A[1] - I,
        A[0] + M,
        A[1] + I
      ], B = {};
      this.renderedTiles.length = 0;
      const x = c.getPreload();
      if (e.nextExtent) {
        const N = h.getZForResolution(
          s.nextResolution,
          u.zDirection
        ), H = UT(e, e.nextExtent);
        this.enqueueTiles(e, H, N, B, x);
      }
      const Q = UT(e, m);
      if (this.enqueueTiles(e, Q, g, B, 0), x > 0 && setTimeout(() => {
        this.enqueueTiles(
          e,
          Q,
          g - 1,
          B,
          x - 1
        );
      }, 0), !(g in B))
        return this.container;
      const v = ve(this), T = e.time;
      for (const N of B[g]) {
        const H = N.getState();
        if ((N instanceof PE || N instanceof wz) && H === pe.EMPTY)
          continue;
        const P = N.tileCoord;
        if (H === pe.LOADED && N.getAlpha(v, T) === 1) {
          N.endTransition(v);
          continue;
        }
        if (H !== pe.IDLE && (r = !1), H !== pe.ERROR && (this.renderComplete = !1), this.findStaleTile_(P, B)) {
          Aae(B, N, g), e.animate = !0;
          continue;
        }
        if (this.findAltTiles_(
          h,
          P,
          g + 1,
          B
        ))
          continue;
        const Z = h.getMinZoom();
        for (let se = g - 1; se >= Z && !this.findAltTiles_(
          h,
          P,
          se,
          B
        ); --se)
          ;
      }
      const S = f / a * l / E, D = this.getRenderContext(e);
      gs(
        this.tempTransform,
        y / 2,
        C / 2,
        S,
        S,
        0,
        -y / 2,
        -C / 2
      ), n.extent && this.clipUnrotated(D, e, w), u.getInterpolate() || (D.imageSmoothingEnabled = !1), this.preRender(D, e);
      const F = Object.keys(B).map(Number);
      F.sort(Qo);
      let R;
      const Y = [], L = [];
      for (let N = F.length - 1; N >= 0; --N) {
        const H = F[N], P = u.getTilePixelSize(
          H,
          l,
          o
        ), V = h.getResolution(H) / f, Z = P[0] * V * S, se = P[1] * V * S, k = h.getTileCoordForCoordAndZ(
          qs(b),
          H
        ), _ = h.getTileCoordExtent(k), q = Ei(this.tempTransform, [
          E * (_[0] - b[0]) / f,
          E * (b[3] - _[3]) / f
        ]), U = E * u.getGutterForProjection(o);
        for (const J of B[H]) {
          if (J.getState() !== pe.LOADED)
            continue;
          const ae = J.tileCoord, $ = k[1] - ae[1], Ce = Math.round(q[0] - ($ - 1) * Z), Re = k[2] - ae[2], Oe = Math.round(q[1] - (Re - 1) * se), K = Math.round(q[0] - $ * Z), Ae = Math.round(q[1] - Re * se), ut = Ce - K, Me = Oe - Ae, Fe = F.length === 1;
          let jt = !1;
          R = [K, Ae, K + ut, Ae, K + ut, Ae + Me, K, Ae + Me];
          for (let Rt = 0, rt = Y.length; Rt < rt; ++Rt)
            if (!Fe && H < L[Rt]) {
              const Ke = Y[Rt];
              Yi(
                [K, Ae, K + ut, Ae + Me],
                [Ke[0], Ke[3], Ke[4], Ke[7]]
              ) && (jt || (D.save(), jt = !0), D.beginPath(), D.moveTo(R[0], R[1]), D.lineTo(R[2], R[3]), D.lineTo(R[4], R[5]), D.lineTo(R[6], R[7]), D.moveTo(Ke[6], Ke[7]), D.lineTo(Ke[4], Ke[5]), D.lineTo(Ke[2], Ke[3]), D.lineTo(Ke[0], Ke[1]), D.clip());
            }
          Y.push(R), L.push(H), this.drawTile(J, e, K, Ae, ut, Me, U, Fe), jt && D.restore(), this.renderedTiles.unshift(J), this.updateUsedTiles(e.usedTiles, u, J);
        }
      }
      if (this.renderedRevision = d, this.renderedResolution = f, this.extentChanged = !this.renderedExtent_ || !Zs(this.renderedExtent_, b), this.renderedExtent_ = b, this.renderedPixelRatio = l, this.postRender(this.context, e), n.extent && D.restore(), D.imageSmoothingEnabled = !0, this.renderComplete) {
        const N = (H, P) => {
          const ie = ve(u), V = P.wantedTiles[ie], Z = V ? Object.keys(V).length : 0;
          this.updateCacheSize(Z), this.tileCache_.expireCache();
        };
        e.postRenderFunctions.push(N);
      }
      return !this.renderComplete && !r && (e.animate = !0), this.container;
    }
    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     */
    updateCacheSize(e) {
      this.tileCache_.highWaterMark = Math.max(
        this.tileCache_.highWaterMark,
        e * 2
      );
    }
    /**
     * @param {import("../../Tile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     * @protected
     */
    drawTile(e, i, r, n, s, o, a, A) {
      let l;
      if (e instanceof Pb) {
        if (l = zE(e.getData()), !l)
          throw new Error("Rendering array data is not yet supported");
      } else
        l = this.getTileImage(
          /** @type {import("../../ImageTile.js").default} */
          e
        );
      if (!l)
        return;
      const c = this.getRenderContext(i), u = ve(this), d = i.layerStatesArray[i.layerIndex], h = d.opacity * (A ? e.getAlpha(u, i.time) : 1), g = h !== c.globalAlpha;
      g && (c.save(), c.globalAlpha = h), c.drawImage(
        l,
        a,
        a,
        l.width - 2 * a,
        l.height - 2 * a,
        r,
        n,
        s,
        o
      ), g && c.restore(), h !== d.opacity ? i.animate = !0 : A && e.endTransition(u);
    }
    /**
     * @return {HTMLCanvasElement} Image
     */
    getImage() {
      const e = this.context;
      return e ? e.canvas : null;
    }
    /**
     * Get the image from a tile.
     * @param {import("../../ImageTile.js").default} tile Tile.
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @protected
     */
    getTileImage(e) {
      return e.getImage();
    }
    /**
     * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
     * @param {import("../../source/Tile.js").default} tileSource Tile source.
     * @param {import('../../Tile.js').default} tile Tile.
     * @protected
     */
    updateUsedTiles(e, i, r) {
      const n = ve(i);
      n in e || (e[n] = {}), e[n][r.getKey()] = !0;
    }
  }
  class SB extends Goe {
    /**
     * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
     */
    constructor(e) {
      super(e);
    }
    /**
     * @override
     */
    createRenderer() {
      return new Cz(this, {
        cacheSize: this.getCacheSize()
      });
    }
  }
  class lae extends HA {
    /**
     * @param {Options<ImageSourceType>} [options] Layer options.
     */
    constructor(e) {
      e = e || {}, super(e);
    }
  }
  class cae extends tx {
    /**
     * @param {import("../../layer/Image.js").default} imageLayer Image layer.
     */
    constructor(e) {
      super(e), this.image = null;
    }
    /**
     * @return {import('../../DataTile.js').ImageLike} Image.
     */
    getImage() {
      return this.image ? this.image.getImage() : null;
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(e) {
      const i = e.layerStatesArray[e.layerIndex], r = e.pixelRatio, n = e.viewState, s = n.resolution, o = this.getLayer().getSource(), a = e.viewHints;
      let A = e.extent;
      if (i.extent !== void 0 && (A = fr(
        A,
        is(i.extent, n.projection)
      )), !a[Ai.ANIMATING] && !a[Ai.INTERACTING] && !GA(A))
        if (o) {
          const l = n.projection, c = o.getImage(
            A,
            s,
            r,
            l
          );
          c && (this.loadImage(c) ? this.image = c : c.getState() === ze.EMPTY && (this.image = null));
        } else
          this.image = null;
      return !!this.image;
    }
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray} Data at the pixel location.
     * @override
     */
    getData(e) {
      const i = this.frameState;
      if (!i)
        return null;
      const r = this.getLayer(), n = Ei(
        i.pixelToCoordinateTransform,
        e.slice()
      ), s = r.getExtent();
      if (s && !zl(s, n))
        return null;
      const o = this.image.getExtent(), a = this.image.getImage(), A = mt(o), l = Math.floor(
        a.width * ((n[0] - o[0]) / A)
      );
      if (l < 0 || l >= a.width)
        return null;
      const c = Fi(o), u = Math.floor(
        a.height * ((o[3] - n[1]) / c)
      );
      return u < 0 || u >= a.height ? null : this.getImageData(a, l, u);
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    renderFrame(e, i) {
      const r = this.image, n = r.getExtent(), s = r.getResolution(), [o, a] = Array.isArray(s) ? s : [s, s], A = r.getPixelRatio(), l = e.layerStatesArray[e.layerIndex], c = e.pixelRatio, u = e.viewState, d = u.center, h = u.resolution, g = c * o / (h * A), f = c * a / (h * A);
      this.prepareContainer(e, i);
      const p = this.context.canvas.width, m = this.context.canvas.height, E = this.getRenderContext(e);
      let y = !1, C = !0;
      if (l.extent) {
        const B = is(
          l.extent,
          u.projection
        );
        C = Yi(B, e.extent), y = C && !ts(B, e.extent), y && this.clipUnrotated(E, e, B);
      }
      const w = r.getImage(), M = gs(
        this.tempTransform,
        p / 2,
        m / 2,
        g,
        f,
        0,
        A * (n[0] - d[0]) / o,
        A * (d[1] - n[3]) / a
      );
      this.renderedResolution = a * c / A;
      const I = w.width * M[0], b = w.height * M[3];
      if (this.getLayer().getSource().getInterpolate() || (E.imageSmoothingEnabled = !1), this.preRender(E, e), C && I >= 0.5 && b >= 0.5) {
        const B = M[4], x = M[5], Q = l.opacity;
        Q !== 1 && (E.save(), E.globalAlpha = Q), E.drawImage(w, 0, 0, +w.width, +w.height, B, x, I, b), Q !== 1 && E.restore();
      }
      return this.postRender(this.context, e), y && E.restore(), E.imageSmoothingEnabled = !0, this.container;
    }
  }
  class Ix extends lae {
    /**
     * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
     */
    constructor(e) {
      super(e);
    }
    /**
     * @override
     */
    createRenderer() {
      return new cae(this);
    }
    /**
     * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
     * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
     * source's `crossOrigin` property is set.
     *
     * ```js
     * // display layer data on every pointer move
     * map.on('pointermove', (event) => {
     *   console.log(layer.getData(event.pixel));
     * });
     * ```
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     * @api
     * @override
     */
    getData(e) {
      return super.getData(e);
    }
  }
  const K0 = {
    /**
     * Triggered when a tile starts loading.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
     * @api
     */
    TILELOADSTART: "tileloadstart",
    /**
     * Triggered when a tile finishes loading, either when its data is loaded,
     * or when loading was aborted because the tile is no longer needed.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadend
     * @api
     */
    TILELOADEND: "tileloadend",
    /**
     * Triggered if tile loading results in an error. Note that this is not the
     * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
     * for details.
     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
     * @api
     */
    TILELOADERROR: "tileloaderror"
  }, Tc = [0, 0, 0], qa = 5;
  class dc {
    /**
     * @param {Options} options Tile grid options.
     */
    constructor(e) {
      this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, Mt(
        kq(
          this.resolutions_,
          /**
           * @param {number} a First resolution
           * @param {number} b Second resolution
           * @return {number} Comparison result
           */
          (n, s) => s - n
        ),
        "`resolutions` must be sorted in descending order"
      );
      let i;
      if (!e.origins) {
        for (let n = 0, s = this.resolutions_.length - 1; n < s; ++n)
          if (!i)
            i = this.resolutions_[n] / this.resolutions_[n + 1];
          else if (this.resolutions_[n] / this.resolutions_[n + 1] !== i) {
            i = void 0;
            break;
          }
      }
      this.zoomFactor_ = i, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, Mt(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      ));
      const r = e.extent;
      r !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = qs(r)), Mt(
        !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
        "Either `origin` or `origins` must be configured, never both"
      ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, Mt(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      )), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : Hv, Mt(
        !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
        "Either `tileSize` or `tileSizes` must be configured, never both"
      ), this.extent_ = r !== void 0 ? r : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map((n, s) => {
        const o = new yB(
          Math.min(0, n[0]),
          Math.max(n[0] - 1, -1),
          Math.min(0, n[1]),
          Math.max(n[1] - 1, -1)
        );
        if (r) {
          const a = this.getTileRangeForExtentAndZ(r, s);
          o.minX = Math.max(a.minX, o.minX), o.maxX = Math.min(a.maxX, o.maxX), o.minY = Math.max(a.minY, o.minY), o.maxY = Math.min(a.maxY, o.maxY);
        }
        return o;
      }) : r && this.calculateTileRanges_(r);
    }
    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
     * @api
     */
    forEachTileCoord(e, i, r) {
      const n = this.getTileRangeForExtentAndZ(e, i);
      for (let s = n.minX, o = n.maxX; s <= o; ++s)
        for (let a = n.minY, A = n.maxY; a <= A; ++a)
          r([i, s, a]);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */
    forEachTileCoordParentTileRange(e, i, r, n) {
      let s, o, a, A = null, l = e[0] - 1;
      for (this.zoomFactor_ === 2 ? (o = e[1], a = e[2]) : A = this.getTileCoordExtent(e, n); l >= this.minZoom; ) {
        if (o !== void 0 && a !== void 0 ? (o = Math.floor(o / 2), a = Math.floor(a / 2), s = Qc(o, o, a, a, r)) : s = this.getTileRangeForExtentAndZ(
          A,
          l,
          r
        ), i(l, s))
          return !0;
        --l;
      }
      return !1;
    }
    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_;
    }
    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */
    getMaxZoom() {
      return this.maxZoom;
    }
    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */
    getMinZoom() {
      return this.minZoom;
    }
    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */
    getOrigin(e) {
      return this.origin_ ? this.origin_ : this.origins_[e];
    }
    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */
    getResolution(e) {
      return this.resolutions_[e];
    }
    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileCoordChildTileRange(e, i, r) {
      if (e[0] < this.maxZoom) {
        if (this.zoomFactor_ === 2) {
          const s = e[1] * 2, o = e[2] * 2;
          return Qc(
            s,
            s + 1,
            o,
            o + 1,
            i
          );
        }
        const n = this.getTileCoordExtent(
          e,
          r || this.tmpExtent_
        );
        return this.getTileRangeForExtentAndZ(
          n,
          e[0] + 1,
          i
        );
      }
      return null;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default|null} Tile range.
     */
    getTileRangeForTileCoordAndZ(e, i, r) {
      if (i > this.maxZoom || i < this.minZoom)
        return null;
      const n = e[0], s = e[1], o = e[2];
      if (i === n)
        return Qc(
          s,
          o,
          s,
          o,
          r
        );
      if (this.zoomFactor_) {
        const A = Math.pow(this.zoomFactor_, i - n), l = Math.floor(s * A), c = Math.floor(o * A);
        if (i < n)
          return Qc(l, l, c, c, r);
        const u = Math.floor(A * (s + 1)) - 1, d = Math.floor(A * (o + 1)) - 1;
        return Qc(l, u, c, d, r);
      }
      const a = this.getTileCoordExtent(e, this.tmpExtent_);
      return this.getTileRangeForExtentAndZ(a, i, r);
    }
    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */
    getTileRangeForExtentAndZ(e, i, r) {
      this.getTileCoordForXYAndZ_(e[0], e[3], i, !1, Tc);
      const n = Tc[1], s = Tc[2];
      this.getTileCoordForXYAndZ_(e[2], e[1], i, !0, Tc);
      const o = Tc[1], a = Tc[2];
      return Qc(n, o, s, a, r);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */
    getTileCoordCenter(e) {
      const i = this.getOrigin(e[0]), r = this.getResolution(e[0]), n = mr(this.getTileSize(e[0]), this.tmpSize_);
      return [
        i[0] + (e[1] + 0.5) * n[0] * r,
        i[1] - (e[2] + 0.5) * n[1] * r
      ];
    }
    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getTileCoordExtent(e, i) {
      const r = this.getOrigin(e[0]), n = this.getResolution(e[0]), s = mr(this.getTileSize(e[0]), this.tmpSize_), o = r[0] + e[1] * s[0] * n, a = r[1] - (e[2] + 1) * s[1] * n, A = o + s[0] * n, l = a + s[1] * n;
      return fs(o, a, A, l, i);
    }
    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndResolution(e, i, r) {
      return this.getTileCoordForXYAndResolution_(
        e[0],
        e[1],
        i,
        !1,
        r
      );
    }
    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    getTileCoordForXYAndResolution_(e, i, r, n, s) {
      const o = this.getZForResolution(r), a = r / this.getResolution(o), A = this.getOrigin(o), l = mr(this.getTileSize(o), this.tmpSize_);
      let c = a * (e - A[0]) / r / l[0], u = a * (A[1] - i) / r / l[1];
      return n ? (c = dA(c, qa) - 1, u = dA(u, qa) - 1) : (c = cu(c, qa), u = cu(u, qa)), ad(o, c, u, s);
    }
    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */
    getTileCoordForXYAndZ_(e, i, r, n, s) {
      const o = this.getOrigin(r), a = this.getResolution(r), A = mr(this.getTileSize(r), this.tmpSize_);
      let l = (e - o[0]) / a / A[0], c = (o[1] - i) / a / A[1];
      return n ? (l = dA(l, qa) - 1, c = dA(c, qa) - 1) : (l = cu(l, qa), c = cu(c, qa)), ad(r, l, c, s);
    }
    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */
    getTileCoordForCoordAndZ(e, i, r) {
      return this.getTileCoordForXYAndZ_(
        e[0],
        e[1],
        i,
        !1,
        r
      );
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */
    getTileCoordResolution(e) {
      return this.resolutions_[e[0]];
    }
    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */
    getTileSize(e) {
      return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
    }
    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
     */
    getFullTileRange(e) {
      return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
    }
    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */
    getZForResolution(e, i) {
      const r = nB(
        this.resolutions_,
        e,
        i || 0
      );
      return yi(r, this.minZoom, this.maxZoom);
    }
    /**
     * The tile with the provided tile coordinate intersects the given viewport.
     * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
     * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
     * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
     */
    tileCoordIntersectsViewport(e, i) {
      return yU(
        i,
        0,
        i.length,
        2,
        this.getTileCoordExtent(e)
      );
    }
    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */
    calculateTileRanges_(e) {
      const i = this.resolutions_.length, r = new Array(i);
      for (let n = this.minZoom; n < i; ++n)
        r[n] = this.getTileRangeForExtentAndZ(e, n);
      this.fullTileRanges_ = r;
    }
  }
  class bz extends dc {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(e) {
      super({
        extent: e.extent,
        origin: e.origin,
        origins: e.origins,
        resolutions: e.resolutions,
        tileSize: e.tileSize,
        tileSizes: e.tileSizes,
        sizes: e.sizes
      }), this.matrixIds_ = e.matrixIds;
    }
    /**
     * @param {number} z Z.
     * @return {string} MatrixId..
     */
    getMatrixId(e) {
      return this.matrixIds_[e];
    }
    /**
     * Get the list of matrix identifiers.
     * @return {Array<string>} MatrixIds.
     * @api
     */
    getMatrixIds() {
      return this.matrixIds_;
    }
  }
  function uae(t, e, i) {
    const r = [], n = [], s = [], o = [], a = [];
    i = i !== void 0 ? i : [];
    const A = "SupportedCRS", l = "TileMatrix", c = "Identifier", u = "ScaleDenominator", d = "TopLeftCorner", h = "TileWidth", g = "TileHeight", f = t[A], p = Xe(f), m = p.getMetersPerUnit(), E = p.getAxisOrientation().startsWith("ne");
    return t[l].sort(function(y, C) {
      return C[u] - y[u];
    }), t[l].forEach(function(y) {
      let C;
      if (i.length > 0 ? C = i.find(function(w) {
        return y[c] == w[l] ? !0 : y[c].includes(":") ? !1 : t[c] + ":" + y[c] === w[l];
      }) : C = !0, C) {
        n.push(y[c]);
        const w = y[u] * 28e-5 / m, M = y[h], I = y[g];
        E ? s.push([
          y[d][1],
          y[d][0]
        ]) : s.push(y[d]), r.push(w), o.push(
          M == I ? M : [M, I]
        ), a.push([y.MatrixWidth, y.MatrixHeight]);
      }
    }), new bz({
      extent: e,
      origins: s,
      resolutions: r,
      matrixIds: n,
      tileSizes: o,
      sizes: a
    });
  }
  function Mz(t) {
    let e = t.getDefaultTileGrid();
    return e || (e = gae(t), t.setDefaultTileGrid(e)), e;
  }
  function dae(t, e, i) {
    const r = e[0], n = t.getTileCoordCenter(e), s = bf(i);
    if (!zl(s, n)) {
      const o = mt(s), a = Math.ceil(
        (s[0] - n[0]) / o
      );
      return n[0] += o * a, t.getTileCoordForCoordAndZ(n, r);
    }
    return e;
  }
  function hae(t, e, i, r) {
    r = r !== void 0 ? r : "top-left";
    const n = Iz(t, e, i);
    return new dc({
      extent: t,
      origin: jq(t, r),
      resolutions: n,
      tileSize: i
    });
  }
  function vx(t) {
    const e = t || {}, i = e.extent || Xe("EPSG:3857").getExtent(), r = {
      extent: i,
      minZoom: e.minZoom,
      tileSize: e.tileSize,
      resolutions: Iz(
        i,
        e.maxZoom,
        e.tileSize,
        e.maxResolution
      )
    };
    return new dc(r);
  }
  function Iz(t, e, i, r) {
    e = e !== void 0 ? e : NU, i = mr(i !== void 0 ? i : Hv);
    const n = Fi(t), s = mt(t);
    r = r > 0 ? r : Math.max(s / i[0], n / i[1]);
    const o = e + 1, a = new Array(o);
    for (let A = 0; A < o; ++A)
      a[A] = r / Math.pow(2, A);
    return a;
  }
  function gae(t, e, i, r) {
    const n = bf(t);
    return hae(n, e, i, r);
  }
  function bf(t) {
    t = Xe(t);
    let e = t.getExtent();
    if (!e) {
      const i = 180 * Fa.degrees / t.getMetersPerUnit();
      e = fs(-i, -i, i, i);
    }
    return e;
  }
  class vz extends Nd {
    /**
     * @param {Options} options SourceTile source options.
     */
    constructor(e) {
      super({
        attributions: e.attributions,
        attributionsCollapsible: e.attributionsCollapsible,
        projection: e.projection,
        state: e.state,
        wrapX: e.wrapX,
        interpolate: e.interpolate
      }), this.on, this.once, this.un, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
      const i = [256, 256];
      this.tileGrid && mr(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), i), this.tmpSize = [0, 0], this.key_ = e.key || ve(this), this.tileOptions = {
        transition: e.transition,
        interpolate: e.interpolate
      }, this.zDirection = e.zDirection ? e.zDirection : 0;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */
    getGutterForProjection(e) {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     */
    getKey() {
      return this.key_;
    }
    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */
    setKey(e) {
      this.key_ !== e && (this.key_ = e, this.changed());
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     * @override
     */
    getResolutions(e) {
      const i = e ? this.getTileGridForProjection(e) : this.tileGrid;
      return i ? i.getResolutions() : null;
    }
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {TileType|null} Tile.
     */
    getTile(e, i, r, n, s) {
      return it();
    }
    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
     * @api
     */
    getTileGrid() {
      return this.tileGrid;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */
    getTileGridForProjection(e) {
      return this.tileGrid ? this.tileGrid : Mz(e);
    }
    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */
    getTilePixelRatio(e) {
      return this.tilePixelRatio_;
    }
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */
    getTilePixelSize(e, i, r) {
      const n = this.getTileGridForProjection(r), s = this.getTilePixelRatio(i), o = mr(n.getTileSize(e), this.tmpSize);
      return s == 1 ? o : aee(o, s, this.tmpSize);
    }
    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */
    getTileCoordForTileUrlFunction(e, i) {
      const r = i !== void 0 ? i : this.getProjection(), n = i !== void 0 ? this.getTileGridForProjection(r) : this.tileGrid || this.getTileGridForProjection(r);
      return this.getWrapX() && r.isGlobal() && (e = dae(n, e, r)), wie(e, n) ? e : null;
    }
    /**
     * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
     * @api
     */
    clear() {
    }
    /**
     * @override
     */
    refresh() {
      this.clear(), super.refresh();
    }
  }
  class fae extends on {
    /**
     * @param {string} type Type.
     * @param {import("../Tile.js").default} tile The tile.
     */
    constructor(e, i) {
      super(e), this.tile = i;
    }
  }
  function Mg(t, e) {
    const i = [];
    Object.keys(e).forEach(function(n) {
      e[n] !== null && e[n] !== void 0 && i.push(n + "=" + encodeURIComponent(e[n]));
    });
    const r = i.join("&");
    return t = t.replace(/[?&]$/, ""), t += t.includes("?") ? "&" : "?", t + r;
  }
  const pae = /\{z\}/g, mae = /\{x\}/g, Eae = /\{y\}/g, yae = /\{-y\}/g;
  function Bae(t, e, i, r, n) {
    return t.replace(pae, e.toString()).replace(mae, i.toString()).replace(Eae, r.toString()).replace(yae, function() {
      if (n === void 0)
        throw new Error(
          "If the URL template has a {-y} placeholder, the grid extent must be known"
        );
      return (n - r).toString();
    });
  }
  function xz(t) {
    const e = [];
    let i = /\{([a-z])-([a-z])\}/.exec(t);
    if (i) {
      const r = i[1].charCodeAt(0), n = i[2].charCodeAt(0);
      let s;
      for (s = r; s <= n; ++s)
        e.push(t.replace(i[0], String.fromCharCode(s)));
      return e;
    }
    if (i = /\{(\d+)-(\d+)\}/.exec(t), i) {
      const r = parseInt(i[2], 10);
      for (let n = parseInt(i[1], 10); n <= r; n++)
        e.push(t.replace(i[0], n.toString()));
      return e;
    }
    return e.push(t), e;
  }
  function wae(t, e) {
    return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(i, r, n) {
        if (!i)
          return;
        let s;
        const o = i[0];
        if (e) {
          const a = e.getFullTileRange(o);
          a && (s = a.getHeight() - 1);
        }
        return Bae(t, o, i[1], i[2], s);
      }
    );
  }
  function Qz(t, e) {
    const i = t.length, r = new Array(i);
    for (let n = 0; n < i; ++n)
      r[n] = wae(t[n], e);
    return jb(r);
  }
  function jb(t) {
    return t.length === 1 ? t[0] : (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(e, i, r) {
        if (!e)
          return;
        const n = yL(e), s = pa(n, t.length);
        return t[s](e, i, r);
      }
    );
  }
  class DB extends vz {
    /**
     * @param {Options} options Image tile options.
     */
    constructor(e) {
      super({
        attributions: e.attributions,
        cacheSize: e.cacheSize,
        projection: e.projection,
        state: e.state,
        tileGrid: e.tileGrid,
        tilePixelRatio: e.tilePixelRatio,
        wrapX: e.wrapX,
        transition: e.transition,
        interpolate: e.interpolate,
        key: e.key,
        attributionsCollapsible: e.attributionsCollapsible,
        zDirection: e.zDirection
      }), this.generateTileUrlFunction_ = this.tileUrlFunction === DB.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile load function of the source.
     * @return {import("../Tile.js").LoadFunction} TileLoadFunction
     * @api
     */
    getTileLoadFunction() {
      return this.tileLoadFunction;
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the tile URL function of the source.
     * @return {import("../Tile.js").UrlFunction} TileUrlFunction
     * @api
     */
    getTileUrlFunction() {
      return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Return the URLs used for this source.
     * When a tileUrlFunction is used instead of url or urls,
     * null will be returned.
     * @return {!Array<string>|null} URLs.
     * @api
     */
    getUrls() {
      return this.urls;
    }
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    handleTileChange(e) {
      const i = (
        /** @type {import("../Tile.js").default} */
        e.target
      ), r = ve(i), n = i.getState();
      let s;
      n == pe.LOADING ? (this.tileLoadingKeys_[r] = !0, s = K0.TILELOADSTART) : r in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[r], s = n == pe.ERROR ? K0.TILELOADERROR : n == pe.LOADED ? K0.TILELOADEND : void 0), s != null && this.dispatchEvent(new fae(s, i));
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile load function of the source.
     * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @api
     */
    setTileLoadFunction(e) {
      this.tileLoadFunction = e, this.changed();
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the tile URL function of the source.
     * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
     * @param {string} [key] Optional new tile key for the source.
     * @api
     */
    setTileUrlFunction(e, i) {
      this.tileUrlFunction = e, typeof i < "u" ? this.setKey(i) : this.changed();
    }
    /**
     * Set the URL to use for requests.
     * @param {string} url URL.
     * @api
     */
    setUrl(e) {
      const i = xz(e);
      this.urls = i, this.setUrls(i);
    }
    /**
     * Deprecated.  Use an ImageTile source instead.
     * Set the URLs to use for requests.
     * @param {Array<string>} urls URLs.
     * @api
     */
    setUrls(e) {
      this.urls = e;
      const i = e.join(`
`);
      this.generateTileUrlFunction_ ? this.setTileUrlFunction(Qz(e, this.tileGrid), i) : this.setKey(i);
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    tileUrlFunction(e, i, r) {
    }
  }
  class xx extends DB {
    /**
     * @param {!Options} options Image tile options.
     */
    constructor(e) {
      super({
        attributions: e.attributions,
        cacheSize: e.cacheSize,
        projection: e.projection,
        state: e.state,
        tileGrid: e.tileGrid,
        tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : Cae,
        tilePixelRatio: e.tilePixelRatio,
        tileUrlFunction: e.tileUrlFunction,
        url: e.url,
        urls: e.urls,
        wrapX: e.wrapX,
        transition: e.transition,
        interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
        key: e.key,
        attributionsCollapsible: e.attributionsCollapsible,
        zDirection: e.zDirection
      }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : ix, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     * @override
     */
    getGutterForProjection(e) {
      return this.getProjection() && e && !Fo(this.getProjection(), e) ? 0 : this.getGutter();
    }
    /**
     * @return {number} Gutter.
     */
    getGutter() {
      return 0;
    }
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     * @override
     */
    getKey() {
      let e = super.getKey();
      return this.getInterpolate() || (e += ":disable-interpolation"), e;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     * @override
     */
    getTileGridForProjection(e) {
      const i = this.getProjection();
      if (this.tileGrid && (!i || Fo(i, e)))
        return this.tileGrid;
      const r = ve(e);
      return r in this.tileGridForProjection || (this.tileGridForProjection[r] = Mz(e)), this.tileGridForProjection[r];
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {string} key The key set on the tile.
     * @return {!ImageTile} Tile.
     * @private
     */
    createTile_(e, i, r, n, s, o) {
      const a = [e, i, r], A = this.getTileCoordForTileUrlFunction(
        a,
        s
      ), l = A ? this.tileUrlFunction(A, n, s) : void 0, c = new this.tileClass(
        a,
        l !== void 0 ? pe.IDLE : pe.EMPTY,
        l !== void 0 ? l : "",
        this.crossOrigin,
        this.tileLoadFunction,
        this.tileOptions
      );
      return c.key = o, c.addEventListener(Ge.CHANGE, this.handleTileChange.bind(this)), c;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!(ImageTile|ReprojTile)} Tile.
     * @override
     */
    getTile(e, i, r, n, s) {
      const o = this.getProjection();
      if (!o || !s || Fo(o, s))
        return this.getTileInternal(
          e,
          i,
          r,
          n,
          o || s
        );
      const a = [e, i, r], A = this.getKey(), l = this.getTileGridForProjection(o), c = this.getTileGridForProjection(s), u = this.getTileCoordForTileUrlFunction(
        a,
        s
      ), d = new PE(
        o,
        l,
        s,
        c,
        a,
        u,
        this.getTilePixelRatio(n),
        this.getGutter(),
        (h, g, f, p) => this.getTileInternal(h, g, f, p, o),
        this.reprojectionErrorThreshold_,
        this.renderReprojectionEdges_,
        this.tileOptions
      );
      return d.key = A, d;
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {!import("../proj/Projection.js").default} projection Projection.
     * @return {!ImageTile} Tile.
     * @protected
     */
    getTileInternal(e, i, r, n, s) {
      const o = this.getKey();
      return this.createTile_(e, i, r, n, s, o);
    }
    /**
     * Sets whether to render reprojection edges or not (usually for debugging).
     * @param {boolean} render Render the edges.
     * @api
     */
    setRenderReprojectionEdges(e) {
      this.renderReprojectionEdges_ != e && (this.renderReprojectionEdges_ = e, this.changed());
    }
    /**
     * Sets the tile grid to use when reprojecting the tiles to the given
     * projection instead of the default tile grid for the projection.
     *
     * This can be useful when the default tile grid cannot be created
     * (e.g. projection has no extent defined) or
     * for optimization reasons (custom tile size, resolutions, ...).
     *
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
     * @api
     */
    setTileGridForProjection(e, i) {
      const r = Xe(e);
      if (r) {
        const n = ve(r);
        n in this.tileGridForProjection || (this.tileGridForProjection[n] = i);
      }
    }
  }
  function Cae(t, e) {
    t.getImage().src = e;
  }
  const pA = 4;
  function Hb(t) {
    return Array.isArray(t) ? Math.min(...t) : t;
  }
  class bae extends Pv {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent.
     * @param {number} targetResolution Target resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {FunctionType} getImageFunction
     *     Function returning source images (extent, resolution, pixelRatio).
     * @param {boolean} interpolate Use linear interpolation when resampling.
     */
    constructor(e, i, r, n, s, o, a) {
      let A = e.getExtent();
      A && e.canWrapX() && (A = A.slice(), A[0] = -1 / 0, A[2] = 1 / 0);
      let l = i.getExtent();
      l && i.canWrapX() && (l = l.slice(), l[0] = -1 / 0, l[2] = 1 / 0);
      const c = l ? fr(r, l) : r, u = xn(c), d = bg(
        e,
        i,
        u,
        n
      ), h = bx, g = new Mx(
        e,
        i,
        c,
        A,
        d * h,
        n
      ), f = g.calculateSourceExtent(), p = GA(f) ? null : o(f, d, s), m = p ? ze.IDLE : ze.EMPTY, E = p ? p.getPixelRatio() : 1;
      super(r, n, E, m), this.targetProj_ = i, this.maxSourceExtent_ = A, this.triangulation_ = g, this.targetResolution_ = n, this.targetExtent_ = r, this.sourceImage_ = p, this.sourcePixelRatio_ = E, this.interpolate_ = a, this.canvas_ = null, this.sourceListenerKey_ = null;
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.state == ze.LOADING && this.unlistenSource_(), super.disposeInternal();
    }
    /**
     * @return {HTMLCanvasElement} Image.
     * @override
     */
    getImage() {
      return this.canvas_;
    }
    /**
     * @return {import("../proj/Projection.js").default} Projection.
     */
    getProjection() {
      return this.targetProj_;
    }
    /**
     * @private
     */
    reproject_() {
      const e = this.sourceImage_.getState();
      if (e == ze.LOADED) {
        const i = mt(this.targetExtent_) / this.targetResolution_, r = Fi(this.targetExtent_) / this.targetResolution_;
        this.canvas_ = Bz(
          i,
          r,
          this.sourcePixelRatio_,
          Hb(this.sourceImage_.getResolution()),
          this.maxSourceExtent_,
          this.targetResolution_,
          this.targetExtent_,
          this.triangulation_,
          [
            {
              extent: this.sourceImage_.getExtent(),
              image: this.sourceImage_.getImage()
            }
          ],
          0,
          void 0,
          this.interpolate_,
          !0
        );
      }
      this.state = e, this.changed();
    }
    /**
     * Load not yet loaded URI.
     * @override
     */
    load() {
      if (this.state == ze.IDLE) {
        this.state = ze.LOADING, this.changed();
        const e = this.sourceImage_.getState();
        e == ze.LOADED || e == ze.ERROR ? this.reproject_() : (this.sourceListenerKey_ = nt(
          this.sourceImage_,
          Ge.CHANGE,
          (i) => {
            const r = this.sourceImage_.getState();
            (r == ze.LOADED || r == ze.ERROR) && (this.unlistenSource_(), this.reproject_());
          }
        ), this.sourceImage_.load());
      }
    }
    /**
     * @private
     */
    unlistenSource_() {
      Pt(
        /** @type {!import("../events.js").EventsKey} */
        this.sourceListenerKey_
      ), this.sourceListenerKey_ = null;
    }
  }
  const X0 = {
    /**
     * Triggered when an image starts loading.
     * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
     * @api
     */
    IMAGELOADSTART: "imageloadstart",
    /**
     * Triggered when an image finishes loading.
     * @event module:ol/source/Image.ImageSourceEvent#imageloadend
     * @api
     */
    IMAGELOADEND: "imageloadend",
    /**
     * Triggered if image loading results in an error.
     * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
     * @api
     */
    IMAGELOADERROR: "imageloaderror"
  };
  class Mae extends on {
    /**
     * @param {string} type Type.
     * @param {import("../Image.js").default} image The image.
     */
    constructor(e, i) {
      super(e), this.image = i;
    }
  }
  class Qx extends Nd {
    /**
     * @param {Options} options Single image source options.
     */
    constructor(e) {
      super({
        attributions: e.attributions,
        projection: e.projection,
        state: e.state,
        interpolate: e.interpolate !== void 0 ? e.interpolate : !0
      }), this.on, this.once, this.un, this.loader = e.loader || null, this.resolutions_ = e.resolutions !== void 0 ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = e.loader ? e.loader.length === 0 : !1, this.wantedProjection_ = null;
    }
    /**
     * @return {Array<number>|null} Resolutions.
     * @override
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * @param {Array<number>|null} resolutions Resolutions.
     */
    setResolutions(e) {
      this.resolutions_ = e;
    }
    /**
     * @protected
     * @param {number} resolution Resolution.
     * @return {number} Resolution.
     */
    findNearestResolution(e) {
      const i = this.getResolutions();
      if (i) {
        const r = nB(i, e, 0);
        e = i[r];
      }
      return e;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     */
    getImage(e, i, r, n) {
      const s = this.getProjection();
      if (!s || !n || Fo(s, n))
        return s && (n = s), this.getImageInternal(e, i, r, n);
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() && Fo(this.reprojectedImage_.getProjection(), n) && this.reprojectedImage_.getResolution() == i && Zs(this.reprojectedImage_.getExtent(), e))
          return this.reprojectedImage_;
        this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
      }
      return this.reprojectedImage_ = new bae(
        s,
        n,
        e,
        i,
        r,
        (o, a, A) => this.getImageInternal(o, a, A, s),
        this.getInterpolate()
      ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
    }
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     * @protected
     */
    getImageInternal(e, i, r, n) {
      if (this.loader) {
        const s = Fz(e, i, r, 1), o = this.findNearestResolution(i);
        if (this.image && (this.static_ || this.wantedProjection_ === n && (this.wantedExtent_ && ts(this.wantedExtent_, s) || ts(this.image.getExtent(), s)) && (this.wantedResolution_ && Hb(this.wantedResolution_) === o || Hb(this.image.getResolution()) === o)))
          return this.image;
        this.wantedProjection_ = n, this.wantedExtent_ = s, this.wantedResolution_ = o, this.image = new Pv(
          s,
          o,
          r,
          this.loader
        ), this.image.addEventListener(
          Ge.CHANGE,
          this.handleImageChange.bind(this)
        );
      }
      return this.image;
    }
    /**
     * Handle image change events.
     * @param {import("../events/Event.js").default} event Event.
     * @protected
     */
    handleImageChange(e) {
      const i = (
        /** @type {import("../Image.js").default} */
        e.target
      );
      let r;
      switch (i.getState()) {
        case ze.LOADING:
          this.loading = !0, r = X0.IMAGELOADSTART;
          break;
        case ze.LOADED:
          this.loading = !1, r = X0.IMAGELOADEND;
          break;
        case ze.ERROR:
          this.loading = !1, r = X0.IMAGELOADERROR;
          break;
        default:
          return;
      }
      this.hasListener(r) && this.dispatchEvent(new Mae(r, i));
    }
  }
  function Iae(t, e) {
    t.getImage().src = e;
  }
  function Fz(t, e, i, r) {
    const n = e / i, s = xn(t), o = dA(mt(t) / n, pA), a = dA(Fi(t) / n, pA), A = dA((r - 1) * o / 2, pA), l = o + 2 * A, c = dA((r - 1) * a / 2, pA), u = a + 2 * c;
    return ag(s, n, 0, [
      l,
      u
    ]);
  }
  const OE = "1.3.0", LT = [101, 101];
  function Sz(t, e, i, r, n) {
    n.WIDTH = i[0], n.HEIGHT = i[1];
    const s = r.getAxisOrientation(), o = gv(n.VERSION, "1.3") >= 0;
    n[o ? "CRS" : "SRS"] = r.getCode();
    const a = o && s.startsWith("ne") ? [e[1], e[0], e[3], e[2]] : e;
    return n.BBOX = a.join(","), Mg(t, n);
  }
  function Dz(t, e, i, r, n, s, o) {
    s = Object.assign({ REQUEST: "GetMap" }, s);
    const a = e / i, A = [
      AD(mt(t) / a, pA),
      AD(Fi(t) / a, pA)
    ];
    if (i != 1)
      switch (o) {
        case "geoserver":
          const c = 90 * i + 0.5 | 0;
          "FORMAT_OPTIONS" in s ? s.FORMAT_OPTIONS += ";dpi:" + c : s.FORMAT_OPTIONS = "dpi:" + c;
          break;
        case "mapserver":
          s.MAP_RESOLUTION = 90 * i;
          break;
        case "carmentaserver":
        case "qgis":
          s.DPI = 90 * i;
          break;
        default:
          throw new Error("Unknown `serverType` configured");
      }
    return Sz(n, t, A, r, s);
  }
  function GE(t, e) {
    return Object.assign(
      {
        REQUEST: e,
        SERVICE: "WMS",
        VERSION: OE,
        FORMAT: "image/png",
        STYLES: "",
        TRANSPARENT: !0
      },
      t
    );
  }
  function vae(t) {
    const e = t.hidpi === void 0 ? !0 : t.hidpi, i = Xe(t.projection || "EPSG:3857"), r = t.ratio || 1.5, n = t.load || QU, s = t.crossOrigin ?? null;
    return (o, a, A) => {
      o = Fz(o, a, A, r), A != 1 && (!e || t.serverType === void 0) && (A = 1);
      const l = Dz(
        o,
        a,
        A,
        i,
        t.url,
        GE(t.params, "GetMap"),
        t.serverType
      ), c = new Image();
      return c.crossOrigin = s, n(c, l).then((u) => ({ image: u, extent: o, pixelRatio: A }));
    };
  }
  function xae(t, e, i) {
    if (t.url === void 0)
      return;
    const r = Xe(t.projection || "EPSG:3857"), n = ag(
      e,
      i,
      0,
      LT
    ), s = {
      QUERY_LAYERS: t.params.LAYERS,
      INFO_FORMAT: "application/json"
    };
    Object.assign(
      s,
      GE(t.params, "GetFeatureInfo"),
      t.params
    );
    const o = cu((e[0] - n[0]) / i, pA), a = cu((n[3] - e[1]) / i, pA), A = gv(s.VERSION, "1.3") >= 0;
    return s[A ? "I" : "X"] = o, s[A ? "J" : "Y"] = a, Sz(
      t.url,
      n,
      LT,
      r,
      s
    );
  }
  function Qae(t, e) {
    if (t.url === void 0)
      return;
    const i = {
      SERVICE: "WMS",
      VERSION: OE,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (e !== void 0) {
      const r = Xe(t.projection || "EPSG:3857").getMetersPerUnit() || 1, n = 28e-5;
      i.SCALE = e * r / n;
    }
    if (Object.assign(i, t.params), t.params !== void 0 && i.LAYER === void 0) {
      const r = i.LAYERS;
      if (!(!Array.isArray(r) || r.length !== 1))
        return;
      i.LAYER = r;
    }
    return Mg(t.url, i);
  }
  class Fae extends xx {
    /**
     * @param {Options} [options] Tile WMS options.
     */
    constructor(e) {
      e = e || /** @type {Options} */
      {};
      const i = Object.assign({}, e.params);
      super({
        attributions: e.attributions,
        attributionsCollapsible: e.attributionsCollapsible,
        cacheSize: e.cacheSize,
        crossOrigin: e.crossOrigin,
        interpolate: e.interpolate,
        projection: e.projection,
        reprojectionErrorThreshold: e.reprojectionErrorThreshold,
        tileClass: e.tileClass,
        tileGrid: e.tileGrid,
        tileLoadFunction: e.tileLoadFunction,
        url: e.url,
        urls: e.urls,
        wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
        transition: e.transition,
        zDirection: e.zDirection
      }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.params_ = i, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = yr(), this.updateV13_(), this.setKey(this.getKeyForParams_());
    }
    /**
     * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
     * projection. Return `undefined` if the GetFeatureInfo URL cannot be
     * constructed.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
     *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
     *     in the `LAYERS` parameter will be used. `VERSION` should not be
     *     specified here.
     * @return {string|undefined} GetFeatureInfo URL.
     * @api
     */
    getFeatureInfoUrl(e, i, r, n) {
      const s = Xe(r), o = this.getProjection() || s;
      let a = this.getTileGrid();
      a || (a = this.getTileGridForProjection(o));
      const A = kd(
        e,
        s,
        o
      ), l = bg(
        o,
        s,
        e,
        i
      ), c = a.getZForResolution(l, this.zDirection), u = a.getResolution(c), d = a.getTileCoordForCoordAndZ(A, c);
      if (a.getResolutions().length <= d[0])
        return;
      let h = a.getTileCoordExtent(d, this.tmpExtent_);
      const g = this.gutter_;
      g !== 0 && (h = $r(h, u * g, h));
      const f = {
        QUERY_LAYERS: this.params_.LAYERS
      };
      Object.assign(
        f,
        GE(this.params_, "GetFeatureInfo"),
        n
      );
      const p = Math.floor((A[0] - h[0]) / u), m = Math.floor((h[3] - A[1]) / u);
      return f[this.v13_ ? "I" : "X"] = p, f[this.v13_ ? "J" : "Y"] = m, this.getRequestUrl_(
        d,
        h,
        1,
        o || s,
        f
      );
    }
    /**
     * Return the GetLegendGraphic URL, optionally optimized for the passed
     * resolution and possibly including any passed specific parameters. Returns
     * `undefined` if the GetLegendGraphic URL cannot be constructed.
     *
     * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
     *     will not be calculated and included in URL.
     * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
     *     request is generated for this wms layer, else it will try to use the
     *     configured wms layer. Default `FORMAT` is `image/png`.
     *     `VERSION` should not be specified here.
     * @return {string|undefined} GetLegendGraphic URL.
     * @api
     */
    getLegendUrl(e, i) {
      if (this.urls[0] === void 0)
        return;
      const r = {
        SERVICE: "WMS",
        VERSION: OE,
        REQUEST: "GetLegendGraphic",
        FORMAT: "image/png"
      };
      if (i === void 0 || i.LAYER === void 0) {
        const n = this.params_.LAYERS;
        if (!(!Array.isArray(n) || n.length === 1))
          return;
        r.LAYER = n;
      }
      if (e !== void 0) {
        const n = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, s = 28e-5;
        r.SCALE = e * n / s;
      }
      return Object.assign(r, i), Mg(
        /** @type {string} */
        this.urls[0],
        r
      );
    }
    /**
     * @return {number} Gutter.
     * @override
     */
    getGutter() {
      return this.gutter_;
    }
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
    getParams() {
      return this.params_;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} tileExtent Tile extent.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {Object} params Params.
     * @return {string|undefined} Request URL.
     * @private
     */
    getRequestUrl_(e, i, r, n, s) {
      const o = this.urls;
      if (!o)
        return;
      let a;
      if (o.length == 1)
        a = o[0];
      else {
        const A = pa(yL(e), o.length);
        a = o[A];
      }
      return Dz(
        i,
        (this.tileGrid || this.getTileGridForProjection(n)).getResolution(e[0]),
        r,
        n,
        a,
        s,
        this.serverType_
      );
    }
    /**
     * Get the tile pixel ratio for this source.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     * @override
     */
    getTilePixelRatio(e) {
      return !this.hidpi_ || this.serverType_ === void 0 ? 1 : e;
    }
    /**
     * @private
     * @return {string} The key for the current params.
     */
    getKeyForParams_() {
      let e = 0;
      const i = [];
      for (const r in this.params_)
        i[e++] = r + "-" + this.params_[r];
      return i.join("/");
    }
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
    updateParams(e) {
      Object.assign(this.params_, e), this.updateV13_(), this.setKey(this.getKeyForParams_());
    }
    /**
     * @private
     */
    updateV13_() {
      const e = this.params_.VERSION || OE;
      this.v13_ = gv(e, "1.3") >= 0;
    }
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
     * @param {number} pixelRatio The pixel ratio
     * @param {import("../proj/Projection.js").default} projection The projection
     * @return {string|undefined} The tile URL
     * @override
     */
    tileUrlFunction(e, i, r) {
      let n = this.getTileGrid();
      if (n || (n = this.getTileGridForProjection(r)), n.getResolutions().length <= e[0])
        return;
      i != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (i = 1);
      const s = n.getResolution(e[0]);
      let o = n.getTileCoordExtent(e, this.tmpExtent_);
      const a = this.gutter_;
      a !== 0 && (o = $r(o, s * a, o));
      const A = Object.assign(
        {},
        GE(this.params_, "GetMap")
      );
      return this.getRequestUrl_(
        e,
        o,
        i,
        r,
        A
      );
    }
  }
  class Sae extends Qx {
    /**
     * @param {Options} [options] ImageWMS options.
     */
    constructor(e) {
      e = e || {}, super({
        attributions: e.attributions,
        interpolate: e.interpolate,
        projection: e.projection,
        resolutions: e.resolutions
      }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : Iae, this.params_ = Object.assign({}, e.params), this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5, this.loaderProjection_ = null;
    }
    /**
     * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
     * projection. Return `undefined` if the GetFeatureInfo URL cannot be
     * constructed.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../proj.js").ProjectionLike} projection Projection.
     * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
     *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
     *     in the `LAYERS` parameter will be used. `VERSION` should not be
     *     specified here.
     * @return {string|undefined} GetFeatureInfo URL.
     * @api
     */
    getFeatureInfoUrl(e, i, r, n) {
      const s = Xe(r), o = this.getProjection();
      o && o !== s && (i = bg(
        o,
        s,
        e,
        i
      ), e = kd(e, s, o));
      const a = {
        url: this.url_,
        params: {
          ...this.params_,
          ...n
        },
        projection: o || s
      };
      return xae(a, e, i);
    }
    /**
     * Return the GetLegendGraphic URL, optionally optimized for the passed
     * resolution and possibly including any passed specific parameters. Returns
     * `undefined` if the GetLegendGraphic URL cannot be constructed.
     *
     * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
     *     will not be calculated and included in URL.
     * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
     *     request is generated for this wms layer, else it will try to use the
     *     configured wms layer. Default `FORMAT` is `image/png`.
     *     `VERSION` should not be specified here.
     * @return {string|undefined} GetLegendGraphic URL.
     * @api
     */
    getLegendUrl(e, i) {
      return Qae(
        {
          url: this.url_,
          params: {
            ...this.params_,
            ...i
          }
        },
        e
      );
    }
    /**
     * Get the user-provided params, i.e. those passed to the constructor through
     * the "params" option, and possibly updated using the updateParams method.
     * @return {Object} Params.
     * @api
     */
    getParams() {
      return this.params_;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../Image.js").default} Single image.
     * @override
     */
    getImageInternal(e, i, r, n) {
      return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== n) && (this.loaderProjection_ = n, this.loader = vae({
        crossOrigin: this.crossOrigin_,
        params: this.params_,
        projection: n,
        serverType: this.serverType_,
        hidpi: this.hidpi_,
        url: this.url_,
        ratio: this.ratio_,
        load: (s, o) => (this.image.setImage(s), this.imageLoadFunction_(this.image, o), QU(s))
      })), super.getImageInternal(e, i, r, n));
    }
    /**
     * Return the image load function of the source.
     * @return {import("../Image.js").LoadFunction} The image load function.
     * @api
     */
    getImageLoadFunction() {
      return this.imageLoadFunction_;
    }
    /**
     * Return the URL used for this WMS source.
     * @return {string|undefined} URL.
     * @api
     */
    getUrl() {
      return this.url_;
    }
    /**
     * Set the image load function of the source.
     * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
     * @api
     */
    setImageLoadFunction(e) {
      this.imageLoadFunction_ = e, this.changed();
    }
    /**
     * Set the URL to use for requests.
     * @param {string|undefined} url URL.
     * @api
     */
    setUrl(e) {
      e != this.url_ && (this.url_ = e, this.loader = null, this.changed());
    }
    /**
     * Update the user-provided params.
     * @param {Object} params Params.
     * @api
     */
    updateParams(e) {
      Object.assign(this.params_, e), this.changed();
    }
    /**
     * @override
     */
    changed() {
      this.image = null, super.changed();
    }
  }
  let fu = [];
  function Dae(t = rn.layerConf, e) {
    if (Array.isArray(t)) {
      if (fu = t, typeof e == "function") {
        e(fu);
        return;
      }
      return;
    }
    fetch(t, { method: "GET", timeout: 1e4 }).then((i) => {
      i.json().then((r) => (fu = r, typeof e == "function" ? e(fu) : !0)).catch((r) => (console.error("An error occured when parsing the response after loading '" + t + "':", r), e(!1, r)));
    }).catch((i) => {
      console.error("An error occured when trying to fetch services from '" + t + "':", i), e(!1, i);
    });
  }
  function Tz(t) {
    const e = Object.keys(t);
    return fu.find((i) => e.every((r) => i[r] === t[r])) || null;
  }
  function Tae() {
    return fu;
  }
  function Rae(t, e) {
    const i = Tz({ id: t });
    if (i && typeof e == "string") {
      const r = i.gfiAttributes && i.gfiAttributes[e];
      return typeof r == "string" ? r : null;
    } else if (i)
      return i.gfiAttributes || null;
    return null;
  }
  const Fx = {
    getLayerWhere: Tz,
    getDisplayNamesOfFeatureAttributes: Rae,
    initializeLayerList: Dae,
    getLayerList: Tae
  }, _ae = "EPSG:3857";
  function Sx() {
    return Math.floor(Math.random() * 9999999);
  }
  function Rz(t, e) {
    const i = { ...t }, r = {}, n = [
      "STYLES",
      "TIME",
      "CRS"
    ];
    return Object.keys(e).forEach((s) => {
      r[s.toUpperCase()] = e[s];
    }), n.forEach((s) => {
      e[s] && (i[s] = e[s]);
    }), i;
  }
  function _z(t) {
    let e = {};
    return e = Object.assign({
      CACHEID: Sx(),
      FORMAT: t.format || "image/png",
      LAYERS: t.layers,
      VERSION: t.version,
      TRANSPARENT: t.transparent,
      SINGLETILE: t.singleTile,
      CQL_FILTER: t.cqlFilter
    }, t.singleTile ? {} : { WIDTH: t.tilesize, HEIGHT: t.tilesize }), e = Rz(e, t), e;
  }
  function Jb({ isSecured: t }) {
    return async (e, i) => {
      const r = await fetch(i, { credentials: t ? "include" : "omit" }), n = await r.blob();
      e.getImage().src = URL.createObjectURL(n);
    };
  }
  function kz(t, e) {
    const i = _z(t), r = t.crs ? Xe(t.crs) : void 0;
    let n = null;
    return t.singleTile ? new Sae({
      url: t.url,
      params: i,
      serverType: t.serverType,
      projection: r,
      attributions: t.olAttribution,
      crossOrigin: t.crossOrigin,
      imageLoadFunction: Jb(t)
    }) : (e && e.resolutions && (n = new dc({
      resolutions: e.resolutions,
      origin: e.origin ? e.origin : void 0,
      tileSize: parseInt(t.tilesize, 10)
    })), new Fae({
      url: t.url,
      params: i,
      gutter: t.gutter || 0,
      tileGrid: n,
      projection: r,
      attributions: t.olAttribution,
      crossOrigin: t.crossOrigin,
      tileLoadFunction: Jb(t)
    }));
  }
  function kae(t, e = {}, i) {
    const r = kz(t, i), n = t.singleTile ? Ix : SB;
    return r.set("olcs.projection", Xe(_ae)), new n(Object.assign({
      source: r,
      minResolution: typeof t.minResolution == "string" ? parseFloat(t.minResolution) : t.minResolution,
      maxResolution: typeof t.maxResolution == "string" ? parseFloat(t.maxResolution) : t.maxResolution,
      id: t.id,
      extent: t.extent
    }, e));
  }
  function Yae(t) {
    const e = t.getSource().getParams().SESSIONID;
    let i = e;
    for (; e === i; )
      i = Sx();
    return t.getSource().updateParams({ SESSIONID: i }), i;
  }
  function Nae(t, e, i) {
    const r = Fx.getLayerWhere({ Id: t.get("id") }), n = e.getView().getResolution(), s = e.getView().getProjection(), o = Object.assign({
      INFO_FORMAT: r && r.infoFormat || "text/xml"
    }, r && typeof r.featureCount < "u" ? { FEATURE_COUNT: r.featureCount } : {});
    return t.getSource().getFeatureInfoUrl(i, n, s, o);
  }
  const Uae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    addOptionalParams: Rz,
    createLayer: kae,
    createLayerSource: kz,
    defaultLoadFunction: Jb,
    generateSessionId: Sx,
    getGfiURL: Nae,
    makeParams: _z,
    updateSource: Yae
  }, Symbol.toStringTag, { value: "Module" }));
  class Dx extends xx {
    /**
     * @param {Options} options WMTS options.
     */
    constructor(e) {
      const i = e.requestEncoding !== void 0 ? e.requestEncoding : "KVP", r = e.tileGrid;
      let n = e.urls;
      n === void 0 && e.url !== void 0 && (n = xz(e.url)), super({
        attributions: e.attributions,
        attributionsCollapsible: e.attributionsCollapsible,
        cacheSize: e.cacheSize,
        crossOrigin: e.crossOrigin,
        interpolate: e.interpolate,
        projection: e.projection,
        reprojectionErrorThreshold: e.reprojectionErrorThreshold,
        tileClass: e.tileClass,
        tileGrid: r,
        tileLoadFunction: e.tileLoadFunction,
        tilePixelRatio: e.tilePixelRatio,
        urls: n,
        wrapX: e.wrapX !== void 0 ? e.wrapX : !1,
        transition: e.transition,
        zDirection: e.zDirection
      }), this.version_ = e.version !== void 0 ? e.version : "1.0.0", this.format_ = e.format !== void 0 ? e.format : "image/jpeg", this.dimensions_ = e.dimensions !== void 0 ? e.dimensions : {}, this.layer_ = e.layer, this.matrixSet_ = e.matrixSet, this.style_ = e.style, this.requestEncoding_ = i, this.setKey(this.getKeyForDimensions_()), n && n.length > 0 && (this.tileUrlFunction = jb(
        n.map(this.createFromWMTSTemplate.bind(this))
      ));
    }
    /**
     * Set the URLs to use for requests.
     * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
     * @param {Array<string>} urls URLs.
     * @override
     */
    setUrls(e) {
      this.urls = e;
      const i = e.join(`
`);
      this.setTileUrlFunction(
        jb(
          e.map(this.createFromWMTSTemplate.bind(this))
        ),
        i
      );
    }
    /**
     * Get the dimensions, i.e. those passed to the constructor through the
     * "dimensions" option, and possibly updated using the updateDimensions
     * method.
     * @return {!Object} Dimensions.
     * @api
     */
    getDimensions() {
      return this.dimensions_;
    }
    /**
     * Return the image format of the WMTS source.
     * @return {string} Format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * Return the layer of the WMTS source.
     * @return {string} Layer.
     * @api
     */
    getLayer() {
      return this.layer_;
    }
    /**
     * Return the matrix set of the WMTS source.
     * @return {string} MatrixSet.
     * @api
     */
    getMatrixSet() {
      return this.matrixSet_;
    }
    /**
     * Return the request encoding, either "KVP" or "REST".
     * @return {RequestEncoding} Request encoding.
     * @api
     */
    getRequestEncoding() {
      return this.requestEncoding_;
    }
    /**
     * Return the style of the WMTS source.
     * @return {string} Style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Return the version of the WMTS source.
     * @return {string} Version.
     * @api
     */
    getVersion() {
      return this.version_;
    }
    /**
     * @private
     * @return {string} The key for the current dimensions.
     */
    getKeyForDimensions_() {
      const e = this.urls ? this.urls.slice(0) : [];
      for (const i in this.dimensions_)
        e.push(i + "-" + this.dimensions_[i]);
      return e.join("/");
    }
    /**
     * Update the dimensions.
     * @param {Object} dimensions Dimensions.
     * @api
     */
    updateDimensions(e) {
      Object.assign(this.dimensions_, e), this.setKey(this.getKeyForDimensions_());
    }
    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */
    createFromWMTSTemplate(e) {
      const i = this.requestEncoding_, r = {
        layer: this.layer_,
        style: this.style_,
        tilematrixset: this.matrixSet_
      };
      i == "KVP" && Object.assign(r, {
        Service: "WMTS",
        Request: "GetTile",
        Version: this.version_,
        Format: this.format_
      }), e = i == "KVP" ? Mg(e, r) : e.replace(/\{(\w+?)\}/g, function(o, a) {
        return a.toLowerCase() in r ? r[a.toLowerCase()] : o;
      });
      const n = (
        /** @type {import("../tilegrid/WMTS.js").default} */
        this.tileGrid
      ), s = this.dimensions_;
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function(o, a, A) {
          if (!o)
            return;
          const l = {
            TileMatrix: n.getMatrixId(o[0]),
            TileCol: o[1],
            TileRow: o[2]
          };
          Object.assign(l, s);
          let c = e;
          return i == "KVP" ? c = Mg(c, l) : c = c.replace(/\{(\w+?)\}/g, function(u, d) {
            return encodeURIComponent(l[d]);
          }), c;
        }
      );
    }
  }
  function Lae(t, e) {
    const i = t.Contents.Layer, r = i == null ? void 0 : i.find(function(v) {
      return v.Identifier == e.layer;
    });
    if (!r)
      return null;
    const n = t.Contents.TileMatrixSet;
    let s;
    r.TileMatrixSetLink.length > 1 ? "projection" in e ? s = r.TileMatrixSetLink.findIndex(function(v) {
      const S = n.find(function(R) {
        return R.Identifier == v.TileMatrixSet;
      }).SupportedCRS, D = Xe(S), F = Xe(e.projection);
      return D && F ? Fo(D, F) : S == e.projection;
    }) : s = r.TileMatrixSetLink.findIndex(function(v) {
      return v.TileMatrixSet == e.matrixSet;
    }) : s = 0, s < 0 && (s = 0);
    const o = (
      /** @type {string} */
      r.TileMatrixSetLink[s].TileMatrixSet
    ), a = (
      /** @type {Array<Object>} */
      r.TileMatrixSetLink[s].TileMatrixSetLimits
    );
    let A = (
      /** @type {string} */
      r.Format[0]
    );
    "format" in e && (A = e.format), s = r.Style.findIndex(function(v) {
      return "style" in e ? v.Title == e.style : v.isDefault;
    }), s < 0 && (s = 0);
    const l = (
      /** @type {string} */
      r.Style[s].Identifier
    ), c = {};
    "Dimension" in r && r.Dimension.forEach(function(v, T, S) {
      const D = v.Identifier;
      let F = v.Default;
      F === void 0 && (F = v.Value[0]), c[D] = F;
    });
    const d = t.Contents.TileMatrixSet.find(function(v) {
      return v.Identifier == o;
    });
    let h;
    const g = d.SupportedCRS;
    if (g && (h = Xe(g)), "projection" in e) {
      const v = Xe(e.projection);
      v && (!h || Fo(v, h)) && (h = v);
    }
    let f = !1;
    const p = h.getAxisOrientation().startsWith("ne");
    let m = d.TileMatrix[0], E = {
      MinTileCol: 0,
      MinTileRow: 0,
      // subtract one to end up at tile top left
      MaxTileCol: m.MatrixWidth - 1,
      MaxTileRow: m.MatrixHeight - 1
    };
    if (a) {
      E = a[a.length - 1];
      const v = d.TileMatrix.find(
        (T) => T.Identifier === E.TileMatrix || d.Identifier + ":" + T.Identifier === E.TileMatrix
      );
      v && (m = v);
    }
    const y = m.ScaleDenominator * 28e-5 / h.getMetersPerUnit(), C = p ? [m.TopLeftCorner[1], m.TopLeftCorner[0]] : m.TopLeftCorner, w = m.TileWidth * y, M = m.TileHeight * y;
    let I = d.BoundingBox;
    I && p && (I = [
      I[1],
      I[0],
      I[3],
      I[2]
    ]);
    let b = [
      C[0] + w * E.MinTileCol,
      // add one to get proper bottom/right coordinate
      C[1] - M * (1 + E.MaxTileRow),
      C[0] + w * (1 + E.MaxTileCol),
      C[1] - M * E.MinTileRow
    ];
    if (I !== void 0 && !ts(I, b)) {
      const v = r.WGS84BoundingBox, T = Xe("EPSG:4326").getExtent();
      if (b = I, v)
        f = v[0] === T[0] && v[2] === T[2];
      else {
        const S = cU(
          I,
          d.SupportedCRS,
          "EPSG:4326"
        );
        f = S[0] - 1e-10 <= T[0] && S[2] + 1e-10 >= T[2];
      }
    }
    const B = uae(
      d,
      b,
      a
    ), x = [];
    let Q = e.requestEncoding;
    if (Q = Q !== void 0 ? Q : "", "OperationsMetadata" in t && "GetTile" in t.OperationsMetadata) {
      const v = t.OperationsMetadata.GetTile.DCP.HTTP.Get;
      for (let T = 0, S = v.length; T < S; ++T)
        if (v[T].Constraint) {
          const F = v[T].Constraint.find(function(R) {
            return R.name == "GetEncoding";
          }).AllowedValues.Value;
          if (Q === "" && (Q = F[0]), Q === "KVP")
            F.includes("KVP") && x.push(
              /** @type {string} */
              v[T].href
            );
          else
            break;
        } else v[T].href && (Q = "KVP", x.push(
          /** @type {string} */
          v[T].href
        ));
    }
    return x.length === 0 && (Q = "REST", r.ResourceURL.forEach(function(v) {
      v.resourceType === "tile" && (A = v.format, x.push(
        /** @type {string} */
        v.template
      ));
    })), {
      urls: x,
      layer: e.layer,
      matrixSet: o,
      format: A,
      projection: h,
      requestEncoding: Q,
      tileGrid: B,
      style: l,
      dimensions: c,
      wrapX: f,
      crossOrigin: e.crossOrigin
    };
  }
  const Vb = "http://www.w3.org/2001/XMLSchema-instance";
  function Bt(t, e) {
    return Lz().createElementNS(t, e);
  }
  function jl(t, e) {
    return Yz(t, e, []).join("");
  }
  function Yz(t, e, i) {
    if (t.nodeType == Node.CDATA_SECTION_NODE || t.nodeType == Node.TEXT_NODE)
      i.push(t.nodeValue);
    else {
      let r;
      for (r = t.firstChild; r; r = r.nextSibling)
        Yz(r, e, i);
    }
    return i;
  }
  function wl(t) {
    return "documentElement" in t;
  }
  function zae(t, e, i) {
    return t.getAttributeNS(e, i) || "";
  }
  function Cl(t) {
    return new DOMParser().parseFromString(t, "application/xml");
  }
  function Nz(t, e) {
    return (
      /**
       * @param {Node} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(i, r) {
        const n = t.call(this, i, r);
        if (n !== void 0) {
          const s = (
            /** @type {Array<*>} */
            r[r.length - 1]
          );
          xr(s, n);
        }
      }
    );
  }
  function st(t, e) {
    return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(i, r) {
        const n = t.call(e ?? this, i, r);
        n !== void 0 && /** @type {Array<*>} */
        r[r.length - 1].push(n);
      }
    );
  }
  function tt(t, e) {
    return (
      /**
       * @param {Node} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(i, r) {
        const n = t.call(e ?? this, i, r);
        n !== void 0 && (r[r.length - 1] = n);
      }
    );
  }
  function fn(t, e, i) {
    return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(r, n) {
        const s = t.call(this, r, n);
        if (s !== void 0) {
          const o = (
            /** @type {!Object} */
            n[n.length - 1]
          ), a = r.localName;
          let A;
          a in o ? A = o[a] : (A = [], o[a] = A), A.push(s);
        }
      }
    );
  }
  function Le(t, e, i) {
    return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(r, n) {
        const s = t.call(this, r, n);
        if (s !== void 0) {
          const o = (
            /** @type {!Object} */
            n[n.length - 1]
          ), a = e !== void 0 ? e : r.localName;
          o[a] = s;
        }
      }
    );
  }
  function ce(t, e) {
    return (
      /**
       * @param {Element} node Node.
       * @param {*} value Value to be written.
       * @param {Array<*>} objectStack Object stack.
       * @this {*}
       */
      function(i, r, n) {
        t.call(e ?? this, i, r, n), /** @type {NodeStackItem} */
        n[n.length - 1].node.appendChild(i);
      }
    );
  }
  function Ln(t, e) {
    return (
      /**
       * @param {*} value Value.
       * @param {Array<*>} objectStack Object stack.
       * @param {string} [newNodeName] Node name.
       * @return {Node} Node.
       */
      function(i, r, n) {
        const o = /** @type {NodeStackItem} */ r[r.length - 1].node;
        let a = t;
        a === void 0 && (a = n);
        const A = e !== void 0 ? e : o.namespaceURI;
        return Bt(
          A,
          /** @type {string} */
          a
        );
      }
    );
  }
  const Uz = Ln();
  function ni(t, e, i) {
    i = i !== void 0 ? i : {};
    let r, n;
    for (r = 0, n = t.length; r < n; ++r)
      i[t[r]] = e;
    return i;
  }
  function Ql(t, e, i, r) {
    let n;
    for (n = e.firstElementChild; n; n = n.nextElementSibling) {
      const s = t[n.namespaceURI];
      if (s !== void 0) {
        const o = s[n.localName];
        o !== void 0 && o.call(r, n, i);
      }
    }
  }
  function Ze(t, e, i, r, n) {
    return r.push(t), Ql(e, i, r, n), /** @type {T} */
    r.pop();
  }
  function Pae(t, e, i, r, n, s) {
    const o = (n !== void 0 ? n : i).length;
    let a, A;
    for (let l = 0; l < o; ++l)
      a = i[l], a !== void 0 && (A = e.call(
        s,
        a,
        r,
        n !== void 0 ? n[l] : void 0
      ), A !== void 0 && t[A.namespaceURI][A.localName].call(
        s,
        A,
        a,
        r
      ));
  }
  function Ni(t, e, i, r, n, s, o) {
    return n.push(t), Pae(e, i, r, n, s, o), /** @type {O|undefined} */
    n.pop();
  }
  let Z0;
  function Oae() {
    return Z0 === void 0 && typeof XMLSerializer < "u" && (Z0 = new XMLSerializer()), Z0;
  }
  let q0;
  function Lz() {
    return q0 === void 0 && typeof document < "u" && (q0 = document.implementation.createDocument("", "", null)), q0;
  }
  class zz {
    /**
     * Read the source document.
     *
     * @param {Document|Element|string} source The XML source.
     * @return {Object|null} An object representing the source.
     * @api
     */
    read(e) {
      if (!e)
        return null;
      if (typeof e == "string") {
        const i = Cl(e);
        return this.readFromDocument(i);
      }
      return wl(e) ? this.readFromDocument(
        /** @type {Document} */
        e
      ) : this.readFromNode(
        /** @type {Element} */
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @return {Object|null} Object
     */
    readFromDocument(e) {
      for (let i = e.firstChild; i; i = i.nextSibling)
        if (i.nodeType == Node.ELEMENT_NODE)
          return this.readFromNode(
            /** @type {Element} */
            i
          );
      return null;
    }
    /**
     * @abstract
     * @param {Element} node Node.
     * @return {Object|null} Object
     */
    readFromNode(e) {
      it();
    }
  }
  const Gae = "http://www.w3.org/1999/xlink";
  function Tx(t) {
    return t.getAttributeNS(Gae, "href");
  }
  function jae(t) {
    const e = jl(t, !1);
    return Hae(e);
  }
  function Hae(t) {
    const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(t);
    if (e)
      return parseFloat(e[1]);
  }
  function pn(t) {
    const e = jl(t, !1);
    return pu(e);
  }
  function pu(t) {
    const e = /^\s*(\d+)\s*$/.exec(t);
    if (e)
      return parseInt(e[1], 10);
  }
  function Lt(t) {
    return jl(t, !1).trim();
  }
  function tr(t, e) {
    t.appendChild(Lz().createTextNode(e));
  }
  const Qn = [null, "http://www.opengis.net/ows/1.1"], Jae = ni(Qn, {
    ServiceIdentification: Le(mAe),
    ServiceProvider: Le(yAe),
    OperationsMetadata: Le(fAe)
  });
  class Vae extends zz {
    constructor() {
      super();
    }
    /**
     * @param {Element} node Node.
     * @return {Object|null} Object
     * @override
     */
    readFromNode(e) {
      const i = Ze({}, Jae, e, []);
      return i || null;
    }
  }
  const Wae = ni(Qn, {
    DeliveryPoint: Le(Lt),
    City: Le(Lt),
    AdministrativeArea: Le(Lt),
    PostalCode: Le(Lt),
    Country: Le(Lt),
    ElectronicMailAddress: Le(Lt)
  }), Kae = ni(Qn, {
    Value: fn(BAe)
  }), Xae = ni(Qn, {
    AllowedValues: Le(AAe)
  }), Zae = ni(Qn, {
    Phone: Le(pAe),
    Address: Le(aAe)
  }), qae = ni(Qn, {
    HTTP: Le(hAe)
  }), $ae = ni(Qn, {
    Get: fn(dAe),
    Post: void 0
    // TODO
  }), eAe = ni(Qn, {
    DCP: Le(uAe)
  }), tAe = ni(Qn, {
    Operation: gAe
  }), iAe = ni(Qn, {
    Voice: Le(Lt),
    Facsimile: Le(Lt)
  }), rAe = ni(Qn, {
    Constraint: fn(lAe)
  }), nAe = ni(Qn, {
    IndividualName: Le(Lt),
    PositionName: Le(Lt),
    ContactInfo: Le(cAe)
  }), sAe = ni(Qn, {
    Abstract: Le(Lt),
    AccessConstraints: Le(Lt),
    Fees: Le(Lt),
    Title: Le(Lt),
    ServiceTypeVersion: Le(Lt),
    ServiceType: Le(Lt)
  }), oAe = ni(Qn, {
    ProviderName: Le(Lt),
    ProviderSite: Le(Tx),
    ServiceContact: Le(EAe)
  });
  function aAe(t, e) {
    return Ze({}, Wae, t, e);
  }
  function AAe(t, e) {
    return Ze({}, Kae, t, e);
  }
  function lAe(t, e) {
    const i = t.getAttribute("name");
    if (i)
      return Ze({ name: i }, Xae, t, e);
  }
  function cAe(t, e) {
    return Ze({}, Zae, t, e);
  }
  function uAe(t, e) {
    return Ze({}, qae, t, e);
  }
  function dAe(t, e) {
    const i = Tx(t);
    if (i)
      return Ze(
        { href: i },
        rAe,
        t,
        e
      );
  }
  function hAe(t, e) {
    return Ze({}, $ae, t, e);
  }
  function gAe(t, e) {
    const i = t.getAttribute("name"), r = Ze({}, eAe, t, e);
    if (!r)
      return;
    const n = (
      /** @type {Object} */
      e[e.length - 1]
    );
    n[i] = r;
  }
  function fAe(t, e) {
    return Ze({}, tAe, t, e);
  }
  function pAe(t, e) {
    return Ze({}, iAe, t, e);
  }
  function mAe(t, e) {
    return Ze({}, sAe, t, e);
  }
  function EAe(t, e) {
    return Ze({}, nAe, t, e);
  }
  function yAe(t, e) {
    return Ze({}, oAe, t, e);
  }
  function BAe(t, e) {
    return Lt(t);
  }
  const Ho = [null, "http://www.opengis.net/wmts/1.0"], Od = [null, "http://www.opengis.net/ows/1.1"], wAe = ni(Ho, {
    Contents: Le(TAe)
  });
  class CAe extends zz {
    constructor() {
      super(), this.owsParser_ = new Vae();
    }
    /**
     * @param {Element} node Node.
     * @return {Object|null} Object
     * @override
     */
    readFromNode(e) {
      let i = e.getAttribute("version");
      i && (i = i.trim());
      let r = this.owsParser_.readFromNode(e);
      return r ? (r.version = i, r = Ze(
        r,
        wAe,
        e,
        []
      ), r || null) : null;
    }
  }
  const bAe = ni(Ho, {
    Layer: fn(RAe),
    TileMatrixSet: fn(_Ae)
  }), MAe = ni(
    Ho,
    {
      Style: fn(kAe),
      Format: fn(Lt),
      TileMatrixSetLink: fn(YAe),
      Dimension: fn(NAe),
      ResourceURL: fn(UAe)
    },
    ni(Od, {
      Title: Le(Lt),
      Abstract: Le(Lt),
      WGS84BoundingBox: Le(Oz),
      BoundingBox: fn(LAe),
      Identifier: Le(Lt)
    })
  ), IAe = ni(
    Ho,
    {
      LegendURL: fn(zAe)
    },
    ni(Od, {
      Title: Le(Lt),
      Identifier: Le(Lt)
    })
  ), vAe = ni(Ho, {
    TileMatrixSet: Le(Lt),
    TileMatrixSetLimits: Le(OAe)
  }), xAe = ni(Ho, {
    TileMatrixLimits: st(GAe)
  }), QAe = ni(Ho, {
    TileMatrix: Le(Lt),
    MinTileRow: Le(pn),
    MaxTileRow: Le(pn),
    MinTileCol: Le(pn),
    MaxTileCol: Le(pn)
  }), FAe = ni(
    Ho,
    {
      Default: Le(Lt),
      Value: fn(Lt)
    },
    ni(Od, {
      Identifier: Le(Lt)
    })
  ), Pz = ni(Od, {
    LowerCorner: st(Wb),
    UpperCorner: st(Wb)
  }), SAe = ni(
    Ho,
    {
      WellKnownScaleSet: Le(Lt),
      TileMatrix: fn(PAe)
    },
    ni(Od, {
      SupportedCRS: Le(Lt),
      Identifier: Le(Lt),
      BoundingBox: Le(Oz)
    })
  ), DAe = ni(
    Ho,
    {
      TopLeftCorner: Le(Wb),
      ScaleDenominator: Le(jae),
      TileWidth: Le(pn),
      TileHeight: Le(pn),
      MatrixWidth: Le(pn),
      MatrixHeight: Le(pn)
    },
    ni(Od, {
      Identifier: Le(Lt)
    })
  );
  function TAe(t, e) {
    return Ze({}, bAe, t, e);
  }
  function RAe(t, e) {
    return Ze({}, MAe, t, e);
  }
  function _Ae(t, e) {
    return Ze({}, SAe, t, e);
  }
  function kAe(t, e) {
    const i = Ze({}, IAe, t, e);
    if (!i)
      return;
    const r = t.getAttribute("isDefault") === "true";
    return i.isDefault = r, i;
  }
  function YAe(t, e) {
    return Ze({}, vAe, t, e);
  }
  function NAe(t, e) {
    return Ze({}, FAe, t, e);
  }
  function UAe(t, e) {
    const i = t.getAttribute("format"), r = t.getAttribute("template"), n = t.getAttribute("resourceType"), s = {};
    return i && (s.format = i), r && (s.template = r), n && (s.resourceType = n), s;
  }
  function Oz(t, e) {
    const i = Ze(
      [],
      Pz,
      t,
      e
    );
    if (i.length == 2)
      return $i(i);
  }
  function LAe(t, e) {
    const i = t.getAttribute("crs"), r = Ze(
      [],
      Pz,
      t,
      e
    );
    if (r.length == 2)
      return { extent: $i(r), crs: i };
  }
  function zAe(t, e) {
    const i = {};
    return i.format = t.getAttribute("format"), i.href = Tx(t), i;
  }
  function Wb(t, e) {
    const i = Lt(t).split(/\s+/);
    if (!i || i.length != 2)
      return;
    const r = +i[0], n = +i[1];
    if (!(isNaN(r) || isNaN(n)))
      return [r, n];
  }
  function PAe(t, e) {
    return Ze({}, DAe, t, e);
  }
  function OAe(t, e) {
    return Ze([], xAe, t, e);
  }
  function GAe(t, e) {
    return Ze({}, QAe, t, e);
  }
  function jE(t, e) {
    console.error("content: Layer " + e + ": " + t);
  }
  function Gz(t, e, i, r) {
    for (let n = 0; n < i; ++n)
      t[n] = r / Math.pow(2, n), e[n] = n;
  }
  function jz(t) {
    return fetch(t).then((e) => {
      if (e && e.status === 200)
        return e.text();
      throw console.error(e), new Error(`Failing WMTS request to ${t}. Status: ${e == null ? void 0 : e.status}`);
    }).then((e) => new CAe().read(e));
  }
  function Hz(t, e) {
    const i = Xe(t.coordinateSystem), r = i.getExtent(), n = t.style, s = t.format, o = t.wrapX ? t.wrapX : !1, a = t.urls, A = r ? mt(r) / parseInt(t.tileSize, 10) : null, l = parseInt(t.resLength, 10), c = new Array(l), u = new Array(l), d = new Dx({
      projection: i,
      attributions: t.olAttribution,
      tileGrid: new bz({
        origin: t.origin,
        resolutions: c,
        matrixIds: u,
        tileSize: t.tileSize
      }),
      tilePixelRatio: Uv,
      urls: a,
      matrixSet: t.tileMatrixSet,
      matrixSizes: t.matrixSizes,
      layer: t.layers,
      format: s,
      style: n,
      version: t.version,
      transparent: t.transparent.toString(),
      wrapX: o,
      requestEncoding: t.requestEncoding,
      scales: t.scales
    });
    A ? Gz(c, u, l, A) : jE(t.name, `${i.getCode()} has been given as projection to wmts.js for layer with id ${t.id}, but only "EPSG:4326" and "EPSG:3857" are supported. Please use the "capabilitiesUrl" and "optionsFromCapabilities" configuration parameters on this layer.`), d.matrixSizes = t.matrixSizes, d.scales = t.scales, e.setSource(d), e.getSource().refresh();
  }
  function Jz(t, e) {
    const i = t.layers, r = t.capabilitiesUrl, n = t.tileMatrixSet, s = t.format, o = {
      layer: i,
      format: s
    };
    n && n.length > 0 ? o.matrixSet = n : o.projection = "EPSG:3857", jz(r).then((a) => {
      const A = Lae(a, o), l = a.Contents.TileMatrixSet.filter((d) => d.Identifier === A.matrixSet)[0], c = [], u = [];
      if (l.TileMatrix.forEach(({ MatrixHeight: d, MatrixWidth: h, ScaleDenominator: g }) => {
        c.push([h, d]), u.push(g);
      }), A !== null) {
        const d = new Dx(A);
        d.matrixSizes = c, d.scales = u, e.set("options", A), e.setSource(d), e.getSource().refresh();
      } else {
        const d = "Cannot get options from WMTS-Capabilities";
        throw jE(d, t.name || t.id), new Error(d);
      }
    }).catch((a) => {
      a !== "Fetch error" && jE(a, t.name || t.id);
    });
  }
  function jAe(t, e = {}) {
    const i = new SB(Object.assign({
      id: t.id,
      source: new Dx({}),
      name: t.name,
      minResolution: typeof t.minResolution == "string" ? parseFloat(t.minResolution) : t.minResolution,
      maxResolution: typeof t.maxResolution == "string" ? parseFloat(t.maxResolution) : t.maxResolution,
      supported: ["2D", "3D"],
      showSettings: !0,
      extent: null,
      typ: t.typ,
      legendURL: t.legendURL,
      infoFormat: t.infoFormat
    }, e));
    return t.optionsFromCapabilities === void 0 || t.capabilitiesUrl === void 0 ? Hz(t, i) : Jz(t, i), i;
  }
  const HAe = {
    createLayer: jAe,
    createLayerSourceByCapabilities: Jz,
    createLayerSourceByDefinitions: Hz,
    getWMTSCapabilities: jz,
    generateArrays: Gz,
    showErrorMessage: jE
  }, JAe = "data:image/svg+xml,%3csvg%20width='23'%20height='32'%20viewBox='0%200%2030%2043'%20xmlns='http://www.w3.org/2000/svg'%3e%3ctitle%3eDB6C494E-88E8-49F1-89CE-97CBEC3A5240%3c/title%3e%3cpath%20d='M14.584%201C7.101%201%201%207.101%201%2014.584c0%208.103%207.865%2020.448%2011.63%2025.93a2.36%202.36%200%200%200%203.908%200c3.766-5.482%2011.63-17.922%2011.63-25.93C28.168%207.054%2022.068%201%2014.584%201z'%20stroke='%23FFF'%20stroke-width='2'%20fill='%23005CA9'%20fill-rule='nonzero'/%3e%3c/svg%3e";
  let Vz = {};
  function VAe(t) {
    Vz = t;
  }
  const Wz = new Ol({
    crossOrigin: "anonymous",
    src: JAe,
    // center bottom of marker 📍 is intended to show the spot
    anchor: [0.5, 1]
  }), TB = new pr({
    width: 2,
    color: "#005CA9"
  }), Rx = new vr({
    color: "#005CA915"
  }), zT = new hi({ image: Wz }), PT = new hi({ stroke: TB }), OT = new hi({ stroke: TB, fill: Rx }), WAe = new hi({ stroke: TB, fill: Rx }), KAe = new hi({ stroke: TB, fill: Rx, image: Wz }), XAe = {
    Point: zT,
    LineString: PT,
    MultiLineString: PT,
    MultiPoint: zT,
    MultiPolygon: OT,
    Polygon: OT,
    GeometryCollection: KAe,
    Circle: WAe
  };
  function ZAe(t) {
    const e = t.getGeometry().getType();
    return Vz[e] || XAe[e];
  }
  const Mf = 34962, If = 34963, _x = 35044, HE = 35048, qAe = 5121, $Ae = 5123, ele = 5125, Kz = 5126, GT = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
  function tle(t, e) {
    e = Object.assign(
      {
        preserveDrawingBuffer: !0,
        antialias: !Z$
        // https://bugs.webkit.org/show_bug.cgi?id=237906
      },
      e
    );
    const i = GT.length;
    for (let r = 0; r < i; ++r)
      try {
        const n = t.getContext(GT[r], e);
        if (n)
          return (
            /** @type {!WebGLRenderingContext} */
            n
          );
      } catch {
      }
    return null;
  }
  const ile = {
    STATIC_DRAW: _x
  };
  class dd {
    /**
     * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
     * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
     * Default is `STATIC_DRAW`.
     */
    constructor(e, i) {
      this.array_ = null, this.type_ = e, Mt(
        e === Mf || e === If,
        "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"
      ), this.usage_ = i !== void 0 ? i : ile.STATIC_DRAW;
    }
    /**
     * Populates the buffer with an array of the given size (all values will be zeroes).
     * @param {number} size Array size
     * @return {WebGLArrayBuffer} This
     */
    ofSize(e) {
      return this.array_ = new (Ip(this.type_))(e), this;
    }
    /**
     * Populates the buffer with an array of the given size.
     * @param {Array<number>} array Numerical array
     * @return {WebGLArrayBuffer} This
     */
    fromArray(e) {
      return this.array_ = Ip(this.type_).from(e), this;
    }
    /**
     * Populates the buffer with a raw binary array buffer.
     * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
     * initialized for the same typed array class.
     * @return {WebGLArrayBuffer} This
     */
    fromArrayBuffer(e) {
      return this.array_ = new (Ip(this.type_))(e), this;
    }
    /**
     * @return {number} Buffer type.
     */
    getType() {
      return this.type_;
    }
    /**
     * Will return null if the buffer was not initialized
     * @return {Float32Array|Uint32Array|null} Array.
     */
    getArray() {
      return this.array_;
    }
    /**
     * @param {Float32Array|Uint32Array} array Array.
     */
    setArray(e) {
      const i = Ip(this.type_);
      if (!(e instanceof i))
        throw new Error(`Expected ${i}`);
      this.array_ = e;
    }
    /**
     * @return {number} Usage.
     */
    getUsage() {
      return this.usage_;
    }
    /**
     * Will return 0 if the buffer is not initialized
     * @return {number} Array size
     */
    getSize() {
      return this.array_ ? this.array_.length : 0;
    }
  }
  function Ip(t) {
    switch (t) {
      case Mf:
        return Float32Array;
      case If:
        return Uint32Array;
      default:
        return Float32Array;
    }
  }
  const vp = {
    LOST: "webglcontextlost",
    RESTORED: "webglcontextrestored"
  }, rle = `
  precision mediump float;

  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;

  uniform vec2 u_screenSize;

  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, nle = `
  precision mediump float;

  uniform sampler2D u_image;
  uniform float u_opacity;

  varying vec2 v_texCoord;

  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
  class jT {
    /**
     * @param {Options} options Options.
     */
    constructor(e) {
      this.gl_ = e.webGlContext;
      const i = this.gl_;
      this.scaleRatio_ = e.scaleRatio || 1, this.renderTargetTexture_ = i.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = i.createFramebuffer(), this.depthBuffer_ = i.createRenderbuffer();
      const r = i.createShader(i.VERTEX_SHADER);
      i.shaderSource(
        r,
        e.vertexShader || rle
      ), i.compileShader(r);
      const n = i.createShader(i.FRAGMENT_SHADER);
      i.shaderSource(
        n,
        e.fragmentShader || nle
      ), i.compileShader(n), this.renderTargetProgram_ = i.createProgram(), i.attachShader(this.renderTargetProgram_, r), i.attachShader(this.renderTargetProgram_, n), i.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = i.createBuffer();
      const s = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
      i.bindBuffer(i.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), i.bufferData(
        i.ARRAY_BUFFER,
        new Float32Array(s),
        i.STATIC_DRAW
      ), this.renderTargetAttribLocation_ = i.getAttribLocation(
        this.renderTargetProgram_,
        "a_position"
      ), this.renderTargetUniformLocation_ = i.getUniformLocation(
        this.renderTargetProgram_,
        "u_screenSize"
      ), this.renderTargetOpacityLocation_ = i.getUniformLocation(
        this.renderTargetProgram_,
        "u_opacity"
      ), this.renderTargetTextureLocation_ = i.getUniformLocation(
        this.renderTargetProgram_,
        "u_image"
      ), this.uniforms_ = [], e.uniforms && Object.keys(e.uniforms).forEach((o) => {
        this.uniforms_.push({
          value: e.uniforms[o],
          location: i.getUniformLocation(this.renderTargetProgram_, o)
        });
      });
    }
    getRenderTargetTexture() {
      return this.renderTargetTexture_;
    }
    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     */
    getGL() {
      return this.gl_;
    }
    /**
     * Initialize the render target texture of the post process, make sure it is at the
     * right size and bind it as a render target for the next draw calls.
     * The last step to be initialized will be the one where the primitives are rendered.
     * @param {import("../Map.js").FrameState} frameState current frame state
     */
    init(e) {
      const i = this.getGL(), r = [
        i.drawingBufferWidth * this.scaleRatio_,
        i.drawingBufferHeight * this.scaleRatio_
      ];
      if (i.bindFramebuffer(i.FRAMEBUFFER, this.getFrameBuffer()), i.bindRenderbuffer(i.RENDERBUFFER, this.getDepthBuffer()), i.viewport(0, 0, r[0], r[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== r[0] || this.renderTargetTextureSize_[1] !== r[1]) {
        this.renderTargetTextureSize_ = r;
        const n = 0, s = i.RGBA, o = 0, a = i.RGBA, A = i.UNSIGNED_BYTE, l = null;
        i.bindTexture(i.TEXTURE_2D, this.renderTargetTexture_), i.texImage2D(
          i.TEXTURE_2D,
          n,
          s,
          r[0],
          r[1],
          o,
          a,
          A,
          l
        ), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.framebufferTexture2D(
          i.FRAMEBUFFER,
          i.COLOR_ATTACHMENT0,
          i.TEXTURE_2D,
          this.renderTargetTexture_,
          0
        ), i.renderbufferStorage(
          i.RENDERBUFFER,
          i.DEPTH_COMPONENT16,
          r[0],
          r[1]
        ), i.framebufferRenderbuffer(
          i.FRAMEBUFFER,
          i.DEPTH_ATTACHMENT,
          i.RENDERBUFFER,
          this.depthBuffer_
        );
      }
    }
    /**
     * Render to the next postprocessing pass (or to the canvas if final pass).
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
     */
    apply(e, i, r, n) {
      const s = this.getGL(), o = e.size;
      if (s.bindFramebuffer(
        s.FRAMEBUFFER,
        i ? i.getFrameBuffer() : null
      ), s.activeTexture(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, this.renderTargetTexture_), !i) {
        const A = ve(s.canvas);
        if (!e.renderTargets[A]) {
          const l = s.getContextAttributes();
          l && l.preserveDrawingBuffer && (s.clearColor(0, 0, 0, 0), s.clearDepth(1), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT)), e.renderTargets[A] = !0;
        }
      }
      s.disable(s.DEPTH_TEST), s.enable(s.BLEND), s.blendFunc(s.ONE, s.ONE_MINUS_SRC_ALPHA), s.viewport(0, 0, s.drawingBufferWidth, s.drawingBufferHeight), s.bindBuffer(s.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), s.useProgram(this.renderTargetProgram_), s.enableVertexAttribArray(this.renderTargetAttribLocation_), s.vertexAttribPointer(
        this.renderTargetAttribLocation_,
        2,
        s.FLOAT,
        !1,
        0,
        0
      ), s.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), s.uniform1i(this.renderTargetTextureLocation_, 0);
      const a = e.layerStatesArray[e.layerIndex].opacity;
      s.uniform1f(this.renderTargetOpacityLocation_, a), this.applyUniforms(e), r && r(s, e), s.drawArrays(s.TRIANGLES, 0, 6), n && n(s, e);
    }
    /**
     * @return {WebGLFramebuffer} Frame buffer
     */
    getFrameBuffer() {
      return this.frameBuffer_;
    }
    /**
     * @return {WebGLRenderbuffer} Depth buffer
     */
    getDepthBuffer() {
      return this.depthBuffer_;
    }
    /**
     * Sets the custom uniforms based on what was given in the constructor.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @private
     */
    applyUniforms(e) {
      const i = this.getGL();
      let r, n = 1;
      this.uniforms_.forEach(function(s) {
        if (r = typeof s.value == "function" ? s.value(e) : s.value, r instanceof HTMLCanvasElement || r instanceof ImageData)
          s.texture || (s.texture = i.createTexture()), i.activeTexture(i[`TEXTURE${n}`]), i.bindTexture(i.TEXTURE_2D, s.texture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), r instanceof ImageData ? i.texImage2D(
            i.TEXTURE_2D,
            0,
            i.RGBA,
            i.RGBA,
            r.width,
            r.height,
            0,
            i.UNSIGNED_BYTE,
            new Uint8Array(r.data)
          ) : i.texImage2D(
            i.TEXTURE_2D,
            0,
            i.RGBA,
            i.RGBA,
            i.UNSIGNED_BYTE,
            r
          ), i.uniform1i(s.location, n++);
        else if (Array.isArray(r))
          switch (r.length) {
            case 2:
              i.uniform2f(s.location, r[0], r[1]);
              return;
            case 3:
              i.uniform3f(s.location, r[0], r[1], r[2]);
              return;
            case 4:
              i.uniform4f(
                s.location,
                r[0],
                r[1],
                r[2],
                r[3]
              );
              return;
            default:
              return;
          }
        else typeof r == "number" && i.uniform1f(s.location, r);
      });
    }
  }
  const Eo = {
    PROJECTION_MATRIX: "u_projectionMatrix",
    SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix",
    TIME: "u_time",
    ZOOM: "u_zoom",
    RESOLUTION: "u_resolution",
    ROTATION: "u_rotation",
    VIEWPORT_SIZE_PX: "u_viewportSizePx",
    PIXEL_RATIO: "u_pixelRatio",
    HIT_DETECTION: "u_hitDetection"
  }, Gi = {
    UNSIGNED_BYTE: qAe,
    UNSIGNED_SHORT: $Ae,
    UNSIGNED_INT: ele,
    FLOAT: Kz
  }, JE = {};
  function HT(t) {
    return "shared/" + t;
  }
  let JT = 0;
  function sle() {
    const t = "unique/" + JT;
    return JT += 1, t;
  }
  function ole(t) {
    let e = JE[t];
    if (!e) {
      const i = document.createElement("canvas");
      i.width = 1, i.height = 1, i.style.position = "absolute", i.style.left = "0", e = { users: 0, context: tle(i) }, JE[t] = e;
    }
    return e.users += 1, e.context;
  }
  function ale(t) {
    const e = JE[t];
    if (!e || (e.users -= 1, e.users > 0))
      return;
    const i = e.context, r = i.getExtension("WEBGL_lose_context");
    r && r.loseContext();
    const n = i.canvas;
    n.width = 1, n.height = 1, delete JE[t];
  }
  class Ale extends Td {
    /**
     * @param {Options} [options] Options.
     */
    constructor(e) {
      super(), e = e || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = e.canvasCacheKey ? HT(e.canvasCacheKey) : sle(), this.gl_ = ole(this.canvasCacheKey_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.needsToBeRecreated_ = !1;
      const i = this.gl_.canvas;
      i.addEventListener(
        vp.LOST,
        this.boundHandleWebGLContextLost_
      ), i.addEventListener(
        vp.RESTORED,
        this.boundHandleWebGLContextRestored_
      ), this.offsetRotateMatrix_ = ri(), this.offsetScaleMatrix_ = ri(), this.tmpMat4_ = VA(), this.uniformLocationsByProgram_ = {}, this.attribLocationsByProgram_ = {}, this.uniforms_ = [], e.uniforms && this.setUniforms(e.uniforms), this.postProcessPasses_ = e.postProcesses ? e.postProcesses.map(
        (r) => new jT({
          webGlContext: this.gl_,
          scaleRatio: r.scaleRatio,
          vertexShader: r.vertexShader,
          fragmentShader: r.fragmentShader,
          uniforms: r.uniforms
        })
      ) : [new jT({ webGlContext: this.gl_ })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
    }
    /**
     * @param {Object<string, UniformValue>} uniforms Uniform definitions.
     */
    setUniforms(e) {
      this.uniforms_ = [], this.addUniforms(e);
    }
    /**
     * @param {Object<string, UniformValue>} uniforms Uniform definitions.
     */
    addUniforms(e) {
      for (const i in e)
        this.uniforms_.push({
          name: i,
          value: e[i]
        });
    }
    /**
     * @param {string} canvasCacheKey The canvas cache key.
     * @return {boolean} The provided key matches the one this helper was constructed with.
     */
    canvasCacheKeyMatches(e) {
      return this.canvasCacheKey_ === HT(e);
    }
    /**
     * Get a WebGL extension.  If the extension is not supported, null is returned.
     * Extensions are cached after they are enabled for the first time.
     * @param {string} name The extension name.
     * @return {Object|null} The extension or null if not supported.
     */
    getExtension(e) {
      if (e in this.extensionCache_)
        return this.extensionCache_[e];
      const i = this.gl_.getExtension(e);
      return this.extensionCache_[e] = i, i;
    }
    /**
     * Just bind the buffer if it's in the cache. Otherwise create
     * the WebGL buffer, bind it, populate it, and add an entry to
     * the cache.
     * @param {import("./Buffer").default} buffer Buffer.
     */
    bindBuffer(e) {
      const i = this.gl_, r = ve(e);
      let n = this.bufferCache_[r];
      if (!n) {
        const s = i.createBuffer();
        n = {
          buffer: e,
          webGlBuffer: s
        }, this.bufferCache_[r] = n;
      }
      i.bindBuffer(e.getType(), n.webGlBuffer);
    }
    /**
     * Update the data contained in the buffer array; this is required for the
     * new data to be rendered
     * @param {import("./Buffer").default} buffer Buffer.
     */
    flushBufferData(e) {
      const i = this.gl_;
      this.bindBuffer(e), i.bufferData(e.getType(), e.getArray(), e.getUsage());
    }
    /**
     * @param {import("./Buffer.js").default} buf Buffer.
     */
    deleteBuffer(e) {
      const i = ve(e);
      delete this.bufferCache_[i];
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      const e = this.gl_.canvas;
      e.removeEventListener(
        vp.LOST,
        this.boundHandleWebGLContextLost_
      ), e.removeEventListener(
        vp.RESTORED,
        this.boundHandleWebGLContextRestored_
      ), ale(this.canvasCacheKey_), delete this.gl_;
    }
    /**
     * Clear the buffer & set the viewport to draw.
     * Post process passes will be initialized here, the first one being bound as a render target for
     * subsequent draw calls.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
     * @param {boolean} [enableDepth] If true, enables depth testing.
     */
    prepareDraw(e, i, r) {
      const n = this.gl_, s = this.getCanvas(), o = e.size, a = e.pixelRatio;
      (s.width !== o[0] * a || s.height !== o[1] * a) && (s.width = o[0] * a, s.height = o[1] * a, s.style.width = o[0] + "px", s.style.height = o[1] + "px");
      for (let A = this.postProcessPasses_.length - 1; A >= 0; A--)
        this.postProcessPasses_[A].init(e);
      n.bindTexture(n.TEXTURE_2D, null), n.clearColor(0, 0, 0, 0), n.depthRange(0, 1), n.clearDepth(1), n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT), n.enable(n.BLEND), n.blendFunc(n.ONE, i ? n.ZERO : n.ONE_MINUS_SRC_ALPHA), r ? (n.enable(n.DEPTH_TEST), n.depthFunc(n.LEQUAL)) : n.disable(n.DEPTH_TEST);
    }
    /**
     * @param {WebGLFramebuffer|null} frameBuffer The frame buffer.
     * @param {WebGLTexture} [texture] The texture.
     */
    bindFrameBuffer(e, i) {
      const r = this.getGL();
      r.bindFramebuffer(r.FRAMEBUFFER, e), i && r.framebufferTexture2D(
        r.FRAMEBUFFER,
        r.COLOR_ATTACHMENT0,
        r.TEXTURE_2D,
        i,
        0
      );
    }
    /**
     * Bind the frame buffer from the initial render.
     */
    bindInitialFrameBuffer() {
      const e = this.getGL(), i = this.postProcessPasses_[0].getFrameBuffer();
      e.bindFramebuffer(e.FRAMEBUFFER, i);
      const r = this.postProcessPasses_[0].getRenderTargetTexture();
      e.framebufferTexture2D(
        e.FRAMEBUFFER,
        e.COLOR_ATTACHMENT0,
        e.TEXTURE_2D,
        r,
        0
      );
    }
    /**
     * Prepare a program to use a texture.
     * @param {WebGLTexture} texture The texture.
     * @param {number} slot The texture slot.
     * @param {string} uniformName The corresponding uniform name.
     */
    bindTexture(e, i, r) {
      const n = this.gl_;
      n.activeTexture(n.TEXTURE0 + i), n.bindTexture(n.TEXTURE_2D, e), n.uniform1i(this.getUniformLocation(r), i);
    }
    /**
     * Set up an attribute array buffer for use in the vertex shader.
     * @param {import("./Buffer").default} buffer The buffer.
     * @param {string} attributeName The attribute name.
     * @param {number} size The number of components per attribute vertex.
     */
    bindAttribute(e, i, r) {
      const n = this.getGL();
      this.bindBuffer(e);
      const s = this.getAttributeLocation(i);
      n.enableVertexAttribArray(s), n.vertexAttribPointer(s, r, n.FLOAT, !1, 0, 0);
    }
    /**
     * Clear the render target & bind it for future draw operations.
     * This is similar to `prepareDraw`, only post processes will not be applied.
     * Note: the whole viewport will be drawn to the render target, regardless of its size.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
     * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
     * @param {boolean} [enableDepth] If true, enables depth testing.
     */
    prepareDrawToRenderTarget(e, i, r, n) {
      const s = this.gl_, o = i.getSize();
      s.bindFramebuffer(s.FRAMEBUFFER, i.getFramebuffer()), s.bindRenderbuffer(s.RENDERBUFFER, i.getDepthbuffer()), s.viewport(0, 0, o[0], o[1]), s.bindTexture(s.TEXTURE_2D, i.getTexture()), s.clearColor(0, 0, 0, 0), s.depthRange(0, 1), s.clearDepth(1), s.clear(s.COLOR_BUFFER_BIT | s.DEPTH_BUFFER_BIT), s.enable(s.BLEND), s.blendFunc(s.ONE, r ? s.ZERO : s.ONE_MINUS_SRC_ALPHA), n ? (s.enable(s.DEPTH_TEST), s.depthFunc(s.LEQUAL)) : s.disable(s.DEPTH_TEST);
    }
    /**
     * Execute a draw call based on the currently bound program, texture, buffers, attributes.
     * @param {number} start Start index.
     * @param {number} end End index.
     */
    drawElements(e, i) {
      const r = this.gl_;
      this.getExtension("OES_element_index_uint");
      const n = r.UNSIGNED_INT, s = 4, o = i - e, a = e * s;
      r.drawElements(r.TRIANGLES, o, n, a);
    }
    /**
     * Apply the successive post process passes which will eventually render to the actual canvas.
     * @param {import("../Map.js").FrameState} frameState current frame state
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
     * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
     */
    finalizeDraw(e, i, r) {
      for (let n = 0, s = this.postProcessPasses_.length; n < s; n++)
        n === s - 1 ? this.postProcessPasses_[n].apply(
          e,
          null,
          i,
          r
        ) : this.postProcessPasses_[n].apply(
          e,
          this.postProcessPasses_[n + 1]
        );
    }
    /**
     * @return {HTMLCanvasElement} Canvas.
     */
    getCanvas() {
      return (
        /** @type {HTMLCanvasElement} */
        this.gl_.canvas
      );
    }
    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     */
    getGL() {
      return this.gl_;
    }
    /**
     * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    applyFrameState(e) {
      const i = e.size, r = e.viewState.rotation, n = e.pixelRatio;
      this.setUniformFloatValue(
        Eo.TIME,
        (Date.now() - this.startTime_) * 1e-3
      ), this.setUniformFloatValue(Eo.ZOOM, e.viewState.zoom), this.setUniformFloatValue(
        Eo.RESOLUTION,
        e.viewState.resolution
      ), this.setUniformFloatValue(Eo.PIXEL_RATIO, n), this.setUniformFloatVec2(Eo.VIEWPORT_SIZE_PX, [
        i[0],
        i[1]
      ]), this.setUniformFloatValue(Eo.ROTATION, r);
    }
    /**
     * Sets the `u_hitDetection` uniform.
     * @param {boolean} enabled Whether to enable the hit detection code path
     */
    applyHitDetectionUniform(e) {
      const i = this.getUniformLocation(Eo.HIT_DETECTION);
      this.getGL().uniform1i(i, e ? 1 : 0), e && this.setUniformFloatValue(Eo.PIXEL_RATIO, 0.5);
    }
    /**
     * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    applyUniforms(e) {
      const i = this.gl_;
      let r, n = 0;
      this.uniforms_.forEach((s) => {
        if (r = typeof s.value == "function" ? s.value(e) : s.value, r instanceof HTMLCanvasElement || r instanceof HTMLImageElement || r instanceof ImageData || r instanceof WebGLTexture) {
          r instanceof WebGLTexture && !s.texture ? (s.prevValue = void 0, s.texture = r) : s.texture || (s.prevValue = void 0, s.texture = i.createTexture()), this.bindTexture(s.texture, n, s.name), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE);
          const o = !(r instanceof HTMLImageElement) || /** @type {HTMLImageElement} */
          r.complete;
          !(r instanceof WebGLTexture) && o && s.prevValue !== r && (s.prevValue = r, i.texImage2D(
            i.TEXTURE_2D,
            0,
            i.RGBA,
            i.RGBA,
            i.UNSIGNED_BYTE,
            r
          )), n++;
        } else if (Array.isArray(r) && r.length === 6)
          this.setUniformMatrixValue(
            s.name,
            Bl(this.tmpMat4_, r)
          );
        else if (Array.isArray(r) && r.length <= 4)
          switch (r.length) {
            case 2:
              i.uniform2f(
                this.getUniformLocation(s.name),
                r[0],
                r[1]
              );
              return;
            case 3:
              i.uniform3f(
                this.getUniformLocation(s.name),
                r[0],
                r[1],
                r[2]
              );
              return;
            case 4:
              i.uniform4f(
                this.getUniformLocation(s.name),
                r[0],
                r[1],
                r[2],
                r[3]
              );
              return;
            default:
              return;
          }
        else typeof r == "number" && i.uniform1f(this.getUniformLocation(s.name), r);
      });
    }
    /**
     * Set up a program for use. The program will be set as the current one. Then, the uniforms used
     * in the program will be set based on the current frame state and the helper configuration.
     * @param {WebGLProgram} program Program.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     */
    useProgram(e, i) {
      this.gl_.useProgram(e), this.currentProgram_ = e, i && (this.applyFrameState(i), this.applyUniforms(i));
    }
    /**
     * Will attempt to compile a vertex or fragment shader based on source
     * On error, the shader will be returned but
     * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
     * Use `gl.getShaderInfoLog(shader)` to have details
     * @param {string} source Shader source
     * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
     * @return {WebGLShader} Shader object
     */
    compileShader(e, i) {
      const r = this.gl_, n = r.createShader(i);
      return r.shaderSource(n, e), r.compileShader(n), n;
    }
    /**
     * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
     * @param {string} fragmentShaderSource Fragment shader source.
     * @param {string} vertexShaderSource Vertex shader source.
     * @return {WebGLProgram} Program
     */
    getProgram(e, i) {
      const r = this.gl_, n = this.compileShader(
        e,
        r.FRAGMENT_SHADER
      ), s = this.compileShader(
        i,
        r.VERTEX_SHADER
      ), o = r.createProgram();
      if (r.attachShader(o, n), r.attachShader(o, s), r.linkProgram(o), !r.getShaderParameter(n, r.COMPILE_STATUS)) {
        const a = `Fragment shader compilation failed: ${r.getShaderInfoLog(
          n
        )}`;
        throw new Error(a);
      }
      if (r.deleteShader(n), !r.getShaderParameter(s, r.COMPILE_STATUS)) {
        const a = `Vertex shader compilation failed: ${r.getShaderInfoLog(
          s
        )}`;
        throw new Error(a);
      }
      if (r.deleteShader(s), !r.getProgramParameter(o, r.LINK_STATUS)) {
        const a = `GL program linking failed: ${r.getProgramInfoLog(
          o
        )}`;
        throw new Error(a);
      }
      return o;
    }
    /**
     * Will get the location from the shader or the cache
     * @param {string} name Uniform name
     * @return {WebGLUniformLocation} uniformLocation
     */
    getUniformLocation(e) {
      const i = ve(this.currentProgram_);
      return this.uniformLocationsByProgram_[i] === void 0 && (this.uniformLocationsByProgram_[i] = {}), this.uniformLocationsByProgram_[i][e] === void 0 && (this.uniformLocationsByProgram_[i][e] = this.gl_.getUniformLocation(this.currentProgram_, e)), this.uniformLocationsByProgram_[i][e];
    }
    /**
     * Will get the location from the shader or the cache
     * @param {string} name Attribute name
     * @return {number} attribLocation
     */
    getAttributeLocation(e) {
      const i = ve(this.currentProgram_);
      return this.attribLocationsByProgram_[i] === void 0 && (this.attribLocationsByProgram_[i] = {}), this.attribLocationsByProgram_[i][e] === void 0 && (this.attribLocationsByProgram_[i][e] = this.gl_.getAttribLocation(this.currentProgram_, e)), this.attribLocationsByProgram_[i][e];
    }
    /**
     * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
     * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {import("../transform").Transform} transform Transform to update.
     * @return {import("../transform").Transform} The updated transform object.
     */
    makeProjectionTransform(e, i) {
      const r = e.size, n = e.viewState.rotation, s = e.viewState.resolution, o = e.viewState.center;
      return gs(
        i,
        0,
        0,
        2 / (s * r[0]),
        2 / (s * r[1]),
        -n,
        -o[0],
        -o[1]
      ), i;
    }
    /**
     * Give a value for a standard float uniform
     * @param {string} uniform Uniform name
     * @param {number} value Value
     */
    setUniformFloatValue(e, i) {
      this.gl_.uniform1f(this.getUniformLocation(e), i);
    }
    /**
     * Give a value for a vec2 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Array of length 4.
     */
    setUniformFloatVec2(e, i) {
      this.gl_.uniform2fv(this.getUniformLocation(e), i);
    }
    /**
     * Give a value for a vec4 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Array of length 4.
     */
    setUniformFloatVec4(e, i) {
      this.gl_.uniform4fv(this.getUniformLocation(e), i);
    }
    /**
     * Give a value for a standard matrix4 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Matrix value
     */
    setUniformMatrixValue(e, i) {
      this.gl_.uniformMatrix4fv(this.getUniformLocation(e), !1, i);
    }
    /**
     * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
     * internally.
     * @param {string} attribName Attribute name
     * @param {number} size Number of components per attributes
     * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
     * @param {number} stride Stride in bytes (0 means attribs are packed)
     * @param {number} offset Offset in bytes
     * @private
     */
    enableAttributeArray_(e, i, r, n, s) {
      const o = this.getAttributeLocation(e);
      o < 0 || (this.gl_.enableVertexAttribArray(o), this.gl_.vertexAttribPointer(o, i, r, !1, n, s));
    }
    /**
     * Will enable the following attributes to be read from the currently bound buffer,
     * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
     * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
     * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
     */
    enableAttributes(e) {
      const i = lle(e);
      let r = 0;
      for (let n = 0; n < e.length; n++) {
        const s = e[n];
        this.enableAttributeArray_(
          s.name,
          s.size,
          s.type || Kz,
          i,
          r
        ), r += s.size * Xz(s.type);
      }
    }
    /**
     * WebGL context was lost
     * @param {WebGLContextEvent} event The context loss event.
     * @private
     */
    handleWebGLContextLost(e) {
      nc(this.bufferCache_), this.currentProgram_ = null, e.preventDefault();
    }
    /**
     * WebGL context was restored
     * @private
     */
    handleWebGLContextRestored() {
      this.needsToBeRecreated_ = !0;
    }
    /**
     * Returns whether this helper needs to be recreated, as the context was lost and then restored.
     * @return {boolean} Whether this helper needs to be recreated.
     */
    needsToBeRecreated() {
      return this.needsToBeRecreated_;
    }
    /**
     * Will create or reuse a given webgl texture and apply the given size. If no image data
     * specified, the texture will be empty, otherwise image data will be used and the `size`
     * parameter will be ignored.  If a Uint8Array is provided for data, a size must also be provided.
     * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
     * @param {Array<number>} size Expected size of the texture
     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|Uint8Array|null} data Image data/object to bind to the texture
     * @param {WebGLTexture} [texture] Existing texture to reuse
     * @param {boolean} [nearest] Use gl.NEAREST for min/mag filter.
     * @return {WebGLTexture} The generated texture
     */
    createTexture(e, i, r, n) {
      const s = this.gl_;
      r = r || s.createTexture();
      const o = n ? s.NEAREST : s.LINEAR;
      s.bindTexture(s.TEXTURE_2D, r), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, o), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, o), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE);
      const a = 0, A = s.RGBA, l = 0, c = s.RGBA, u = s.UNSIGNED_BYTE;
      return i instanceof Uint8Array ? s.texImage2D(
        s.TEXTURE_2D,
        a,
        A,
        e[0],
        e[1],
        l,
        c,
        u,
        i
      ) : i ? s.texImage2D(s.TEXTURE_2D, a, A, c, u, i) : s.texImage2D(
        s.TEXTURE_2D,
        a,
        A,
        e[0],
        e[1],
        l,
        c,
        u,
        null
      ), r;
    }
  }
  function lle(t) {
    let e = 0;
    for (let i = 0; i < t.length; i++) {
      const r = t[i];
      e += r.size * Xz(r.type);
    }
    return e;
  }
  function Xz(t) {
    switch (t) {
      case Gi.UNSIGNED_BYTE:
        return Uint8Array.BYTES_PER_ELEMENT;
      case Gi.UNSIGNED_SHORT:
        return Uint16Array.BYTES_PER_ELEMENT;
      case Gi.UNSIGNED_INT:
        return Uint32Array.BYTES_PER_ELEMENT;
      case Gi.FLOAT:
      default:
        return Float32Array.BYTES_PER_ELEMENT;
    }
  }
  class vf extends KU {
    /**
     * @param {LayerType} layer Layer.
     * @param {Options} [options] Options.
     */
    constructor(e, i) {
      super(e), i = i || {}, this.inversePixelTransform_ = ri(), this.postProcesses_ = i.postProcesses, this.uniforms_ = i.uniforms, this.helper, this.onMapChanged_ = () => {
        this.clearCache(), this.removeHelper();
      }, e.addChangeListener(qt.MAP, this.onMapChanged_), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
    }
    /**
     * @param {WebGLRenderingContext} context The WebGL rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    dispatchPreComposeEvent(e, i) {
      const r = this.getLayer();
      if (r.hasListener(dr.PRECOMPOSE)) {
        const n = new Lh(
          dr.PRECOMPOSE,
          void 0,
          i,
          e
        );
        r.dispatchEvent(n);
      }
    }
    /**
     * @param {WebGLRenderingContext} context The WebGL rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    dispatchPostComposeEvent(e, i) {
      const r = this.getLayer();
      if (r.hasListener(dr.POSTCOMPOSE)) {
        const n = new Lh(
          dr.POSTCOMPOSE,
          void 0,
          i,
          e
        );
        r.dispatchEvent(n);
      }
    }
    /**
     * Reset options (only handles uniforms).
     * @param {Options} options Options.
     */
    reset(e) {
      this.uniforms_ = e.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
    }
    /**
     * @protected
     */
    removeHelper() {
      this.helper && (this.helper.dispose(), delete this.helper);
    }
    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(e) {
      if (this.getLayer().getRenderSource()) {
        let i = !0, r = -1, n;
        for (let o = 0, a = e.layerStatesArray.length; o < a; o++) {
          const A = e.layerStatesArray[o].layer, l = A.getRenderer();
          if (!(l instanceof vf)) {
            i = !0;
            continue;
          }
          const c = A.getClassName();
          if ((i || c !== n) && (r += 1, i = !1), n = c, l === this)
            break;
        }
        const s = "map/" + e.mapId + "/group/" + r;
        (!this.helper || !this.helper.canvasCacheKeyMatches(s) || this.helper.needsToBeRecreated()) && (this.removeHelper(), this.helper = new Ale({
          postProcesses: this.postProcesses_,
          uniforms: this.uniforms_,
          canvasCacheKey: s
        }), n && (this.helper.getCanvas().className = n), this.afterHelperCreated());
      }
      return this.prepareFrameInternal(e);
    }
    /**
     * @protected
     */
    afterHelperCreated() {
    }
    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @protected
     */
    prepareFrameInternal(e) {
      return !0;
    }
    /**
     * @protected
     */
    clearCache() {
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      var e;
      this.clearCache(), this.removeHelper(), (e = this.getLayer()) == null || e.removeChangeListener(
        qt.MAP,
        this.onMapChanged_
      ), super.disposeInternal();
    }
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
    dispatchRenderEvent_(e, i, r) {
      const n = this.getLayer();
      if (n.hasListener(e)) {
        gs(
          this.inversePixelTransform_,
          0,
          0,
          r.pixelRatio,
          -r.pixelRatio,
          0,
          0,
          -r.size[1]
        );
        const s = new Lh(
          e,
          this.inversePixelTransform_,
          r,
          i
        );
        n.dispatchEvent(s);
      }
    }
    /**
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    preRender(e, i) {
      this.dispatchRenderEvent_(dr.PRERENDER, e, i);
    }
    /**
     * @param {WebGLRenderingContext} context The rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    postRender(e, i) {
      this.dispatchRenderEvent_(dr.POSTRENDER, e, i);
    }
  }
  const lo = new Uint8Array(4);
  class kx {
    /**
     * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
     * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
     */
    constructor(e, i) {
      this.helper_ = e;
      const r = e.getGL();
      this.texture_ = r.createTexture(), this.framebuffer_ = r.createFramebuffer(), this.depthbuffer_ = r.createRenderbuffer(), this.size_ = i || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_();
    }
    /**
     * Changes the size of the render target texture. Note: will do nothing if the size
     * is already the same.
     * @param {Array<number>} size Expected size of the render target texture
     */
    setSize(e) {
      jo(e, this.size_) || (this.size_[0] = e[0], this.size_[1] = e[1], this.updateSize_());
    }
    /**
     * Returns the size of the render target texture
     * @return {Array<number>} Size of the render target texture
     */
    getSize() {
      return this.size_;
    }
    /**
     * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
     * render target into memory, which is an expensive operation.
     * This content will be kept in cache but should be cleared after each new render.
     */
    clearCachedData() {
      this.dataCacheDirty_ = !0;
    }
    /**
     * Returns the full content of the frame buffer as a series of r, g, b, a components
     * in the 0-255 range (unsigned byte).
     * @return {Uint8Array} Integer array of color values
     */
    readAll() {
      if (this.dataCacheDirty_) {
        const e = this.size_, i = this.helper_.getGL();
        i.bindFramebuffer(i.FRAMEBUFFER, this.framebuffer_), i.readPixels(
          0,
          0,
          e[0],
          e[1],
          i.RGBA,
          i.UNSIGNED_BYTE,
          this.data_
        ), this.dataCacheDirty_ = !1;
      }
      return this.data_;
    }
    /**
     * Reads one pixel of the frame buffer as an array of r, g, b, a components
     * in the 0-255 range (unsigned byte).
     * If x and/or y are outside of existing data, an array filled with 0 is returned.
     * @param {number} x Pixel coordinate
     * @param {number} y Pixel coordinate
     * @return {Uint8Array} Integer array with one color value (4 components)
     */
    readPixel(e, i) {
      if (e < 0 || i < 0 || e > this.size_[0] || i >= this.size_[1])
        return lo[0] = 0, lo[1] = 0, lo[2] = 0, lo[3] = 0, lo;
      this.readAll();
      const r = Math.floor(e) + (this.size_[1] - Math.floor(i) - 1) * this.size_[0];
      return lo[0] = this.data_[r * 4], lo[1] = this.data_[r * 4 + 1], lo[2] = this.data_[r * 4 + 2], lo[3] = this.data_[r * 4 + 3], lo;
    }
    /**
     * @return {WebGLTexture} Texture to render to
     */
    getTexture() {
      return this.texture_;
    }
    /**
     * @return {WebGLFramebuffer} Frame buffer of the render target
     */
    getFramebuffer() {
      return this.framebuffer_;
    }
    /**
     * @return {WebGLRenderbuffer} Depth buffer of the render target
     */
    getDepthbuffer() {
      return this.depthbuffer_;
    }
    /**
     * @private
     */
    updateSize_() {
      const e = this.size_, i = this.helper_.getGL();
      this.texture_ = this.helper_.createTexture(e, null, this.texture_), i.bindFramebuffer(i.FRAMEBUFFER, this.framebuffer_), i.viewport(0, 0, e[0], e[1]), i.framebufferTexture2D(
        i.FRAMEBUFFER,
        i.COLOR_ATTACHMENT0,
        i.TEXTURE_2D,
        this.texture_,
        0
      ), i.bindRenderbuffer(i.RENDERBUFFER, this.depthbuffer_), i.renderbufferStorage(
        i.RENDERBUFFER,
        i.DEPTH_COMPONENT16,
        e[0],
        e[1]
      ), i.framebufferRenderbuffer(
        i.FRAMEBUFFER,
        i.DEPTH_ATTACHMENT,
        i.RENDERBUFFER,
        this.depthbuffer_
      ), this.data_ = new Uint8Array(e[0] * e[1] * 4);
    }
  }
  const Oh = {
    GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS",
    GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS",
    GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS"
  }, VT = 0.985;
  function Zz(t, e) {
    e = e || [];
    const i = 256, r = i - 1;
    return e[0] = Math.floor(t / i / i / i) / r, e[1] = Math.floor(t / i / i) % i / r, e[2] = Math.floor(t / i) % i / r, e[3] = t % i / r, e;
  }
  function qz(t) {
    let e = 0;
    const i = 256, r = i - 1;
    return e += Math.round(t[0] * i * i * i * r), e += Math.round(t[1] * i * i * r), e += Math.round(t[2] * i * r), e += Math.round(t[3] * r), e;
  }
  function $z() {
    const t = 'const t="GENERATE_POLYGON_BUFFERS",e="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS";function r(t,e){const n=e[0],r=e[1];return e[0]=t[0]*n+t[2]*r+t[4],e[1]=t[1]*n+t[3]*r+t[5],e}function x(t,e){const n=(r=e)[0]*r[3]-r[1]*r[2];var r;!function(t,e){if(!t)throw new Error(e)}(0!==n,"Transformation matrix cannot be inverted");const x=e[0],o=e[1],u=e[2],i=e[3],f=e[4],s=e[5];return t[0]=i/n,t[1]=-o/n,t[2]=-u/n,t[3]=x/n,t[4]=(u*s-i*f)/n,t[5]=-(x*s-o*f)/n,t}function o(t,e,n=2){const r=e&&e.length,x=r?e[0]*n:t.length;let o=u(t,0,x,n,!0);const i=[];if(!o||o.next===o.prev)return i;let s,l,c;if(r&&(o=function(t,e,n,r){const x=[];for(let n=0,o=e.length;n<o;n++){const i=u(t,e[n]*r,n<o-1?e[n+1]*r:t.length,r,!1);i===i.next&&(i.steiner=!0),x.push(g(i))}x.sort(y);for(let t=0;t<x.length;t++)n=h(x[t],n);return n}(t,e,o,n)),t.length>80*n){s=1/0,l=1/0;let e=-1/0,r=-1/0;for(let o=n;o<x;o+=n){const n=t[o],x=t[o+1];n<s&&(s=n),x<l&&(l=x),n>e&&(e=n),x>r&&(r=x)}c=Math.max(e-s,r-l),c=0!==c?32767/c:0}return f(o,i,n,s,l,c,0),i}function u(t,e,n,r,x){let o;if(x===function(t,e,n,r){let x=0;for(let o=e,u=n-r;o<n;o+=r)x+=(t[u]-t[o])*(t[o+1]+t[u+1]),u=o;return x}(t,e,n,r)>0)for(let x=e;x<n;x+=r)o=z(x/r|0,t[x],t[x+1],o);else for(let x=n-r;x>=e;x-=r)o=z(x/r|0,t[x],t[x+1],o);return o&&M(o,o.next)&&(F(o),o=o.next),o}function i(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!M(r,r.next)&&0!==d(r.prev,r,r.next))r=r.next;else{if(F(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function f(t,e,n,r,x,o,u){if(!t)return;!u&&o&&function(t,e,n,r){let x=t;do{0===x.z&&(x.z=v(x.x,x.y,e,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==t);x.prevZ.nextZ=null,x.prevZ=null,function(t){let e,n=1;do{let r,x=t;t=null;let o=null;for(e=0;x;){e++;let u=x,i=0;for(let t=0;t<n&&(i++,u=u.nextZ,u);t++);let f=n;for(;i>0||f>0&&u;)0!==i&&(0===f||!u||x.z<=u.z)?(r=x,x=x.nextZ,i--):(r=u,u=u.nextZ,f--),o?o.nextZ=r:t=r,r.prevZ=o,o=r;x=u}o.nextZ=null,n*=2}while(e>1)}(x)}(t,r,x,o);let y=t;for(;t.prev!==t.next;){const h=t.prev,p=t.next;if(o?l(t,r,x,o):s(t))e.push(h.i,t.i,p.i),F(t),t=p.next,y=p.next;else if((t=p)===y){u?1===u?f(t=c(i(t),e),e,n,r,x,o,2):2===u&&a(t,e,n,r,x,o):f(i(t),e,n,r,x,o,1);break}}}function s(t){const e=t.prev,n=t,r=t.next;if(d(e,n,r)>=0)return!1;const x=e.x,o=n.x,u=r.x,i=e.y,f=n.y,s=r.y,l=x<o?x<u?x:u:o<u?o:u,c=i<f?i<s?i:s:f<s?f:s,a=x>o?x>u?x:u:o>u?o:u,y=i>f?i>s?i:s:f>s?f:s;let h=r.next;for(;h!==e;){if(h.x>=l&&h.x<=a&&h.y>=c&&h.y<=y&&b(x,i,o,f,u,s,h.x,h.y)&&d(h.prev,h,h.next)>=0)return!1;h=h.next}return!0}function l(t,e,n,r){const x=t.prev,o=t,u=t.next;if(d(x,o,u)>=0)return!1;const i=x.x,f=o.x,s=u.x,l=x.y,c=o.y,a=u.y,y=i<f?i<s?i:s:f<s?f:s,h=l<c?l<a?l:a:c<a?c:a,p=i>f?i>s?i:s:f>s?f:s,g=l>c?l>a?l:a:c>a?c:a,Z=v(y,h,e,n,r),M=v(p,g,e,n,r);let w=t.prevZ,m=t.nextZ;for(;w&&w.z>=Z&&m&&m.z<=M;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;if(w=w.prevZ,m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;w&&w.z>=Z;){if(w.x>=y&&w.x<=p&&w.y>=h&&w.y<=g&&w!==x&&w!==u&&b(i,l,f,c,s,a,w.x,w.y)&&d(w.prev,w,w.next)>=0)return!1;w=w.prevZ}for(;m&&m.z<=M;){if(m.x>=y&&m.x<=p&&m.y>=h&&m.y<=g&&m!==x&&m!==u&&b(i,l,f,c,s,a,m.x,m.y)&&d(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function c(t,e){let n=t;do{const r=n.prev,x=n.next.next;!M(r,x)&&w(r,n,n.next,x)&&E(r,x)&&E(x,r)&&(e.push(r.i,n.i,x.i),F(n),F(n.next),n=t=x),n=n.next}while(n!==t);return i(n)}function a(t,e,n,r,x,o){let u=t;do{let t=u.next.next;for(;t!==u.prev;){if(u.i!==t.i&&Z(u,t)){let s=I(u,t);return u=i(u,u.next),s=i(s,s.next),f(u,e,n,r,x,o,0),void f(s,e,n,r,x,o,0)}t=t.next}u=u.next}while(u!==t)}function y(t,e){return t.x-e.x}function h(t,e){const n=function(t,e){let n=e;const r=t.x,x=t.y;let o,u=-1/0;do{if(x<=n.y&&x>=n.next.y&&n.next.y!==n.y){const t=n.x+(x-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>u&&(u=t,o=n.x<n.next.x?n:n.next,t===r))return o}n=n.next}while(n!==e);if(!o)return null;const i=o,f=o.x,s=o.y;let l=1/0;n=o;do{if(r>=n.x&&n.x>=f&&r!==n.x&&b(x<s?r:u,x,f,s,x<s?u:r,x,n.x,n.y)){const e=Math.abs(x-n.y)/(r-n.x);E(n,t)&&(e<l||e===l&&(n.x>o.x||n.x===o.x&&p(o,n)))&&(o=n,l=e)}n=n.next}while(n!==i);return o}(t,e);if(!n)return e;const r=I(n,t);return i(r,r.next),i(n,n.next)}function p(t,e){return d(t.prev,t,e.prev)<0&&d(e.next,t,t.next)<0}function v(t,e,n,r,x){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-n)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function g(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function b(t,e,n,r,x,o,u,i){return(x-u)*(e-i)>=(t-u)*(o-i)&&(t-u)*(r-i)>=(n-u)*(e-i)&&(n-u)*(o-i)>=(x-u)*(r-i)}function Z(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&w(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(E(t,e)&&E(e,t)&&function(t,e){let n=t,r=!1;const x=(t.x+e.x)/2,o=(t.y+e.y)/2;do{n.y>o!=n.next.y>o&&n.next.y!==n.y&&x<(n.next.x-n.x)*(o-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(d(t.prev,t,e.prev)||d(t,e.prev,e))||M(t,e)&&d(t.prev,t,t.next)>0&&d(e.prev,e,e.next)>0)}function d(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function M(t,e){return t.x===e.x&&t.y===e.y}function w(t,e,n,r){const x=A(d(t,e,n)),o=A(d(t,e,r)),u=A(d(n,r,t)),i=A(d(n,r,e));return x!==o&&u!==i||(!(0!==x||!m(t,n,e))||(!(0!==o||!m(t,r,e))||(!(0!==u||!m(n,t,r))||!(0!==i||!m(n,e,r)))))}function m(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function A(t){return t>0?1:t<0?-1:0}function E(t,e){return d(t.prev,t,t.next)<0?d(t,e,t.next)>=0&&d(t,t.prev,e)>=0:d(t,e,t.prev)<0||d(t,t.next,e)<0}function I(t,e){const n=P(t.i,t.x,t.y),r=P(e.i,e.x,e.y),x=t.next,o=e.prev;return t.next=e,e.prev=t,n.next=x,x.prev=n,r.next=n,n.prev=r,o.next=r,r.prev=o,r}function z(t,e,n,r){const x=P(t,e,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function F(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function P(t,e,n){return{i:t,x:e,y:n,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}new Array(6);const B=[],N={vertexPosition:0,indexPosition:0};function R(t,e,n,r,x){t[e+0]=n,t[e+1]=r,t[e+2]=x}function S(t,e,n,r,x,o){const u=3+x,i=t[e+0],f=t[e+1],s=B;s.length=x;for(let n=0;n<s.length;n++)s[n]=t[e+2+n];let l=o?o.vertexPosition:0,c=o?o.indexPosition:0;const a=l/u;return R(n,l,i,f,0),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,1),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,2),s.length&&n.set(s,l+3),l+=u,R(n,l,i,f,3),s.length&&n.set(s,l+3),l+=u,r[c++]=a,r[c++]=a+1,r[c++]=a+3,r[c++]=a+1,r[c++]=a+2,r[c++]=a+3,N.vertexPosition=l,N.indexPosition=c,N}function T(t,e,n,x,o,u,i,f,s,l,c){const a=10+f.length,y=u.length/a,h=[t[e+0],t[e+1]],p=[t[n],t[n+1]],v=t[e+2],g=t[n+2],b=r(s,[...h]),Z=r(s,[...p]);function d(t,e,n){const r=Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])),x=[(e[0]-t[0])/r,(e[1]-t[1])/r],o=[-x[1],x[0]],u=Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1])),i=[(n[0]-t[0])/u,(n[1]-t[1])/u],f=0===r||0===u?0:Math.acos((s=i[0]*x[0]+i[1]*x[1],l=-1,c=1,Math.min(Math.max(s,l),c)));var s,l,c;return i[0]*o[0]+i[1]*o[1]>0?f:2*Math.PI-f}let M=-1,w=-1,m=c;const A=null!==o;if(null!==x){M=d(b,Z,r(s,[...[t[x],t[x+1]]])),Math.cos(M)<=.985&&(m+=Math.tan((M-Math.PI)/2))}if(A){w=d(Z,b,r(s,[...[t[o],t[o+1]]])),Math.cos(w)<=.985&&(m+=Math.tan((Math.PI-w)/2))}function E(t,e){return 0===e?1e4*t:Math.sign(e)*(1e4*t+Math.abs(e))}return u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(0,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(1,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(2,c)),u.push(...f),u.push(h[0],h[1],v,p[0],p[1],g,M,w,l,E(3,c)),u.push(...f),i.push(y,y+1,y+2,y+1,y+3,y+2),{length:l+Math.sqrt((Z[0]-b[0])*(Z[0]-b[0])+(Z[1]-b[1])*(Z[1]-b[1])),angle:m}}function _(t,e,n,r,x){const u=2+x;let i=e;const f=t.slice(i,i+x);i+=x;const s=t[i++];let l=0;const c=new Array(s-1);for(let e=0;e<s;e++)l+=t[i++],e<s-1&&(c[e]=l);const a=t.slice(i,i+2*l),y=o(a,c,2);for(let t=0;t<y.length;t++)r.push(y[t]+n.length/u);for(let t=0;t<a.length;t+=2)n.push(a[t],a[t+1],...f);return i+2*l}const O=self;O.onmessage=r=>{const o=r.data;switch(o.type){case e:{const t=3,e=2,n=o.customAttributesSize,r=e+n,x=new Float32Array(o.renderInstructions),u=x.length/r,i=4*u*(n+t),f=new Uint32Array(6*u),s=new Float32Array(i);let l;for(let t=0;t<x.length;t+=r)l=S(x,t,s,f,n,l);const c=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},o);O.postMessage(c,[s.buffer,f.buffer,x.buffer]);break}case n:{const t=[],e=[],n=o.customAttributesSize,r=3,u=new Float32Array(o.renderInstructions);let i=0;const f=[1,0,0,1,0,0];let s,l;for(x(f,o.renderInstructionsTransform);i<u.length;){l=Array.from(u.slice(i,i+n)),i+=n,s=u[i++];const x=i,o=i+(s-1)*r,c=u[x]===u[o]&&u[x+1]===u[o+1];let a=0,y=0;for(let n=0;n<s-1;n++){let h=null;n>0?h=i+(n-1)*r:c&&(h=o-r);let p=null;n<s-2?p=i+(n+2)*r:c&&(p=x+r);const v=T(u,i+n*r,i+(n+1)*r,h,p,t,e,l,f,a,y);a=v.length,y=v.angle}i+=s*r}const c=Uint32Array.from(e),a=Float32Array.from(t),y=Object.assign({vertexBuffer:a.buffer,indexBuffer:c.buffer,renderInstructions:u.buffer},o);O.postMessage(y,[a.buffer,c.buffer,u.buffer]);break}case t:{const t=[],e=[],n=o.customAttributesSize,r=new Float32Array(o.renderInstructions);let x=0;for(;x<r.length;)x=_(r,x,t,e,n);const u=Uint32Array.from(e),i=Float32Array.from(t),f=Object.assign({vertexBuffer:i.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},o);O.postMessage(f,[i.buffer,u.buffer,r.buffer]);break}}};';
    return new Worker(typeof Blob > "u" ? "data:application/javascript;base64," + Buffer.from(t, "binary").toString("base64") : URL.createObjectURL(new Blob([t], { type: "application/javascript" })));
  }
  function eP(t, e) {
    const i = t.viewState.projection, n = e.getSource().getWrapX() && i.canWrapX(), s = i.getExtent(), o = t.extent, a = n ? mt(s) : null, A = n ? Math.ceil((o[2] - s[2]) / a) + 1 : 1;
    return [n ? Math.floor((o[0] - s[0]) / a) : 0, A, a];
  }
  class cle extends vf {
    /**
     * @param {import("../../layer/Layer.js").default} layer Layer.
     * @param {Options} options Options.
     */
    constructor(e, i) {
      const r = i.uniforms || {}, n = ri();
      r[Eo.PROJECTION_MATRIX] = n, super(e, {
        uniforms: r,
        postProcesses: i.postProcesses
      }), this.sourceRevision_ = -1, this.verticesBuffer_ = new dd(Mf, HE), this.indicesBuffer_ = new dd(
        If,
        HE
      ), this.vertexShader_ = i.vertexShader, this.fragmentShader_ = i.fragmentShader, this.program_, this.hitDetectionEnabled_ = i.hitDetectionEnabled ?? !0;
      const s = i.attributes ? i.attributes.map(function(a) {
        return {
          name: "a_" + a.name,
          size: 1,
          type: Gi.FLOAT
        };
      }) : [];
      this.attributes = [
        {
          name: "a_position",
          size: 2,
          type: Gi.FLOAT
        },
        {
          name: "a_index",
          size: 1,
          type: Gi.FLOAT
        }
      ], this.hitDetectionEnabled_ && (this.attributes.push({
        name: "a_hitColor",
        size: 4,
        type: Gi.FLOAT
      }), this.attributes.push({
        name: "a_featureUid",
        size: 1,
        type: Gi.FLOAT
      })), this.attributes.push(...s), this.customAttributes = i.attributes ? i.attributes : [], this.previousExtent_ = yr(), this.currentTransform_ = n, this.renderTransform_ = ri(), this.invertRenderTransform_ = ri(), this.renderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.lastSentId = 0, this.worker_ = $z(), this.worker_.addEventListener(
        "message",
        /**
         * @param {*} event Event.
         */
        (a) => {
          const A = a.data;
          if (A.type === Oh.GENERATE_POINT_BUFFERS) {
            const l = A.projectionTransform;
            this.verticesBuffer_.fromArrayBuffer(A.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.fromArrayBuffer(A.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = l, xA(
              this.invertRenderTransform_,
              this.renderTransform_
            ), this.renderInstructions_ = new Float32Array(
              a.data.renderInstructions
            ), A.id === this.lastSentId && (this.ready = !0), this.getLayer().changed();
          }
        }
      ), this.featureCache_ = {}, this.featureCount_ = 0;
      const o = this.getLayer().getSource();
      this.sourceListenKeys_ = [
        nt(
          o,
          Ii.ADDFEATURE,
          this.handleSourceFeatureAdded_,
          this
        ),
        nt(
          o,
          Ii.CHANGEFEATURE,
          this.handleSourceFeatureChanged_,
          this
        ),
        nt(
          o,
          Ii.REMOVEFEATURE,
          this.handleSourceFeatureDelete_,
          this
        ),
        nt(
          o,
          Ii.CLEAR,
          this.handleSourceFeatureClear_,
          this
        )
      ], o.forEachFeature((a) => {
        this.featureCache_[ve(a)] = {
          feature: a,
          properties: a.getProperties(),
          geometry: a.getGeometry()
        }, this.featureCount_++;
      });
    }
    /**
     * @override
     */
    afterHelperCreated() {
      this.program_ = this.helper.getProgram(
        this.fragmentShader_,
        this.vertexShader_
      ), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new kx(this.helper)), this.verticesBuffer_.getArray() && this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.getArray() && this.helper.flushBufferData(this.indicesBuffer_);
    }
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceFeatureAdded_(e) {
      const i = e.feature;
      this.featureCache_[ve(i)] = {
        feature: i,
        properties: i.getProperties(),
        geometry: i.getGeometry()
      }, this.featureCount_++;
    }
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceFeatureChanged_(e) {
      const i = e.feature;
      this.featureCache_[ve(i)] = {
        feature: i,
        properties: i.getProperties(),
        geometry: i.getGeometry()
      };
    }
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceFeatureDelete_(e) {
      const i = e.feature;
      delete this.featureCache_[ve(i)], this.featureCount_--;
    }
    /**
     * @private
     */
    handleSourceFeatureClear_() {
      this.featureCache_ = {}, this.featureCount_ = 0;
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    renderFrame(e) {
      const i = this.helper.getGL();
      this.preRender(i, e);
      const [r, n, s] = eP(
        e,
        this.getLayer()
      );
      return this.renderWorlds(e, !1, r, n, s), this.helper.finalizeDraw(
        e,
        this.dispatchPreComposeEvent,
        this.dispatchPostComposeEvent
      ), this.hitDetectionEnabled_ && (this.renderWorlds(e, !0, r, n, s), this.hitRenderTarget_.clearCachedData()), this.postRender(i, e), this.helper.getCanvas();
    }
    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrameInternal(e) {
      const i = this.getLayer(), r = i.getSource(), n = e.viewState, s = !e.viewHints[Ai.ANIMATING] && !e.viewHints[Ai.INTERACTING], o = !Zs(this.previousExtent_, e.extent), a = this.sourceRevision_ < r.getRevision();
      if (a && (this.sourceRevision_ = r.getRevision()), s && (o || a)) {
        const A = n.projection, l = n.resolution, c = i instanceof gf ? i.getRenderBuffer() : 0, u = $r(e.extent, c * l);
        r.loadFeatures(u, l, A), this.rebuildBuffers_(e), this.previousExtent_ = e.extent.slice();
      }
      return this.helper.useProgram(this.program_, e), this.helper.prepareDraw(e), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), !0;
    }
    /**
     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
     * @param {import("../../Map").FrameState} frameState Frame state.
     * @private
     */
    rebuildBuffers_(e) {
      const i = ri();
      this.helper.makeProjectionTransform(e, i);
      const n = (this.hitDetectionEnabled_ ? 7 : 2) + this.customAttributes.length, s = n * this.featureCount_;
      (!this.renderInstructions_ || this.renderInstructions_.length !== s) && (this.renderInstructions_ = new Float32Array(s));
      let o, a;
      const A = [], l = [];
      let c = -1;
      for (const d in this.featureCache_)
        if (o = this.featureCache_[d], a = /** @type {import("../../geom").Point} */
        o.geometry, !(!a || a.getType() !== "Point")) {
          if (A[0] = a.getFlatCoordinates()[0], A[1] = a.getFlatCoordinates()[1], Ei(i, A), this.renderInstructions_[++c] = A[0], this.renderInstructions_[++c] = A[1], this.hitDetectionEnabled_) {
            const h = Zz(c + 5, l);
            this.renderInstructions_[++c] = h[0], this.renderInstructions_[++c] = h[1], this.renderInstructions_[++c] = h[2], this.renderInstructions_[++c] = h[3], this.renderInstructions_[++c] = Number(d);
          }
          for (let h = 0; h < this.customAttributes.length; h++) {
            const g = this.customAttributes[h].callback(
              o.feature,
              o.properties
            );
            this.renderInstructions_[++c] = g;
          }
        }
      const u = {
        id: ++this.lastSentId,
        type: Oh.GENERATE_POINT_BUFFERS,
        renderInstructions: this.renderInstructions_.buffer,
        customAttributesSize: n - 2
      };
      u.projectionTransform = i, this.ready = !1, this.worker_.postMessage(u, [this.renderInstructions_.buffer]), this.renderInstructions_ = null;
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     * @override
     */
    forEachFeatureAtCoordinate(e, i, r, n, s) {
      if (Mt(
        this.hitDetectionEnabled_,
        "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
      ), !this.renderInstructions_ || !this.hitDetectionEnabled_)
        return;
      const o = Ei(
        i.coordinateToPixelTransform,
        e.slice()
      ), a = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), A = [a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255], l = qz(A), c = this.renderInstructions_[l], u = Math.floor(c).toString(), h = this.getLayer().getSource().getFeatureByUid(u);
      if (h)
        return n(h, this.getLayer(), null);
    }
    /**
     * Render the world, either to the main framebuffer or to the hit framebuffer
     * @param {import("../../Map.js").FrameState} frameState current frame state
     * @param {boolean} forHitDetection whether the rendering is for hit detection
     * @param {number} startWorld the world to render in the first iteration
     * @param {number} endWorld the last world to render
     * @param {number} worldWidth the width of the worlds being rendered
     */
    renderWorlds(e, i, r, n, s) {
      let o = r;
      this.helper.useProgram(this.program_, e), i && (this.hitRenderTarget_.setSize([
        Math.floor(e.size[0] / 2),
        Math.floor(e.size[1] / 2)
      ]), this.helper.prepareDrawToRenderTarget(
        e,
        this.hitRenderTarget_,
        !0
      )), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes);
      do {
        this.helper.makeProjectionTransform(e, this.currentTransform_), nf(this.currentTransform_, o * s, 0), sc(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e), this.helper.applyHitDetectionUniform(i);
        const a = this.indicesBuffer_.getSize();
        this.helper.drawElements(0, a);
      } while (++o < n);
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.worker_.terminate(), this.sourceListenKeys_.forEach(function(e) {
        Pt(e);
      }), this.sourceListenKeys_ = null, super.disposeInternal();
    }
    renderDeclutter() {
    }
  }
  class ule {
    /**
     * @param {string} name The name of the texture.
     * @param {Uint8Array} data The texture data.
     */
    constructor(e, i) {
      this.name = e, this.data = i, this.texture_ = null;
    }
    /**
     * @param {WebGLRenderingContext} gl Rendering context.
     * @return {WebGLTexture} The texture.
     */
    getTexture(e) {
      if (!this.texture_) {
        const i = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, i), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texImage2D(
          e.TEXTURE_2D,
          0,
          e.RGBA,
          this.data.length / 4,
          1,
          0,
          e.RGBA,
          e.UNSIGNED_BYTE,
          this.data
        ), this.texture_ = i;
      }
      return this.texture_;
    }
    /**
     * @param {WebGLRenderingContext} gl Rendering context.
     */
    delete(e) {
      this.texture_ && e.deleteTexture(this.texture_), this.texture_ = null;
    }
  }
  class dle extends Rd {
    /**
     * @param {TileRepresentationOptions<TileType>} options The tile representation options.
     */
    constructor(e) {
      super(), this.tile, this.handleTileChange_ = this.handleTileChange_.bind(this), this.gutter = e.gutter || 0, this.helper = e.helper, this.loaded = !1, this.ready = !1;
    }
    /**
     * @param {TileType} tile Tile.
     */
    setTile(e) {
      if (e !== this.tile)
        if (this.tile && this.tile.removeEventListener(Ge.CHANGE, this.handleTileChange_), this.tile = e, this.loaded = e.getState() === pe.LOADED, this.loaded)
          this.uploadTile();
        else {
          if (e instanceof ix) {
            const i = e.getImage();
            i instanceof Image && !i.crossOrigin && (i.crossOrigin = "anonymous");
          }
          e.addEventListener(Ge.CHANGE, this.handleTileChange_);
        }
    }
    /**
     * @abstract
     * @protected
     */
    uploadTile() {
      it();
    }
    setReady() {
      this.ready = !0, this.dispatchEvent(Ge.CHANGE);
    }
    handleTileChange_() {
      this.tile.getState() === pe.LOADED && (this.loaded = !0, this.uploadTile());
    }
    /**
     * @param {import("./Helper.js").default} helper The WebGL helper.
     */
    setHelper(e) {
      this.helper = e, this.helper && this.loaded && this.uploadTile();
    }
    /**
     * @override
     */
    disposeInternal() {
      this.setHelper(null), this.tile.removeEventListener(Ge.CHANGE, this.handleTileChange_);
    }
  }
  const hle = {
    TILE_TRANSFORM: "u_tileTransform",
    TRANSITION_ALPHA: "u_transitionAlpha",
    DEPTH: "u_depth",
    RENDER_EXTENT: "u_renderExtent",
    // intersection of layer, source, and view extent
    PATTERN_ORIGIN: "u_patternOrigin",
    RESOLUTION: "u_resolution",
    ZOOM: "u_zoom",
    GLOBAL_ALPHA: "u_globalAlpha",
    PROJECTION_MATRIX: "u_projectionMatrix",
    SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix"
  };
  function WT(t) {
    return 1 / (t + 2);
  }
  function gle() {
    return { tileIds: /* @__PURE__ */ new Set(), representationsByZ: {} };
  }
  function KT(t, e) {
    return t.tileIds.has(ve(e));
  }
  function XT(t, e, i) {
    const r = t.representationsByZ;
    i in r || (r[i] = /* @__PURE__ */ new Set()), r[i].add(e), t.tileIds.add(ve(e.tile));
  }
  function $0(t, e) {
    const i = t.layerStatesArray[t.layerIndex];
    i.extent && (e = fr(
      e,
      is(i.extent, t.viewState.projection)
    ));
    const r = (
      /** @type {import("../../source/Tile.js").default} */
      i.layer.getRenderSource()
    );
    if (!r.getWrapX()) {
      const n = r.getTileGridForProjection(t.viewState.projection).getExtent();
      n && (e = fr(e, n));
    }
    return e;
  }
  function ZT(t, e) {
    return `${t.getKey()},${t.getRevision()},${Xc(e)}`;
  }
  class fle extends vf {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} options Options.
     */
    constructor(e, i) {
      super(e, {
        uniforms: i.uniforms,
        postProcesses: i.postProcesses
      }), this.renderComplete = !1, this.tileTransform_ = ri(), this.tempMat4 = VA(), this.tempTileRange_ = new yB(0, 0, 0, 0), this.tempTileCoord_ = ad(0, 0, 0), this.tempSize_ = [0, 0];
      const r = i.cacheSize !== void 0 ? i.cacheSize : 512;
      this.tileRepresentationCache = new mL(r), this.frameState = null, this.renderedProjection_ = void 0;
    }
    /**
     * @param {Options} options Options.
     * @override
     */
    reset(e) {
      super.reset({
        uniforms: e.uniforms
      });
    }
    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrameInternal(e) {
      this.renderedProjection_ ? e.viewState.projection !== this.renderedProjection_ && (this.clearCache(), this.renderedProjection_ = e.viewState.projection) : this.renderedProjection_ = e.viewState.projection;
      const r = this.getLayer().getRenderSource();
      return !r || GA($0(e, e.extent)) ? !1 : r.getState() === "ready";
    }
    /**
     * @abstract
     * @param {import("../../webgl/BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options tile representation options
     * @return {TileRepresentation} A new tile representation
     * @protected
     */
    createTileRepresentation(e) {
      return it();
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent The extent to be rendered.
     * @param {number} initialZ The zoom level.
     * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.
     * @param {number} preload Number of additional levels to load.
     */
    enqueueTiles(e, i, r, n, s) {
      const o = e.viewState, a = this.getLayer(), A = a.getRenderSource(), l = A.getTileGridForProjection(o.projection), c = A.getGutterForProjection(o.projection), u = ve(A);
      u in e.wantedTiles || (e.wantedTiles[u] = {});
      const d = e.wantedTiles[u], h = this.tileRepresentationCache, g = a.getMapInternal(), f = Math.max(
        r - s,
        l.getMinZoom(),
        l.getZForResolution(
          Math.min(
            a.getMaxResolution(),
            g ? g.getView().getResolutionForZoom(Math.max(a.getMinZoom(), 0)) : l.getResolution(0)
          ),
          A.zDirection
        )
      );
      for (let p = r; p >= f; --p) {
        const m = l.getTileRangeForExtentAndZ(
          i,
          p,
          this.tempTileRange_
        ), E = l.getResolution(p);
        for (let y = m.minX; y <= m.maxX; ++y)
          for (let C = m.minY; C <= m.maxY; ++C) {
            const w = ad(p, y, C, this.tempTileCoord_), M = ZT(A, w);
            let I, b;
            if (h.containsKey(M) && (I = h.get(M), b = I.tile), (!I || I.tile.key !== A.getKey()) && (b = A.getTile(
              p,
              y,
              C,
              e.pixelRatio,
              o.projection
            ), !b) || KT(n, b))
              continue;
            I ? I.setTile(b) : (I = this.createTileRepresentation({
              tile: b,
              grid: l,
              helper: this.helper,
              gutter: c
            }), h.set(M, I)), XT(
              n,
              I,
              p
            );
            const B = b.getKey();
            d[B] = !0, b.getState() === pe.IDLE && (e.tileQueue.isKeyQueued(B) || e.tileQueue.enqueue([
              b,
              u,
              l.getTileCoordCenter(w),
              E
            ]));
          }
      }
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha
     * @protected
     */
    beforeTilesRender(e, i) {
      this.helper.prepareDraw(this.frameState, !i, !0);
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} If returns false, tile mask rendering will be skipped
     * @protected
     */
    beforeTilesMaskRender(e) {
      return !1;
    }
    /**
     * @param {TileRepresentation} tileRepresentation Tile representation
     * @param {import("../../transform.js").Transform} tileTransform Tile transform
     * @param {import("../../Map.js").FrameState} frameState Frame state
     * @param {import("../../extent.js").Extent} renderExtent Render extent
     * @param {number} tileResolution Tile resolution
     * @param {import("../../size.js").Size} tileSize Tile size
     * @param {import("../../coordinate.js").Coordinate} tileOrigin Tile origin
     * @param {import("../../extent.js").Extent} tileExtent tile Extent
     * @param {number} depth Depth
     * @param {number} gutter Gutter
     * @param {number} alpha Alpha
     * @protected
     */
    renderTile(e, i, r, n, s, o, a, A, l, c, u) {
    }
    /**
     * @param {TileRepresentation} tileRepresentation Tile representation
     * @param {number} tileZ Tile Z
     * @param {import("../../extent.js").Extent} extent Render extent
     * @param {number} depth Depth
     * @protected
     */
    renderTileMask(e, i, r, n) {
    }
    drawTile_(e, i, r, n, s, o, a) {
      if (!i.ready)
        return;
      const l = i.tile.tileCoord, c = Xc(l), u = c in o ? o[c] : 1, d = a.getResolution(r), h = mr(a.getTileSize(r), this.tempSize_), g = a.getOrigin(r), f = a.getTileCoordExtent(l), p = u < 1 ? -1 : WT(r);
      u < 1 && (e.animate = !0);
      const m = e.viewState, E = m.center[0], y = m.center[1], C = h[0] + 2 * n, w = h[1] + 2 * n, M = C / w, I = (E - g[0]) / (h[0] * d), b = (g[1] - y) / (h[1] * d), B = m.resolution / d, x = l[1], Q = l[2];
      ab(this.tileTransform_), Nh(
        this.tileTransform_,
        2 / (e.size[0] * B / C),
        -2 / (e.size[1] * B / C)
      ), Lq(this.tileTransform_, m.rotation), Nh(this.tileTransform_, 1, 1 / M), nf(
        this.tileTransform_,
        (h[0] * (x - I) - n) / C,
        (h[1] * (Q - b) - n) / w
      ), this.renderTile(
        /** @type {TileRepresentation} */
        i,
        this.tileTransform_,
        e,
        s,
        d,
        h,
        g,
        f,
        p,
        n,
        u
      );
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    renderFrame(e) {
      this.frameState = e, this.renderComplete = !0;
      const i = this.helper.getGL();
      this.preRender(i, e);
      const r = e.viewState, n = this.getLayer(), s = n.getRenderSource(), o = s.getTileGridForProjection(r.projection), a = s.getGutterForProjection(r.projection), A = $0(e, e.extent), l = o.getZForResolution(
        r.resolution,
        s.zDirection
      ), c = gle(), u = n.getPreload();
      if (e.nextExtent) {
        const y = o.getZForResolution(
          r.nextResolution,
          s.zDirection
        ), C = $0(e, e.nextExtent);
        this.enqueueTiles(
          e,
          C,
          y,
          c,
          u
        );
      }
      this.enqueueTiles(e, A, l, c, 0), u > 0 && setTimeout(() => {
        this.enqueueTiles(
          e,
          A,
          l - 1,
          c,
          u - 1
        );
      }, 0);
      const d = {};
      let h = !1;
      const g = c.representationsByZ;
      if (l in g) {
        const y = ve(this), C = e.time;
        for (const w of g[l]) {
          const M = w.tile;
          if ((M instanceof PE || M instanceof wz) && M.getState() === pe.EMPTY)
            continue;
          const I = M.tileCoord;
          if (w.ready) {
            const x = M.getAlpha(y, C);
            if (x === 1) {
              M.endTransition(y);
              continue;
            }
            h = !0;
            const Q = Xc(I);
            d[Q] = x;
          }
          if (this.renderComplete = !1, this.findAltTiles_(
            o,
            I,
            l + 1,
            c
          ))
            continue;
          const B = o.getMinZoom();
          for (let x = l - 1; x >= B && !this.findAltTiles_(
            o,
            I,
            x,
            c
          ); --x)
            ;
        }
      }
      const f = Object.keys(g).map(Number).sort(WN);
      if (this.beforeTilesMaskRender(e))
        for (let y = 0, C = f.length; y < C; ++y) {
          const w = f[y];
          for (const M of g[w]) {
            const I = M.tile.tileCoord;
            if (Xc(I) in d)
              continue;
            const B = o.getTileCoordExtent(I);
            this.renderTileMask(
              /** @type {TileRepresentation} */
              M,
              w,
              B,
              WT(w)
            );
          }
        }
      this.beforeTilesRender(e, h);
      for (let y = 0, C = f.length; y < C; ++y) {
        const w = f[y];
        for (const M of g[w]) {
          const I = M.tile.tileCoord;
          Xc(I) in d || this.drawTile_(
            e,
            M,
            w,
            a,
            A,
            d,
            o
          );
        }
      }
      if (l in g)
        for (const y of g[l]) {
          const C = y.tile.tileCoord;
          Xc(C) in d && this.drawTile_(
            e,
            y,
            l,
            a,
            A,
            d,
            o
          );
        }
      this.beforeFinalize(e), this.helper.finalizeDraw(
        e,
        this.dispatchPreComposeEvent,
        this.dispatchPostComposeEvent
      );
      const m = this.helper.getCanvas(), E = this.tileRepresentationCache;
      for (; E.canExpireCache(); )
        E.pop().dispose();
      return this.postRender(i, e), m;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    beforeFinalize(e) {
    }
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile representation lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of
     * tile representations by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */
    findAltTiles_(e, i, r, n) {
      const s = e.getTileRangeForTileCoordAndZ(
        i,
        r,
        this.tempTileRange_
      );
      if (!s)
        return !1;
      let o = !0;
      const a = this.tileRepresentationCache, A = this.getLayer().getRenderSource();
      for (let l = s.minX; l <= s.maxX; ++l)
        for (let c = s.minY; c <= s.maxY; ++c) {
          const u = ZT(A, [r, l, c]);
          let d = !1;
          if (a.containsKey(u)) {
            const h = a.get(u);
            h.ready && !KT(n, h.tile) && (XT(
              n,
              h,
              r
            ), d = !0);
          }
          d || (o = !1);
        }
      return o;
    }
    /**
     * @override
     */
    clearCache() {
      super.clearCache();
      const e = this.tileRepresentationCache;
      e.forEach(
        (i) => i.dispose()
      ), e.clear();
    }
    /**
     * @override
     */
    afterHelperCreated() {
      super.afterHelperCreated(), this.tileRepresentationCache.forEach(
        (e) => e.setHelper(this.helper)
      );
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      super.disposeInternal(), delete this.frameState;
    }
  }
  const eC = {
    TILE_TEXTURE_ARRAY: "u_tileTextures",
    TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
    TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight"
  };
  function ple(t, e) {
    return `operator_${t}_${Object.keys(e.functions).length}`;
  }
  function Fl(t) {
    const e = t.toString();
    return e.includes(".") ? e : e + ".0";
  }
  function Yx(t) {
    if (t.length < 2 || t.length > 4)
      throw new Error(
        "`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."
      );
    return `vec${t.length}(${t.map(Fl).join(", ")})`;
  }
  function cm(t) {
    const e = Hn(t), i = e.length > 3 ? e[3] : 1;
    return Yx([e[0] / 255, e[1] / 255, e[2] / 255, i]);
  }
  function mle(t) {
    const e = mr(t);
    return Yx(e);
  }
  const tC = {};
  let Ele = 0;
  function wh(t) {
    return t in tC || (tC[t] = Ele++), tC[t];
  }
  function ta(t) {
    return Fl(wh(t));
  }
  function tP(t) {
    return "u_var_" + t;
  }
  function qT() {
    return {
      inFragmentShader: !1,
      variables: {},
      properties: {},
      functions: {},
      bandCount: 0,
      featureId: !1,
      geometryType: !1
    };
  }
  const iC = "getBandValue", yle = "u_paletteTextures", iP = "featureId", rP = "geometryType";
  function Ble(t, e, i, r) {
    const n = Er(t, e, i);
    return Nx(n, e, r);
  }
  function Vt(t) {
    return (e, i, r) => {
      const n = i.args.length, s = new Array(n);
      for (let o = 0; o < n; ++o)
        s[o] = Nx(i.args[o], r, e);
      return t(s, e);
    };
  }
  const wle = {
    [te.Get]: (t, e) => {
      const r = (
        /** @type {string} */
        /** @type {LiteralExpression} */
        e.args[0].value
      );
      return r in t.properties || (t.properties[r] = {
        name: r,
        type: e.type
      }), (t.inFragmentShader ? "v_prop_" : "a_prop_") + r;
    },
    [te.Id]: (t) => (t.featureId = !0, (t.inFragmentShader ? "v_" : "a_") + iP),
    [te.GeometryType]: (t) => (t.geometryType = !0, (t.inFragmentShader ? "v_" : "a_") + rP),
    [te.LineMetric]: () => "currentLineMetric",
    // this variable is assumed to always be present in shaders, default is 0.
    [te.Var]: (t, e) => {
      const r = (
        /** @type {string} */
        /** @type {LiteralExpression} */
        e.args[0].value
      );
      return r in t.variables || (t.variables[r] = {
        name: r,
        type: e.type
      }), tP(r);
    },
    [te.Resolution]: () => "u_resolution",
    [te.Zoom]: () => "u_zoom",
    [te.Time]: () => "u_time",
    [te.Any]: Vt((t) => `(${t.join(" || ")})`),
    [te.All]: Vt((t) => `(${t.join(" && ")})`),
    [te.Not]: Vt(([t]) => `(!${t})`),
    [te.Equal]: Vt(
      ([t, e]) => `(${t} == ${e})`
    ),
    [te.NotEqual]: Vt(
      ([t, e]) => `(${t} != ${e})`
    ),
    [te.GreaterThan]: Vt(
      ([t, e]) => `(${t} > ${e})`
    ),
    [te.GreaterThanOrEqualTo]: Vt(
      ([t, e]) => `(${t} >= ${e})`
    ),
    [te.LessThan]: Vt(
      ([t, e]) => `(${t} < ${e})`
    ),
    [te.LessThanOrEqualTo]: Vt(
      ([t, e]) => `(${t} <= ${e})`
    ),
    [te.Multiply]: Vt(
      (t) => `(${t.join(" * ")})`
    ),
    [te.Divide]: Vt(
      ([t, e]) => `(${t} / ${e})`
    ),
    [te.Add]: Vt((t) => `(${t.join(" + ")})`),
    [te.Subtract]: Vt(
      ([t, e]) => `(${t} - ${e})`
    ),
    [te.Clamp]: Vt(
      ([t, e, i]) => `clamp(${t}, ${e}, ${i})`
    ),
    [te.Mod]: Vt(([t, e]) => `mod(${t}, ${e})`),
    [te.Pow]: Vt(([t, e]) => `pow(${t}, ${e})`),
    [te.Abs]: Vt(([t]) => `abs(${t})`),
    [te.Floor]: Vt(([t]) => `floor(${t})`),
    [te.Ceil]: Vt(([t]) => `ceil(${t})`),
    [te.Round]: Vt(([t]) => `floor(${t} + 0.5)`),
    [te.Sin]: Vt(([t]) => `sin(${t})`),
    [te.Cos]: Vt(([t]) => `cos(${t})`),
    [te.Atan]: Vt(([t, e]) => e !== void 0 ? `atan(${t}, ${e})` : `atan(${t})`),
    [te.Sqrt]: Vt(([t]) => `sqrt(${t})`),
    [te.Match]: Vt((t) => {
      const e = t[0], i = t[t.length - 1];
      let r = null;
      for (let n = t.length - 3; n >= 1; n -= 2) {
        const s = t[n], o = t[n + 1];
        r = `(${e} == ${s} ? ${o} : ${r || i})`;
      }
      return r;
    }),
    [te.Between]: Vt(
      ([t, e, i]) => `(${t} >= ${e} && ${t} <= ${i})`
    ),
    [te.Interpolate]: Vt(([t, e, ...i]) => {
      let r = "";
      for (let n = 0; n < i.length - 2; n += 2) {
        const s = i[n], o = r || i[n + 1], a = i[n + 2], A = i[n + 3];
        let l;
        t === Fl(1) ? l = `(${e} - ${s}) / (${a} - ${s})` : l = `(pow(${t}, (${e} - ${s})) - 1.0) / (pow(${t}, (${a} - ${s})) - 1.0)`, r = `mix(${o}, ${A}, clamp(${l}, 0.0, 1.0))`;
      }
      return r;
    }),
    [te.Case]: Vt((t) => {
      const e = t[t.length - 1];
      let i = null;
      for (let r = t.length - 3; r >= 0; r -= 2) {
        const n = t[r], s = t[r + 1];
        i = `(${n} ? ${s} : ${i || e})`;
      }
      return i;
    }),
    [te.In]: Vt(([t, ...e], i) => {
      const r = ple("in", i), n = [];
      for (let s = 0; s < e.length; s += 1)
        n.push(`  if (inputValue == ${e[s]}) { return true; }`);
      return i.functions[r] = `bool ${r}(float inputValue) {
${n.join(`
`)}
  return false;
}`, `${r}(${t})`;
    }),
    [te.Array]: Vt(
      (t) => `vec${t.length}(${t.join(", ")})`
    ),
    [te.Color]: Vt((t) => {
      if (t.length === 1)
        return `vec4(vec3(${t[0]} / 255.0), 1.0)`;
      if (t.length === 2)
        return `vec4(vec3(${t[0]} / 255.0), ${t[1]})`;
      const e = t.slice(0, 3).map((r) => `${r} / 255.0`);
      if (t.length === 3)
        return `vec4(${e.join(", ")}, 1.0)`;
      const i = t[3];
      return `vec4(${e.join(", ")}, ${i})`;
    }),
    [te.Band]: Vt(([t, e, i], r) => {
      if (!(iC in r.functions)) {
        let n = "";
        const s = r.bandCount || 1;
        for (let o = 0; o < s; o++) {
          const a = Math.floor(o / 4);
          let A = o % 4;
          o === s - 1 && A === 1 && (A = 3);
          const l = `${eC.TILE_TEXTURE_ARRAY}[${a}]`;
          n += `  if (band == ${o + 1}.0) {
    return texture2D(${l}, v_textureCoord + vec2(dx, dy))[${A}];
  }
`;
        }
        r.functions[iC] = `float getBandValue(float band, float xOffset, float yOffset) {
  float dx = xOffset / ${eC.TEXTURE_PIXEL_WIDTH};
  float dy = yOffset / ${eC.TEXTURE_PIXEL_HEIGHT};
${n}
}`;
      }
      return `${iC}(${t}, ${e ?? "0.0"}, ${i ?? "0.0"})`;
    }),
    [te.Palette]: (t, e) => {
      const [i, ...r] = e.args, n = r.length, s = new Uint8Array(n * 4);
      for (let l = 0; l < r.length; l++) {
        const c = (
          /** @type {string | Array<number>} */
          /** @type {LiteralExpression} */
          r[l].value
        ), u = Hn(c), d = l * 4;
        s[d] = u[0], s[d + 1] = u[1], s[d + 2] = u[2], s[d + 3] = u[3] * 255;
      }
      t.paletteTextures || (t.paletteTextures = []);
      const o = `${yle}[${t.paletteTextures.length}]`, a = new ule(o, s);
      t.paletteTextures.push(a);
      const A = Nx(i, Ve, t);
      return `texture2D(${o}, vec2((${A} + 0.5) / ${n}.0, 0.5))`;
    }
    // TODO: unimplemented
    // Ops.Number
    // Ops.String
    // Ops.Coalesce
    // Ops.Concat
    // Ops.ToString
  };
  function Nx(t, e, i) {
    if (t instanceof PU) {
      const r = wle[t.operator];
      if (r === void 0)
        throw new Error(
          `No compiler defined for this operator: ${JSON.stringify(
            t.operator
          )}`
        );
      return r(i, t, e);
    }
    if ((t.type & Ve) > 0)
      return Fl(
        /** @type {number} */
        t.value
      );
    if ((t.type & Mr) > 0)
      return t.value.toString();
    if ((t.type & sr) > 0)
      return ta(t.value.toString());
    if ((t.type & Qi) > 0)
      return cm(
        /** @type {Array<number> | string} */
        t.value
      );
    if ((t.type & tn) > 0)
      return Yx(
        /** @type {Array<number>} */
        t.value
      );
    if ((t.type & Ns) > 0)
      return mle(
        /** @type {number|import('../size.js').Size} */
        t.value
      );
    throw new Error(
      `Unexpected expression ${t.value} (expected type ${uu(
        e
      )})`
    );
  }
  function Cle() {
    return {
      "fill-color": "rgba(255,255,255,0.4)",
      "stroke-color": "#3399CC",
      "stroke-width": 1.25,
      "circle-radius": 5,
      "circle-fill-color": "rgba(255,255,255,0.4)",
      "circle-stroke-width": 1.25,
      "circle-stroke-color": "#3399CC"
    };
  }
  const Rc = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;
float currentLineMetric = 0.; // an actual value will be used in the stroke shaders
`, _c = Cle();
  class nP {
    constructor() {
      this.uniforms_ = [], this.attributes_ = [], this.varyings_ = [], this.hasSymbol_ = !1, this.symbolSizeExpression_ = `vec2(${Fl(
        _c["circle-radius"]
      )} + ${Fl(_c["circle-stroke-width"] * 0.5)})`, this.symbolRotationExpression_ = "0.0", this.symbolOffsetExpression_ = "vec2(0.0)", this.symbolColorExpression_ = cm(
        /** @type {string} */
        _c["circle-fill-color"]
      ), this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression_ = "false", this.symbolRotateWithView_ = !1, this.hasStroke_ = !1, this.strokeWidthExpression_ = Fl(_c["stroke-width"]), this.strokeColorExpression_ = cm(
        /** @type {string} */
        _c["stroke-color"]
      ), this.strokeOffsetExpression_ = "0.", this.strokeCapExpression_ = ta("round"), this.strokeJoinExpression_ = ta("round"), this.strokeMiterLimitExpression_ = "10.", this.strokeDistanceFieldExpression_ = "-1000.", this.hasFill_ = !1, this.fillColorExpression_ = cm(
        /** @type {string} */
        _c["fill-color"]
      ), this.vertexShaderFunctions_ = [], this.fragmentShaderFunctions_ = [];
    }
    /**
     * Adds a uniform accessible in both fragment and vertex shaders.
     * The given name should include a type, such as `sampler2D u_texture`.
     * @param {string} name Uniform name
     * @return {ShaderBuilder} the builder object
     */
    addUniform(e) {
      return this.uniforms_.push(e), this;
    }
    /**
     * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
     * The given name should include a type, such as `vec2 a_position`.
     * @param {string} name Attribute name
     * @return {ShaderBuilder} the builder object
     */
    addAttribute(e) {
      return this.attributes_.push(e), this;
    }
    /**
     * Adds a varying defined in the vertex shader and accessible from the fragment shader.
     * The type and expression of the varying have to be specified separately.
     * @param {string} name Varying name
     * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
     * @param {string} expression Expression used to assign a value to the varying.
     * @return {ShaderBuilder} the builder object
     */
    addVarying(e, i, r) {
      return this.varyings_.push({
        name: e,
        type: i,
        expression: r
      }), this;
    }
    /**
     * Sets an expression to compute the size of the shape.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec2` value.
     * @param {string} expression Size expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolSizeExpression(e) {
      return this.hasSymbol_ = !0, this.symbolSizeExpression_ = e, this;
    }
    /**
     * @return {string} The current symbol size expression
     */
    getSymbolSizeExpression() {
      return this.symbolSizeExpression_;
    }
    /**
     * Sets an expression to compute the rotation of the shape.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `float` value in radians.
     * @param {string} expression Size expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolRotationExpression(e) {
      return this.symbolRotationExpression_ = e, this;
    }
    /**
     * Sets an expression to compute the offset of the symbol from the point center.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec2` value.
     * @param {string} expression Offset expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolOffsetExpression(e) {
      return this.symbolOffsetExpression_ = e, this;
    }
    /**
     * @return {string} The current symbol offset expression
     */
    getSymbolOffsetExpression() {
      return this.symbolOffsetExpression_;
    }
    /**
     * Sets an expression to compute the color of the shape.
     * This expression can use all the uniforms, varyings and attributes available
     * in the fragment shader, and should evaluate to a `vec4` value.
     * @param {string} expression Color expression
     * @return {ShaderBuilder} the builder object
     */
    setSymbolColorExpression(e) {
      return this.hasSymbol_ = !0, this.symbolColorExpression_ = e, this;
    }
    /**
     * @return {string} The current symbol color expression
     */
    getSymbolColorExpression() {
      return this.symbolColorExpression_;
    }
    /**
     * Sets an expression to compute the texture coordinates of the vertices.
     * This expression can use all the uniforms and attributes available
     * in the vertex shader, and should evaluate to a `vec4` value.
     * @param {string} expression Texture coordinate expression
     * @return {ShaderBuilder} the builder object
     */
    setTextureCoordinateExpression(e) {
      return this.texCoordExpression_ = e, this;
    }
    /**
     * Sets an expression to determine whether a fragment (pixel) should be discarded,
     * i.e. not drawn at all.
     * This expression can use all the uniforms, varyings and attributes available
     * in the fragment shader, and should evaluate to a `bool` value (it will be
     * used in an `if` statement)
     * @param {string} expression Fragment discard expression
     * @return {ShaderBuilder} the builder object
     */
    setFragmentDiscardExpression(e) {
      return this.discardExpression_ = e, this;
    }
    /**
     * @return {string} The current fragment discard expression
     */
    getFragmentDiscardExpression() {
      return this.discardExpression_;
    }
    /**
     * Sets whether the symbols should rotate with the view or stay aligned with the map.
     * Note: will only be used for point geometry shaders.
     * @param {boolean} rotateWithView Rotate with view
     * @return {ShaderBuilder} the builder object
     */
    setSymbolRotateWithView(e) {
      return this.symbolRotateWithView_ = e, this;
    }
    /**
     * @param {string} expression Stroke width expression, returning value in pixels
     * @return {ShaderBuilder} the builder object
     */
    setStrokeWidthExpression(e) {
      return this.hasStroke_ = !0, this.strokeWidthExpression_ = e, this;
    }
    /**
     * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
     * @return {ShaderBuilder} the builder object
     */
    setStrokeColorExpression(e) {
      return this.hasStroke_ = !0, this.strokeColorExpression_ = e, this;
    }
    /**
     * @return {string} The current stroke color expression
     */
    getStrokeColorExpression() {
      return this.strokeColorExpression_;
    }
    /**
     * @param {string} expression Stroke color expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeOffsetExpression(e) {
      return this.strokeOffsetExpression_ = e, this;
    }
    /**
     * @param {string} expression Stroke line cap expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeCapExpression(e) {
      return this.strokeCapExpression_ = e, this;
    }
    /**
     * @param {string} expression Stroke line join expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeJoinExpression(e) {
      return this.strokeJoinExpression_ = e, this;
    }
    /**
     * @param {string} expression Stroke miter limit expression, evaluate to `float`
     * @return {ShaderBuilder} the builder object
     */
    setStrokeMiterLimitExpression(e) {
      return this.strokeMiterLimitExpression_ = e, this;
    }
    /**
     * @param {string} expression Stroke distance field expression, evaluate to `float`
     * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
     * @return {ShaderBuilder} the builder object
     */
    setStrokeDistanceFieldExpression(e) {
      return this.strokeDistanceFieldExpression_ = e, this;
    }
    /**
     * @param {string} expression Fill color expression, evaluate to `vec4`
     * @return {ShaderBuilder} the builder object
     */
    setFillColorExpression(e) {
      return this.hasFill_ = !0, this.fillColorExpression_ = e, this;
    }
    /**
     * @return {string} The current fill color expression
     */
    getFillColorExpression() {
      return this.fillColorExpression_;
    }
    addVertexShaderFunction(e) {
      this.vertexShaderFunctions_.includes(e) || this.vertexShaderFunctions_.push(e);
    }
    addFragmentShaderFunction(e) {
      this.fragmentShaderFunctions_.includes(e) || this.fragmentShaderFunctions_.push(e);
    }
    /**
     * Generates a symbol vertex shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getSymbolVertexShader() {
      return this.hasSymbol_ ? `${Rc}
${this.uniforms_.map(function(e) {
        return "uniform " + e + ";";
      }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec4 a_hitColor;
${this.attributes_.map(function(e) {
        return "attribute " + e + ";";
      }).join(`
`)}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(e) {
        return "varying " + e.type + " " + e.name + ";";
      }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx;
  if (a_index == 0.0) {
    offsetPx -= halfSizePx;
  } else if (a_index == 1.0) {
    offsetPx += halfSizePx * vec2(1., -1.);
  } else if (a_index == 2.0) {
    offsetPx += halfSizePx;
  } else {
    offsetPx += halfSizePx * vec2(-1., 1.);
  }
  float angle = ${this.symbolRotationExpression_};
  ${this.symbolRotateWithView_ ? "angle += u_rotation;" : ""}
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  v_hitColor = a_hitColor;
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); 
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.varyings_.map(function(e) {
        return "  " + e.name + " = " + e.expression + ";";
      }).join(`
`)}
}` : null;
    }
    /**
     * Generates a symbol fragment shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getSymbolFragmentShader() {
      return this.hasSymbol_ ? `${Rc}
${this.uniforms_.map(function(e) {
        return "uniform " + e + ";";
      }).join(`
`)}
varying vec2 v_texCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(e) {
        return "varying " + e.type + " " + e.name + ";";
      }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

void main(void) {
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
    }
    /**
     * Generates a stroke vertex shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getStrokeVertexShader() {
      return this.hasStroke_ ? `${Rc}
${this.uniforms_.map(function(e) {
        return "uniform " + e + ";";
      }).join(`
`)}
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute float a_measureStart;
attribute float a_measureEnd;
attribute float a_parameters;
attribute float a_distance;
attribute vec2 a_joinAngles;
attribute vec4 a_hitColor;
${this.attributes_.map(function(e) {
        return "attribute " + e + ";";
      }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
${this.varyings_.map(function(e) {
        return "varying " + e.type + " " + e.name + ";";
      }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);
  currentLineMetric = vertexNumber < 1.5 ? a_measureStart : a_measureEnd;
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)
  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);
  
  // compute current vertex position
  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;
  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${VT} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_width = lineWidth;
  v_hitColor = a_hitColor;
  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);
  v_measureStart = a_measureStart;
  v_measureEnd = a_measureEnd;
${this.varyings_.map(function(e) {
        return "  " + e.name + " = " + e.expression + ";";
      }).join(`
`)}
}` : null;
    }
    /**
     * Generates a stroke fragment shader from the builder parameters
     *
     * @return {string|null} The full shader as a string; null if no size or color specified
     */
    getStrokeFragmentShader() {
      return this.hasStroke_ ? `${Rc}
${this.uniforms_.map(function(e) {
        return "uniform " + e + ";";
      }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
varying float v_measureStart;
varying float v_measureEnd;
${this.varyings_.map(function(e) {
        return "varying " + e.type + " " + e.name + ";";
      }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${VT}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${ta("butt")}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${ta("square")}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${ta("bevel")}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${ta("miter")}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

void main(void) {
  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPoint);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif

  float segmentLength = length(v_segmentEnd - v_segmentStart);
  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPoint = currentPoint - v_segmentStart;
  float lengthToPoint = max(0., min(dot(segmentTangent, startToPoint), segmentLength));
  float currentLengthPx = lengthToPoint + v_distanceOffsetPx; 
  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));
  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;
  currentLineMetric = mix(v_measureStart, v_measureEnd, lengthToPoint / segmentLength);

  if (${this.discardExpression_}) { discard; }

  vec4 color = ${this.strokeColorExpression_};
  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);
  float distance = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distance = max(distance, ${this.strokeDistanceFieldExpression_});
  color.a *= smoothstep(0.5, -0.5, distance);
  gl_FragColor = color;
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
    }
    /**
     * Generates a fill vertex shader from the builder parameters
     *
     * @return {string|null} The full shader as a string; null if no color specified
     */
    getFillVertexShader() {
      return this.hasFill_ ? `${Rc}
${this.uniforms_.map(function(e) {
        return "uniform " + e + ";";
      }).join(`
`)}
attribute vec2 a_position;
attribute vec4 a_hitColor;
${this.attributes_.map(function(e) {
        return "attribute " + e + ";";
      }).join(`
`)}
varying vec4 v_hitColor;
${this.varyings_.map(function(e) {
        return "varying " + e.type + " " + e.name + ";";
      }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_hitColor = a_hitColor;
${this.varyings_.map(function(e) {
        return "  " + e.name + " = " + e.expression + ";";
      }).join(`
`)}
}` : null;
    }
    /**
     * Generates a fill fragment shader from the builder parameters
     * @return {string|null} The full shader as a string; null if no color specified
     */
    getFillFragmentShader() {
      return this.hasFill_ ? `${Rc}
${this.uniforms_.map(function(e) {
        return "uniform " + e + ";";
      }).join(`
`)}
varying vec4 v_hitColor;
${this.varyings_.map(function(e) {
        return "varying " + e.type + " " + e.name + ";";
      }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_};
  gl_FragColor.a *= u_globalAlpha;
  gl_FragColor.rgb *= gl_FragColor.a;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}` : null;
    }
  }
  function wt(t, e, i) {
    const r = Zv();
    return Ble(
      e,
      i,
      r,
      t
    );
  }
  function Ch(t) {
    const e = Hn(t), i = e[0] * 256, r = e[1], n = e[2] * 256, s = Math.round(e[3] * 255);
    return [i + r, n + s];
  }
  const ble = `vec4 unpackColor(vec2 packedColor) {
  return vec4(
    fract(floor(packedColor[0] / 256.0) / 256.0),
    fract(packedColor[0] / 256.0),
    fract(floor(packedColor[1] / 256.0) / 256.0),
    fract(packedColor[1] / 256.0)
  );
}`;
  function Kb(t) {
    return t === Qi || t === Ns ? 2 : t === tn ? 4 : 1;
  }
  function xp(t) {
    const e = Kb(t);
    return e > 1 ? (
      /** @type {'vec2'|'vec3'|'vec4'} */
      `vec${e}`
    ) : "float";
  }
  function VE(t) {
    return (JSON.stringify(t).split("").reduce((i, r) => (i << 5) - i + r.charCodeAt(0), 0) >>> 0).toString();
  }
  function Ux(t, e, i, r) {
    if (`${r}radius` in t && r !== "icon-") {
      let n = wt(
        i,
        t[`${r}radius`],
        Ve
      );
      if (`${r}radius2` in t) {
        const s = wt(
          i,
          t[`${r}radius2`],
          Ve
        );
        n = `max(${n}, ${s})`;
      }
      `${r}stroke-width` in t && (n = `(${n} + ${wt(
        i,
        t[`${r}stroke-width`],
        Ve
      )} * 0.5)`), e.setSymbolSizeExpression(`vec2(${n} * 2. + 0.5)`);
    }
    if (`${r}scale` in t) {
      const n = wt(
        i,
        t[`${r}scale`],
        Ns
      );
      e.setSymbolSizeExpression(
        `${e.getSymbolSizeExpression()} * ${n}`
      );
    }
    `${r}displacement` in t && e.setSymbolOffsetExpression(
      wt(
        i,
        t[`${r}displacement`],
        tn
      )
    ), `${r}rotation` in t && e.setSymbolRotationExpression(
      wt(i, t[`${r}rotation`], Ve)
    ), `${r}rotate-with-view` in t && e.setSymbolRotateWithView(!!t[`${r}rotate-with-view`]);
  }
  function sP(t, e, i, r, n) {
    let s = "vec4(0.)";
    if (e !== null && (s = e), i !== null && r !== null) {
      const A = `smoothstep(-${r} + 0.63, -${r} - 0.58, ${t})`;
      s = `mix(${i}, ${s}, ${A})`;
    }
    const o = `(1.0 - smoothstep(-0.63, 0.58, ${t}))`;
    let a = `${s} * vec4(1.0, 1.0, 1.0, ${o})`;
    return n !== null && (a = `${a} * vec4(1.0, 1.0, 1.0, ${n})`), a;
  }
  function Lx(t, e, i, r, n) {
    const s = new Image();
    s.crossOrigin = t[`${r}cross-origin`] === void 0 ? "anonymous" : t[`${r}cross-origin`], s.src = t[`${r}src`], i[`u_texture${n}_size`] = () => s.complete ? [s.width, s.height] : [0, 0], e.addUniform(`vec2 u_texture${n}_size`);
    const o = `u_texture${n}_size`;
    return i[`u_texture${n}`] = s, e.addUniform(`sampler2D u_texture${n}`), o;
  }
  function zx(t, e, i, r, n) {
    let s = wt(
      i,
      t[`${e}offset`],
      tn
    );
    if (`${e}offset-origin` in t)
      switch (t[`${e}offset-origin`]) {
        case "top-right":
          s = `vec2(${r}.x, 0.) + ${n} * vec2(-1., 0.) + ${s} * vec2(-1., 1.)`;
          break;
        case "bottom-left":
          s = `vec2(0., ${r}.y) + ${n} * vec2(0., -1.) + ${s} * vec2(1., -1.)`;
          break;
        case "bottom-right":
          s = `${r} - ${n} - ${s}`;
          break;
      }
    return s;
  }
  function Mle(t, e, i, r, n) {
    n.functions.circleDistanceField = `float circleDistanceField(vec2 point, float radius) {
  return length(point) - radius;
}`, Ux(t, e, r, "circle-");
    let s = null;
    "circle-opacity" in t && (s = wt(
      n,
      t["circle-opacity"],
      Ve
    ));
    let o = "coordsPx";
    "circle-scale" in t && (o = `coordsPx / ${wt(
      n,
      t["circle-scale"],
      Ns
    )}`);
    let a = null;
    "circle-fill-color" in t && (a = wt(
      n,
      t["circle-fill-color"],
      Qi
    ));
    let A = null;
    "circle-stroke-color" in t && (A = wt(
      n,
      t["circle-stroke-color"],
      Qi
    ));
    let l = wt(
      n,
      t["circle-radius"],
      Ve
    ), c = null;
    "circle-stroke-width" in t && (c = wt(
      n,
      t["circle-stroke-width"],
      Ve
    ), l = `(${l} + ${c} * 0.5)`);
    const u = `circleDistanceField(${o}, ${l})`, d = sP(
      u,
      a,
      A,
      c,
      s
    );
    e.setSymbolColorExpression(d);
  }
  function Ile(t, e, i, r, n) {
    n.functions.round = `float round(float v) {
  return sign(v) * floor(abs(v) + 0.5);
}`, n.functions.starDistanceField = `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round(beta / alpha) * alpha; // angle in sector
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  vec2 tipToPoint = inSector + vec2(-radius, 0.);
  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);
  return dot(normalize(edgeNormal), tipToPoint);
}`, n.functions.regularDistanceField = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float radiusIn = radius * cos(PI / numPoints);
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  return inSector.x - radiusIn;
}`, Ux(t, e, r, "shape-");
    let s = null;
    "shape-opacity" in t && (s = wt(n, t["shape-opacity"], Ve));
    let o = "coordsPx";
    "shape-scale" in t && (o = `coordsPx / ${wt(n, t["shape-scale"], Ns)}`);
    let a = null;
    "shape-fill-color" in t && (a = wt(
      n,
      t["shape-fill-color"],
      Qi
    ));
    let A = null;
    "shape-stroke-color" in t && (A = wt(
      n,
      t["shape-stroke-color"],
      Qi
    ));
    let l = null;
    "shape-stroke-width" in t && (l = wt(
      n,
      t["shape-stroke-width"],
      Ve
    ));
    const c = wt(
      n,
      t["shape-points"],
      Ve
    );
    let u = "0.";
    "shape-angle" in t && (u = wt(n, t["shape-angle"], Ve));
    let d, h = wt(n, t["shape-radius"], Ve);
    if (l !== null && (h = `${h} + ${l} * 0.5`), "shape-radius2" in t) {
      let f = wt(
        n,
        t["shape-radius2"],
        Ve
      );
      l !== null && (f = `${f} + ${l} * 0.5`), d = `starDistanceField(${o}, ${c}, ${h}, ${f}, ${u})`;
    } else
      d = `regularDistanceField(${o}, ${c}, ${h}, ${u})`;
    const g = sP(
      d,
      a,
      A,
      l,
      s
    );
    e.setSymbolColorExpression(g);
  }
  function vle(t, e, i, r, n) {
    let s = "vec4(1.0)";
    "icon-color" in t && (s = wt(n, t["icon-color"], Qi)), "icon-opacity" in t && (s = `${s} * vec4(1.0, 1.0, 1.0, ${wt(
      n,
      t["icon-opacity"],
      Ve
    )})`);
    const o = VE(t["icon-src"]), a = Lx(
      t,
      e,
      i,
      "icon-",
      o
    );
    if (e.setSymbolColorExpression(
      `${s} * texture2D(u_texture${o}, v_texCoord)`
    ).setSymbolSizeExpression(a), "icon-width" in t && "icon-height" in t && e.setSymbolSizeExpression(
      `vec2(${wt(
        r,
        t["icon-width"],
        Ve
      )}, ${wt(r, t["icon-height"], Ve)})`
    ), "icon-offset" in t && "icon-size" in t) {
      const A = wt(
        r,
        t["icon-size"],
        tn
      ), l = e.getSymbolSizeExpression();
      e.setSymbolSizeExpression(A);
      const c = zx(
        t,
        "icon-",
        r,
        "v_quadSizePx",
        A
      );
      e.setTextureCoordinateExpression(
        `(vec4((${c}).xyxy) + vec4(0., 0., ${A})) / (${l}).xyxy`
      );
    }
    if (Ux(t, e, r, "icon-"), "icon-anchor" in t) {
      const A = wt(
        r,
        t["icon-anchor"],
        tn
      );
      let l = "1.0";
      "icon-scale" in t && (l = wt(r, t["icon-scale"], Ns));
      let c;
      t["icon-anchor-x-units"] === "pixels" && t["icon-anchor-y-units"] === "pixels" ? c = `${A} * ${l}` : t["icon-anchor-x-units"] === "pixels" ? c = `${A} * vec2(vec2(${l}).x, v_quadSizePx.y)` : t["icon-anchor-y-units"] === "pixels" ? c = `${A} * vec2(v_quadSizePx.x, vec2(${l}).x)` : c = `${A} * v_quadSizePx`;
      let u = `v_quadSizePx * vec2(0.5, -0.5) + ${c} * vec2(-1., 1.)`;
      if ("icon-anchor-origin" in t)
        switch (t["icon-anchor-origin"]) {
          case "top-right":
            u = `v_quadSizePx * -0.5 + ${c}`;
            break;
          case "bottom-left":
            u = `v_quadSizePx * 0.5 - ${c}`;
            break;
          case "bottom-right":
            u = `v_quadSizePx * vec2(-0.5, 0.5) + ${c} * vec2(1., -1.)`;
            break;
        }
      e.setSymbolOffsetExpression(
        `${e.getSymbolOffsetExpression()} + ${u}`
      );
    }
  }
  function xle(t, e, i, r, n) {
    if ("stroke-color" in t && e.setStrokeColorExpression(
      wt(n, t["stroke-color"], Qi)
    ), "stroke-pattern-src" in t) {
      const s = VE(t["stroke-pattern-src"]), o = Lx(
        t,
        e,
        i,
        "stroke-pattern-",
        s
      );
      let a = o, A = "vec2(0.)";
      "stroke-pattern-offset" in t && "stroke-pattern-size" in t && (a = wt(
        n,
        t["stroke-pattern-size"],
        tn
      ), A = zx(
        t,
        "stroke-pattern-",
        n,
        o,
        a
      ));
      let l = "0.";
      "stroke-pattern-spacing" in t && (l = wt(
        n,
        t["stroke-pattern-spacing"],
        Ve
      )), n.functions.sampleStrokePattern = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {
  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;
  float spacingScaled = spacingPx * sampleSize.y / lineWidth;
  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));
  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);
  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
  return texture2D(texture, texCoord);
}`;
      const c = `u_texture${s}`;
      let u = "1.";
      "stroke-color" in t && (u = e.getStrokeColorExpression()), e.setStrokeColorExpression(
        `${u} * sampleStrokePattern(${c}, ${o}, ${A}, ${a}, ${l}, currentLengthPx, currentRadiusRatio, v_width)`
      );
    }
    if ("stroke-width" in t && e.setStrokeWidthExpression(
      wt(r, t["stroke-width"], Ve)
    ), "stroke-offset" in t && e.setStrokeOffsetExpression(
      wt(r, t["stroke-offset"], Ve)
    ), "stroke-line-cap" in t && e.setStrokeCapExpression(
      wt(r, t["stroke-line-cap"], sr)
    ), "stroke-line-join" in t && e.setStrokeJoinExpression(
      wt(r, t["stroke-line-join"], sr)
    ), "stroke-miter-limit" in t && e.setStrokeMiterLimitExpression(
      wt(r, t["stroke-miter-limit"], Ve)
    ), "stroke-line-dash" in t) {
      n.functions.getSingleDashDistance = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == ${ta("square")}) {
    distanceSegment -= v_width * 0.5;
  } else if (capType == ${ta("round")}) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);
  }
  return distanceSegment;
}`;
      let s = t["stroke-line-dash"].map(
        (h) => wt(n, h, Ve)
      );
      s.length % 2 === 1 && (s = [...s, ...s]);
      let o = "0.";
      "stroke-line-dash-offset" in t && (o = wt(
        r,
        t["stroke-line-dash-offset"],
        Ve
      ));
      const A = `dashDistanceField_${VE(t["stroke-line-dash"])}`, l = s.map(
        (h, g) => `float dashLength${g} = ${h};`
      ), c = s.map((h, g) => `dashLength${g}`).join(" + ");
      let u = "0.", d = `getSingleDashDistance(distance, radius, ${u}, dashLength0, totalDashLength, capType)`;
      for (let h = 2; h < s.length; h += 2)
        u = `${u} + dashLength${h - 2} + dashLength${h - 1}`, d = `min(${d}, getSingleDashDistance(distance, radius, ${u}, dashLength${h}, totalDashLength, capType))`;
      n.functions[A] = `float ${A}(float distance, float radius, float capType) {
  ${l.join(`
  `)}
  float totalDashLength = ${c};
  return ${d};
}`, e.setStrokeDistanceFieldExpression(
        `${A}(currentLengthPx + ${o}, currentRadiusPx, capType)`
      );
    }
  }
  function Qle(t, e, i, r, n) {
    if ("fill-color" in t && e.setFillColorExpression(
      wt(n, t["fill-color"], Qi)
    ), "fill-pattern-src" in t) {
      const s = VE(t["fill-pattern-src"]), o = Lx(
        t,
        e,
        i,
        "fill-pattern-",
        s
      );
      let a = o, A = "vec2(0.)";
      "fill-pattern-offset" in t && "fill-pattern-size" in t && (a = wt(
        n,
        t["fill-pattern-size"],
        tn
      ), A = zx(
        t,
        "fill-pattern-",
        n,
        o,
        a
      )), n.functions.sampleFillPattern = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {
  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);
  vec2 pxRelativePos = pxPosition - pxOrigin;
  // rotate the relative position from origin by the current view rotation
  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));
  // sample position is computed according to the sample offset & size
  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);
  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels
  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));
  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright
  return texture2D(texture, (samplePos + textureOffset) / textureSize);
}`;
      const l = `u_texture${s}`;
      let c = "1.";
      "fill-color" in t && (c = e.getFillColorExpression()), e.setFillColorExpression(
        `${c} * sampleFillPattern(${l}, ${o}, ${A}, ${a}, pxOrigin, pxPos)`
      );
    }
  }
  function RB(t, e) {
    const i = qT(), r = {
      ...qT(),
      inFragmentShader: !0,
      variables: i.variables
    }, n = new nP(), s = {};
    if ("icon-src" in t ? vle(t, n, s, i, r) : "shape-points" in t ? Ile(t, n, s, i, r) : "circle-radius" in t && Mle(t, n, s, i, r), xle(t, n, s, i, r), Qle(t, n, s, i, r), t.filter) {
      const A = wt(
        r,
        t.filter,
        Mr
      );
      n.setFragmentDiscardExpression(`!${A}`);
    }
    for (const A in r.variables) {
      const l = r.variables[A], c = tP(l.name);
      let u = xp(l.type);
      l.type === Qi && (u = "vec4"), n.addUniform(`${u} ${c}`), s[c] = () => {
        const d = e[l.name];
        return typeof d == "number" ? d : typeof d == "boolean" ? d ? 1 : 0 : l.type === Qi ? Hn(d || "#eee") : typeof d == "string" ? wh(d) : d;
      };
    }
    for (const A in r.properties) {
      const l = r.properties[A];
      i.properties[A] || (i.properties[A] = l);
      let c = xp(l.type), u = `a_prop_${l.name}`;
      l.type === Qi && (c = "vec4", u = `unpackColor(${u})`, n.addVertexShaderFunction(ble)), n.addVarying(`v_prop_${l.name}`, c, u);
    }
    for (const A in i.properties) {
      const l = i.properties[A];
      n.addAttribute(
        `${xp(l.type)} a_prop_${l.name}`
      );
    }
    for (const A in i.functions)
      n.addVertexShaderFunction(i.functions[A]);
    for (const A in r.functions)
      n.addFragmentShaderFunction(r.functions[A]);
    const o = {};
    for (const A in i.properties) {
      const l = i.properties[A], c = (u) => {
        const d = u.get(l.name);
        return l.type === Qi ? Ch([...Hn(d || "#eee")]) : typeof d == "string" ? wh(d) : typeof d == "boolean" ? d ? 1 : 0 : d;
      };
      o[`prop_${l.name}`] = {
        size: Kb(l.type),
        callback: c
      };
    }
    function a(A, l, c, u) {
      const d = i[A], h = r[A];
      if (!d && !h)
        return;
      const g = xp(c), f = Kb(c);
      n.addAttribute(`${g} a_${l}`), h && n.addVarying(`v_${l}`, g, `a_${l}`), o[l] = {
        size: f,
        callback: u
      };
    }
    return a(
      "geometryType",
      rP,
      sr,
      (A) => wh(qv(A.getGeometry()))
    ), a(
      "featureId",
      iP,
      sr | Ve,
      (A) => {
        const l = A.getId() ?? null;
        return typeof l == "string" ? wh(l) : l;
      }
    ), { builder: n, attributes: o, uniforms: s };
  }
  class Fle extends HA {
    /**
     * @param {Options<VectorSourceType>} options Options.
     */
    constructor(e) {
      const i = Object.assign({}, e);
      super(i), this.styleVariables_ = e.variables || {}, this.parseResult_ = RB(e.style, this.styleVariables_), this.hitDetectionDisabled_ = !!e.disableHitDetection;
    }
    /**
     * @override
     */
    createRenderer() {
      const e = Object.keys(this.parseResult_.attributes).map(
        (i) => ({
          name: i,
          ...this.parseResult_.attributes[i]
        })
      );
      return new cle(this, {
        vertexShader: this.parseResult_.builder.getSymbolVertexShader(),
        fragmentShader: this.parseResult_.builder.getSymbolFragmentShader(),
        hitDetectionEnabled: !this.hitDetectionDisabled_,
        uniforms: this.parseResult_.uniforms,
        attributes: (
          /** @type {Array<import('../renderer/webgl/PointsLayer.js').CustomAttribute>} */
          e
        )
      });
    }
    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {Object<string, number>} variables Variables to update.
     */
    updateStyleVariables(e) {
      Object.assign(this.styleVariables_, e), this.changed();
    }
  }
  class oP {
    constructor() {
      this.globalCounter_ = 0, this.refToFeature_ = /* @__PURE__ */ new Map(), this.uidToRef_ = /* @__PURE__ */ new Map(), this.freeGlobalRef_ = [], this.polygonBatch = {
        entries: {},
        geometriesCount: 0,
        verticesCount: 0,
        ringsCount: 0
      }, this.pointBatch = {
        entries: {},
        geometriesCount: 0
      }, this.lineStringBatch = {
        entries: {},
        geometriesCount: 0,
        verticesCount: 0
      };
    }
    /**
     * @param {Array<Feature|RenderFeature>} features Array of features to add to the batch
     * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
     */
    addFeatures(e, i) {
      for (let r = 0; r < e.length; r++)
        this.addFeature(e[r], i);
    }
    /**
     * @param {Feature|RenderFeature} feature Feature to add to the batch
     * @param {import("../../proj.js").TransformFunction} [projectionTransform] Projection transform.
     */
    addFeature(e, i) {
      let r = e.getGeometry();
      r && (i && (r = r.clone(), r.applyTransform(i)), this.addGeometry_(r, e));
    }
    /**
     * @param {Feature|RenderFeature} feature Feature
     * @return {GeometryBatchItem|void} the cleared entry
     * @private
     */
    clearFeatureEntryInPointBatch_(e) {
      const i = ve(e), r = this.pointBatch.entries[i];
      if (r)
        return this.pointBatch.geometriesCount -= r.flatCoordss.length, delete this.pointBatch.entries[i], r;
    }
    /**
     * @param {Feature|RenderFeature} feature Feature
     * @return {GeometryBatchItem|void} the cleared entry
     * @private
     */
    clearFeatureEntryInLineStringBatch_(e) {
      const i = ve(e), r = this.lineStringBatch.entries[i];
      if (r)
        return this.lineStringBatch.verticesCount -= r.verticesCount, this.lineStringBatch.geometriesCount -= r.flatCoordss.length, delete this.lineStringBatch.entries[i], r;
    }
    /**
     * @param {Feature|RenderFeature} feature Feature
     * @return {GeometryBatchItem|void} the cleared entry
     * @private
     */
    clearFeatureEntryInPolygonBatch_(e) {
      const i = ve(e), r = this.polygonBatch.entries[i];
      if (r)
        return this.polygonBatch.verticesCount -= r.verticesCount, this.polygonBatch.ringsCount -= r.ringsCount, this.polygonBatch.geometriesCount -= r.flatCoordss.length, delete this.polygonBatch.entries[i], r;
    }
    /**
     * @param {import("../../geom.js").Geometry|RenderFeature} geometry Geometry
     * @param {Feature|RenderFeature} feature Feature
     * @private
     */
    addGeometry_(e, i) {
      var n;
      const r = e.getType();
      switch (r) {
        case "GeometryCollection": {
          const s = (
            /** @type {import("../../geom.js").GeometryCollection} */
            e.getGeometriesArray()
          );
          for (const o of s)
            this.addGeometry_(o, i);
          break;
        }
        case "MultiPolygon": {
          const s = (
            /** @type {import("../../geom.js").MultiPolygon} */
            e
          );
          this.addCoordinates_(
            r,
            s.getFlatCoordinates(),
            s.getEndss(),
            i,
            ve(i),
            s.getStride()
          );
          break;
        }
        case "MultiLineString": {
          const s = (
            /** @type {import("../../geom.js").MultiLineString|RenderFeature} */
            e
          );
          this.addCoordinates_(
            r,
            s.getFlatCoordinates(),
            s.getEnds(),
            i,
            ve(i),
            s.getStride()
          );
          break;
        }
        case "MultiPoint": {
          const s = (
            /** @type {import("../../geom.js").MultiPoint|RenderFeature} */
            e
          );
          this.addCoordinates_(
            r,
            s.getFlatCoordinates(),
            null,
            i,
            ve(i),
            s.getStride()
          );
          break;
        }
        case "Polygon": {
          const s = (
            /** @type {import("../../geom.js").Polygon|RenderFeature} */
            e
          );
          this.addCoordinates_(
            r,
            s.getFlatCoordinates(),
            s.getEnds(),
            i,
            ve(i),
            s.getStride()
          );
          break;
        }
        case "Point": {
          const s = (
            /** @type {import("../../geom.js").Point} */
            e
          );
          this.addCoordinates_(
            r,
            s.getFlatCoordinates(),
            null,
            i,
            ve(i),
            s.getStride()
          );
          break;
        }
        case "LineString":
        case "LinearRing": {
          const s = (
            /** @type {import("../../geom.js").LineString} */
            e
          ), o = s.getStride();
          this.addCoordinates_(
            r,
            s.getFlatCoordinates(),
            null,
            i,
            ve(i),
            o,
            (n = s.getLayout) == null ? void 0 : n.call(s)
          );
          break;
        }
      }
    }
    /**
     * @param {GeometryType} type Geometry type
     * @param {Array<number>} flatCoords Flat coordinates
     * @param {Array<number> | Array<Array<number>> | null} ends Coordinate ends
     * @param {Feature|RenderFeature} feature Feature
     * @param {string} featureUid Feature uid
     * @param {number} stride Stride
     * @param {import('../../geom/Geometry.js').GeometryLayout} [layout] Layout
     * @private
     */
    addCoordinates_(e, i, r, n, s, o, a) {
      let A;
      switch (e) {
        case "MultiPolygon": {
          const l = (
            /** @type {Array<Array<number>>} */
            r
          );
          for (let c = 0, u = l.length; c < u; c++) {
            let d = l[c];
            const h = c > 0 ? l[c - 1] : null, g = h ? h[h.length - 1] : 0, f = d[d.length - 1];
            d = g > 0 ? d.map((p) => p - g) : d, this.addCoordinates_(
              "Polygon",
              i.slice(g, f),
              d,
              n,
              s,
              o,
              a
            );
          }
          break;
        }
        case "MultiLineString": {
          const l = (
            /** @type {Array<number>} */
            r
          );
          for (let c = 0, u = l.length; c < u; c++) {
            const d = c > 0 ? l[c - 1] : 0;
            this.addCoordinates_(
              "LineString",
              i.slice(d, l[c]),
              null,
              n,
              s,
              o,
              a
            );
          }
          break;
        }
        case "MultiPoint":
          for (let l = 0, c = i.length; l < c; l += o)
            this.addCoordinates_(
              "Point",
              i.slice(l, l + 2),
              null,
              n,
              s,
              null,
              null
            );
          break;
        case "Polygon": {
          const l = (
            /** @type {Array<number>} */
            r
          );
          if (n instanceof Ir) {
            const d = Rv(i, l);
            if (d.length > 1) {
              this.addCoordinates_(
                "MultiPolygon",
                i,
                d,
                n,
                s,
                o,
                a
              );
              return;
            }
          }
          this.polygonBatch.entries[s] || (this.polygonBatch.entries[s] = this.addRefToEntry_(
            s,
            {
              feature: n,
              flatCoordss: [],
              verticesCount: 0,
              ringsCount: 0,
              ringsVerticesCounts: []
            }
          )), A = i.length / o;
          const c = r.length, u = r.map(
            (d, h, g) => h > 0 ? (d - g[h - 1]) / o : d / o
          );
          this.polygonBatch.verticesCount += A, this.polygonBatch.ringsCount += c, this.polygonBatch.geometriesCount++, this.polygonBatch.entries[s].flatCoordss.push(
            Sle(i, o)
          ), this.polygonBatch.entries[s].ringsVerticesCounts.push(
            u
          ), this.polygonBatch.entries[s].verticesCount += A, this.polygonBatch.entries[s].ringsCount += c;
          for (let d = 0, h = l.length; d < h; d++) {
            const g = d > 0 ? l[d - 1] : 0;
            this.addCoordinates_(
              "LinearRing",
              i.slice(g, l[d]),
              null,
              n,
              s,
              o,
              a
            );
          }
          break;
        }
        case "Point":
          this.pointBatch.entries[s] || (this.pointBatch.entries[s] = this.addRefToEntry_(
            s,
            {
              feature: n,
              flatCoordss: []
            }
          )), this.pointBatch.geometriesCount++, this.pointBatch.entries[s].flatCoordss.push(i);
          break;
        case "LineString":
        case "LinearRing":
          this.lineStringBatch.entries[s] || (this.lineStringBatch.entries[s] = this.addRefToEntry_(
            s,
            {
              feature: n,
              flatCoordss: [],
              verticesCount: 0
            }
          )), A = i.length / o, this.lineStringBatch.verticesCount += A, this.lineStringBatch.geometriesCount++, this.lineStringBatch.entries[s].flatCoordss.push(
            Dle(i, o, a)
          ), this.lineStringBatch.entries[s].verticesCount += A;
          break;
      }
    }
    /**
     * @param {string} featureUid Feature uid
     * @param {GeometryBatchItem} entry The entry to add
     * @return {GeometryBatchItem} the added entry
     * @private
     */
    addRefToEntry_(e, i) {
      const r = this.uidToRef_.get(e), n = r || this.freeGlobalRef_.pop() || ++this.globalCounter_;
      return i.ref = n, r || (this.refToFeature_.set(n, i.feature), this.uidToRef_.set(e, n)), i;
    }
    /**
     * Return a ref to the pool of available refs.
     * @param {number} ref the ref to return
     * @param {string} featureUid the feature uid
     * @private
     */
    returnRef_(e, i) {
      if (!e)
        throw new Error("This feature has no ref: " + i);
      this.refToFeature_.delete(e), this.uidToRef_.delete(i), this.freeGlobalRef_.push(e);
    }
    /**
     * @param {Feature|RenderFeature} feature Feature
     */
    changeFeature(e) {
      this.removeFeature(e);
      const i = e.getGeometry();
      i && this.addGeometry_(i, e);
    }
    /**
     * @param {Feature|RenderFeature} feature Feature
     */
    removeFeature(e) {
      let i;
      i = this.clearFeatureEntryInPointBatch_(e) || i, i = this.clearFeatureEntryInPolygonBatch_(e) || i, i = this.clearFeatureEntryInLineStringBatch_(e) || i, i && this.returnRef_(i.ref, ve(i.feature));
    }
    clear() {
      this.polygonBatch.entries = {}, this.polygonBatch.geometriesCount = 0, this.polygonBatch.verticesCount = 0, this.polygonBatch.ringsCount = 0, this.lineStringBatch.entries = {}, this.lineStringBatch.geometriesCount = 0, this.lineStringBatch.verticesCount = 0, this.pointBatch.entries = {}, this.pointBatch.geometriesCount = 0, this.globalCounter_ = 0, this.freeGlobalRef_ = [], this.refToFeature_.clear(), this.uidToRef_.clear();
    }
    /**
     * Resolve the feature associated to a ref.
     * @param {number} ref Hit detected ref
     * @return {Feature|RenderFeature} feature
     */
    getFeatureFromRef(e) {
      return this.refToFeature_.get(e);
    }
  }
  function Sle(t, e) {
    return e === 2 ? t : t.filter((i, r) => r % e < 2);
  }
  function Dle(t, e, i) {
    return e === 3 && i === "XYM" ? t : e === 4 ? t.filter((r, n) => n % e !== 2) : e === 3 ? t.map((r, n) => n % e !== 2 ? r : 0) : new Array(t.length * 1.5).fill(0).map((r, n) => n % 3 === 2 ? 0 : t[Math.round(n / 1.5)]);
  }
  function Px(t, e, i, r) {
    let n = 0;
    for (const s in e) {
      const o = e[s], a = o.callback.call(i, i.feature);
      t[r + n++] = a[0] ?? a, !(!o.size || o.size === 1) && (t[r + n++] = a[1], !(o.size < 3) && (t[r + n++] = a[2], !(o.size < 4) && (t[r + n++] = a[3])));
    }
    return n;
  }
  function _B(t) {
    return Object.keys(t).reduce(
      (e, i) => e + (t[i].size || 1),
      0
    );
  }
  function Tle(t, e, i, r) {
    const n = (2 + _B(i)) * t.geometriesCount;
    (!e || e.length !== n) && (e = new Float32Array(n));
    const s = [];
    let o = 0;
    for (const a in t.entries) {
      const A = t.entries[a];
      for (let l = 0, c = A.flatCoordss.length; l < c; l++)
        s[0] = A.flatCoordss[l][0], s[1] = A.flatCoordss[l][1], Ei(r, s), e[o++] = s[0], e[o++] = s[1], o += Px(
          e,
          i,
          A,
          o
        );
    }
    return e;
  }
  function Rle(t, e, i, r) {
    const n = 3 * t.verticesCount + (1 + _B(i)) * t.geometriesCount;
    (!e || e.length !== n) && (e = new Float32Array(n));
    const s = [];
    let o = 0;
    for (const a in t.entries) {
      const A = t.entries[a];
      for (let l = 0, c = A.flatCoordss.length; l < c; l++) {
        s.length = A.flatCoordss[l].length, So(
          A.flatCoordss[l],
          0,
          s.length,
          3,
          r,
          s,
          3
        ), o += Px(
          e,
          i,
          A,
          o
        ), e[o++] = s.length / 3;
        for (let u = 0, d = s.length; u < d; u += 3)
          e[o++] = s[u], e[o++] = s[u + 1], e[o++] = s[u + 2];
      }
    }
    return e;
  }
  function _le(t, e, i, r) {
    const n = 2 * t.verticesCount + (1 + _B(i)) * t.geometriesCount + t.ringsCount;
    (!e || e.length !== n) && (e = new Float32Array(n));
    const s = [];
    let o = 0;
    for (const a in t.entries) {
      const A = t.entries[a];
      for (let l = 0, c = A.flatCoordss.length; l < c; l++) {
        s.length = A.flatCoordss[l].length, So(
          A.flatCoordss[l],
          0,
          s.length,
          2,
          r,
          s
        ), o += Px(
          e,
          i,
          A,
          o
        ), e[o++] = A.ringsVerticesCounts[l].length;
        for (let u = 0, d = A.ringsVerticesCounts[l].length; u < d; u++)
          e[o++] = A.ringsVerticesCounts[l][u];
        for (let u = 0, d = s.length; u < d; u += 2)
          e[o++] = s[u], e[o++] = s[u + 1];
      }
    }
    return e;
  }
  const kle = [], rC = $z();
  let Yle = 0;
  const co = {
    POSITION: "a_position",
    INDEX: "a_index",
    SEGMENT_START: "a_segmentStart",
    SEGMENT_END: "a_segmentEnd",
    MEASURE_START: "a_measureStart",
    MEASURE_END: "a_measureEnd",
    PARAMETERS: "a_parameters",
    JOIN_ANGLES: "a_joinAngles",
    DISTANCE: "a_distance"
  };
  class aP {
    /**
     * @param {VectorStyle} styleOrShaders Literal style or custom shaders
     * @param {import('../../style/flat.js').StyleVariables} variables Style variables
     * @param {import('../../webgl/Helper.js').default} helper Helper
     * @param {boolean} enableHitDetection Whether to enable the hit detection (needs compatible shader)
     */
    constructor(e, i, r, n) {
      this.helper_, this.hitDetectionEnabled_ = n;
      let s = (
        /** @type {StyleShaders} */
        e
      );
      if (!("builder" in e)) {
        const l = RB(
          /** @type {import('../../style/webgl.js').WebGLStyle} */
          e,
          i
        );
        s = {
          builder: l.builder,
          attributes: l.attributes,
          uniforms: l.uniforms
        };
      }
      this.fillProgram_, this.strokeProgram_, this.symbolProgram_, this.hasFill_ = !!s.builder.getFillVertexShader(), this.hasFill_ && (this.fillVertexShader_ = s.builder.getFillVertexShader(), this.fillFragmentShader_ = s.builder.getFillFragmentShader()), this.hasStroke_ = !!s.builder.getStrokeVertexShader(), this.hasStroke_ && (this.strokeVertexShader_ = s.builder.getStrokeVertexShader(), this.strokeFragmentShader_ = s.builder.getStrokeFragmentShader()), this.hasSymbol_ = !!s.builder.getSymbolVertexShader(), this.hasSymbol_ && (this.symbolVertexShader_ = s.builder.getSymbolVertexShader(), this.symbolFragmentShader_ = s.builder.getSymbolFragmentShader());
      const a = this.hitDetectionEnabled_ ? {
        hitColor: {
          callback() {
            return Zz(this.ref, kle);
          },
          size: 4
        }
      } : {};
      this.customAttributes_ = Object.assign(
        {},
        a,
        s.attributes
      ), this.uniforms_ = s.uniforms;
      const A = Object.entries(this.customAttributes_).map(
        ([l, c]) => ({
          name: `a_${l}`,
          size: c.size || 1,
          type: Gi.FLOAT
        })
      );
      this.polygonAttributesDesc_ = [
        {
          name: co.POSITION,
          size: 2,
          type: Gi.FLOAT
        },
        ...A
      ], this.lineStringAttributesDesc_ = [
        {
          name: co.SEGMENT_START,
          size: 2,
          type: Gi.FLOAT
        },
        {
          name: co.MEASURE_START,
          size: 1,
          type: Gi.FLOAT
        },
        {
          name: co.SEGMENT_END,
          size: 2,
          type: Gi.FLOAT
        },
        {
          name: co.MEASURE_END,
          size: 1,
          type: Gi.FLOAT
        },
        {
          name: co.JOIN_ANGLES,
          size: 2,
          type: Gi.FLOAT
        },
        {
          name: co.DISTANCE,
          size: 1,
          type: Gi.FLOAT
        },
        {
          name: co.PARAMETERS,
          size: 1,
          type: Gi.FLOAT
        },
        ...A
      ], this.pointAttributesDesc_ = [
        {
          name: co.POSITION,
          size: 2,
          type: Gi.FLOAT
        },
        {
          name: co.INDEX,
          size: 1,
          type: Gi.FLOAT
        },
        ...A
      ], this.setHelper(r);
    }
    /**
     * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
     * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
     * @return {Promise<WebGLBuffers>} A promise resolving to WebGL buffers
     */
    async generateBuffers(e, i) {
      const r = this.generateRenderInstructions_(
        e,
        i
      ), [n, s, o] = await Promise.all(
        [
          this.generateBuffersForType_(
            r.polygonInstructions,
            "Polygon",
            i
          ),
          this.generateBuffersForType_(
            r.lineStringInstructions,
            "LineString",
            i
          ),
          this.generateBuffersForType_(
            r.pointInstructions,
            "Point",
            i
          )
        ]
      ), a = xA(
        ri(),
        i
      );
      return {
        polygonBuffers: n,
        lineStringBuffers: s,
        pointBuffers: o,
        invertVerticesTransform: a
      };
    }
    /**
     * @param {import('./MixedGeometryBatch.js').default} geometryBatch Geometry batch
     * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
     * @return {RenderInstructions} Render instructions
     * @private
     */
    generateRenderInstructions_(e, i) {
      const r = this.hasFill_ ? _le(
        e.polygonBatch,
        new Float32Array(0),
        this.customAttributes_,
        i
      ) : null, n = this.hasStroke_ ? Rle(
        e.lineStringBatch,
        new Float32Array(0),
        this.customAttributes_,
        i
      ) : null, s = this.hasSymbol_ ? Tle(
        e.pointBatch,
        new Float32Array(0),
        this.customAttributes_,
        i
      ) : null;
      return {
        polygonInstructions: r,
        lineStringInstructions: n,
        pointInstructions: s
      };
    }
    /**
     * @param {Float32Array|null} renderInstructions Render instructions
     * @param {import("../../geom/Geometry.js").Type} geometryType Geometry type
     * @param {import("../../transform.js").Transform} transform Transform to apply to coordinates
     * @return {Promise<Array<WebGLArrayBuffer>>|null} Indices buffer and vertices buffer; null if nothing to render
     * @private
     */
    generateBuffersForType_(e, i, r) {
      if (e === null)
        return null;
      const n = Yle++;
      let s;
      switch (i) {
        case "Polygon":
          s = Oh.GENERATE_POLYGON_BUFFERS;
          break;
        case "LineString":
          s = Oh.GENERATE_LINE_STRING_BUFFERS;
          break;
        case "Point":
          s = Oh.GENERATE_POINT_BUFFERS;
          break;
      }
      const o = {
        id: n,
        type: s,
        renderInstructions: e.buffer,
        renderInstructionsTransform: r,
        customAttributesSize: _B(this.customAttributes_)
      };
      return rC.postMessage(o, [e.buffer]), e = null, new Promise((a) => {
        const A = (l) => {
          const c = l.data;
          if (c.id !== n || (rC.removeEventListener("message", A), !this.helper_.getGL()))
            return;
          const u = new dd(
            Mf,
            HE
          ).fromArrayBuffer(c.vertexBuffer), d = new dd(
            If,
            HE
          ).fromArrayBuffer(c.indexBuffer);
          this.helper_.flushBufferData(u), this.helper_.flushBufferData(d), a([d, u]);
        };
        rC.addEventListener("message", A);
      });
    }
    /**
     * Render the geometries in the given buffers.
     * @param {WebGLBuffers} buffers WebGL Buffers to draw
     * @param {import("../../Map.js").FrameState} frameState Frame state
     * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
     */
    render(e, i, r) {
      this.hasFill_ && this.renderInternal_(
        e.polygonBuffers[0],
        e.polygonBuffers[1],
        this.fillProgram_,
        this.polygonAttributesDesc_,
        i,
        r
      ), this.hasStroke_ && this.renderInternal_(
        e.lineStringBuffers[0],
        e.lineStringBuffers[1],
        this.strokeProgram_,
        this.lineStringAttributesDesc_,
        i,
        r
      ), this.hasSymbol_ && this.renderInternal_(
        e.pointBuffers[0],
        e.pointBuffers[1],
        this.symbolProgram_,
        this.pointAttributesDesc_,
        i,
        r
      );
    }
    /**
     * @param {WebGLArrayBuffer} indicesBuffer Indices buffer
     * @param {WebGLArrayBuffer} verticesBuffer Vertices buffer
     * @param {WebGLProgram} program Program
     * @param {Array<import('../../webgl/Helper.js').AttributeDescription>} attributes Attribute descriptions
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {function(): void} preRenderCallback This callback will be called right before drawing, and can be used to set uniforms
     * @private
     */
    renderInternal_(e, i, r, n, s, o) {
      const a = e.getSize();
      a !== 0 && (this.helper_.useProgram(r, s), this.helper_.bindBuffer(i), this.helper_.bindBuffer(e), this.helper_.enableAttributes(n), o(), this.helper_.drawElements(0, a));
    }
    /**
     * @param {import('../../webgl/Helper.js').default} helper Helper
     * @param {WebGLBuffers} buffers WebGL Buffers to reload if any
     */
    setHelper(e, i = null) {
      this.helper_ = e, this.hasFill_ && (this.fillProgram_ = this.helper_.getProgram(
        this.fillFragmentShader_,
        this.fillVertexShader_
      )), this.hasStroke_ && (this.strokeProgram_ = this.helper_.getProgram(
        this.strokeFragmentShader_,
        this.strokeVertexShader_
      )), this.hasSymbol_ && (this.symbolProgram_ = this.helper_.getProgram(
        this.symbolFragmentShader_,
        this.symbolVertexShader_
      )), this.helper_.addUniforms(this.uniforms_), i && (i.polygonBuffers && (this.helper_.flushBufferData(i.polygonBuffers[0]), this.helper_.flushBufferData(i.polygonBuffers[1])), i.lineStringBuffers && (this.helper_.flushBufferData(i.lineStringBuffers[0]), this.helper_.flushBufferData(i.lineStringBuffers[1])), i.pointBuffers && (this.helper_.flushBufferData(i.pointBuffers[0]), this.helper_.flushBufferData(i.pointBuffers[1])));
    }
  }
  const kc = {
    ...Eo,
    RENDER_EXTENT: "u_renderExtent",
    // intersection of layer, source, and view extent
    PATTERN_ORIGIN: "u_patternOrigin",
    GLOBAL_ALPHA: "u_globalAlpha"
  };
  class Nle extends vf {
    /**
     * @param {import("../../layer/Layer.js").default} layer Layer.
     * @param {Options} options Options.
     */
    constructor(e, i) {
      const r = {
        [kc.RENDER_EXTENT]: [0, 0, 0, 0],
        [kc.PATTERN_ORIGIN]: [0, 0],
        [kc.GLOBAL_ALPHA]: 1
      };
      super(e, {
        uniforms: r,
        postProcesses: i.postProcesses
      }), this.hitDetectionEnabled_ = !i.disableHitDetection, this.hitRenderTarget_, this.sourceRevision_ = -1, this.previousExtent_ = yr(), this.currentTransform_ = ri(), this.tmpCoords_ = [0, 0], this.tmpTransform_ = ri(), this.tmpMat4_ = VA(), this.currentFrameStateTransform_ = ri(), this.styleVariables_ = {}, this.styles_ = [], this.styleRenderers_ = [], this.buffers_ = [], this.applyOptions_(i), this.batch_ = new oP(), this.initialFeaturesAdded_ = !1, this.sourceListenKeys_ = null;
    }
    /**
     * @private
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    addInitialFeatures_(e) {
      const i = this.getLayer().getSource();
      let r;
      this.batch_.addFeatures(i.getFeatures(), r), this.sourceListenKeys_ = [
        nt(
          i,
          Ii.ADDFEATURE,
          this.handleSourceFeatureAdded_.bind(this, r)
        ),
        nt(
          i,
          Ii.CHANGEFEATURE,
          this.handleSourceFeatureChanged_,
          this
        ),
        nt(
          i,
          Ii.REMOVEFEATURE,
          this.handleSourceFeatureDelete_,
          this
        ),
        nt(
          i,
          Ii.CLEAR,
          this.handleSourceFeatureClear_,
          this
        )
      ];
    }
    /**
     * @param {Options} options Options.
     * @private
     */
    applyOptions_(e) {
      this.styleVariables_ = e.variables, this.styles_ = Array.isArray(e.style) ? e.style : [e.style];
    }
    /**
     * @private
     */
    createRenderers_() {
      this.buffers_ = [], this.styleRenderers_ = this.styles_.map(
        (e) => new aP(
          e,
          this.styleVariables_,
          this.helper,
          this.hitDetectionEnabled_
        )
      );
    }
    /**
     * @override
     */
    reset(e) {
      this.applyOptions_(e), this.helper && this.createRenderers_(), super.reset(e);
    }
    /**
     * @override
     */
    afterHelperCreated() {
      this.styleRenderers_.length ? this.styleRenderers_.forEach(
        (e, i) => e.setHelper(this.helper, this.buffers_[i])
      ) : this.createRenderers_(), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new kx(this.helper));
    }
    /**
     * @param {import("../../proj.js").TransformFunction} projectionTransform Transform function.
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceFeatureAdded_(e, i) {
      const r = i.feature;
      this.batch_.addFeature(r, e);
    }
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceFeatureChanged_(e) {
      const i = e.feature;
      this.batch_.changeFeature(i);
    }
    /**
     * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */
    handleSourceFeatureDelete_(e) {
      const i = e.feature;
      this.batch_.removeFeature(i);
    }
    /**
     * @private
     */
    handleSourceFeatureClear_() {
      this.batch_.clear();
    }
    /**
     * @param {import("../../transform.js").Transform} batchInvertTransform Inverse of the transformation in which geometries are expressed
     * @private
     */
    applyUniforms_(e) {
      fE(this.tmpTransform_, this.currentFrameStateTransform_), sc(this.tmpTransform_, e), this.helper.setUniformMatrixValue(
        kc.PROJECTION_MATRIX,
        Bl(this.tmpMat4_, this.tmpTransform_)
      ), xA(this.tmpTransform_, this.tmpTransform_), this.helper.setUniformMatrixValue(
        kc.SCREEN_TO_WORLD_MATRIX,
        Bl(this.tmpMat4_, this.tmpTransform_)
      ), this.tmpCoords_[0] = 0, this.tmpCoords_[1] = 0, xA(this.tmpTransform_, e), Ei(this.tmpTransform_, this.tmpCoords_), this.helper.setUniformFloatVec2(kc.PATTERN_ORIGIN, this.tmpCoords_);
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     * @override
     */
    renderFrame(e) {
      const i = this.helper.getGL();
      this.preRender(i, e);
      const [r, n, s] = eP(
        e,
        this.getLayer()
      );
      this.helper.prepareDraw(e), this.renderWorlds(e, !1, r, n, s), this.helper.finalizeDraw(
        e,
        this.dispatchPreComposeEvent,
        this.dispatchPostComposeEvent
      );
      const o = this.helper.getCanvas();
      return this.hitDetectionEnabled_ && (this.renderWorlds(e, !0, r, n, s), this.hitRenderTarget_.clearCachedData()), this.postRender(i, e), o;
    }
    /**
     * Determine whether renderFrame should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrameInternal(e) {
      this.initialFeaturesAdded_ || (this.addInitialFeatures_(e), this.initialFeaturesAdded_ = !0);
      const i = this.getLayer(), r = i.getSource(), n = e.viewState, s = !e.viewHints[Ai.ANIMATING] && !e.viewHints[Ai.INTERACTING], o = !Zs(this.previousExtent_, e.extent), a = this.sourceRevision_ < r.getRevision();
      if (a && (this.sourceRevision_ = r.getRevision()), s && (o || a)) {
        const A = n.projection, l = n.resolution, c = i instanceof gf ? i.getRenderBuffer() : 0, u = $r(e.extent, c * l);
        r.loadFeatures(u, l, A), this.ready = !1;
        const d = this.helper.makeProjectionTransform(
          e,
          ri()
        ), h = this.styleRenderers_.map(
          (g, f) => g.generateBuffers(this.batch_, d).then((p) => {
            this.buffers_[f] && this.disposeBuffers(this.buffers_[f]), this.buffers_[f] = p;
          })
        );
        Promise.all(h).then(() => {
          this.ready = !0, this.getLayer().changed();
        }), this.previousExtent_ = e.extent.slice();
      }
      return !0;
    }
    /**
     * Render the world, either to the main framebuffer or to the hit framebuffer
     * @param {import("../../Map.js").FrameState} frameState current frame state
     * @param {boolean} forHitDetection whether the rendering is for hit detection
     * @param {number} startWorld the world to render in the first iteration
     * @param {number} endWorld the last world to render
     * @param {number} worldWidth the width of the worlds being rendered
     */
    renderWorlds(e, i, r, n, s) {
      let o = r;
      i && (this.hitRenderTarget_.setSize([
        Math.floor(e.size[0] / 2),
        Math.floor(e.size[1] / 2)
      ]), this.helper.prepareDrawToRenderTarget(
        e,
        this.hitRenderTarget_,
        !0
      ));
      do {
        this.helper.makeProjectionTransform(
          e,
          this.currentFrameStateTransform_
        ), nf(
          this.currentFrameStateTransform_,
          o * s,
          0
        );
        for (let a = 0, A = this.styleRenderers_.length; a < A; a++) {
          const l = this.styleRenderers_[a], c = this.buffers_[a];
          c && l.render(c, e, () => {
            this.applyUniforms_(c.invertVerticesTransform), this.helper.applyHitDetectionUniform(i);
          });
        }
      } while (++o < n);
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     * @override
     */
    forEachFeatureAtCoordinate(e, i, r, n, s) {
      if (Mt(
        this.hitDetectionEnabled_,
        "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
      ), !this.styleRenderers_.length || !this.hitDetectionEnabled_)
        return;
      const o = Ei(
        i.coordinateToPixelTransform,
        e.slice()
      ), a = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), A = [a[0] / 255, a[1] / 255, a[2] / 255, a[3] / 255], l = qz(A), c = this.batch_.getFeatureFromRef(l);
      if (c)
        return n(c, this.getLayer(), null);
    }
    /**
     * Will release a set of Webgl buffers
     * @param {import('../../render/webgl/VectorStyleRenderer.js').WebGLBuffers} buffers Buffers
     */
    disposeBuffers(e) {
      e.pointBuffers && e.pointBuffers.filter(Boolean).forEach((i) => this.helper.deleteBuffer(i)), e.lineStringBuffers && e.lineStringBuffers.filter(Boolean).forEach((i) => this.helper.deleteBuffer(i)), e.polygonBuffers && e.polygonBuffers.filter(Boolean).forEach((i) => this.helper.deleteBuffer(i));
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      this.buffers_.forEach((e) => {
        this.disposeBuffers(e);
      }), this.sourceListenKeys_ && (this.sourceListenKeys_.forEach(function(e) {
        Pt(e);
      }), this.sourceListenKeys_ = null), super.disposeInternal();
    }
  }
  class Ule extends dle {
    /**
     * @param {import("./BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options The tile texture options.
     * @param {Array<import("../render/webgl/VectorStyleRenderer.js").default>} styleRenderers Array of vector style renderers
     */
    constructor(e, i) {
      super(e), this.batch_ = new oP(), this.styleRenderers_ = i, this.buffers = [], this.maskVertices = new dd(Mf, _x), this.setTile(e.tile);
    }
    /**
     * @private
     */
    generateMaskBuffer_() {
      const e = this.tile.getSourceTiles()[0].extent;
      this.maskVertices.fromArray([
        e[0],
        e[1],
        e[2],
        e[1],
        e[2],
        e[3],
        e[0],
        e[3]
      ]), this.helper.flushBufferData(this.maskVertices);
    }
    /**
     * @override
     */
    uploadTile() {
      this.generateMaskBuffer_(), this.batch_.clear();
      const e = this.tile.getSourceTiles(), i = e.reduce(
        (a, A) => a.concat(A.getFeatures()),
        []
      );
      this.batch_.addFeatures(i);
      const r = e[0].extent[0], n = e[0].extent[1], s = nf(
        ri(),
        -r,
        -n
      ), o = this.styleRenderers_.map(
        (a, A) => a.generateBuffers(this.batch_, s).then((l) => {
          this.buffers[A] = l;
        })
      );
      Promise.all(o).then(() => {
        this.setReady();
      });
    }
  }
  const Zi = {
    ...hle,
    TILE_MASK_TEXTURE: "u_depthMask",
    TILE_ZOOM_LEVEL: "u_tileZoomLevel"
  }, Lle = {
    POSITION: "a_position"
  };
  class zle extends fle {
    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} options Options.
     */
    constructor(e, i) {
      super(e, {
        cacheSize: i.cacheSize,
        uniforms: {
          [Zi.PATTERN_ORIGIN]: [0, 0],
          [Zi.TILE_MASK_TEXTURE]: () => this.tileMaskTarget_.getTexture()
        }
      }), this.hitDetectionEnabled_ = !i.disableHitDetection, this.styles_ = [], this.styleVariables_ = i.variables || {}, this.styleRenderers_ = [], this.currentFrameStateTransform_ = ri(), this.tmpTransform_ = ri(), this.tmpMat4_ = VA(), this.tileMaskTarget_ = null, this.tileMaskIndices_ = new dd(
        If,
        _x
      ), this.tileMaskIndices_.fromArray([0, 1, 3, 1, 2, 3]), this.tileMaskAttributes_ = [
        {
          name: Lle.POSITION,
          size: 2,
          type: Gi.FLOAT
        }
      ], this.tileMaskProgram_, this.applyOptions_(i);
    }
    /**
     * @param {Options} options Options.
     * @override
     */
    reset(e) {
      super.reset(e), this.applyOptions_(e), this.helper && (this.createRenderers_(), this.initTileMask_());
    }
    /**
     * @param {Options} options Options.
     * @private
     */
    applyOptions_(e) {
      this.styles_ = Array.isArray(e.style) ? e.style : [e.style];
    }
    /**
     * @private
     */
    createRenderers_() {
      function e(i) {
        const r = i.getFragmentDiscardExpression(), n = `texture2D(${Zi.TILE_MASK_TEXTURE}, gl_FragCoord.xy / u_pixelRatio / u_viewportSizePx).r * 50. > ${Zi.TILE_ZOOM_LEVEL} + 0.5`;
        i.setFragmentDiscardExpression(
          r !== "false" ? `(${r}) || (${n})` : n
        ), i.addUniform(`sampler2D ${Zi.TILE_MASK_TEXTURE}`), i.addUniform(`float ${Zi.TILE_ZOOM_LEVEL}`);
      }
      this.styleRenderers_ = this.styles_.map((i) => {
        const r = "builder" in i;
        let n;
        if (r)
          e(
            /** @type {import('../../render/webgl/VectorStyleRenderer.js').StyleShaders} */
            i.builder
          ), n = i;
        else {
          const s = RB(
            /** @type {import('../../style/webgl.js').WebGLStyle} */
            i,
            this.styleVariables_
          );
          e(s.builder), n = {
            builder: s.builder,
            attributes: s.attributes,
            uniforms: s.uniforms
          };
        }
        return new aP(
          n,
          this.styleVariables_,
          this.helper,
          this.hitDetectionEnabled_
        );
      });
    }
    /**
     * @private
     */
    initTileMask_() {
      this.tileMaskTarget_ = new kx(this.helper);
      const e = new nP().setFillColorExpression(
        `vec4(${Zi.TILE_ZOOM_LEVEL} / 50., 0., 0., 1.)`
      ).addUniform(`float ${Zi.TILE_ZOOM_LEVEL}`);
      this.tileMaskProgram_ = this.helper.getProgram(
        e.getFillFragmentShader(),
        e.getFillVertexShader()
      ), this.helper.flushBufferData(this.tileMaskIndices_);
    }
    /**
     * @override
     */
    afterHelperCreated() {
      this.createRenderers_(), this.initTileMask_();
    }
    /**
     * @override
     */
    createTileRepresentation(e) {
      const i = new Ule(e, this.styleRenderers_), r = () => {
        i.ready && (this.getLayer().changed(), i.removeEventListener(Ge.CHANGE, r));
      };
      return i.addEventListener(Ge.CHANGE, r), i;
    }
    /**
     * @override
     */
    beforeTilesRender(e, i) {
      super.beforeTilesRender(e, !0), this.helper.makeProjectionTransform(
        e,
        this.currentFrameStateTransform_
      );
    }
    /**
     * @override
     */
    beforeTilesMaskRender(e) {
      this.helper.makeProjectionTransform(
        e,
        this.currentFrameStateTransform_
      );
      const i = e.pixelRatio, r = e.size;
      return this.tileMaskTarget_.setSize([r[0] * i, r[1] * i]), this.helper.prepareDrawToRenderTarget(
        e,
        this.tileMaskTarget_,
        !0,
        !0
      ), this.helper.useProgram(this.tileMaskProgram_, e), fE(this.tmpTransform_, this.currentFrameStateTransform_), this.helper.setUniformMatrixValue(
        Zi.PROJECTION_MATRIX,
        Bl(this.tmpMat4_, this.tmpTransform_)
      ), xA(this.tmpTransform_, this.currentFrameStateTransform_), this.helper.setUniformMatrixValue(
        Zi.SCREEN_TO_WORLD_MATRIX,
        Bl(this.tmpMat4_, this.tmpTransform_)
      ), !0;
    }
    /**
     * @override
     */
    renderTileMask(e, i, r, n) {
      if (!e.ready)
        return;
      this.helper.setUniformFloatValue(Zi.DEPTH, n), this.helper.setUniformFloatValue(Zi.TILE_ZOOM_LEVEL, i), this.helper.setUniformFloatVec4(Zi.RENDER_EXTENT, r), this.helper.setUniformFloatValue(Zi.GLOBAL_ALPHA, 1), this.helper.bindBuffer(
        /** @type {TileGeometry} */
        e.maskVertices
      ), this.helper.bindBuffer(this.tileMaskIndices_), this.helper.enableAttributes(this.tileMaskAttributes_);
      const s = this.tileMaskIndices_.getSize();
      this.helper.drawElements(0, s);
    }
    /**
     * @param {number} alpha Alpha value of the tile
     * @param {import("../../extent.js").Extent} renderExtent Which extent to restrict drawing to
     * @param {import("../../transform.js").Transform} batchInvertTransform Inverse of the transformation in which tile geometries are expressed
     * @param {number} tileZ Tile zoom level
     * @param {number} depth Depth of the tile
     * @private
     */
    applyUniforms_(e, i, r, n, s) {
      fE(this.tmpTransform_, this.currentFrameStateTransform_), sc(this.tmpTransform_, r), this.helper.setUniformMatrixValue(
        Zi.PROJECTION_MATRIX,
        Bl(this.tmpMat4_, this.tmpTransform_)
      ), xA(this.tmpTransform_, this.currentFrameStateTransform_), this.helper.setUniformMatrixValue(
        Zi.SCREEN_TO_WORLD_MATRIX,
        Bl(this.tmpMat4_, this.tmpTransform_)
      ), this.helper.setUniformFloatValue(Zi.GLOBAL_ALPHA, e), this.helper.setUniformFloatValue(Zi.DEPTH, s), this.helper.setUniformFloatValue(Zi.TILE_ZOOM_LEVEL, n), this.helper.setUniformFloatVec4(Zi.RENDER_EXTENT, i);
    }
    /**
     * @override
     */
    renderTile(e, i, r, n, s, o, a, A, l, c, u) {
      const d = fr(A, n, A), h = e.tile.getTileCoord()[0];
      for (let g = 0, f = this.styleRenderers_.length; g < f; g++) {
        const p = this.styleRenderers_[g], m = e.buffers[g];
        p.render(m, r, () => {
          this.applyUniforms_(
            u,
            d,
            m.invertVerticesTransform,
            h,
            l
          );
        });
      }
    }
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(e) {
    }
    /**
     * Clean up.
     * @override
     */
    disposeInternal() {
      super.disposeInternal();
    }
  }
  const Ple = {
    image: ["Polygon", "Circle", "LineString", "Image", "Text"],
    hybrid: ["Polygon", "LineString"],
    vector: []
  }, $T = {
    hybrid: ["Image", "Text", "Default"],
    vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
  };
  class Ole extends Cz {
    /**
     * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
     * @param {import("./TileLayer.js").Options} options Options.
     */
    constructor(e, i) {
      super(e, i), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.renderedOpacity_ = 1, this.tmpTransform_ = ri(), this.tileClipContexts_ = null;
    }
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} x Left of the tile.
     * @param {number} y Top of the tile.
     * @param {number} w Width of the tile.
     * @param {number} h Height of the tile.
     * @param {number} gutter Tile gutter.
     * @param {boolean} transition Apply an alpha transition.
     * @override
     */
    drawTile(e, i, r, n, s, o, a, A) {
      this.updateExecutorGroup_(
        e,
        i.pixelRatio,
        i.viewState.projection
      ), this.tileImageNeedsRender_(e) && this.renderTileImage_(e, i), super.drawTile(e, i, r, n, s, o, a, A);
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
     * @override
     */
    getTile(e, i, r, n) {
      const s = (
        /** @type {import("../../VectorRenderTile.js").default} */
        this.getOrCreateTile(e, i, r, n)
      );
      if (!s)
        return null;
      const a = n.viewState.resolution, A = n.viewHints;
      return (!(A[Ai.ANIMATING] || A[Ai.INTERACTING]) || !s.wantedResolution) && (s.wantedResolution = a), s;
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     * @override
     */
    prepareFrame(e) {
      const i = this.getLayer().getRevision();
      return this.renderedLayerRevision_ !== i && (this.renderedLayerRevision_ = i, this.renderedTiles.length = 0), super.prepareFrame(e);
    }
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../proj/Projection.js").default} projection Projection.
     * @private
     */
    updateExecutorGroup_(e, i, r) {
      const n = (
        /** @type {import("../../layer/VectorTile.js").default} */
        this.getLayer()
      ), s = n.getRevision(), o = n.getRenderOrder() || null, a = e.wantedResolution, A = e.getReplayState(n);
      if (!A.dirty && A.renderedResolution === a && A.renderedRevision == s && A.renderedRenderOrder == o)
        return;
      const l = n.getSource(), c = !!n.getDeclutter(), u = l.getTileGrid(), h = l.getTileGridForProjection(r).getTileCoordExtent(e.wrappedTileCoord), g = l.getSourceTiles(i, r, e), f = ve(n);
      delete e.hitDetectionImageData[f], e.executorGroups[f] = [], A.dirty = !1;
      for (let p = 0, m = g.length; p < m; ++p) {
        const E = g[p];
        if (E.getState() != pe.LOADED)
          continue;
        const y = E.tileCoord, C = u.getTileCoordExtent(y), w = fr(h, C), M = $r(
          w,
          n.getRenderBuffer() * a,
          this.tempExtent
        ), I = Zs(C, w) ? null : M, b = new WU(
          0,
          w,
          a,
          i
        ), B = wb(
          a,
          i
        ), x = function(D, F) {
          let R;
          const Y = D.getStyleFunction() || n.getStyleFunction();
          if (Y && (R = Y(D, a)), R) {
            const L = this.renderFeature(
              D,
              B,
              R,
              b,
              c,
              F
            );
            A.dirty = A.dirty || L;
          }
        }, Q = E.getFeatures();
        o && o !== A.renderedRenderOrder && Q.sort(o);
        for (let D = 0, F = Q.length; D < F; ++D) {
          const R = Q[D];
          (!I || Yi(I, R.getGeometry().getExtent())) && x.call(this, R, D);
        }
        const v = b.finish(), T = n.getRenderMode() !== "vector" && c && g.length === 1 ? null : w, S = new XU(
          T,
          a,
          i,
          l.getOverlaps(),
          v,
          n.getRenderBuffer(),
          !0
        );
        e.executorGroups[f].push(S);
      }
      A.renderedRevision = s, A.renderedRenderOrder = o, A.renderedResolution = a;
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     * @override
     */
    forEachFeatureAtCoordinate(e, i, r, n, s) {
      const o = i.viewState.resolution, a = i.viewState.rotation;
      r = r ?? 0;
      const A = this.getLayer(), c = A.getSource().getTileGridForProjection(
        i.viewState.projection
      ), u = $i([e]);
      $r(u, o * r, u);
      const d = {}, h = function(y, C, w) {
        let M = y.getId();
        M === void 0 && (M = ve(y));
        const I = d[M];
        if (I) {
          if (I !== !0 && w < I.distanceSq) {
            if (w === 0)
              return d[M] = !0, s.splice(s.lastIndexOf(I), 1), n(y, A, C);
            I.geometry = C, I.distanceSq = w;
          }
        } else {
          if (w === 0)
            return d[M] = !0, n(y, A, C);
          s.push(
            d[M] = {
              feature: y,
              layer: A,
              geometry: C,
              distanceSq: w,
              callback: n
            }
          );
        }
      }, g = (
        /** @type {Array<import("../../VectorRenderTile.js").default>} */
        this.renderedTiles
      ), f = ve(A), p = A.getDeclutter(), m = p ? i.declutter[p].all().map((y) => y.value) : null;
      let E;
      e: for (let y = 0, C = g.length; y < C; ++y) {
        const w = g[y], M = c.getTileCoordExtent(w.wrappedTileCoord);
        if (!Yi(M, u))
          continue;
        const I = w.executorGroups[f];
        for (let b = 0, B = I.length; b < B; ++b)
          if (E = I[b].forEachFeatureAtCoordinate(
            e,
            o,
            a,
            r,
            h,
            m
          ), E)
            break e;
      }
      return E;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
     * @override
     */
    getFeatures(e) {
      return this.renderedTiles.length === 0 ? Promise.resolve([]) : new Promise((i, r) => {
        const n = this.getLayer(), s = n.getSource(), o = this.renderedProjection, a = o.getExtent(), A = this.renderedResolution, l = s.getTileGridForProjection(o), c = Ei(
          this.renderedPixelToCoordinateTransform_,
          e.slice()
        ), u = l.getTileCoordForCoordAndResolution(c, A).toString(), d = (
          /** @type {Array<import("../../VectorRenderTile.js").default>} */
          this.renderedTiles.find(
            (y) => y.tileCoord.toString() === u && y.getState() === pe.LOADED
          )
        );
        if (!d || d.loadingSourceTiles > 0) {
          i([]);
          return;
        }
        s.getWrapX() && o.canWrapX() && !ts(
          a,
          l.getTileCoordExtent(d.tileCoord)
        ) && mv(c, o);
        const h = ve(n), g = l.getTileCoordExtent(d.wrappedTileCoord), f = qs(g), p = [
          (c[0] - f[0]) / A,
          (f[1] - c[1]) / A
        ], m = d.getSourceTiles().reduce(
          (y, C) => y.concat(C.getFeatures()),
          /** @type {Array<import("../../Feature.js").FeatureLike>} */
          []
        );
        let E = d.hitDetectionImageData[h];
        if (!E) {
          const y = mr(
            l.getTileSize(
              l.getZForResolution(A, s.zDirection)
            )
          ), C = this.renderedRotation_, w = [
            this.getRenderTransform(
              l.getTileCoordCenter(d.wrappedTileCoord),
              A,
              0,
              kn,
              y[0] * kn,
              y[1] * kn,
              0
            )
          ];
          E = ZU(
            y,
            w,
            m,
            n.getStyleFunction(),
            l.getTileCoordExtent(d.wrappedTileCoord),
            d.getReplayState(n).renderedResolution,
            C
          ), d.hitDetectionImageData[h] = E;
        }
        i(qU(p, m, E));
      });
    }
    /**
     * @param {import("../../extent.js").Extent} extent Extent.
     * @return {Array<import('../../Feature.js').FeatureLike>} Features.
     */
    getFeaturesInExtent(e) {
      const i = [], r = this.getTileCache();
      if (r.getCount() === 0)
        return i;
      const s = this.getLayer().getSource().getTileGridForProjection(
        this.frameState.viewState.projection
      ), o = s.getZForResolution(this.renderedResolution), a = {};
      return r.forEach((A) => {
        if (A.tileCoord[0] !== o || A.getState() !== pe.LOADED)
          return;
        const l = A.getSourceTiles();
        for (let c = 0, u = l.length; c < u; ++c) {
          const d = l[c], h = d.getKey();
          if (h in a)
            continue;
          a[h] = !0;
          const g = d.tileCoord;
          if (Yi(e, s.getTileCoordExtent(g))) {
            const f = d.getFeatures();
            if (f)
              for (let p = 0, m = f.length; p < m; ++p) {
                const E = f[p], y = E.getGeometry();
                Yi(e, y.getExtent()) && i.push(E);
              }
          }
        }
      }), i;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @override
     */
    handleFontsChanged() {
      const e = this.getLayer();
      e.getVisible() && this.renderedLayerRevision_ !== void 0 && e.changed();
    }
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    handleStyleImageChange_(e) {
      this.renderIfReadyAndVisible();
    }
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../layer/Layer.js").State} layerState Layer state.
     */
    renderDeclutter(e, i) {
      const r = this.context, n = r.globalAlpha;
      r.globalAlpha = i.opacity;
      const s = e.viewHints, o = !(s[Ai.ANIMATING] || s[Ai.INTERACTING]), a = [
        this.context.canvas.width,
        this.context.canvas.height
      ], A = this.getLayer().getDeclutter(), l = A ? e.declutter[A] : void 0, c = ve(this.getLayer()), u = (
        /** @type {Array<import("../../VectorRenderTile.js").default>} */
        this.renderedTiles
      );
      for (let d = 0, h = u.length; d < h; ++d) {
        const g = u[d], f = g.executorGroups[c];
        if (f)
          for (let p = f.length - 1; p >= 0; --p)
            f[p].execute(
              this.context,
              a,
              this.getTileRenderTransform(g, e),
              e.viewState.rotation,
              o,
              FE,
              l
            );
      }
      r.globalAlpha = n;
    }
    /**
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    renderDeferredInternal(e) {
      const i = (
        /** @type {Array<import("../../VectorRenderTile.js").default>} */
        this.renderedTiles
      ), r = ve(this.getLayer()), n = i.reduce(
        (A, l, c) => (l.executorGroups[r].forEach(
          (u) => A.push({
            executorGroup: u,
            index: c
          })
        ), A),
        /** @type {Array<{executorGroup: CanvasExecutorGroup, index: number}>} */
        []
      ), s = n.map(
        ({ executorGroup: A }) => A.getDeferredZIndexContexts()
      ), o = {};
      for (let A = 0, l = n.length; A < l; ++A) {
        const c = n[A].executorGroup.getDeferredZIndexContexts();
        for (const u in c)
          o[u] = !0;
      }
      Object.keys(o).map(Number).sort(Qo).forEach((A) => {
        s.forEach((l, c) => {
          l[A] && (l[A].forEach((u) => {
            const { executorGroup: d, index: h } = n[c], g = d.getRenderedContext(), f = g.globalAlpha;
            g.globalAlpha = this.renderedOpacity_;
            const p = this.tileClipContexts_[h];
            p && p.draw(g), u.draw(g), p && g.restore(), g.globalAlpha = f, u.clear();
          }), l[A].length = 0);
        });
      });
    }
    /**
     * @param {import("../../VectorRenderTile.js").default} tile The tile
     * @param {import('../../Map.js').FrameState} frameState Current frame state
     * @return {import('../../transform.js').Transform} Transform to use to render this tile
     */
    getTileRenderTransform(e, i) {
      const r = i.pixelRatio, n = i.viewState, s = n.center, o = n.resolution, a = n.rotation, A = i.size, l = Math.round(A[0] * r), c = Math.round(A[1] * r), d = this.getLayer().getSource().getTileGridForProjection(
        i.viewState.projection
      ), h = e.tileCoord, g = d.getTileCoordExtent(e.wrappedTileCoord), f = d.getTileCoordExtent(h, this.tempExtent)[0] - g[0];
      return sc(
        Nh(this.inversePixelTransform.slice(), 1 / r, 1 / r),
        this.getRenderTransform(
          s,
          o,
          a,
          r,
          l,
          c,
          f
        )
      );
    }
    /**
     * Render the vectors for this layer.
     * @param {CanvasRenderingContext2D} context Target context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @override
     */
    postRender(e, i) {
      var w;
      const r = i.viewHints, n = !(r[Ai.ANIMATING] || r[Ai.INTERACTING]);
      this.renderedPixelToCoordinateTransform_ = i.pixelToCoordinateTransform.slice(), this.renderedRotation_ = i.viewState.rotation, this.renderedOpacity_ = i.layerStatesArray[i.layerIndex].opacity;
      const s = (
        /** @type {import("../../layer/VectorTile.js").default} */
        this.getLayer()
      ), o = s.getRenderMode(), a = e.globalAlpha;
      e.globalAlpha = this.renderedOpacity_;
      const A = s.getDeclutter(), l = A ? $T[o].filter((M) => !FE.includes(M)) : $T[o], c = i.viewState, u = c.rotation, d = s.getSource(), g = d.getTileGridForProjection(c.projection).getZForResolution(
        c.resolution,
        d.zDirection
      ), f = (
        /** @type {Array<import("../../VectorRenderTile.js").default>} */
        this.renderedTiles
      ), p = [], m = [], E = [], y = ve(s);
      let C = !0;
      for (let M = f.length - 1; M >= 0; --M) {
        const I = f[M];
        C = C && !I.getReplayState(s).dirty;
        const b = I.executorGroups[y].filter(
          (D) => D.hasExecutors(l)
        );
        if (b.length === 0)
          continue;
        const B = this.getTileRenderTransform(I, i), x = I.tileCoord[0];
        let Q = !1;
        const v = b[0].getClipCoords(B);
        let T = e, S;
        if (v) {
          S = new ex(), T = S.getContext();
          for (let D = 0, F = p.length; D < F; ++D)
            if (g !== x && x < m[D]) {
              const R = p[D];
              Yi(
                [
                  v[0],
                  v[3],
                  v[4],
                  v[7]
                ],
                [R[0], R[3], R[4], R[7]]
              ) && (Q || (T.save(), Q = !0), T.beginPath(), T.moveTo(v[0], v[1]), T.lineTo(v[2], v[3]), T.lineTo(v[4], v[5]), T.lineTo(v[6], v[7]), T.moveTo(R[6], R[7]), T.lineTo(R[4], R[5]), T.lineTo(R[2], R[3]), T.lineTo(R[0], R[1]), T.clip());
            }
          p.push(v), m.push(x);
        }
        for (let D = 0, F = b.length; D < F; ++D)
          b[D].execute(
            e,
            [e.canvas.width, e.canvas.height],
            B,
            u,
            n,
            l,
            (w = i.declutter) == null ? void 0 : w[A]
          );
        Q && (T === e ? T.restore() : E[M] = S);
      }
      e.globalAlpha = a, this.ready = C, this.tileClipContexts_ = E, i.declutter || this.renderDeferredInternal(i), super.postRender(e, i);
    }
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
     * @param {boolean} [declutter] Enable decluttering.
     * @param {number} [index] Render order index.
     * @return {boolean} `true` if an image is loading.
     */
    renderFeature(e, i, r, n, s, o) {
      if (!r)
        return !1;
      let a = !1;
      if (Array.isArray(r))
        for (let A = 0, l = r.length; A < l; ++A)
          a = SE(
            n,
            e,
            r[A],
            i,
            this.boundHandleStyleImageChange_,
            void 0,
            s,
            o
          ) || a;
      else
        a = SE(
          n,
          e,
          r,
          i,
          this.boundHandleStyleImageChange_,
          void 0,
          s,
          o
        );
      return a;
    }
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @return {boolean} A new tile image was rendered.
     * @private
     */
    tileImageNeedsRender_(e) {
      const i = (
        /** @type {import("../../layer/VectorTile.js").default} */
        this.getLayer()
      );
      if (i.getRenderMode() === "vector")
        return !1;
      const r = e.getReplayState(i), n = i.getRevision(), s = e.wantedResolution;
      return r.renderedTileResolution !== s || r.renderedTileRevision !== n;
    }
    /**
     * @param {import("../../VectorRenderTile.js").default} tile Tile.
     * @param {import("../../Map").FrameState} frameState Frame state.
     * @private
     */
    renderTileImage_(e, i) {
      const r = (
        /** @type {import("../../layer/VectorTile.js").default} */
        this.getLayer()
      ), n = e.getReplayState(r), s = r.getRevision(), o = e.executorGroups[ve(r)];
      n.renderedTileRevision = s;
      const a = e.wrappedTileCoord, A = a[0], l = r.getSource();
      let c = i.pixelRatio;
      const d = i.viewState.projection, h = l.getTileGridForProjection(d), g = h.getResolution(e.tileCoord[0]), f = i.pixelRatio / e.wantedResolution * g, p = h.getResolution(A), m = e.getContext();
      c = Math.round(
        Math.max(c, f / c)
      );
      const E = l.getTilePixelSize(A, c, d);
      m.canvas.width = E[0], m.canvas.height = E[1];
      const y = c / f;
      if (y !== 1) {
        const I = ab(this.tmpTransform_);
        Nh(I, y, y), m.setTransform.apply(m, I);
      }
      const C = h.getTileCoordExtent(a, this.tempExtent), w = f / p, M = ab(this.tmpTransform_);
      Nh(M, w, -w), nf(M, -C[0], -C[3]);
      for (let I = 0, b = o.length; I < b; ++I)
        o[I].execute(
          m,
          [
            m.canvas.width * y,
            m.canvas.height * y
          ],
          M,
          0,
          !0,
          Ple[r.getRenderMode()],
          null
        );
      n.renderedTileResolution = e.wantedResolution;
    }
  }
  class Sl extends gf {
    /**
     * @param {Options<VectorTileSourceType, FeatureType>} [options] Options.
     */
    constructor(e) {
      e = e || {};
      const i = Object.assign({}, e);
      delete i.preload;
      const r = e.cacheSize === void 0 ? 0 : e.cacheSize;
      delete e.cacheSize, delete i.useInterimTilesOnError, super(i), this.on, this.once, this.un, this.cacheSize_ = r;
      const n = e.renderMode || "hybrid";
      Mt(
        n == "hybrid" || n == "vector",
        "`renderMode` must be `'hybrid'` or `'vector'`"
      ), this.renderMode_ = n, this.setPreload(e.preload ? e.preload : 0), this.setUseInterimTilesOnError(
        e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
      ), this.getBackground, this.setBackground;
    }
    /**
     * @override
     */
    createRenderer() {
      return new Ole(this, {
        cacheSize: this.cacheSize_
      });
    }
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
     * @api
     * @override
     */
    getFeatures(e) {
      return super.getFeatures(e);
    }
    /**
     * Get features whose bounding box intersects the provided extent. Only features for cached
     * tiles for the last rendered zoom level are available in the source. So this method is only
     * suitable for requesting tiles for extents that are currently rendered.
     *
     * Features are returned in random tile order and as they are included in the tiles. This means
     * they can be clipped, duplicated across tiles, and simplified to the render resolution.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<FeatureType>} Features.
     * @api
     */
    getFeaturesInExtent(e) {
      return (
        /** @type {Array<FeatureType>} */
        /** @type {*} */
        this.getRenderer().getFeaturesInExtent(e)
      );
    }
    /**
     * @return {VectorTileRenderType} The render mode.
     */
    getRenderMode() {
      return this.renderMode_;
    }
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */
    getPreload() {
      return (
        /** @type {number} */
        this.get(fA.PRELOAD)
      );
    }
    /**
     * Deprecated.  Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */
    getUseInterimTilesOnError() {
      return (
        /** @type {boolean} */
        this.get(fA.USE_INTERIM_TILES_ON_ERROR)
      );
    }
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */
    setPreload(e) {
      this.set(fA.PRELOAD, e);
    }
    /**
     * Deprecated.  Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */
    setUseInterimTilesOnError(e) {
      this.set(fA.USE_INTERIM_TILES_ON_ERROR, e);
    }
  }
  const Yc = {
    defaultMapMarkerPoint: {
      styleId: "defaultMapMarkerPoint",
      rules: [{
        style: {
          type: "icon",
          imageName: `<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='#E10019' class='bi bi-geo-alt-fill' viewBox='0 0 16 16'>
                    <path d='M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z'/>
                    </svg>`,
          imagePath: "",
          imageScale: 2,
          imageOffsetY: 16,
          imageOffsetYUnit: "pixels"
        }
      }]
    },
    defaultMapMarkerPolygon: {
      styleId: "defaultMapMarkerPolygon",
      rules: [{
        style: {
          polygonStrokeColor: [8, 119, 95, 1],
          polygonStrokeWidth: 4,
          polygonFillColor: [8, 119, 95, 0.3],
          polygonStrokeDash: [8]
        }
      }]
    },
    defaultAdditionalMapMarkerPolygon: {
      styleId: "defaultAdditionalMapMarkerPolygon",
      rules: [{
        style: {
          polygonStrokeColor: [255, 255, 0, 1],
          polygonStrokeWidth: 4,
          polygonFillColor: [255, 255, 0, 0.3],
          polygonStrokeDash: [8]
        }
      }]
    },
    defaultHighlightFeaturesPoint: {
      styleId: "defaultHighlightFeaturesPoint",
      rules: [{
        style: {
          type: "circle",
          circleFillColor: [255, 255, 0, 0.9],
          circleRadius: 8
        }
      }]
    },
    defaultHighlightFeaturesPolygon: {
      styleId: "defaultHighlightFeaturesPolygon",
      rules: [{
        style: {
          polygonStrokeColor: [8, 119, 95, 1],
          polygonStrokeWidth: 4,
          polygonFillColor: [8, 119, 95, 0.3],
          polygonStrokeDash: [8]
        }
      }]
    },
    defaultHighlightFeaturesLine: {
      styleId: "defaultHighlightFeaturesLine",
      rules: [{
        style: {
          polygonStrokeColor: [8, 119, 95, 1],
          polygonStrokeWidth: 4,
          polygonFillColor: [8, 119, 95, 0.3],
          polygonStrokeDash: [8]
        }
      }]
    }
  };
  let ku, Xb, Zb, qb, $b, eM, tM, iM, rM, eR, nM, AP;
  function Gle() {
    const t = [];
    return Xb && Xb.forEach((e) => {
      e.typ === "WFS" || e.typ === "GeoJSON" || e.typ === "SensorThings" || e.typ === "TileSet3D" || e.typ === "OAF" ? e != null && e.styleId && t.push(e.styleId) : e.typ === "GROUP" && e.children.forEach((i) => {
        i != null && i.styleId && t.push(i.styleId);
      });
    }), t;
  }
  function jle() {
    const t = [];
    return Zb && Zb.forEach((e) => {
      e != null && e.styleId && (Array.isArray(e.styleId) ? e.styleId.forEach((i) => {
        i instanceof Object ? t.push(i.id) : t.push(i);
      }) : t.push(e.styleId));
    }), t;
  }
  function Hle() {
    let t;
    return qb ? t = qb : t = "defaultMapMarkerPoint", t;
  }
  function Jle() {
    let t;
    return tM ? t = tM : t = "defaultHighlightFeaturesPoint", t;
  }
  function Vle() {
    let t;
    return rM ? t = rM : t = "defaultHighlightFeaturesLine", t;
  }
  function Wle() {
    let t;
    return $b ? t = $b : t = "defaultMapMarkerPolygon", t;
  }
  function Kle() {
    let t;
    return eM ? t = eM : t = "defaultAdditionalMapMarkerPolygon", t;
  }
  function Xle() {
    let t;
    return iM ? t = iM : t = "defaultHighlightFeaturesPolygon", t;
  }
  function Zle() {
    const t = [];
    return nM !== void 0 && nM.forEach((e) => {
      t.push(e.styleId);
    }), t;
  }
  function qle(t) {
    const e = [...t];
    let i = [], r = [];
    return e.push(
      { styleId: "default", rules: [{ style: {} }] },
      Yc.defaultMapMarkerPoint,
      Yc.defaultMapMarkerPolygon,
      Yc.defaultAdditionalMapMarkerPolygon,
      Yc.defaultHighlightFeaturesPoint,
      Yc.defaultHighlightFeaturesPolygon,
      Yc.defaultHighlightFeaturesLine
    ), i.push(
      Gle(),
      Hle(),
      Wle(),
      Kle(),
      Jle(),
      Xle(),
      Vle(),
      jle(),
      Zle(),
      AP
    ), i = i.reduce((n, s) => n.concat(s), []).filter((n) => n), r = e.filter((n) => i.includes(n.styleId)), r;
  }
  async function $le(t, e, i, r, n) {
    var s;
    return Xb = i, Zb = r, qb = t.mapMarkerPointStyleId, $b = t.mapMarkerPolygonStyleId, eM = t.additionalPolygonStyleId, tM = t.highlightFeaturesPointStyleId, iM = t.highlightFeaturesPolygonStyleId, rM = t.highlightFeaturesLineStyleId, AP = t.zoomToFeatureId, eR = e.styleConf, nM = (s = e.featureViaURL) == null ? void 0 : s.layers, await fetch(eR).then((o) => o.json()).then((o) => {
      ku = qle(o);
    }).catch((o) => {
      console.error(o), n(!1, !0);
    }), ku;
  }
  function ece(t) {
    t.forEach((e) => {
      ku.push(e);
    });
  }
  function tce(t) {
    return ku == null ? void 0 : ku.find((e) => e.styleId === t);
  }
  const ice = {
    initializeStyleList: $le,
    addToStyleList: ece,
    returnStyleObject: tce
  };
  function rce(t, e = ".") {
    const i = t.length, r = [];
    let n = "", s = "";
    for (let o = 0; o < i; o++) {
      if (n = t[o], n === "\\")
        o++, n = t[o];
      else if (n === e) {
        r.push(s), s = "";
        continue;
      }
      s += n;
    }
    return s && r.push(s), r;
  }
  function nce(t, e, i = "@", r = ".", n = 20) {
    if (typeof t != "object" || t === null || typeof e != "string" || typeof i == "string" && e.substr(0, i.length) !== i)
      return;
    const s = rce(typeof i == "string" ? e.substring(i.length) : e, r), o = s.length;
    let a = t, A = 0;
    for (let l = 0; l < o; l++)
      if (typeof a != "object" || a === null || (a = a[s[l]], A++, typeof a > "u" || A > n))
        return;
    return a;
  }
  function sce(t, e = ".", i = ",") {
    if (typeof t != "number" && typeof t != "string")
      return "";
    const r = typeof t != "string" ? t.toString() : t, n = r.indexOf("."), s = n > -1 ? r.substring(0, n) : r, o = s.replace(/\B(?=(\d{3})+(?!\d),?.*)/g, e), a = n > -1 ? r.substring(n + 1) : !1;
    return a ? o + i + a : o;
  }
  var um = { exports: {} }, oce = um.exports, tR;
  function ace() {
    return tR || (tR = 1, function(t, e) {
      (function(i, r) {
        t.exports = r();
      })(oce, function() {
        var i = 1e3, r = 6e4, n = 36e5, s = "millisecond", o = "second", a = "minute", A = "hour", l = "day", c = "week", u = "month", d = "quarter", h = "year", g = "date", f = "Invalid Date", p = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, E = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(S) {
          var D = ["th", "st", "nd", "rd"], F = S % 100;
          return "[" + S + (D[(F - 20) % 10] || D[F] || D[0]) + "]";
        } }, y = function(S, D, F) {
          var R = String(S);
          return !R || R.length >= D ? S : "" + Array(D + 1 - R.length).join(F) + S;
        }, C = { s: y, z: function(S) {
          var D = -S.utcOffset(), F = Math.abs(D), R = Math.floor(F / 60), Y = F % 60;
          return (D <= 0 ? "+" : "-") + y(R, 2, "0") + ":" + y(Y, 2, "0");
        }, m: function S(D, F) {
          if (D.date() < F.date()) return -S(F, D);
          var R = 12 * (F.year() - D.year()) + (F.month() - D.month()), Y = D.clone().add(R, u), L = F - Y < 0, N = D.clone().add(R + (L ? -1 : 1), u);
          return +(-(R + (F - Y) / (L ? Y - N : N - Y)) || 0);
        }, a: function(S) {
          return S < 0 ? Math.ceil(S) || 0 : Math.floor(S);
        }, p: function(S) {
          return { M: u, y: h, w: c, d: l, D: g, h: A, m: a, s: o, ms: s, Q: d }[S] || String(S || "").toLowerCase().replace(/s$/, "");
        }, u: function(S) {
          return S === void 0;
        } }, w = "en", M = {};
        M[w] = E;
        var I = "$isDayjsObject", b = function(S) {
          return S instanceof v || !(!S || !S[I]);
        }, B = function S(D, F, R) {
          var Y;
          if (!D) return w;
          if (typeof D == "string") {
            var L = D.toLowerCase();
            M[L] && (Y = L), F && (M[L] = F, Y = L);
            var N = D.split("-");
            if (!Y && N.length > 1) return S(N[0]);
          } else {
            var H = D.name;
            M[H] = D, Y = H;
          }
          return !R && Y && (w = Y), Y || !R && w;
        }, x = function(S, D) {
          if (b(S)) return S.clone();
          var F = typeof D == "object" ? D : {};
          return F.date = S, F.args = arguments, new v(F);
        }, Q = C;
        Q.l = B, Q.i = b, Q.w = function(S, D) {
          return x(S, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
        };
        var v = function() {
          function S(F) {
            this.$L = B(F.locale, null, !0), this.parse(F), this.$x = this.$x || F.x || {}, this[I] = !0;
          }
          var D = S.prototype;
          return D.parse = function(F) {
            this.$d = function(R) {
              var Y = R.date, L = R.utc;
              if (Y === null) return /* @__PURE__ */ new Date(NaN);
              if (Q.u(Y)) return /* @__PURE__ */ new Date();
              if (Y instanceof Date) return new Date(Y);
              if (typeof Y == "string" && !/Z$/i.test(Y)) {
                var N = Y.match(p);
                if (N) {
                  var H = N[2] - 1 || 0, P = (N[7] || "0").substring(0, 3);
                  return L ? new Date(Date.UTC(N[1], H, N[3] || 1, N[4] || 0, N[5] || 0, N[6] || 0, P)) : new Date(N[1], H, N[3] || 1, N[4] || 0, N[5] || 0, N[6] || 0, P);
                }
              }
              return new Date(Y);
            }(F), this.init();
          }, D.init = function() {
            var F = this.$d;
            this.$y = F.getFullYear(), this.$M = F.getMonth(), this.$D = F.getDate(), this.$W = F.getDay(), this.$H = F.getHours(), this.$m = F.getMinutes(), this.$s = F.getSeconds(), this.$ms = F.getMilliseconds();
          }, D.$utils = function() {
            return Q;
          }, D.isValid = function() {
            return this.$d.toString() !== f;
          }, D.isSame = function(F, R) {
            var Y = x(F);
            return this.startOf(R) <= Y && Y <= this.endOf(R);
          }, D.isAfter = function(F, R) {
            return x(F) < this.startOf(R);
          }, D.isBefore = function(F, R) {
            return this.endOf(R) < x(F);
          }, D.$g = function(F, R, Y) {
            return Q.u(F) ? this[R] : this.set(Y, F);
          }, D.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, D.valueOf = function() {
            return this.$d.getTime();
          }, D.startOf = function(F, R) {
            var Y = this, L = !!Q.u(R) || R, N = Q.p(F), H = function(q, U) {
              var J = Q.w(Y.$u ? Date.UTC(Y.$y, U, q) : new Date(Y.$y, U, q), Y);
              return L ? J : J.endOf(l);
            }, P = function(q, U) {
              return Q.w(Y.toDate()[q].apply(Y.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(U)), Y);
            }, ie = this.$W, V = this.$M, Z = this.$D, se = "set" + (this.$u ? "UTC" : "");
            switch (N) {
              case h:
                return L ? H(1, 0) : H(31, 11);
              case u:
                return L ? H(1, V) : H(0, V + 1);
              case c:
                var k = this.$locale().weekStart || 0, _ = (ie < k ? ie + 7 : ie) - k;
                return H(L ? Z - _ : Z + (6 - _), V);
              case l:
              case g:
                return P(se + "Hours", 0);
              case A:
                return P(se + "Minutes", 1);
              case a:
                return P(se + "Seconds", 2);
              case o:
                return P(se + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, D.endOf = function(F) {
            return this.startOf(F, !1);
          }, D.$set = function(F, R) {
            var Y, L = Q.p(F), N = "set" + (this.$u ? "UTC" : ""), H = (Y = {}, Y[l] = N + "Date", Y[g] = N + "Date", Y[u] = N + "Month", Y[h] = N + "FullYear", Y[A] = N + "Hours", Y[a] = N + "Minutes", Y[o] = N + "Seconds", Y[s] = N + "Milliseconds", Y)[L], P = L === l ? this.$D + (R - this.$W) : R;
            if (L === u || L === h) {
              var ie = this.clone().set(g, 1);
              ie.$d[H](P), ie.init(), this.$d = ie.set(g, Math.min(this.$D, ie.daysInMonth())).$d;
            } else H && this.$d[H](P);
            return this.init(), this;
          }, D.set = function(F, R) {
            return this.clone().$set(F, R);
          }, D.get = function(F) {
            return this[Q.p(F)]();
          }, D.add = function(F, R) {
            var Y, L = this;
            F = Number(F);
            var N = Q.p(R), H = function(V) {
              var Z = x(L);
              return Q.w(Z.date(Z.date() + Math.round(V * F)), L);
            };
            if (N === u) return this.set(u, this.$M + F);
            if (N === h) return this.set(h, this.$y + F);
            if (N === l) return H(1);
            if (N === c) return H(7);
            var P = (Y = {}, Y[a] = r, Y[A] = n, Y[o] = i, Y)[N] || 1, ie = this.$d.getTime() + F * P;
            return Q.w(ie, this);
          }, D.subtract = function(F, R) {
            return this.add(-1 * F, R);
          }, D.format = function(F) {
            var R = this, Y = this.$locale();
            if (!this.isValid()) return Y.invalidDate || f;
            var L = F || "YYYY-MM-DDTHH:mm:ssZ", N = Q.z(this), H = this.$H, P = this.$m, ie = this.$M, V = Y.weekdays, Z = Y.months, se = Y.meridiem, k = function(U, J, ae, $) {
              return U && (U[J] || U(R, L)) || ae[J].slice(0, $);
            }, _ = function(U) {
              return Q.s(H % 12 || 12, U, "0");
            }, q = se || function(U, J, ae) {
              var $ = U < 12 ? "AM" : "PM";
              return ae ? $.toLowerCase() : $;
            };
            return L.replace(m, function(U, J) {
              return J || function(ae) {
                switch (ae) {
                  case "YY":
                    return String(R.$y).slice(-2);
                  case "YYYY":
                    return Q.s(R.$y, 4, "0");
                  case "M":
                    return ie + 1;
                  case "MM":
                    return Q.s(ie + 1, 2, "0");
                  case "MMM":
                    return k(Y.monthsShort, ie, Z, 3);
                  case "MMMM":
                    return k(Z, ie);
                  case "D":
                    return R.$D;
                  case "DD":
                    return Q.s(R.$D, 2, "0");
                  case "d":
                    return String(R.$W);
                  case "dd":
                    return k(Y.weekdaysMin, R.$W, V, 2);
                  case "ddd":
                    return k(Y.weekdaysShort, R.$W, V, 3);
                  case "dddd":
                    return V[R.$W];
                  case "H":
                    return String(H);
                  case "HH":
                    return Q.s(H, 2, "0");
                  case "h":
                    return _(1);
                  case "hh":
                    return _(2);
                  case "a":
                    return q(H, P, !0);
                  case "A":
                    return q(H, P, !1);
                  case "m":
                    return String(P);
                  case "mm":
                    return Q.s(P, 2, "0");
                  case "s":
                    return String(R.$s);
                  case "ss":
                    return Q.s(R.$s, 2, "0");
                  case "SSS":
                    return Q.s(R.$ms, 3, "0");
                  case "Z":
                    return N;
                }
                return null;
              }(U) || N.replace(":", "");
            });
          }, D.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, D.diff = function(F, R, Y) {
            var L, N = this, H = Q.p(R), P = x(F), ie = (P.utcOffset() - this.utcOffset()) * r, V = this - P, Z = function() {
              return Q.m(N, P);
            };
            switch (H) {
              case h:
                L = Z() / 12;
                break;
              case u:
                L = Z();
                break;
              case d:
                L = Z() / 3;
                break;
              case c:
                L = (V - ie) / 6048e5;
                break;
              case l:
                L = (V - ie) / 864e5;
                break;
              case A:
                L = V / n;
                break;
              case a:
                L = V / r;
                break;
              case o:
                L = V / i;
                break;
              default:
                L = V;
            }
            return Y ? L : Q.a(L);
          }, D.daysInMonth = function() {
            return this.endOf(u).$D;
          }, D.$locale = function() {
            return M[this.$L];
          }, D.locale = function(F, R) {
            if (!F) return this.$L;
            var Y = this.clone(), L = B(F, R, !0);
            return L && (Y.$L = L), Y;
          }, D.clone = function() {
            return Q.w(this.$d, this);
          }, D.toDate = function() {
            return new Date(this.valueOf());
          }, D.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, D.toISOString = function() {
            return this.$d.toISOString();
          }, D.toString = function() {
            return this.$d.toUTCString();
          }, S;
        }(), T = v.prototype;
        return x.prototype = T, [["$ms", s], ["$s", o], ["$m", a], ["$H", A], ["$W", l], ["$M", u], ["$y", h], ["$D", g]].forEach(function(S) {
          T[S[1]] = function(D) {
            return this.$g(D, S[0], S[1]);
          };
        }), x.extend = function(S, D) {
          return S.$i || (S(D, v, x), S.$i = !0), x;
        }, x.locale = B, x.isDayjs = b, x.unix = function(S) {
          return x(1e3 * S);
        }, x.en = M[w], x.Ls = M, x.p = {}, x;
      });
    }(um)), um.exports;
  }
  var Ace = ace();
  const lce = /* @__PURE__ */ dre(Ace);
  function sM(t) {
    return typeof t == "string" && t.startsWith("@");
  }
  function oM(t, e) {
    Object.keys(t).forEach((n) => {
      t[n] && typeof t[n] == "object" && Object.keys(t[n]).forEach((s) => {
        t[n + "." + s] = t[n][s];
      });
    });
    const i = sM(e);
    let r = t[Object.keys(t).find((n) => n.toLowerCase() === e.toLowerCase())];
    return i && (r = nce(t, e)), r;
  }
  function cce(t, e) {
    let i = String(t);
    return Object.prototype.hasOwnProperty.call(e, t) && (i = e[t]), i;
  }
  function uce(t, e) {
    let i = t;
    return e && (i = String(i) + " " + e), i;
  }
  function dce(t, e) {
    let i = t;
    return e && (i = e + String(i)), i;
  }
  function hce(t, e, i) {
    let r, n;
    return e === "contains" ? (n = Object.keys(i).filter((s) => s.includes(t))[0], r = i[n]) : e === "startsWith" ? (n = Object.keys(i).filter((s) => s.startsWith(t))[0], r = i[n]) : e === "endsWith" ? (n = Object.keys(i).filter((s) => s.endsWith(t))[0], r = i[n]) : r = i[t], r;
  }
  function gce(t, e, i) {
    const r = t;
    return e && Object.keys(e).forEach((n) => {
      e[n] === "%value%" ? r.setAttribute(n, i) : r.setAttribute(n, e[n]);
    }), r;
  }
  function iR(t, e, i) {
    var c, u, d, h, g, f, p;
    const r = e != null && e.type ? e.type : "string", n = e != null && e.condition ? e.condition : null, s = new XMLSerializer();
    let o = oM(i, t), a = e != null && e.format ? e.format : "YYYY-MM-DDTHH:mm:ss.SSSZ", A, l;
    switch (n && (o = hce(t, n, i)), r) {
      case "date": {
        if (A = new Date(String(o)), a === "YYYY-MM-DDTHH:mm:ss.SSSZ") {
          const m = A.getTimezoneOffset();
          let E = m / 60 % 24, y = m % 60;
          E = E < 0 ? "+" + ("0" + Math.abs(E)).slice(-2) : "-" + ("0" + Math.abs(E)).slice(-2), y = y < 0 ? ":" + ("0" + Math.abs(y)).slice(-2) : ":" + ("0" + y).slice(-2), o = A.toISOString().slice(0, -1) + E + y;
        } else isNaN(A.getDay()) ? console.warn("If the attribute is missing, ISO 8601 is used.") : o = lce(String(o)).format(a);
        break;
      }
      case "number": {
        o = sce(o);
        break;
      }
      case "linechart": {
        o = Object.assign({
          name: t,
          staObject: o
        }, e);
        break;
      }
      case "boolean": {
        a = a === "DD.MM.YYYY HH:mm:ss" ? { true: "true", false: "false" } : a, o = cce(o, a);
        break;
      }
      case "html": {
        o !== void 0 && ((c = e == null ? void 0 : e.html) != null && c.tag && (l = document.createElement((u = e == null ? void 0 : e.html) == null ? void 0 : u.tag)), ((d = e == null ? void 0 : e.html) == null ? void 0 : d.innerHTML) === "%value%" ? l.innerHTML = o : (h = e == null ? void 0 : e.html) != null && h.innerHTML && (l.innerHTML = (g = e == null ? void 0 : e.html) == null ? void 0 : g.innerHTML), l && ((f = e == null ? void 0 : e.html) != null && f.properties && (l = gce(l, (p = e == null ? void 0 : e.html) == null ? void 0 : p.properties, o)), o = s.serializeToString(l), o = o.replace(/ xmlns="(.*?)"/g, "")));
        break;
      }
      // default equals to mappingObj.type === "string"
      default:
        o = String(o);
    }
    return o && e.suffix && o !== "undefined" && (o = uce(o, e.suffix)), o && e.prefix && o !== "undefined" && (o = dce(o, e.prefix)), o;
  }
  function aM(t, e, i = !0) {
    let r;
    return e ? (i ? (r = {}, Object.keys(e).forEach((n) => {
      let s = e[n], o = oM(t, n);
      typeof s == "object" && (o = iR(n, s, t), s = s.name), o && o !== "undefined" && (r[s] = o);
    })) : typeof e == "string" ? r = oM(t, e) : r = iR(e.name, e, t), r) : !1;
  }
  function rR(t) {
    return typeof t == "string" && t.indexOf(",") > -1 ? parseFloat(t.replace(",", ".")) : t;
  }
  function fce(t, e) {
    const i = sM(e);
    let r = e;
    return i && (r = aM(t, r, !1)), Array.isArray(r) && r.forEach((n, s, o) => {
      sM(n) && (o[s] = aM(t, n, !1));
    }), r;
  }
  function pce(t, e) {
    let i = t;
    if (typeof t == "string" && typeof e == "string" && t === e)
      return !0;
    if (typeof t == "boolean" && typeof e == "boolean") {
      if (t === e)
        return !0;
    } else if (typeof e == "number") {
      if (i = parseFloat(i), !isNaN(t) && i === parseFloat(e))
        return !0;
    } else if (Array.isArray(e) && e.every((r) => typeof r == "number" || r === null) && (e.length === 2 || e.length === 4) && (i = parseFloat(rR(i)), !isNaN(rR(t))))
      return e.length === 2 || e.length === 4 && (i = 1 / (parseFloat(e[3], 10) - parseFloat(e[2], 10)) * (i - parseFloat(e[2], 10))), e[0] === null && e[1] === null ? !0 : e[0] === null ? i < parseFloat(e[1]) : e[1] === null ? i >= parseFloat(e[0]) : i >= parseFloat(e[0]) && i < parseFloat(e[1]);
    return !1;
  }
  function nR(t, e, i) {
    let r = t;
    typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "features") && Array.isArray(t.features) && t.features.length > 0 && (r = t.features[0].getProperties());
    const n = aM(r, e, !1), s = fce(r, i);
    return (typeof n == "boolean" || typeof n == "string" || typeof n == "number") && (typeof s == "boolean" || typeof s == "string" || typeof s == "number" || Array.isArray(s) && s.every((o) => typeof o == "number" || o === null) && (s.length === 2 || s.length === 4)) ? pce(n, s) : !1;
  }
  function mce(t, e) {
    var i;
    if ((i = e == null ? void 0 : e.conditions) != null && i.properties && t) {
      const r = t.getProperties(), n = e.conditions.properties;
      let s, o;
      if (Array.isArray(n))
        for (o in n) {
          const a = n[o].value;
          if (s = n[o].attrName, !nR(r, s, a))
            return !1;
        }
      else
        for (s in n) {
          const a = n[s];
          if (!nR(r, s, a))
            return !1;
        }
      return !0;
    }
    return !0;
  }
  function Ece(t, e) {
    return t.rules.forEach((i) => {
      typeof (e == null ? void 0 : e.get("rotation")) < "u" && (i.style.rotation = e.get("rotation"));
    }), t.rules.filter((i) => mce(e, i));
  }
  function yce(t) {
    const e = [1, 1, 1, 1];
    return t.concat(e).slice(0, 4);
  }
  function Bce(t) {
    const e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, i = t.replace(e, function(n, s, o, a) {
      return s + s + o + o + a + a;
    });
    let r;
    return r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, r = r.exec(i), r ? [
      parseFloat(r[1], 16),
      parseFloat(r[2], 16),
      parseFloat(r[3], 16)
    ] : null;
  }
  function nC(t) {
    const e = Number(t).toString(16);
    return e.length === 1 ? "0" + e : e;
  }
  function wce(t, e, i) {
    return "#" + nC(t) + nC(e) + nC(i);
  }
  function sC(t, e) {
    let i, r = t, n = [];
    return Array.isArray(r) ? i = "rgb" : typeof r == "string" && r.indexOf("#") === 0 ? i = "hex" : typeof r == "string" && r.indexOf("#") === -1 && (i = "rgb", n = r.replace("[", "").replace("]", "").replace(/ /g, "").split(","), r = [n[0], n[1], n[2], n[3]]), i === "hex" && e === "rgb" ? r = Bce(r) : i === "rgb" && e === "hex" ? r = wce(r[0], r[1], r[2]) : i === "rgb" && e === "rgba" && (r = "rgba(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + r[3] + ")"), r = e === "rgb" ? yce(r) : r, r;
  }
  const WE = {
    "circle-radius": 10,
    "circle-fill-color": "#006688",
    "circle-rotate-with-view": !1,
    "circle-displacement": [0, 0],
    "circle-opacity": 0.6
  }, $a = {
    fillColor: "#006688",
    strokeColor: "#006688",
    strokeWidth: 1,
    opacity: 1
  }, lP = Object.assign({
    "stroke-color": ["get", "strokeColor"],
    "stroke-width": ["get", "strokeWidth", "number"],
    "fill-color": ["get", "fillColor"],
    opacity: ["get", "opacity", "number"],
    size: ["get", "circleSize", "number"]
  }, WE);
  function Cce() {
    class t extends HA {
      /**
       * Creates a new renderer that takes the defined style of the new layer as an input.
       * @returns {module:ol/renderer/webgl/WebGLVectorLayerRenderer} the custom renderer
       * @experimental
       */
      createRenderer() {
        return new Nle(this, {
          style: lP
        });
      }
    }
    return t;
  }
  function bce() {
    class t extends Sl {
      /**
       * Creates a new renderer that takes the defined style of the new layer as an input.
       * @returns {module:ol/renderer/webgl/WebGLVectorTileLayerRenderer} the custom renderer
       * @experimental
       */
      createRenderer() {
        const i = RB(lP), r = [255, 255, 255, 0], n = [119, 119, 119, 1];
        return new zle(this, {
          style: {
            fill: {
              fragment: i.builder.getFillFragmentShader(),
              vertex: i.builder.getFillVertexShader()
            },
            stroke: {
              fragment: i.builder.getStrokeFragmentShader(),
              vertex: i.builder.getStrokeVertexShader()
            },
            symbol: {
              fragment: i.builder.getSymbolFragmentShader(),
              vertex: i.builder.getSymbolVertexShader()
            },
            builder: i.builder,
            attributes: {
              fillColor: {
                size: 2,
                callback: (s) => {
                  var a, A;
                  const o = this.getStyle()(s, 1);
                  if (o && o[0]) {
                    const l = (A = (a = o[0]) == null ? void 0 : a.getFill()) == null ? void 0 : A.getColor();
                    return Ch(l && typeof l == "string" ? Hn(l) : r);
                  }
                  return Ch(n);
                }
              },
              strokeColor: {
                size: 2,
                callback: (s) => {
                  var a, A;
                  const o = this.getStyle()(s, 1);
                  if (o && o[0]) {
                    const l = (A = (a = o[0]) == null ? void 0 : a.getStroke()) == null ? void 0 : A.getColor();
                    return Ch(l ? Hn(l) : r);
                  }
                  return Ch(n);
                }
              },
              strokeWidth: {
                size: 1,
                callback: (s) => {
                  var a, A;
                  const o = this.getStyle()(s, 1);
                  if (o && o[0]) {
                    const l = (A = (a = o[0]) == null ? void 0 : a.getStroke()) == null ? void 0 : A.getWidth();
                    if (l !== void 0)
                      return l > 10 ? l / 10 : 1;
                  }
                  return 1;
                }
              }
            }
          }
        });
      }
    }
    return t;
  }
  function Mce(t, e) {
    let i;
    if (e && (i = Ece(e, t)[0]), i != null && i.style) {
      t.styleRule = i;
      const r = sC(i.style.polygonFillColor, "rgba"), n = sC(i.style.circleFillColor, "hex"), s = r || n, o = sC(i.style.polygonStrokeColor || i.style.lineStrokeColor, "hex"), a = i.style.polygonStrokeWidth || i.style.lineStrokeWidth, A = i.style.circleRadius;
      t.set("fillColor", s || $a.fillColor), t.set("strokeColor", o || $a.strokeColor), t.set("strokeWidth", a || $a.strokeWidth), t.set("opacity", s ? (i.style.polygonFillColor || i.style.circleFillColor)[3] : $a.opacity), t.set("circleSize", A || WE["circle-radius"] * 2);
    } else
      t.set("fillColor", $a.fillColor), t.set("strokeColor", $a.strokeColor), t.set("strokeWidth", $a.strokeWidth), t.set("opacity", $a.opacity), t.set("circleSize", WE["circle-radius"] * 2);
  }
  function Ice(t) {
    var e, i;
    (i = (e = t.getGeometry()) == null ? void 0 : e.setCoordinates) == null || i.call(e, t.getGeometry().getCoordinates(), "XY");
  }
  function vce(t, e = ["boolean"]) {
    for (const i in t.getProperties()) {
      const r = parseFloat(t.get(i)), n = typeof t.get(i) == "string" && t.get(i).toLowerCase() === "true" ? !0 : void 0, s = typeof t.get(i) == "string" && t.get(i).toLowerCase() === "false" ? !1 : void 0;
      !isNaN(parseFloat(t.get(i))) && !(e != null && e.includes("number")) && t.set(i, r), n === !0 && !e.includes("boolean") && t.set(i, n), s === !1 && !e.includes("boolean") && t.set(i, s);
    }
  }
  function hd(t, e, i, r) {
    const n = ice.returnStyleObject(e);
    Array.isArray(t) && t.forEach((s) => {
      r && s.getGeometry().getType() === "MultiPoint" && s.setGeometry(s.getGeometry().getPoint(0)), Ice(s), Mce(s, n), vce(s, i);
    });
  }
  function kB(t) {
    let e = Fle;
    const i = {
      id: t.id,
      source: t.source,
      disableHitDetection: !1,
      name: t.name,
      typ: t.typ,
      gfiAttributes: t.gfiAttributes,
      gfiTheme: t.gfiTheme,
      hitTolerance: t.hitTolerance || 10,
      opacity: t.transparency ? (100 - t.transparency) / 100 : t.opacity,
      renderer: "webgl",
      styleId: t.styleId,
      excludeTypesFromParsing: t.excludeTypesFromParsing,
      extent: t.extent
    };
    return t.isPointLayer ? new e({
      style: t.style || WE,
      disableHitDetection: !1,
      ...i,
      isPointLayer: !0
    }) : (t.typ === "VectorTile" ? e = bce() : e = Cce(), new e({
      ...i,
      isPointLayer: !1
    }));
  }
  class xce extends Do {
    /**
     * @param {Options<FeatureType>} [options] Cluster options.
     */
    constructor(e) {
      e = e || {}, super({
        attributions: e.attributions,
        wrapX: e.wrapX
      }), this.resolution = void 0, this.distance = e.distance !== void 0 ? e.distance : 20, this.minDistance = e.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = e.geometryFunction || function(i) {
        const r = (
          /** @type {Point} */
          i.getGeometry()
        );
        return Mt(
          !r || r.getType() === "Point",
          "The default `geometryFunction` can only handle `Point` or null geometries"
        ), r;
      }, this.createCustomCluster_ = e.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(e.source || null);
    }
    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
     * @api
     * @override
     */
    clear(e) {
      this.features.length = 0, super.clear(e);
    }
    /**
     * Get the distance in pixels between clusters.
     * @return {number} Distance.
     * @api
     */
    getDistance() {
      return this.distance;
    }
    /**
     * Get a reference to the wrapped source.
     * @return {VectorSource<FeatureType>|null} Source.
     * @api
     */
    getSource() {
      return this.source;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @override
     */
    loadFeatures(e, i, r) {
      var n;
      (n = this.source) == null || n.loadFeatures(e, i, r), i !== this.resolution && (this.resolution = i, this.refresh());
    }
    /**
     * Set the distance within which features will be clusterd together.
     * @param {number} distance The distance in pixels.
     * @api
     */
    setDistance(e) {
      this.updateDistance(e, this.minDistance);
    }
    /**
     * Set the minimum distance between clusters. Will be capped at the
     * configured distance.
     * @param {number} minDistance The minimum distance in pixels.
     * @api
     */
    setMinDistance(e) {
      this.updateDistance(this.distance, e);
    }
    /**
     * The configured minimum distance between clusters.
     * @return {number} The minimum distance in pixels.
     * @api
     */
    getMinDistance() {
      return this.minDistance;
    }
    /**
     * Replace the wrapped source.
     * @param {VectorSource<FeatureType>|null} source The new source for this instance.
     * @api
     */
    setSource(e) {
      this.source && this.source.removeEventListener(Ge.CHANGE, this.boundRefresh_), this.source = e, e && e.addEventListener(Ge.CHANGE, this.boundRefresh_), this.refresh();
    }
    /**
     * Handle the source changing.
     * @override
     */
    refresh() {
      this.clear(), this.cluster(), this.addFeatures(this.features);
    }
    /**
     * Update the distances and refresh the source if necessary.
     * @param {number} distance The new distance.
     * @param {number} minDistance The new minimum distance.
     */
    updateDistance(e, i) {
      const r = e === 0 ? 0 : Math.min(i, e) / e, n = e !== this.distance || this.interpolationRatio !== r;
      this.distance = e, this.minDistance = i, this.interpolationRatio = r, n && this.refresh();
    }
    /**
     * @protected
     */
    cluster() {
      if (this.resolution === void 0 || !this.source)
        return;
      const e = yr(), i = this.distance * this.resolution, r = this.source.getFeatures(), n = {};
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        if (!(ve(a) in n)) {
          const A = this.geometryFunction(a);
          if (A) {
            const l = A.getCoordinates();
            Qu(l, e), $r(e, i, e);
            const c = this.source.getFeaturesInExtent(e).filter(function(u) {
              const d = ve(u);
              return d in n ? !1 : (n[d] = !0, !0);
            });
            this.features.push(this.createCluster(c, e));
          }
        }
      }
    }
    /**
     * @param {Array<FeatureType>} features Features
     * @param {import("../extent.js").Extent} extent The searched extent for these features.
     * @return {Feature} The cluster feature.
     * @protected
     */
    createCluster(e, i) {
      const r = [0, 0];
      for (let a = e.length - 1; a >= 0; --a) {
        const A = this.geometryFunction(e[a]);
        A ? eU(r, A.getCoordinates()) : e.splice(a, 1);
      }
      tU(r, 1 / e.length);
      const n = xn(i), s = this.interpolationRatio, o = new Cn([
        r[0] * (1 - s) + n[0] * s,
        r[1] * (1 - s) + n[1] * s
      ]);
      return this.createCustomCluster_ ? this.createCustomCluster_(o, e) : new hr({
        geometry: o,
        features: e
      });
    }
  }
  function Ox(t, e, i) {
    let r, n, s;
    return typeof t == "string" ? n = t : typeof t == "function" ? r = t : typeof t == "object" && (s = i.readFeatures(t, {
      dataProjection: "EPSG:4326",
      featureProjection: "EPSG:25832"
    })), new Do({
      loader: r,
      features: s,
      url: n,
      strategy: e,
      format: i
    });
  }
  function Gx(t, e, i) {
    return new xce({
      source: t,
      distance: e,
      geometryFunction: i
    });
  }
  function AM({ url: t, features: e, clusterDistance: i, renderer: r, styleId: n, excludeTypesFromParsing: s, isPointLayer: o }, a) {
    const A = new ld();
    let l = null;
    return l = Ox(t || e, a.loadingStrategy, A), typeof i == "number" && (l = Gx(l, i, a.clusterGeometryFunction)), (typeof i == "number" ? l.getSource() : l).once("featuresloadend", (c) => {
      typeof a.afterLoading == "function" && a.afterLoading(c == null ? void 0 : c.features);
    }), r === "webgl" && ((e == null ? void 0 : e.length) > 0 && hd(l.getFeatures(), n, s, o), l.once("featuresloadend", (c) => {
      hd(c == null ? void 0 : c.features, n, s, o);
    })), l;
  }
  function Qce(t = {}, { layerParams: e = {}, options: i = {} } = {}) {
    let r, n;
    return e.renderer === "webgl" ? (n = AM({
      ...t,
      renderer: e.renderer,
      styleId: e.styleId,
      excludeTypesFromParsing: e.excludeTypesFromParsing,
      isPointLayer: e.isPointLayer
    }, i), r = kB({
      ...t,
      ...e,
      source: n
    }), r) : (n = AM(t, i), r = new Bs(Object.assign({
      id: t.id,
      source: n
    }, e)), i.style ? r.setStyle(i.style) : t.style ? r.setStyle(t.style) : r.setStyle(ZAe), r);
  }
  function Fce(t) {
    t.getSource().refresh(), t.get("renderer") === "webgl" && t.getSource().once("featuresloadend", (e) => {
      hd(e == null ? void 0 : e.features, t.get("styleId"), t.get("excludeTypesFromParsing"), t.get("isPointLayer"));
    });
  }
  function YB(t, e) {
    t.forEach((i) => i.setStyle(e));
  }
  function cP(t) {
    YB(t.getSource().getFeatures(), () => null);
  }
  function Sce(t) {
    YB(t.getSource().getFeatures(), void 0);
  }
  function Dce(t, e) {
    const i = t.getSource().getFeatures().filter((r) => e.indexOf(r.getId()) >= 0);
    cP(t), YB(i, void 0);
  }
  function Tce(t, e) {
    const i = t.url;
    fetch(i, e).then((r) => r.text()).then((r) => {
      const n = e.getFormat().readFeatures(r);
      e.addFeatures(n), e.dispatchEvent({
        type: "featuresloadend",
        features: e.getFeatures()
      });
    }).catch((r) => {
      console.error(r);
    });
  }
  const Rce = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    createLayer: Qce,
    createLayerSource: AM,
    hideAllFeatures: cP,
    loadFeaturesManually: Tce,
    setCustomStyles: VAe,
    setFeatureStyle: YB,
    showAllFeatures: Sce,
    showFeaturesById: Dce,
    updateSource: Fce
  }, Symbol.toStringTag, { value: "Module" }));
  class uP extends fx {
    constructor() {
      super(), this.xmlSerializer_ = Oae();
    }
    /**
     * @return {import("./Feature.js").Type} Format.
     * @override
     */
    getType() {
      return "xml";
    }
    /**
     * Read a single feature.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     * @override
     */
    readFeature(e, i) {
      if (!e)
        return null;
      if (typeof e == "string") {
        const r = Cl(e);
        return this.readFeatureFromDocument(r, i);
      }
      return wl(e) ? this.readFeatureFromDocument(
        /** @type {Document} */
        e,
        i
      ) : this.readFeatureFromNode(
        /** @type {Element} */
        e,
        i
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromDocument(e, i) {
      const r = this.readFeaturesFromDocument(e, i);
      return r.length > 0 ? r[0] : null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromNode(e, i) {
      return null;
    }
    /**
     * Read all features from a feature collection.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     * @override
     */
    readFeatures(e, i) {
      if (!e)
        return [];
      if (typeof e == "string") {
        const r = Cl(e);
        return this.readFeaturesFromDocument(r, i);
      }
      return wl(e) ? this.readFeaturesFromDocument(
        /** @type {Document} */
        e,
        i
      ) : this.readFeaturesFromNode(
        /** @type {Element} */
        e,
        i
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    readFeaturesFromDocument(e, i) {
      const r = [];
      for (let n = e.firstChild; n; n = n.nextSibling)
        n.nodeType == Node.ELEMENT_NODE && xr(
          r,
          this.readFeaturesFromNode(
            /** @type {Element} */
            n,
            i
          )
        );
      return r;
    }
    /**
     * @abstract
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    readFeaturesFromNode(e, i) {
      return it();
    }
    /**
     * Read a single geometry from a source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    readGeometry(e, i) {
      if (!e)
        return null;
      if (typeof e == "string") {
        const r = Cl(e);
        return this.readGeometryFromDocument(r, i);
      }
      return wl(e) ? this.readGeometryFromDocument(
        /** @type {Document} */
        e,
        i
      ) : this.readGeometryFromNode(
        /** @type {Element} */
        e,
        i
      );
    }
    /**
     * @param {Document} doc Document.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromDocument(e, i) {
      return null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromNode(e, i) {
      return null;
    }
    /**
     * Read the projection from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    readProjection(e) {
      if (!e)
        return null;
      if (typeof e == "string") {
        const i = Cl(e);
        return this.readProjectionFromDocument(i);
      }
      return wl(e) ? this.readProjectionFromDocument(
        /** @type {Document} */
        e
      ) : this.readProjectionFromNode(
        /** @type {Element} */
        e
      );
    }
    /**
     * @param {Document} doc Document.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromDocument(e) {
      return this.dataProjection;
    }
    /**
     * @param {Element} node Node.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromNode(e) {
      return this.dataProjection;
    }
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @override
     */
    writeFeature(e, i) {
      const r = this.writeFeatureNode(e, i);
      return this.xmlSerializer_.serializeToString(r);
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @protected
     * @return {Node} Node.
     */
    writeFeatureNode(e, i) {
      return null;
    }
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Result.
     * @api
     * @override
     */
    writeFeatures(e, i) {
      const r = this.writeFeaturesNode(e, i);
      return this.xmlSerializer_.serializeToString(r);
    }
    /**
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeFeaturesNode(e, i) {
      return null;
    }
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded geometry.
     * @override
     */
    writeGeometry(e, i) {
      const r = this.writeGeometryNode(e, i);
      return this.xmlSerializer_.serializeToString(r);
    }
    /**
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     */
    writeGeometryNode(e, i) {
      return null;
    }
  }
  const wa = "http://www.opengis.net/gml", _ce = /^\s*$/;
  class He extends uP {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(e) {
      super(), e = e || {}, this.featureType = e.featureType, this.featureNS = e.featureNS, this.srsName = e.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
        featureMember: st(this.readFeaturesInternal),
        featureMembers: tt(this.readFeaturesInternal)
      }, this.supportedMediaTypes = ["application/gml+xml"];
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<Feature> | undefined} Features.
     */
    readFeaturesInternal(e, i) {
      const r = e.localName;
      let n = null;
      if (r == "FeatureCollection")
        n = Ze(
          [],
          this.FEATURE_COLLECTION_PARSERS,
          e,
          i,
          this
        );
      else if (r == "featureMembers" || r == "featureMember" || r == "member") {
        const s = i[0];
        let o = s.featureType, a = s.featureNS;
        const A = "p", l = "p0";
        if (!o && e.childNodes) {
          o = [], a = {};
          for (let d = 0, h = e.childNodes.length; d < h; ++d) {
            const g = (
              /** @type {Element} */
              e.childNodes[d]
            );
            if (g.nodeType === 1) {
              const f = g.nodeName.split(":").pop();
              if (!o.includes(f)) {
                let p = "", m = 0;
                const E = g.namespaceURI;
                for (const y in a) {
                  if (a[y] === E) {
                    p = y;
                    break;
                  }
                  ++m;
                }
                p || (p = A + m, a[p] = E), o.push(p + ":" + f);
              }
            }
          }
          r != "featureMember" && (s.featureType = o, s.featureNS = a);
        }
        if (typeof a == "string") {
          const d = a;
          a = {}, a[l] = d;
        }
        const c = {}, u = Array.isArray(o) ? o : [o];
        for (const d in a) {
          const h = {};
          for (let g = 0, f = u.length; g < f; ++g)
            (u[g].includes(":") ? u[g].split(":")[0] : l) === d && (h[u[g].split(":").pop()] = r == "featureMembers" ? st(this.readFeatureElement, this) : tt(this.readFeatureElement, this));
          c[a[d]] = h;
        }
        r == "featureMember" || r == "member" ? n = Ze(void 0, c, e, i) : n = Ze([], c, e, i);
      }
      return n === null && (n = []), n;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
     */
    readGeometryOrExtent(e, i) {
      const r = (
        /** @type {Object} */
        i[0]
      );
      return r.srsName = e.firstElementChild.getAttribute("srsName"), r.srsDimension = e.firstElementChild.getAttribute("srsDimension"), Ze(
        null,
        this.GEOMETRY_PARSERS,
        e,
        i,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Geometry.
     */
    readExtentElement(e, i) {
      const r = (
        /** @type {Object} */
        i[0]
      ), n = (
        /** @type {import("../extent.js").Extent} */
        this.readGeometryOrExtent(e, i)
      );
      return n ? px(n, r) : void 0;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../geom/Geometry.js").default|undefined} Geometry.
     */
    readGeometryElement(e, i) {
      const r = (
        /** @type {Object} */
        i[0]
      ), n = (
        /** @type {import("../geom/Geometry.js").default} */
        this.readGeometryOrExtent(e, i)
      );
      return n ? uc(n, !1, r) : void 0;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @param {boolean} asFeature whether result should be wrapped as a feature.
     * @return {Feature|Object} Feature
     */
    readFeatureElementInternal(e, i, r) {
      let n;
      const s = {};
      for (let A = e.firstElementChild; A; A = A.nextElementSibling) {
        let l;
        const c = A.localName;
        A.childNodes.length === 0 || A.childNodes.length === 1 && (A.firstChild.nodeType === 3 || A.firstChild.nodeType === 4) ? (l = jl(A, !1), _ce.test(l) && (l = void 0)) : (r && (l = c === "boundedBy" ? this.readExtentElement(A, i) : this.readGeometryElement(A, i)), l ? c !== "boundedBy" && (n = c) : l = this.readFeatureElementInternal(A, i, !1));
        const u = A.attributes.length;
        if (u > 0 && !(l instanceof bv)) {
          l = { _content_: l };
          for (let d = 0; d < u; d++) {
            const h = A.attributes[d].name;
            l[h] = A.attributes[d].value;
          }
        }
        s[c] ? (s[c] instanceof Array || (s[c] = [s[c]]), s[c].push(l)) : s[c] = l;
      }
      if (!r)
        return s;
      const o = new hr(s);
      n && o.setGeometryName(n);
      const a = e.getAttribute("fid") || zae(e, this.namespace, "id");
      return a && o.setId(a), o;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Feature} Feature.
     */
    readFeatureElement(e, i) {
      return this.readFeatureElementInternal(e, i, !0);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Point|undefined} Point.
     */
    readPoint(e, i) {
      const r = this.readFlatCoordinatesFromNode(e, i);
      if (r)
        return new Cn(r, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPoint|undefined} MultiPoint.
     */
    readMultiPoint(e, i) {
      const r = Ze(
        [],
        this.MULTIPOINT_PARSERS,
        e,
        i,
        this
      );
      if (r)
        return new lc(r);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiLineString(e, i) {
      const r = Ze(
        [],
        this.MULTILINESTRING_PARSERS,
        e,
        i,
        this
      );
      if (r)
        return new Da(r);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiPolygon(e, i) {
      const r = Ze(
        [],
        this.MULTIPOLYGON_PARSERS,
        e,
        i,
        this
      );
      if (r)
        return new Ta(r);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    pointMemberParser(e, i) {
      Ql(this.POINTMEMBER_PARSERS, e, i, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    lineStringMemberParser(e, i) {
      Ql(this.LINESTRINGMEMBER_PARSERS, e, i, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    polygonMemberParser(e, i) {
      Ql(this.POLYGONMEMBER_PARSERS, e, i, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readLineString(e, i) {
      const r = this.readFlatCoordinatesFromNode(e, i);
      if (r)
        return new bn(r, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} LinearRing flat coordinates.
     */
    readFlatLinearRing(e, i) {
      const r = Ze(
        null,
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        e,
        i,
        this
      );
      if (r)
        return r;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LinearRing|undefined} LinearRing.
     */
    readLinearRing(e, i) {
      const r = this.readFlatCoordinatesFromNode(e, i);
      if (r)
        return new rd(r, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readPolygon(e, i) {
      const r = Ze(
        [null],
        this.FLAT_LINEAR_RINGS_PARSERS,
        e,
        i,
        this
      );
      if (r && r[0]) {
        const n = r[0], s = [n.length];
        let o, a;
        for (o = 1, a = r.length; o < a; ++o)
          xr(n, r[o]), s.push(n.length);
        return new en(n, "XYZ", s);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>} Flat coordinates.
     */
    readFlatCoordinatesFromNode(e, i) {
      return Ze(
        null,
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        e,
        i,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @override
     */
    readGeometryFromNode(e, i) {
      const r = this.readGeometryElement(e, [
        this.getReadOptions(e, i || {})
      ]);
      return r || null;
    }
    /**
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @override
     */
    readFeaturesFromNode(e, i) {
      const r = {
        featureType: this.featureType,
        featureNS: this.featureNS
      };
      return r && Object.assign(r, this.getReadOptions(e, i)), this.readFeaturesInternal(e, [r]) || [];
    }
    /**
     * @param {Element} node Node.
     * @return {import("../proj/Projection.js").default} Projection.
     * @override
     */
    readProjectionFromNode(e) {
      return Xe(
        this.srsName ? this.srsName : e.firstElementChild.getAttribute("srsName")
      );
    }
  }
  He.prototype.namespace = wa;
  He.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  He.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  He.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {}
  };
  He.prototype.MULTIPOINT_PARSERS = {
    "http://www.opengis.net/gml": {
      pointMember: st(He.prototype.pointMemberParser),
      pointMembers: st(He.prototype.pointMemberParser)
    }
  };
  He.prototype.MULTILINESTRING_PARSERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: st(
        He.prototype.lineStringMemberParser
      ),
      lineStringMembers: st(
        He.prototype.lineStringMemberParser
      )
    }
  };
  He.prototype.MULTIPOLYGON_PARSERS = {
    "http://www.opengis.net/gml": {
      polygonMember: st(He.prototype.polygonMemberParser),
      polygonMembers: st(He.prototype.polygonMemberParser)
    }
  };
  He.prototype.POINTMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: st(He.prototype.readFlatCoordinatesFromNode)
    }
  };
  He.prototype.LINESTRINGMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      LineString: st(He.prototype.readLineString)
    }
  };
  He.prototype.POLYGONMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Polygon: st(He.prototype.readPolygon)
    }
  };
  He.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml": {
      LinearRing: tt(He.prototype.readFlatLinearRing)
    }
  };
  const kce = wa + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", Yce = {
    MultiLineString: "lineStringMember",
    MultiCurve: "curveMember",
    MultiPolygon: "polygonMember",
    MultiSurface: "surfaceMember"
  };
  class _t extends He {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(e) {
      e = e || {}, super(e), this.FEATURE_COLLECTION_PARSERS[wa].featureMember = st(
        this.readFeaturesInternal
      ), this.schemaLocation = e.schemaLocation ? e.schemaLocation : kce;
    }
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatCoordinates(e, i) {
      const r = jl(e, !1).replace(/^\s*|\s*$/g, ""), s = /** @type {import("../xml.js").NodeStackItem} */ i[0].srsName;
      let o = "enu";
      if (s) {
        const l = Xe(s);
        l && (o = l.getAxisOrientation());
      }
      const a = r.trim().split(/\s+/), A = [];
      for (let l = 0, c = a.length; l < c; l++) {
        const u = a[l].split(/,+/), d = parseFloat(u[0]), h = parseFloat(u[1]), g = u.length === 3 ? parseFloat(u[2]) : 0;
        o.startsWith("en") ? A.push(d, h, g) : A.push(h, d, g);
      }
      return A;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readBox(e, i) {
      const r = Ze(
        [null],
        this.BOX_PARSERS_,
        e,
        i,
        this
      );
      return fs(
        r[1][0],
        r[1][1],
        r[1][3],
        r[1][4]
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    innerBoundaryIsParser(e, i) {
      const r = Ze(
        void 0,
        this.RING_PARSERS,
        e,
        i,
        this
      );
      r && /** @type {Array<Array<number>>} */
      i[i.length - 1].push(r);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    outerBoundaryIsParser(e, i) {
      const r = Ze(
        void 0,
        this.RING_PARSERS,
        e,
        i,
        this
      );
      if (r) {
        const n = (
          /** @type {Array<Array<number>>} */
          i[i.length - 1]
        );
        n[0] = r;
      }
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    GEOMETRY_NODE_FACTORY_(e, i, r) {
      const n = i[i.length - 1], s = n.multiSurface, o = n.surface, a = n.multiCurve;
      return Array.isArray(e) ? r = "Envelope" : (r = /** @type {import("../geom/Geometry.js").default} */
      e.getType(), r === "MultiPolygon" && s === !0 ? r = "MultiSurface" : r === "Polygon" && o === !0 ? r = "Surface" : r === "MultiLineString" && a === !0 && (r = "MultiCurve")), Bt("http://www.opengis.net/gml", r);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(e, i, r) {
      const n = i.getId();
      n && e.setAttribute(
        "fid",
        /** @type {string} */
        n
      );
      const s = (
        /** @type {Object} */
        r[r.length - 1]
      ), o = s.featureNS, a = i.getGeometryName();
      s.serializers || (s.serializers = {}, s.serializers[o] = {});
      const A = [], l = [];
      if (i.hasProperties()) {
        const u = i.getProperties();
        for (const d in u) {
          const h = u[d];
          h != null && (A.push(d), l.push(h), d == a || typeof /** @type {?} */
          h.getSimplifiedGeometry == "function" ? d in s.serializers[o] || (s.serializers[o][d] = ce(
            this.writeGeometryElement,
            this
          )) : d in s.serializers[o] || (s.serializers[o][d] = ce(tr)));
        }
      }
      const c = Object.assign({}, s);
      c.node = e, Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        c,
        s.serializers,
        Ln(void 0, o),
        l,
        r,
        A
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(e, i, r) {
      const s = r[r.length - 1].srsName;
      if (e.nodeName !== "LineStringSegment" && s && e.setAttribute("srsName", s), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
        const o = this.createCoordinatesNode_(e.namespaceURI);
        e.appendChild(o), this.writeCoordinates_(o, i, r);
      } else if (e.nodeName === "Curve") {
        const o = Bt(e.namespaceURI, "segments");
        e.appendChild(o), this.writeCurveSegments_(o, i, r);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(e, i, r) {
      const n = this.GEOMETRY_NODE_FACTORY_(i, r);
      n && (e.appendChild(n), this.writeCurveOrLineString(n, i, r));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName, a = n.curve;
      o && e.setAttribute("srsName", o);
      const A = i.getLineStrings();
      Ni(
        { node: e, hasZ: s, srsName: o, curve: a },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        A,
        r,
        void 0,
        this
      );
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(e, i, r) {
      const n = (
        /** @type {import("./Feature.js").WriteOptions} */
        r[r.length - 1]
      ), s = Object.assign({}, n);
      s.node = e;
      let o;
      Array.isArray(i) ? o = px(
        /** @type {import("../extent.js").Extent} */
        i,
        n
      ) : o = uc(
        /** @type {import("../geom/Geometry.js").default} */
        i,
        !0,
        n
      ), Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        s,
        this.GEOMETRY_SERIALIZERS,
        this.GEOMETRY_NODE_FACTORY_,
        [o],
        r,
        void 0,
        this
      );
    }
    /**
     * @param {string} namespaceURI XML namespace.
     * @return {Element} coordinates node.
     * @private
     */
    createCoordinatesNode_(e) {
      const i = Bt(e, "coordinates");
      return i.setAttribute("decimal", "."), i.setAttribute("cs", ","), i.setAttribute("ts", " "), i;
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCoordinates_(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName, a = i.getCoordinates(), A = a.length, l = new Array(A);
      for (let c = 0; c < A; ++c) {
        const u = a[c];
        l[c] = this.getCoords_(u, o, s);
      }
      tr(e, l.join(" "));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LineString.js").default} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCurveSegments_(e, i, r) {
      const n = Bt(e.namespaceURI, "LineStringSegment");
      e.appendChild(n), this.writeCurveOrLineString(n, i, r);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName;
      if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
        const a = i.getLinearRings();
        Ni(
          { node: e, hasZ: s, srsName: o },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          a,
          r,
          void 0,
          this
        );
      } else if (e.nodeName === "Surface") {
        const a = Bt(e.namespaceURI, "patches");
        e.appendChild(a), this.writeSurfacePatches_(a, i, r);
      }
    }
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    RING_NODE_FACTORY_(e, i, r) {
      const n = i[i.length - 1], s = n.node, o = n.exteriorWritten;
      return o === void 0 && (n.exteriorWritten = !0), Bt(
        s.namespaceURI,
        o !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeSurfacePatches_(e, i, r) {
      const n = Bt(e.namespaceURI, "PolygonPatch");
      e.appendChild(n), this.writeSurfaceOrPolygon(n, i, r);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(e, i, r) {
      const n = Bt(e.namespaceURI, "LinearRing");
      e.appendChild(n), this.writeLinearRing(n, i, r);
    }
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    getCoords_(e, i, r) {
      let s = (i ? Xe(i).getAxisOrientation() : "enu").startsWith("en") ? e[0] + "," + e[1] : e[1] + "," + e[0];
      if (r) {
        const o = e[2] || 0;
        s += "," + o;
      }
      return s;
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName;
      o && e.setAttribute("srsName", o);
      const a = this.createCoordinatesNode_(e.namespaceURI);
      e.appendChild(a);
      const A = i.getCoordinates(), l = this.getCoords_(A, o, s);
      tr(a, l);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName;
      o && e.setAttribute("srsName", o);
      const a = i.getPoints();
      Ni(
        { node: e, hasZ: s, srsName: o },
        this.POINTMEMBER_SERIALIZERS,
        Ln("pointMember"),
        a,
        r,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(e, i, r) {
      const n = Bt(e.namespaceURI, "Point");
      e.appendChild(n), this.writePoint(n, i, r);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(e, i, r) {
      const s = r[r.length - 1].srsName;
      s && e.setAttribute("srsName", s);
      const o = this.createCoordinatesNode_(e.namespaceURI);
      e.appendChild(o), this.writeCoordinates_(o, i, r);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName, a = n.surface;
      o && e.setAttribute("srsName", o);
      const A = i.getPolygons();
      Ni(
        { node: e, hasZ: s, srsName: o, surface: a },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        A,
        r,
        void 0,
        this
      );
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(e, i, r) {
      const n = this.GEOMETRY_NODE_FACTORY_(i, r);
      n && (e.appendChild(n), this.writeSurfaceOrPolygon(n, i, r));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(e, i, r) {
      const s = r[r.length - 1].srsName;
      s && e.setAttribute("srsName", s);
      const o = ["lowerCorner", "upperCorner"], a = [i[0] + " " + i[1], i[2] + " " + i[3]];
      Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        { node: e },
        this.ENVELOPE_SERIALIZERS,
        Uz,
        a,
        r,
        o,
        this
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, i, r) {
      const n = i[i.length - 1].node;
      return Bt(
        "http://www.opengis.net/gml",
        Yce[n.nodeName]
      );
    }
  }
  _t.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      coordinates: tt(_t.prototype.readFlatCoordinates)
    }
  };
  _t.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {
      innerBoundaryIs: _t.prototype.innerBoundaryIsParser,
      outerBoundaryIs: _t.prototype.outerBoundaryIsParser
    }
  };
  _t.prototype.BOX_PARSERS_ = {
    "http://www.opengis.net/gml": {
      coordinates: st(_t.prototype.readFlatCoordinates)
    }
  };
  _t.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: tt(He.prototype.readPoint),
      MultiPoint: tt(He.prototype.readMultiPoint),
      LineString: tt(He.prototype.readLineString),
      MultiLineString: tt(He.prototype.readMultiLineString),
      LinearRing: tt(He.prototype.readLinearRing),
      Polygon: tt(He.prototype.readPolygon),
      MultiPolygon: tt(He.prototype.readMultiPolygon),
      Box: tt(_t.prototype.readBox)
    }
  };
  _t.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      Curve: ce(_t.prototype.writeCurveOrLineString),
      MultiCurve: ce(_t.prototype.writeMultiCurveOrLineString),
      Point: ce(_t.prototype.writePoint),
      MultiPoint: ce(_t.prototype.writeMultiPoint),
      LineString: ce(_t.prototype.writeCurveOrLineString),
      MultiLineString: ce(
        _t.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: ce(_t.prototype.writeLinearRing),
      Polygon: ce(_t.prototype.writeSurfaceOrPolygon),
      MultiPolygon: ce(
        _t.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: ce(_t.prototype.writeSurfaceOrPolygon),
      MultiSurface: ce(
        _t.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: ce(_t.prototype.writeEnvelope)
    }
  };
  _t.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: ce(
        _t.prototype.writeLineStringOrCurveMember
      ),
      curveMember: ce(
        _t.prototype.writeLineStringOrCurveMember
      )
    }
  };
  _t.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      outerBoundaryIs: ce(_t.prototype.writeRing),
      innerBoundaryIs: ce(_t.prototype.writeRing)
    }
  };
  _t.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      pointMember: ce(_t.prototype.writePointMember)
    }
  };
  _t.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: ce(
        _t.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: ce(
        _t.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  _t.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: ce(tr),
      upperCorner: ce(tr)
    }
  };
  const Nce = wa + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", Uce = {
    MultiLineString: "lineStringMember",
    MultiCurve: "curveMember",
    MultiPolygon: "polygonMember",
    MultiSurface: "surfaceMember"
  };
  class me extends He {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(e) {
      e = e || {}, super(e), this.surface_ = e.surface !== void 0 ? e.surface : !1, this.curve_ = e.curve !== void 0 ? e.curve : !1, this.multiCurve_ = e.multiCurve !== void 0 ? e.multiCurve : !0, this.multiSurface_ = e.multiSurface !== void 0 ? e.multiSurface : !0, this.schemaLocation = e.schemaLocation ? e.schemaLocation : Nce, this.hasZ = e.hasZ !== void 0 ? e.hasZ : !1;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiLineString|undefined} MultiLineString.
     */
    readMultiCurve(e, i) {
      const r = Ze(
        [],
        this.MULTICURVE_PARSERS,
        e,
        i,
        this
      );
      if (r)
        return new Da(r);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Polygon.
     */
    readFlatCurveRing(e, i) {
      const r = Ze(
        [],
        this.MULTICURVE_PARSERS,
        e,
        i,
        this
      ), n = [];
      for (let s = 0, o = r.length; s < o; ++s)
        xr(n, r[s].getFlatCoordinates());
      return n;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {MultiPolygon|undefined} MultiPolygon.
     */
    readMultiSurface(e, i) {
      const r = Ze(
        [],
        this.MULTISURFACE_PARSERS,
        e,
        i,
        this
      );
      if (r)
        return new Ta(r);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    curveMemberParser(e, i) {
      Ql(this.CURVEMEMBER_PARSERS, e, i, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    surfaceMemberParser(e, i) {
      Ql(this.SURFACEMEMBER_PARSERS, e, i, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPatch(e, i) {
      return Ze(
        [null],
        this.PATCHES_PARSERS,
        e,
        i,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readSegment(e, i) {
      return Ze([], this.SEGMENTS_PARSERS, e, i, this);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<(Array<number>)>|undefined} flat coordinates.
     */
    readPolygonPatch(e, i) {
      return Ze(
        [null],
        this.FLAT_LINEAR_RINGS_PARSERS,
        e,
        i,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} flat coordinates.
     */
    readLineStringSegment(e, i) {
      return Ze(
        [null],
        this.GEOMETRY_FLAT_COORDINATES_PARSERS,
        e,
        i,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    interiorParser(e, i) {
      const r = Ze(
        void 0,
        this.RING_PARSERS,
        e,
        i,
        this
      );
      r && /** @type {Array<Array<number>>} */
      i[i.length - 1].push(r);
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    exteriorParser(e, i) {
      const r = Ze(
        void 0,
        this.RING_PARSERS,
        e,
        i,
        this
      );
      if (r) {
        const n = (
          /** @type {Array<Array<number>>} */
          i[i.length - 1]
        );
        n[0] = r;
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Polygon|undefined} Polygon.
     */
    readSurface(e, i) {
      const r = Ze(
        [null],
        this.SURFACE_PARSERS,
        e,
        i,
        this
      );
      if (r && r[0]) {
        const n = r[0], s = [n.length];
        let o, a;
        for (o = 1, a = r.length; o < a; ++o)
          xr(n, r[o]), s.push(n.length);
        return new en(n, "XYZ", s);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {LineString|undefined} LineString.
     */
    readCurve(e, i) {
      const r = Ze(
        [null],
        this.CURVE_PARSERS,
        e,
        i,
        this
      );
      if (r)
        return new bn(r, "XYZ");
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {import("../extent.js").Extent|undefined} Envelope.
     */
    readEnvelope(e, i) {
      const r = Ze(
        [null],
        this.ENVELOPE_PARSERS,
        e,
        i,
        this
      );
      return fs(
        r[1][0],
        r[1][1],
        r[2][0],
        r[2][1]
      );
    }
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPos(e, i) {
      let r = jl(e, !1);
      const n = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, s = [];
      let o;
      for (; o = n.exec(r); )
        s.push(parseFloat(o[1])), r = r.substr(o[0].length);
      if (r !== "")
        return;
      const A = i[0].srsName;
      if ((A ? Xe(A).getAxisOrientation() : "enu") === "neu")
        for (let u = 0, d = s.length; u < d; u += 3) {
          const h = s[u], g = s[u + 1];
          s[u] = g, s[u + 1] = h;
        }
      const c = s.length;
      if (c == 2 && s.push(0), c !== 0)
        return s;
    }
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     * @return {Array<number>|undefined} Flat coordinates.
     */
    readFlatPosList(e, i) {
      const r = jl(e, !1).replace(/^\s*|\s*$/g, ""), n = i[0], s = n.srsName, o = n.srsDimension, a = s ? Xe(s).getAxisOrientation() : "enu", A = r.split(/\s+/);
      let l = 2;
      e.getAttribute("srsDimension") ? l = pu(e.getAttribute("srsDimension")) : e.getAttribute("dimension") ? l = pu(e.getAttribute("dimension")) : /** @type {Element} */ e.parentNode.getAttribute("srsDimension") ? l = pu(
        /** @type {Element} */
        e.parentNode.getAttribute("srsDimension")
      ) : o && (l = pu(o));
      const c = a.startsWith("en");
      let u, d, h;
      const g = [];
      for (let f = 0, p = A.length; f < p; f += l)
        u = parseFloat(A[f]), d = parseFloat(A[f + 1]), h = l === 3 ? parseFloat(A[f + 2]) : 0, c ? g.push(u, d, h) : g.push(d, u, h);
      return g;
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} value Point geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writePos_(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = s ? "3" : "2";
      e.setAttribute("srsDimension", o);
      const a = n.srsName, A = a ? Xe(a).getAxisOrientation() : "enu", l = i.getCoordinates();
      let c = A.startsWith("en") ? l[0] + " " + l[1] : l[1] + " " + l[0];
      if (s) {
        const u = l[2] || 0;
        c += " " + u;
      }
      tr(e, c);
    }
    /**
     * @param {Array<number>} point Point geometry.
     * @param {string} [srsName] Optional srsName
     * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
     * @return {string} The coords string.
     * @private
     */
    getCoords_(e, i, r) {
      let s = (i ? Xe(i).getAxisOrientation() : "enu").startsWith("en") ? e[0] + " " + e[1] : e[1] + " " + e[0];
      if (r) {
        const o = e[2] || 0;
        s += " " + o;
      }
      return s;
    }
    /**
     * @param {Element} node Node.
     * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writePosList_(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = s ? "3" : "2";
      e.setAttribute("srsDimension", o);
      const a = n.srsName, A = i.getCoordinates(), l = A.length, c = new Array(l);
      let u;
      for (let d = 0; d < l; ++d)
        u = A[d], c[d] = this.getCoords_(u, a, s);
      tr(e, c.join(" "));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} geometry Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePoint(e, i, r) {
      const s = r[r.length - 1].srsName;
      s && e.setAttribute("srsName", s);
      const o = Bt(e.namespaceURI, "pos");
      e.appendChild(o), this.writePos_(o, i, r);
    }
    /**
     * @param {Element} node Node.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {Array<*>} objectStack Node stack.
     */
    writeEnvelope(e, i, r) {
      const s = r[r.length - 1].srsName;
      s && e.setAttribute("srsName", s);
      const o = ["lowerCorner", "upperCorner"], a = [i[0] + " " + i[1], i[2] + " " + i[3]];
      Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        { node: e },
        this.ENVELOPE_SERIALIZERS,
        Uz,
        a,
        r,
        o,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLinearRing(e, i, r) {
      const s = r[r.length - 1].srsName;
      s && e.setAttribute("srsName", s);
      const o = Bt(e.namespaceURI, "posList");
      e.appendChild(o), this.writePosList_(o, i, r);
    }
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node} Node.
     * @private
     */
    RING_NODE_FACTORY_(e, i, r) {
      const n = i[i.length - 1], s = n.node, o = n.exteriorWritten;
      return o === void 0 && (n.exteriorWritten = !0), Bt(
        s.namespaceURI,
        o !== void 0 ? "interior" : "exterior"
      );
    }
    /**
     * @param {Element} node Node.
     * @param {Polygon} geometry Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygon(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName;
      if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
        const a = i.getLinearRings();
        Ni(
          { node: e, hasZ: s, srsName: o },
          this.RING_SERIALIZERS,
          this.RING_NODE_FACTORY_,
          a,
          r,
          void 0,
          this
        );
      } else if (e.nodeName === "Surface") {
        const a = Bt(e.namespaceURI, "patches");
        e.appendChild(a), this.writeSurfacePatches_(a, i, r);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {LineString} geometry LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeCurveOrLineString(e, i, r) {
      const s = r[r.length - 1].srsName;
      if (e.nodeName !== "LineStringSegment" && s && e.setAttribute("srsName", s), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
        const o = Bt(e.namespaceURI, "posList");
        e.appendChild(o), this.writePosList_(o, i, r);
      } else if (e.nodeName === "Curve") {
        const o = Bt(e.namespaceURI, "segments");
        e.appendChild(o), this.writeCurveSegments_(o, i, r);
      }
    }
    /**
     * @param {Element} node Node.
     * @param {MultiPolygon} geometry MultiPolygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiSurfaceOrPolygon(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName, a = n.surface;
      o && e.setAttribute("srsName", o);
      const A = i.getPolygons();
      Ni(
        { node: e, hasZ: s, srsName: o, surface: a },
        this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        A,
        r,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiPoint(e, i, r) {
      const n = r[r.length - 1], s = n.srsName, o = n.hasZ;
      s && e.setAttribute("srsName", s);
      const a = i.getPoints();
      Ni(
        { node: e, hasZ: o, srsName: s },
        this.POINTMEMBER_SERIALIZERS,
        Ln("pointMember"),
        a,
        r,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {MultiLineString} geometry MultiLineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeMultiCurveOrLineString(e, i, r) {
      const n = r[r.length - 1], s = n.hasZ, o = n.srsName, a = n.curve;
      o && e.setAttribute("srsName", o);
      const A = i.getLineStrings();
      Ni(
        { node: e, hasZ: s, srsName: o, curve: a },
        this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
        this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
        A,
        r,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeRing(e, i, r) {
      const n = Bt(e.namespaceURI, "LinearRing");
      e.appendChild(n), this.writeLinearRing(n, i, r);
    }
    /**
     * @param {Node} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeSurfaceOrPolygonMember(e, i, r) {
      const n = this.GEOMETRY_NODE_FACTORY_(i, r);
      n && (e.appendChild(n), this.writeSurfaceOrPolygon(n, i, r));
    }
    /**
     * @param {Element} node Node.
     * @param {import("../geom/Point.js").default} point Point geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writePointMember(e, i, r) {
      const n = Bt(e.namespaceURI, "Point");
      e.appendChild(n), this.writePoint(n, i, r);
    }
    /**
     * @param {Node} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeLineStringOrCurveMember(e, i, r) {
      const n = this.GEOMETRY_NODE_FACTORY_(i, r);
      n && (e.appendChild(n), this.writeCurveOrLineString(n, i, r));
    }
    /**
     * @param {Element} node Node.
     * @param {Polygon} polygon Polygon geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeSurfacePatches_(e, i, r) {
      const n = Bt(e.namespaceURI, "PolygonPatch");
      e.appendChild(n), this.writeSurfaceOrPolygon(n, i, r);
    }
    /**
     * @param {Element} node Node.
     * @param {LineString} line LineString geometry.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeCurveSegments_(e, i, r) {
      const n = Bt(e.namespaceURI, "LineStringSegment");
      e.appendChild(n), this.writeCurveOrLineString(n, i, r);
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     */
    writeGeometryElement(e, i, r) {
      const n = (
        /** @type {import("./Feature.js").WriteOptions} */
        r[r.length - 1]
      ), s = Object.assign({}, n);
      s.node = e;
      let o;
      Array.isArray(i) ? o = px(
        /** @type {import("../extent.js").Extent} */
        i,
        n
      ) : o = uc(
        /** @type {import("../geom/Geometry.js").default} */
        i,
        !0,
        n
      ), Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        s,
        this.GEOMETRY_SERIALIZERS,
        this.GEOMETRY_NODE_FACTORY_,
        [o],
        r,
        void 0,
        this
      );
    }
    /**
     * @param {Element} node Node.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {Array<*>} objectStack Node stack.
     */
    writeFeatureElement(e, i, r) {
      const n = i.getId();
      n && e.setAttribute(
        "fid",
        /** @type {string} */
        n
      );
      const s = (
        /** @type {Object} */
        r[r.length - 1]
      ), o = s.featureNS, a = i.getGeometryName();
      s.serializers || (s.serializers = {}, s.serializers[o] = {});
      const A = [], l = [];
      if (i.hasProperties()) {
        const u = i.getProperties();
        for (const d in u) {
          const h = u[d];
          h != null && (A.push(d), l.push(h), d == a || typeof /** @type {?} */
          h.getSimplifiedGeometry == "function" ? d in s.serializers[o] || (s.serializers[o][d] = ce(
            this.writeGeometryElement,
            this
          )) : d in s.serializers[o] || (s.serializers[o][d] = ce(tr)));
        }
      }
      const c = Object.assign({}, s);
      c.node = e, Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        c,
        s.serializers,
        Ln(void 0, o),
        l,
        r,
        A
      );
    }
    /**
     * @param {Node} node Node.
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {Array<*>} objectStack Node stack.
     * @private
     */
    writeFeatureMembers_(e, i, r) {
      const n = (
        /** @type {Object} */
        r[r.length - 1]
      ), s = n.featureType, o = n.featureNS, a = {};
      a[o] = {}, a[o][s] = ce(
        this.writeFeatureElement,
        this
      );
      const A = Object.assign({}, n);
      A.node = e, Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        A,
        a,
        Ln(s, o),
        i,
        r
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Node|undefined} Node.
     * @private
     */
    MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, i, r) {
      const n = i[i.length - 1].node;
      return Bt(
        this.namespace,
        Uce[n.nodeName]
      );
    }
    /**
     * @const
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [nodeName] Node name.
     * @return {Element|undefined} Node.
     * @private
     */
    GEOMETRY_NODE_FACTORY_(e, i, r) {
      const n = i[i.length - 1], s = n.multiSurface, o = n.surface, a = n.curve, A = n.multiCurve;
      return Array.isArray(e) ? r = "Envelope" : (r = /** @type {import("../geom/Geometry.js").default} */
      e.getType(), r === "MultiPolygon" && s === !0 ? r = "MultiSurface" : r === "Polygon" && o === !0 ? r = "Surface" : r === "LineString" && a === !0 ? r = "Curve" : r === "MultiLineString" && A === !0 && (r = "MultiCurve")), Bt(this.namespace, r);
    }
    /**
     * Encode a geometry in GML 3.1.1 Simple Features.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Node} Node.
     * @api
     * @override
     */
    writeGeometryNode(e, i) {
      i = this.adaptOptions(i);
      const r = Bt(this.namespace, "geom"), n = {
        node: r,
        hasZ: this.hasZ,
        srsName: this.srsName,
        curve: this.curve_,
        surface: this.surface_,
        multiSurface: this.multiSurface_,
        multiCurve: this.multiCurve_
      };
      return i && Object.assign(n, i), this.writeGeometryElement(r, e, [n]), r;
    }
    /**
     * Encode an array of features in the GML 3.1.1 format as an XML node.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Options.
     * @return {Element} Node.
     * @api
     * @override
     */
    writeFeaturesNode(e, i) {
      i = this.adaptOptions(i);
      const r = Bt(this.namespace, "featureMembers");
      r.setAttributeNS(
        Vb,
        "xsi:schemaLocation",
        this.schemaLocation
      );
      const n = {
        srsName: this.srsName,
        hasZ: this.hasZ,
        curve: this.curve_,
        surface: this.surface_,
        multiSurface: this.multiSurface_,
        multiCurve: this.multiCurve_,
        featureNS: this.featureNS,
        featureType: this.featureType
      };
      return i && Object.assign(n, i), this.writeFeatureMembers_(r, e, [n]), r;
    }
  }
  me.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml": {
      pos: tt(me.prototype.readFlatPos),
      posList: tt(me.prototype.readFlatPosList),
      coordinates: tt(_t.prototype.readFlatCoordinates)
    }
  };
  me.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml": {
      interior: me.prototype.interiorParser,
      exterior: me.prototype.exteriorParser
    }
  };
  me.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml": {
      Point: tt(He.prototype.readPoint),
      MultiPoint: tt(He.prototype.readMultiPoint),
      LineString: tt(He.prototype.readLineString),
      MultiLineString: tt(He.prototype.readMultiLineString),
      LinearRing: tt(He.prototype.readLinearRing),
      Polygon: tt(He.prototype.readPolygon),
      MultiPolygon: tt(He.prototype.readMultiPolygon),
      Surface: tt(me.prototype.readSurface),
      MultiSurface: tt(me.prototype.readMultiSurface),
      Curve: tt(me.prototype.readCurve),
      MultiCurve: tt(me.prototype.readMultiCurve),
      Envelope: tt(me.prototype.readEnvelope)
    }
  };
  me.prototype.MULTICURVE_PARSERS = {
    "http://www.opengis.net/gml": {
      curveMember: st(me.prototype.curveMemberParser),
      curveMembers: st(me.prototype.curveMemberParser)
    }
  };
  me.prototype.MULTISURFACE_PARSERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: st(me.prototype.surfaceMemberParser),
      surfaceMembers: st(me.prototype.surfaceMemberParser)
    }
  };
  me.prototype.CURVEMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      LineString: st(He.prototype.readLineString),
      Curve: st(me.prototype.readCurve)
    }
  };
  me.prototype.SURFACEMEMBER_PARSERS = {
    "http://www.opengis.net/gml": {
      Polygon: st(He.prototype.readPolygon),
      Surface: st(me.prototype.readSurface)
    }
  };
  me.prototype.SURFACE_PARSERS = {
    "http://www.opengis.net/gml": {
      patches: tt(me.prototype.readPatch)
    }
  };
  me.prototype.CURVE_PARSERS = {
    "http://www.opengis.net/gml": {
      segments: tt(me.prototype.readSegment)
    }
  };
  me.prototype.ENVELOPE_PARSERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: st(me.prototype.readFlatPosList),
      upperCorner: st(me.prototype.readFlatPosList)
    }
  };
  me.prototype.PATCHES_PARSERS = {
    "http://www.opengis.net/gml": {
      PolygonPatch: tt(me.prototype.readPolygonPatch)
    }
  };
  me.prototype.SEGMENTS_PARSERS = {
    "http://www.opengis.net/gml": {
      LineStringSegment: Nz(
        me.prototype.readLineStringSegment
      )
    }
  };
  He.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml": {
      LinearRing: tt(He.prototype.readFlatLinearRing),
      Ring: tt(me.prototype.readFlatCurveRing)
    }
  };
  me.prototype.writeFeatures;
  me.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      exterior: ce(me.prototype.writeRing),
      interior: ce(me.prototype.writeRing)
    }
  };
  me.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lowerCorner: ce(tr),
      upperCorner: ce(tr)
    }
  };
  me.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      surfaceMember: ce(
        me.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: ce(
        me.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  me.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      pointMember: ce(me.prototype.writePointMember)
    }
  };
  me.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      lineStringMember: ce(
        me.prototype.writeLineStringOrCurveMember
      ),
      curveMember: ce(
        me.prototype.writeLineStringOrCurveMember
      )
    }
  };
  me.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml": {
      Curve: ce(me.prototype.writeCurveOrLineString),
      MultiCurve: ce(me.prototype.writeMultiCurveOrLineString),
      Point: ce(me.prototype.writePoint),
      MultiPoint: ce(me.prototype.writeMultiPoint),
      LineString: ce(me.prototype.writeCurveOrLineString),
      MultiLineString: ce(
        me.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: ce(me.prototype.writeLinearRing),
      Polygon: ce(me.prototype.writeSurfaceOrPolygon),
      MultiPolygon: ce(
        me.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: ce(me.prototype.writeSurfaceOrPolygon),
      MultiSurface: ce(
        me.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: ce(me.prototype.writeEnvelope)
    }
  };
  const jx = me;
  jx.prototype.writeFeatures;
  jx.prototype.writeFeaturesNode;
  const lM = 65536 * 65536, sR = 1 / lM, Lce = 12, oR = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8"), oC = 0, Qp = 1, lh = 2, Fp = 5;
  class zce {
    /**
     * @param {Uint8Array | ArrayBuffer} [buf]
     */
    constructor(e = new Uint8Array(16)) {
      this.buf = ArrayBuffer.isView(e) ? e : new Uint8Array(e), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
    }
    // === READING =================================================================
    /**
     * @template T
     * @param {(tag: number, result: T, pbf: Pbf) => void} readField
     * @param {T} result
     * @param {number} [end]
     */
    readFields(e, i, r = this.length) {
      for (; this.pos < r; ) {
        const n = this.readVarint(), s = n >> 3, o = this.pos;
        this.type = n & 7, e(s, i, this), this.pos === o && this.skip(n);
      }
      return i;
    }
    /**
     * @template T
     * @param {(tag: number, result: T, pbf: Pbf) => void} readField
     * @param {T} result
     */
    readMessage(e, i) {
      return this.readFields(e, i, this.readVarint() + this.pos);
    }
    readFixed32() {
      const e = this.dataView.getUint32(this.pos, !0);
      return this.pos += 4, e;
    }
    readSFixed32() {
      const e = this.dataView.getInt32(this.pos, !0);
      return this.pos += 4, e;
    }
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64() {
      const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * lM;
      return this.pos += 8, e;
    }
    readSFixed64() {
      const e = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * lM;
      return this.pos += 8, e;
    }
    readFloat() {
      const e = this.dataView.getFloat32(this.pos, !0);
      return this.pos += 4, e;
    }
    readDouble() {
      const e = this.dataView.getFloat64(this.pos, !0);
      return this.pos += 8, e;
    }
    /**
     * @param {boolean} [isSigned]
     */
    readVarint(e) {
      const i = this.buf;
      let r, n;
      return n = i[this.pos++], r = n & 127, n < 128 || (n = i[this.pos++], r |= (n & 127) << 7, n < 128) || (n = i[this.pos++], r |= (n & 127) << 14, n < 128) || (n = i[this.pos++], r |= (n & 127) << 21, n < 128) ? r : (n = i[this.pos], r |= (n & 15) << 28, Pce(r, e, this));
    }
    readVarint64() {
      return this.readVarint(!0);
    }
    readSVarint() {
      const e = this.readVarint();
      return e % 2 === 1 ? (e + 1) / -2 : e / 2;
    }
    readBoolean() {
      return !!this.readVarint();
    }
    readString() {
      const e = this.readVarint() + this.pos, i = this.pos;
      return this.pos = e, e - i >= Lce && oR ? oR.decode(this.buf.subarray(i, e)) : eue(this.buf, i, e);
    }
    readBytes() {
      const e = this.readVarint() + this.pos, i = this.buf.subarray(this.pos, e);
      return this.pos = e, i;
    }
    // verbose for performance reasons; doesn't affect gzipped size
    /**
     * @param {number[]} [arr]
     * @param {boolean} [isSigned]
     */
    readPackedVarint(e = [], i) {
      const r = this.readPackedEnd();
      for (; this.pos < r; ) e.push(this.readVarint(i));
      return e;
    }
    /** @param {number[]} [arr] */
    readPackedSVarint(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readSVarint());
      return e;
    }
    /** @param {boolean[]} [arr] */
    readPackedBoolean(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readBoolean());
      return e;
    }
    /** @param {number[]} [arr] */
    readPackedFloat(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readFloat());
      return e;
    }
    /** @param {number[]} [arr] */
    readPackedDouble(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readDouble());
      return e;
    }
    /** @param {number[]} [arr] */
    readPackedFixed32(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readFixed32());
      return e;
    }
    /** @param {number[]} [arr] */
    readPackedSFixed32(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readSFixed32());
      return e;
    }
    /** @param {number[]} [arr] */
    readPackedFixed64(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readFixed64());
      return e;
    }
    /** @param {number[]} [arr] */
    readPackedSFixed64(e = []) {
      const i = this.readPackedEnd();
      for (; this.pos < i; ) e.push(this.readSFixed64());
      return e;
    }
    readPackedEnd() {
      return this.type === lh ? this.readVarint() + this.pos : this.pos + 1;
    }
    /** @param {number} val */
    skip(e) {
      const i = e & 7;
      if (i === oC) for (; this.buf[this.pos++] > 127; )
        ;
      else if (i === lh) this.pos = this.readVarint() + this.pos;
      else if (i === Fp) this.pos += 4;
      else if (i === Qp) this.pos += 8;
      else throw new Error(`Unimplemented type: ${i}`);
    }
    // === WRITING =================================================================
    /**
     * @param {number} tag
     * @param {number} type
     */
    writeTag(e, i) {
      this.writeVarint(e << 3 | i);
    }
    /** @param {number} min */
    realloc(e) {
      let i = this.length || 16;
      for (; i < this.pos + e; ) i *= 2;
      if (i !== this.length) {
        const r = new Uint8Array(i);
        r.set(this.buf), this.buf = r, this.dataView = new DataView(r.buffer), this.length = i;
      }
    }
    finish() {
      return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
    }
    /** @param {number} val */
    writeFixed32(e) {
      this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
    }
    /** @param {number} val */
    writeSFixed32(e) {
      this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
    }
    /** @param {number} val */
    writeFixed64(e) {
      this.realloc(8), this.dataView.setInt32(this.pos, e & -1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * sR), !0), this.pos += 8;
    }
    /** @param {number} val */
    writeSFixed64(e) {
      this.realloc(8), this.dataView.setInt32(this.pos, e & -1, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * sR), !0), this.pos += 8;
    }
    /** @param {number} val */
    writeVarint(e) {
      if (e = +e || 0, e > 268435455 || e < 0) {
        Oce(e, this);
        return;
      }
      this.realloc(4), this.buf[this.pos++] = e & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = (e >>>= 7) & 127 | (e > 127 ? 128 : 0), !(e <= 127) && (this.buf[this.pos++] = e >>> 7 & 127)));
    }
    /** @param {number} val */
    writeSVarint(e) {
      this.writeVarint(e < 0 ? -e * 2 - 1 : e * 2);
    }
    /** @param {boolean} val */
    writeBoolean(e) {
      this.writeVarint(+e);
    }
    /** @param {string} str */
    writeString(e) {
      e = String(e), this.realloc(e.length * 4), this.pos++;
      const i = this.pos;
      this.pos = tue(this.buf, e, this.pos);
      const r = this.pos - i;
      r >= 128 && aR(i, r, this), this.pos = i - 1, this.writeVarint(r), this.pos += r;
    }
    /** @param {number} val */
    writeFloat(e) {
      this.realloc(4), this.dataView.setFloat32(this.pos, e, !0), this.pos += 4;
    }
    /** @param {number} val */
    writeDouble(e) {
      this.realloc(8), this.dataView.setFloat64(this.pos, e, !0), this.pos += 8;
    }
    /** @param {Uint8Array} buffer */
    writeBytes(e) {
      const i = e.length;
      this.writeVarint(i), this.realloc(i);
      for (let r = 0; r < i; r++) this.buf[this.pos++] = e[r];
    }
    /**
     * @template T
     * @param {(obj: T, pbf: Pbf) => void} fn
     * @param {T} obj
     */
    writeRawMessage(e, i) {
      this.pos++;
      const r = this.pos;
      e(i, this);
      const n = this.pos - r;
      n >= 128 && aR(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
    }
    /**
     * @template T
     * @param {number} tag
     * @param {(obj: T, pbf: Pbf) => void} fn
     * @param {T} obj
     */
    writeMessage(e, i, r) {
      this.writeTag(e, lh), this.writeRawMessage(i, r);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedVarint(e, i) {
      i.length && this.writeMessage(e, Hce, i);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedSVarint(e, i) {
      i.length && this.writeMessage(e, Jce, i);
    }
    /**
     * @param {number} tag
     * @param {boolean[]} arr
     */
    writePackedBoolean(e, i) {
      i.length && this.writeMessage(e, Kce, i);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedFloat(e, i) {
      i.length && this.writeMessage(e, Vce, i);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedDouble(e, i) {
      i.length && this.writeMessage(e, Wce, i);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedFixed32(e, i) {
      i.length && this.writeMessage(e, Xce, i);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedSFixed32(e, i) {
      i.length && this.writeMessage(e, Zce, i);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedFixed64(e, i) {
      i.length && this.writeMessage(e, qce, i);
    }
    /**
     * @param {number} tag
     * @param {number[]} arr
     */
    writePackedSFixed64(e, i) {
      i.length && this.writeMessage(e, $ce, i);
    }
    /**
     * @param {number} tag
     * @param {Uint8Array} buffer
     */
    writeBytesField(e, i) {
      this.writeTag(e, lh), this.writeBytes(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeFixed32Field(e, i) {
      this.writeTag(e, Fp), this.writeFixed32(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeSFixed32Field(e, i) {
      this.writeTag(e, Fp), this.writeSFixed32(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeFixed64Field(e, i) {
      this.writeTag(e, Qp), this.writeFixed64(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeSFixed64Field(e, i) {
      this.writeTag(e, Qp), this.writeSFixed64(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeVarintField(e, i) {
      this.writeTag(e, oC), this.writeVarint(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeSVarintField(e, i) {
      this.writeTag(e, oC), this.writeSVarint(i);
    }
    /**
     * @param {number} tag
     * @param {string} str
     */
    writeStringField(e, i) {
      this.writeTag(e, lh), this.writeString(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeFloatField(e, i) {
      this.writeTag(e, Fp), this.writeFloat(i);
    }
    /**
     * @param {number} tag
     * @param {number} val
     */
    writeDoubleField(e, i) {
      this.writeTag(e, Qp), this.writeDouble(i);
    }
    /**
     * @param {number} tag
     * @param {boolean} val
     */
    writeBooleanField(e, i) {
      this.writeVarintField(e, +i);
    }
  }
  function Pce(t, e, i) {
    const r = i.buf;
    let n, s;
    if (s = r[i.pos++], n = (s & 112) >> 4, s < 128 || (s = r[i.pos++], n |= (s & 127) << 3, s < 128) || (s = r[i.pos++], n |= (s & 127) << 10, s < 128) || (s = r[i.pos++], n |= (s & 127) << 17, s < 128) || (s = r[i.pos++], n |= (s & 127) << 24, s < 128) || (s = r[i.pos++], n |= (s & 1) << 31, s < 128)) return Nc(t, n, e);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function Nc(t, e, i) {
    return i ? e * 4294967296 + (t >>> 0) : (e >>> 0) * 4294967296 + (t >>> 0);
  }
  function Oce(t, e) {
    let i, r;
    if (t >= 0 ? (i = t % 4294967296 | 0, r = t / 4294967296 | 0) : (i = ~(-t % 4294967296), r = ~(-t / 4294967296), i ^ 4294967295 ? i = i + 1 | 0 : (i = 0, r = r + 1 | 0)), t >= 18446744073709552e3 || t < -18446744073709552e3)
      throw new Error("Given varint doesn't fit into 10 bytes");
    e.realloc(10), Gce(i, r, e), jce(r, e);
  }
  function Gce(t, e, i) {
    i.buf[i.pos++] = t & 127 | 128, t >>>= 7, i.buf[i.pos++] = t & 127 | 128, t >>>= 7, i.buf[i.pos++] = t & 127 | 128, t >>>= 7, i.buf[i.pos++] = t & 127 | 128, t >>>= 7, i.buf[i.pos] = t & 127;
  }
  function jce(t, e) {
    const i = (t & 7) << 4;
    e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = t & 127 | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = t & 127 | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = t & 127 | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = t & 127 | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = t & 127)))));
  }
  function aR(t, e, i) {
    const r = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
    i.realloc(r);
    for (let n = i.pos - 1; n >= t; n--) i.buf[n + r] = i.buf[n];
  }
  function Hce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeVarint(t[i]);
  }
  function Jce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeSVarint(t[i]);
  }
  function Vce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeFloat(t[i]);
  }
  function Wce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeDouble(t[i]);
  }
  function Kce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeBoolean(t[i]);
  }
  function Xce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeFixed32(t[i]);
  }
  function Zce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeSFixed32(t[i]);
  }
  function qce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeFixed64(t[i]);
  }
  function $ce(t, e) {
    for (let i = 0; i < t.length; i++) e.writeSFixed64(t[i]);
  }
  function eue(t, e, i) {
    let r = "", n = e;
    for (; n < i; ) {
      const s = t[n];
      let o = null, a = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (n + a > i) break;
      let A, l, c;
      a === 1 ? s < 128 && (o = s) : a === 2 ? (A = t[n + 1], (A & 192) === 128 && (o = (s & 31) << 6 | A & 63, o <= 127 && (o = null))) : a === 3 ? (A = t[n + 1], l = t[n + 2], (A & 192) === 128 && (l & 192) === 128 && (o = (s & 15) << 12 | (A & 63) << 6 | l & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : a === 4 && (A = t[n + 1], l = t[n + 2], c = t[n + 3], (A & 192) === 128 && (l & 192) === 128 && (c & 192) === 128 && (o = (s & 15) << 18 | (A & 63) << 12 | (l & 63) << 6 | c & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, a = 1) : o > 65535 && (o -= 65536, r += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), r += String.fromCharCode(o), n += a;
    }
    return r;
  }
  function tue(t, e, i) {
    for (let r = 0, n, s; r < e.length; r++) {
      if (n = e.charCodeAt(r), n > 55295 && n < 57344)
        if (s)
          if (n < 56320) {
            t[i++] = 239, t[i++] = 191, t[i++] = 189, s = n;
            continue;
          } else
            n = s - 55296 << 10 | n - 56320 | 65536, s = null;
        else {
          n > 56319 || r + 1 === e.length ? (t[i++] = 239, t[i++] = 191, t[i++] = 189) : s = n;
          continue;
        }
      else s && (t[i++] = 239, t[i++] = 191, t[i++] = 189, s = null);
      n < 128 ? t[i++] = n : (n < 2048 ? t[i++] = n >> 6 | 192 : (n < 65536 ? t[i++] = n >> 12 | 224 : (t[i++] = n >> 18 | 240, t[i++] = n >> 12 & 63 | 128), t[i++] = n >> 6 & 63 | 128), t[i++] = n & 63 | 128);
    }
    return i;
  }
  class dP extends fx {
    /**
     * @param {Options<FeatureType>} [options] Options.
     */
    constructor(e) {
      super(), e = e || {}, this.dataProjection = new sf({
        code: "",
        units: "tile-pixels"
      }), this.featureClass = e.featureClass ? e.featureClass : (
        /** @type {import('./Feature.js').FeatureToFeatureClass<FeatureType>} */
        Ir
      ), this.geometryName_ = e.geometryName, this.layerName_ = e.layerName ? e.layerName : "layer", this.layers_ = e.layers ? e.layers : null, this.idProperty_ = e.idProperty, this.supportedMediaTypes = [
        "application/vnd.mapbox-vector-tile",
        "application/x-protobuf"
      ];
    }
    /**
     * Read the raw geometry from the pbf offset stored in a raw feature's geometry
     * property.
     * @param {PBF} pbf PBF.
     * @param {Object} feature Raw feature.
     * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
     * @param {Array<number>} ends Array to store ends in.
     * @private
     */
    readRawGeometry_(e, i, r, n) {
      e.pos = i.geometry;
      const s = e.readVarint() + e.pos;
      let o = 1, a = 0, A = 0, l = 0, c = 0, u = 0;
      for (; e.pos < s; ) {
        if (!a) {
          const d = e.readVarint();
          o = d & 7, a = d >> 3;
        }
        if (a--, o === 1 || o === 2)
          A += e.readSVarint(), l += e.readSVarint(), o === 1 && c > u && (n.push(c), u = c), r.push(A, l), c += 2;
        else if (o === 7)
          c > u && (r.push(
            r[u],
            r[u + 1]
          ), c += 2);
        else
          throw new Error("Invalid command found in the PBF");
      }
      c > u && (n.push(c), u = c);
    }
    /**
     * @private
     * @param {PBF} pbf PBF
     * @param {Object} rawFeature Raw Mapbox feature.
     * @param {import("./Feature.js").ReadOptions} options Read options.
     * @return {FeatureType|null} Feature.
     */
    createFeature_(e, i, r) {
      const n = i.type;
      if (n === 0)
        return null;
      let s;
      const o = i.properties;
      let a;
      this.idProperty_ ? (a = o[this.idProperty_], delete o[this.idProperty_]) : a = i.id, o[this.layerName_] = i.layer.name;
      const A = (
        /** @type {Array<number>} */
        []
      ), l = (
        /** @type {Array<number>} */
        []
      );
      this.readRawGeometry_(e, i, A, l);
      const c = oue(n, l.length);
      if (this.featureClass === Ir)
        s = new /** @type {import('./Feature.js').FeatureToFeatureClass<RenderFeature>} */
        this.featureClass(c, A, l, 2, o, a), s.transform(r.dataProjection);
      else {
        let u;
        if (c == "Polygon") {
          const g = Rv(A, l);
          u = g.length > 1 ? new Ta(A, "XY", g) : new en(A, "XY", l);
        } else
          u = c === "Point" ? new Cn(A, "XY") : c === "LineString" ? new bn(A, "XY") : c === "MultiPoint" ? new lc(A, "XY") : c === "MultiLineString" ? new Da(A, "XY", l) : null;
        const d = (
          /** @type {typeof import("../Feature.js").default} */
          this.featureClass
        );
        s = new d(), this.geometryName_ && s.setGeometryName(this.geometryName_);
        const h = uc(u, !1, r);
        s.setGeometry(h), a !== void 0 && s.setId(a), s.setProperties(o, !0);
      }
      return (
        /** @type {FeatureType} */
        s
      );
    }
    /**
     * @return {import("./Feature.js").Type} Format.
     * @override
     */
    getType() {
      return "arraybuffer";
    }
    /**
     * Read all features.
     *
     * @param {ArrayBuffer} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {Array<FeatureType>} Features.
     * @api
     * @override
     */
    readFeatures(e, i) {
      const r = this.layers_;
      i = this.adaptOptions(i);
      const n = Xe(i.dataProjection);
      n.setWorldExtent(i.extent), i.dataProjection = n;
      const s = new zce(
        /** @type {ArrayBuffer} */
        e
      ), o = s.readFields(iue, {}), a = [];
      for (const A in o) {
        if (r && !r.includes(A))
          continue;
        const l = o[A], c = l ? [0, 0, l.extent, l.extent] : null;
        n.setExtent(c);
        for (let u = 0, d = l.length; u < d; ++u) {
          const h = sue(s, l, u), g = this.createFeature_(s, h, i);
          g !== null && a.push(g);
        }
      }
      return (
        /** @type {Array<FeatureType>} */
        a
      );
    }
    /**
     * Read the projection from the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     * @override
     */
    readProjection(e) {
      return this.dataProjection;
    }
    /**
     * Sets the layers that features will be read from.
     * @param {Array<string>} layers Layers.
     * @api
     */
    setLayers(e) {
      this.layers_ = e;
    }
  }
  function iue(t, e, i) {
    if (t === 3) {
      const r = {
        keys: [],
        values: [],
        features: []
      }, n = i.readVarint() + i.pos;
      i.readFields(rue, r, n), r.length = r.features.length, r.length && (e[r.name] = r);
    }
  }
  function rue(t, e, i) {
    if (t === 15)
      e.version = i.readVarint();
    else if (t === 1)
      e.name = i.readString();
    else if (t === 5)
      e.extent = i.readVarint();
    else if (t === 2)
      e.features.push(i.pos);
    else if (t === 3)
      e.keys.push(i.readString());
    else if (t === 4) {
      let r = null;
      const n = i.readVarint() + i.pos;
      for (; i.pos < n; )
        t = i.readVarint() >> 3, r = t === 1 ? i.readString() : t === 2 ? i.readFloat() : t === 3 ? i.readDouble() : t === 4 ? i.readVarint64() : t === 5 ? i.readVarint() : t === 6 ? i.readSVarint() : t === 7 ? i.readBoolean() : null;
      e.values.push(r);
    }
  }
  function nue(t, e, i) {
    if (t == 1)
      e.id = i.readVarint();
    else if (t == 2) {
      const r = i.readVarint() + i.pos;
      for (; i.pos < r; ) {
        const n = e.layer.keys[i.readVarint()], s = e.layer.values[i.readVarint()];
        e.properties[n] = s;
      }
    } else t == 3 ? e.type = i.readVarint() : t == 4 && (e.geometry = i.pos);
  }
  function sue(t, e, i) {
    t.pos = e.features[i];
    const r = t.readVarint() + t.pos, n = {
      layer: e,
      type: 0,
      properties: {}
    };
    return t.readFields(nue, n, r), n;
  }
  function oue(t, e) {
    let i;
    return t === 1 ? i = e === 1 ? "Point" : "MultiPoint" : t === 2 ? i = e === 1 ? "LineString" : "MultiLineString" : t === 3 && (i = "Polygon"), i;
  }
  class Ot extends me {
    /**
     * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
     */
    constructor(e) {
      e = e || {}, super(e), this.schemaLocation = e.schemaLocation ? e.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
    }
    /**
     * @param {Node} node Node.
     * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
     * @param {Array<*>} objectStack Node stack.
     * @override
     */
    writeGeometryElement(e, i, r) {
      const n = r[r.length - 1];
      r[r.length - 1] = Object.assign(
        { multiCurve: !0, multiSurface: !0 },
        n
      ), super.writeGeometryElement(e, i, r);
    }
  }
  Ot.prototype.namespace = "http://www.opengis.net/gml/3.2";
  Ot.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      pos: tt(me.prototype.readFlatPos),
      posList: tt(me.prototype.readFlatPosList),
      coordinates: tt(_t.prototype.readFlatCoordinates)
    }
  };
  Ot.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      interior: me.prototype.interiorParser,
      exterior: me.prototype.exteriorParser
    }
  };
  Ot.prototype.GEOMETRY_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Point: tt(He.prototype.readPoint),
      MultiPoint: tt(He.prototype.readMultiPoint),
      LineString: tt(He.prototype.readLineString),
      MultiLineString: tt(He.prototype.readMultiLineString),
      LinearRing: tt(He.prototype.readLinearRing),
      Polygon: tt(He.prototype.readPolygon),
      MultiPolygon: tt(He.prototype.readMultiPolygon),
      Surface: tt(Ot.prototype.readSurface),
      MultiSurface: tt(me.prototype.readMultiSurface),
      Curve: tt(Ot.prototype.readCurve),
      MultiCurve: tt(me.prototype.readMultiCurve),
      Envelope: tt(Ot.prototype.readEnvelope)
    }
  };
  Ot.prototype.MULTICURVE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      curveMember: st(me.prototype.curveMemberParser),
      curveMembers: st(me.prototype.curveMemberParser)
    }
  };
  Ot.prototype.MULTISURFACE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      surfaceMember: st(me.prototype.surfaceMemberParser),
      surfaceMembers: st(me.prototype.surfaceMemberParser)
    }
  };
  Ot.prototype.CURVEMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineString: st(He.prototype.readLineString),
      Curve: st(me.prototype.readCurve)
    }
  };
  Ot.prototype.SURFACEMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Polygon: st(He.prototype.readPolygon),
      Surface: st(me.prototype.readSurface)
    }
  };
  Ot.prototype.SURFACE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      patches: tt(me.prototype.readPatch)
    }
  };
  Ot.prototype.CURVE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      segments: tt(me.prototype.readSegment)
    }
  };
  Ot.prototype.ENVELOPE_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      lowerCorner: st(me.prototype.readFlatPosList),
      upperCorner: st(me.prototype.readFlatPosList)
    }
  };
  Ot.prototype.PATCHES_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      PolygonPatch: tt(me.prototype.readPolygonPatch)
    }
  };
  Ot.prototype.SEGMENTS_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineStringSegment: Nz(
        me.prototype.readLineStringSegment
      )
    }
  };
  Ot.prototype.MULTIPOINT_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      pointMember: st(He.prototype.pointMemberParser),
      pointMembers: st(He.prototype.pointMemberParser)
    }
  };
  Ot.prototype.MULTILINESTRING_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      lineStringMember: st(
        He.prototype.lineStringMemberParser
      ),
      lineStringMembers: st(
        He.prototype.lineStringMemberParser
      )
    }
  };
  Ot.prototype.MULTIPOLYGON_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      polygonMember: st(He.prototype.polygonMemberParser),
      polygonMembers: st(He.prototype.polygonMemberParser)
    }
  };
  Ot.prototype.POINTMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Point: st(He.prototype.readFlatCoordinatesFromNode)
    }
  };
  Ot.prototype.LINESTRINGMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LineString: st(He.prototype.readLineString)
    }
  };
  Ot.prototype.POLYGONMEMBER_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      Polygon: st(He.prototype.readPolygon)
    }
  };
  Ot.prototype.RING_PARSERS = {
    "http://www.opengis.net/gml/3.2": {
      LinearRing: tt(He.prototype.readFlatLinearRing),
      Ring: tt(Ot.prototype.readFlatCurveRing)
    }
  };
  Ot.prototype.RING_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      exterior: ce(me.prototype.writeRing),
      interior: ce(me.prototype.writeRing)
    }
  };
  Ot.prototype.ENVELOPE_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      lowerCorner: ce(tr),
      upperCorner: ce(tr)
    }
  };
  Ot.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      surfaceMember: ce(
        me.prototype.writeSurfaceOrPolygonMember
      ),
      polygonMember: ce(
        me.prototype.writeSurfaceOrPolygonMember
      )
    }
  };
  Ot.prototype.POINTMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      pointMember: ce(me.prototype.writePointMember)
    }
  };
  Ot.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      lineStringMember: ce(
        me.prototype.writeLineStringOrCurveMember
      ),
      curveMember: ce(
        me.prototype.writeLineStringOrCurveMember
      )
    }
  };
  Ot.prototype.GEOMETRY_SERIALIZERS = {
    "http://www.opengis.net/gml/3.2": {
      Curve: ce(me.prototype.writeCurveOrLineString),
      MultiCurve: ce(me.prototype.writeMultiCurveOrLineString),
      Point: ce(Ot.prototype.writePoint),
      MultiPoint: ce(me.prototype.writeMultiPoint),
      LineString: ce(me.prototype.writeCurveOrLineString),
      MultiLineString: ce(
        me.prototype.writeMultiCurveOrLineString
      ),
      LinearRing: ce(me.prototype.writeLinearRing),
      Polygon: ce(me.prototype.writeSurfaceOrPolygon),
      MultiPolygon: ce(
        me.prototype.writeMultiSurfaceOrPolygon
      ),
      Surface: ce(me.prototype.writeSurfaceOrPolygon),
      MultiSurface: ce(
        me.prototype.writeMultiSurfaceOrPolygon
      ),
      Envelope: ce(me.prototype.writeEnvelope)
    }
  };
  class hP {
    /**
     * @param {!string} tagName The XML tag name for this filter.
     */
    constructor(e) {
      this.tagName_ = e;
    }
    /**
     * The XML tag name for a filter.
     * @return {!string} Name.
     */
    getTagName() {
      return this.tagName_;
    }
  }
  class aue extends hP {
    /**
     * @param {!string} tagName The XML tag name for this filter.
     * @param {Array<import("./Filter.js").default>} conditions Conditions.
     */
    constructor(e, i) {
      super(e), this.conditions = i, Mt(this.conditions.length >= 2, "At least 2 conditions are required");
    }
  }
  class Aue extends aue {
    /**
     * @param {...import("./Filter.js").default} conditions Conditions.
     */
    constructor(e) {
      super("And", Array.prototype.slice.call(arguments));
    }
  }
  class lue extends hP {
    /**
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../../extent.js").Extent} extent Extent.
     * @param {string} [srsName] SRS name. No srsName attribute will be set
     * on geometries when this is not provided.
     */
    constructor(e, i, r) {
      if (super("BBOX"), this.geometryName = e, this.extent = i, i.length !== 4)
        throw new Error(
          "Expected an extent with four values ([minX, minY, maxX, maxY])"
        );
      this.srsName = r;
    }
  }
  function cue(t) {
    const e = [null].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply(Aue, e))();
  }
  function uue(t, e, i) {
    return new lue(t, e, i);
  }
  const AR = {
    "http://www.opengis.net/gml": {
      boundedBy: Le(
        He.prototype.readExtentElement,
        "bounds"
      )
    },
    "http://www.opengis.net/wfs/2.0": {
      member: st(He.prototype.readFeaturesInternal)
    }
  }, due = {
    "http://www.opengis.net/wfs": {
      totalInserted: Le(pn),
      totalUpdated: Le(pn),
      totalDeleted: Le(pn)
    },
    "http://www.opengis.net/wfs/2.0": {
      totalInserted: Le(pn),
      totalUpdated: Le(pn),
      totalDeleted: Le(pn)
    }
  }, hue = {
    "http://www.opengis.net/wfs": {
      TransactionSummary: Le(
        cR,
        "transactionSummary"
      ),
      InsertResults: Le(dR, "insertIds")
    },
    "http://www.opengis.net/wfs/2.0": {
      TransactionSummary: Le(
        cR,
        "transactionSummary"
      ),
      InsertResults: Le(dR, "insertIds")
    }
  }, gue = {
    "http://www.opengis.net/wfs": {
      PropertyName: ce(tr)
    },
    "http://www.opengis.net/wfs/2.0": {
      PropertyName: ce(tr)
    }
  }, gP = {
    "http://www.opengis.net/wfs": {
      Insert: ce(hR),
      Update: ce(fR),
      Delete: ce(gR),
      Property: ce(pR),
      Native: ce(mR)
    },
    "http://www.opengis.net/wfs/2.0": {
      Insert: ce(hR),
      Update: ce(fR),
      Delete: ce(gR),
      Property: ce(pR),
      Native: ce(mR)
    }
  }, fP = "feature", Hx = "http://www.w3.org/2000/xmlns/", Jx = {
    "2.0.0": "http://www.opengis.net/ogc/1.1",
    "1.1.0": "http://www.opengis.net/ogc",
    "1.0.0": "http://www.opengis.net/ogc"
  }, cM = {
    "2.0.0": "http://www.opengis.net/wfs/2.0",
    "1.1.0": "http://www.opengis.net/wfs",
    "1.0.0": "http://www.opengis.net/wfs"
  }, Vx = {
    "2.0.0": "http://www.opengis.net/fes/2.0",
    "1.1.0": "http://www.opengis.net/fes",
    "1.0.0": "http://www.opengis.net/fes"
  }, lR = {
    "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
    "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
    "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
  }, Wx = {
    "2.0.0": Ot,
    "1.1.0": me,
    "1.0.0": _t
  }, fue = "1.1.0";
  class pP extends uP {
    /**
     * @param {Options} [options] Optional configuration object.
     */
    constructor(e) {
      super(), e = e || {}, this.version_ = e.version ? e.version : fue, this.featureType_ = e.featureType, this.featureNS_ = e.featureNS, this.gmlFormat_ = e.gmlFormat ? e.gmlFormat : new Wx[this.version_](), this.schemaLocation_ = e.schemaLocation ? e.schemaLocation : lR[this.version_];
    }
    /**
     * @return {Array<string>|string|undefined} featureType
     */
    getFeatureType() {
      return this.featureType_;
    }
    /**
     * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
     */
    setFeatureType(e) {
      this.featureType_ = e;
    }
    /**
     * @protected
     * @param {Element} node Node.
     * @param {import("./Feature.js").ReadOptions} [options] Options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @override
     */
    readFeaturesFromNode(e, i) {
      const r = {
        node: e
      };
      Object.assign(r, {
        featureType: this.featureType_,
        featureNS: this.featureNS_
      }), Object.assign(r, this.getReadOptions(e, i || {}));
      const n = [r];
      let s;
      this.version_ === "2.0.0" ? s = AR : s = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
      let o = Ze(
        [],
        s,
        e,
        n,
        this.gmlFormat_
      );
      return o || (o = []), o;
    }
    /**
     * Read transaction response of the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {TransactionResponse|undefined} Transaction response.
     * @api
     */
    readTransactionResponse(e) {
      if (e) {
        if (typeof e == "string") {
          const i = Cl(e);
          return this.readTransactionResponseFromDocument(i);
        }
        return wl(e) ? this.readTransactionResponseFromDocument(
          /** @type {Document} */
          e
        ) : this.readTransactionResponseFromNode(
          /** @type {Element} */
          e
        );
      }
    }
    /**
     * Read feature collection metadata of the source.
     *
     * @param {Document|Element|Object|string} source Source.
     * @return {FeatureCollectionMetadata|undefined}
     *     FeatureCollection metadata.
     * @api
     */
    readFeatureCollectionMetadata(e) {
      if (e) {
        if (typeof e == "string") {
          const i = Cl(e);
          return this.readFeatureCollectionMetadataFromDocument(i);
        }
        return wl(e) ? this.readFeatureCollectionMetadataFromDocument(
          /** @type {Document} */
          e
        ) : this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          e
        );
      }
    }
    /**
     * @param {Document} doc Document.
     * @return {FeatureCollectionMetadata|undefined}
     *     FeatureCollection metadata.
     */
    readFeatureCollectionMetadataFromDocument(e) {
      for (let i = (
        /** @type {Node} */
        e.firstChild
      ); i; i = i.nextSibling)
        if (i.nodeType == Node.ELEMENT_NODE)
          return this.readFeatureCollectionMetadataFromNode(
            /** @type {Element} */
            i
          );
    }
    /**
     * @param {Element} node Node.
     * @return {FeatureCollectionMetadata|undefined}
     *     FeatureCollection metadata.
     */
    readFeatureCollectionMetadataFromNode(e) {
      const i = {}, r = pu(
        e.getAttribute("numberOfFeatures")
      );
      return i.numberOfFeatures = r, Ze(
        /** @type {FeatureCollectionMetadata} */
        i,
        AR,
        e,
        [],
        this.gmlFormat_
      );
    }
    /**
     * @param {Document} doc Document.
     * @return {TransactionResponse|undefined} Transaction response.
     */
    readTransactionResponseFromDocument(e) {
      for (let i = (
        /** @type {Node} */
        e.firstChild
      ); i; i = i.nextSibling)
        if (i.nodeType == Node.ELEMENT_NODE)
          return this.readTransactionResponseFromNode(
            /** @type {Element} */
            i
          );
    }
    /**
     * @param {Element} node Node.
     * @return {TransactionResponse|undefined} Transaction response.
     */
    readTransactionResponseFromNode(e) {
      return Ze(
        /** @type {TransactionResponse} */
        {},
        hue,
        e,
        []
      );
    }
    /**
     * Encode format as WFS `GetFeature` and return the Node.
     *
     * @param {WriteGetFeatureOptions} options Options.
     * @return {Node} Result.
     * @api
     */
    writeGetFeature(e) {
      const i = Bt(cM[this.version_], "GetFeature");
      i.setAttribute("service", "WFS"), i.setAttribute("version", this.version_), e.handle && i.setAttribute("handle", e.handle), e.outputFormat && i.setAttribute("outputFormat", e.outputFormat), e.maxFeatures !== void 0 && i.setAttribute("maxFeatures", String(e.maxFeatures)), e.resultType && i.setAttribute("resultType", e.resultType), e.startIndex !== void 0 && i.setAttribute("startIndex", String(e.startIndex)), e.count !== void 0 && i.setAttribute("count", String(e.count)), e.viewParams !== void 0 && i.setAttribute("viewParams", e.viewParams), i.setAttributeNS(
        Vb,
        "xsi:schemaLocation",
        this.schemaLocation_
      );
      const r = {
        node: i
      };
      if (Object.assign(r, {
        version: this.version_,
        srsName: e.srsName,
        featureNS: e.featureNS ? e.featureNS : this.featureNS_,
        featurePrefix: e.featurePrefix,
        propertyNames: e.propertyNames ? e.propertyNames : []
      }), Mt(
        Array.isArray(e.featureTypes),
        "`options.featureTypes` must be an Array"
      ), typeof e.featureTypes[0] == "string") {
        let n = e.filter;
        e.bbox && (Mt(
          e.geometryName,
          "`options.geometryName` must also be provided when `options.bbox` is set"
        ), n = this.combineBboxAndFilter(
          e.geometryName,
          e.bbox,
          e.srsName,
          n
        )), Object.assign(r, {
          geometryName: e.geometryName,
          filter: n
        }), xR(
          i,
          /** @type {!Array<string>} */
          e.featureTypes,
          [r]
        );
      } else
        e.featureTypes.forEach((n) => {
          const s = this.combineBboxAndFilter(
            n.geometryName,
            n.bbox,
            e.srsName,
            e.filter
          );
          Object.assign(r, {
            geometryName: n.geometryName,
            filter: s
          }), xR(i, [n.name], [r]);
        });
      return i;
    }
    /**
     * Create a bbox filter and combine it with another optional filter.
     *
     * @param {!string} geometryName Geometry name to use.
     * @param {!import("../extent.js").Extent} extent Extent.
     * @param {string} [srsName] SRS name. No srsName attribute will be
     *    set on geometries when this is not provided.
     * @param {import("./filter/Filter.js").default} [filter] Filter condition.
     * @return {import("./filter/Filter.js").default} The filter.
     */
    combineBboxAndFilter(e, i, r, n) {
      const s = uue(e, i, r);
      return n ? cue(n, s) : s;
    }
    /**
     * Encode format as WFS `Transaction` and return the Node.
     *
     * @param {Array<import("../Feature.js").default>} inserts The features to insert.
     * @param {Array<import("../Feature.js").default>} updates The features to update.
     * @param {Array<import("../Feature.js").default>} deletes The features to delete.
     * @param {WriteTransactionOptions} options Write options.
     * @return {Node} Result.
     * @api
     */
    writeTransaction(e, i, r, n) {
      const s = [], o = n.version ? n.version : this.version_, a = Bt(cM[o], "Transaction");
      a.setAttribute("service", "WFS"), a.setAttribute("version", o);
      let A;
      n && (A = n.gmlOptions ? n.gmlOptions : {}, n.handle && a.setAttribute("handle", n.handle)), a.setAttributeNS(
        Vb,
        "xsi:schemaLocation",
        lR[o]
      );
      const l = pue(a, A, o, n);
      return e && Sp("Insert", e, s, l), i && Sp("Update", i, s, l), r && Sp("Delete", r, s, l), n.nativeElements && Sp(
        "Native",
        n.nativeElements,
        s,
        l
      ), a;
    }
    /**
     * @param {Document} doc Document.
     * @return {import("../proj/Projection.js").default} Projection.
     * @override
     */
    readProjectionFromDocument(e) {
      for (let i = e.firstChild; i; i = i.nextSibling)
        if (i.nodeType == Node.ELEMENT_NODE)
          return this.readProjectionFromNode(
            /** @type {Element} */
            i
          );
      return null;
    }
    /**
     * @param {Element} node Node.
     * @return {import("../proj/Projection.js").default} Projection.
     * @override
     */
    readProjectionFromNode(e) {
      if (e.firstElementChild && e.firstElementChild.firstElementChild) {
        e = e.firstElementChild.firstElementChild;
        for (let i = e.firstElementChild; i; i = i.nextElementSibling)
          if (!(i.childNodes.length === 0 || i.childNodes.length === 1 && i.firstChild.nodeType === 3)) {
            const r = [{}];
            return this.gmlFormat_.readGeometryElement(i, r), Xe(r.pop().srsName);
          }
      }
      return null;
    }
  }
  function pue(t, e, i, r) {
    const n = r.featurePrefix ? r.featurePrefix : fP;
    let s;
    return i === "1.0.0" ? s = 2 : i === "1.1.0" ? s = 3 : i === "2.0.0" && (s = 3.2), Object.assign(
      { node: t },
      {
        version: i,
        featureNS: r.featureNS,
        featureType: r.featureType,
        featurePrefix: n,
        gmlVersion: s,
        hasZ: r.hasZ,
        srsName: r.srsName
      },
      e
    );
  }
  function Sp(t, e, i, r) {
    Ni(
      r,
      gP,
      Ln(t),
      e,
      i
    );
  }
  function cR(t, e) {
    return Ze({}, due, t, e);
  }
  const mue = {
    "http://www.opengis.net/ogc": {
      FeatureId: st(function(t, e) {
        return t.getAttribute("fid");
      })
    },
    "http://www.opengis.net/ogc/1.1": {
      FeatureId: st(function(t, e) {
        return t.getAttribute("fid");
      })
    }
  };
  function uR(t, e) {
    Ql(mue, t, e);
  }
  const Eue = {
    "http://www.opengis.net/wfs": {
      Feature: uR
    },
    "http://www.opengis.net/wfs/2.0": {
      Feature: uR
    }
  };
  function dR(t, e) {
    return Ze([], Eue, t, e);
  }
  function hR(t, e, i) {
    const r = i[i.length - 1], n = r.featureType, s = r.featureNS, o = r.gmlVersion, a = Bt(s, n);
    t.appendChild(a), o === 2 ? _t.prototype.writeFeatureElement(a, e, i) : o === 3 ? me.prototype.writeFeatureElement(a, e, i) : Ot.prototype.writeFeatureElement(a, e, i);
  }
  function mP(t, e, i) {
    const n = i[i.length - 1].version, s = Jx[n], o = Bt(s, "Filter"), a = Bt(s, "FeatureId");
    o.appendChild(a), a.setAttribute(
      "fid",
      /** @type {string} */
      e
    ), t.appendChild(o);
  }
  function Kx(t, e) {
    t = t || fP;
    const i = t + ":";
    return e.startsWith(i) ? e : i + e;
  }
  function gR(t, e, i) {
    const r = i[i.length - 1];
    Mt(e.getId() !== void 0, "Features must have an id set");
    const n = r.featureType, s = r.featurePrefix, o = r.featureNS, a = Kx(s, n);
    t.setAttribute("typeName", a), t.setAttributeNS(Hx, "xmlns:" + s, o);
    const A = e.getId();
    A !== void 0 && mP(t, A, i);
  }
  function fR(t, e, i) {
    const r = i[i.length - 1];
    Mt(e.getId() !== void 0, "Features must have an id set");
    const n = r.version, s = r.featureType, o = r.featurePrefix, a = r.featureNS, A = Kx(o, s), l = e.getGeometryName();
    t.setAttribute("typeName", A), t.setAttributeNS(Hx, "xmlns:" + o, a);
    const c = e.getId();
    if (c !== void 0) {
      const u = e.getKeys(), d = [];
      for (let h = 0, g = u.length; h < g; h++) {
        const f = e.get(u[h]);
        if (f !== void 0) {
          let p = u[h];
          f && typeof /** @type {?} */
          f.getSimplifiedGeometry == "function" && (p = l), d.push({ name: p, value: f });
        }
      }
      Ni(
        /** @type {import("../xml.js").NodeStackItem} */
        {
          version: n,
          gmlVersion: r.gmlVersion,
          node: t,
          hasZ: r.hasZ,
          srsName: r.srsName
        },
        gP,
        Ln("Property"),
        d,
        i
      ), mP(t, c, i);
    }
  }
  function pR(t, e, i) {
    const r = i[i.length - 1], n = r.version, s = cM[n], a = Bt(s, n === "2.0.0" ? "ValueReference" : "Name"), A = r.gmlVersion;
    if (t.appendChild(a), tr(a, e.name), e.value !== void 0 && e.value !== null) {
      const l = Bt(s, "Value");
      t.appendChild(l), e.value && typeof /** @type {?} */
      e.value.getSimplifiedGeometry == "function" ? A === 2 ? _t.prototype.writeGeometryElement(l, e.value, i) : A === 3 ? me.prototype.writeGeometryElement(l, e.value, i) : Ot.prototype.writeGeometryElement(l, e.value, i) : tr(l, e.value);
    }
  }
  function mR(t, e, i) {
    e.vendorId && t.setAttribute("vendorId", e.vendorId), e.safeToIgnore !== void 0 && t.setAttribute("safeToIgnore", String(e.safeToIgnore)), e.value !== void 0 && tr(t, e.value);
  }
  const NB = {
    "http://www.opengis.net/wfs": {
      Query: ce(ER)
    },
    "http://www.opengis.net/wfs/2.0": {
      Query: ce(ER)
    },
    "http://www.opengis.net/ogc": {
      During: ce(wR),
      And: ce(Dp),
      Or: ce(Dp),
      Not: ce(CR),
      BBOX: ce(yR),
      Contains: ce(tA),
      Intersects: ce(tA),
      Within: ce(tA),
      DWithin: ce(BR),
      PropertyIsEqualTo: ce(Xn),
      PropertyIsNotEqualTo: ce(Xn),
      PropertyIsLessThan: ce(Xn),
      PropertyIsLessThanOrEqualTo: ce(Xn),
      PropertyIsGreaterThan: ce(Xn),
      PropertyIsGreaterThanOrEqualTo: ce(Xn),
      PropertyIsNull: ce(bR),
      PropertyIsBetween: ce(MR),
      PropertyIsLike: ce(IR)
    },
    "http://www.opengis.net/fes/2.0": {
      During: ce(wR),
      And: ce(Dp),
      Or: ce(Dp),
      Not: ce(CR),
      BBOX: ce(yR),
      Contains: ce(tA),
      Disjoint: ce(tA),
      Intersects: ce(tA),
      ResourceId: ce(Bue),
      Within: ce(tA),
      DWithin: ce(BR),
      PropertyIsEqualTo: ce(Xn),
      PropertyIsNotEqualTo: ce(Xn),
      PropertyIsLessThan: ce(Xn),
      PropertyIsLessThanOrEqualTo: ce(Xn),
      PropertyIsGreaterThan: ce(Xn),
      PropertyIsGreaterThanOrEqualTo: ce(Xn),
      PropertyIsNull: ce(bR),
      PropertyIsBetween: ce(MR),
      PropertyIsLike: ce(IR)
    }
  };
  function ER(t, e, i) {
    const r = (
      /** @type {Object} */
      i[i.length - 1]
    ), n = r.version, s = r.featurePrefix, o = r.featureNS, a = r.propertyNames, A = r.srsName;
    let l;
    s ? l = Kx(s, e) : l = e;
    let c;
    n === "2.0.0" ? c = "typeNames" : c = "typeName", t.setAttribute(c, l), A && t.setAttribute("srsName", A), o && t.setAttributeNS(Hx, "xmlns:" + s, o);
    const u = (
      /** @type {import("../xml.js").NodeStackItem} */
      Object.assign({}, r)
    );
    u.node = t, Ni(
      u,
      gue,
      Ln("PropertyName"),
      a,
      i
    );
    const d = r.filter;
    if (d) {
      const h = Bt(UB(n), "Filter");
      t.appendChild(h), yue(h, d, i);
    }
  }
  function yue(t, e, i) {
    const r = (
      /** @type {Object} */
      i[i.length - 1]
    ), n = { node: t };
    Object.assign(n, { context: r }), Ni(
      n,
      NB,
      Ln(e.getTagName()),
      [e],
      i
    );
  }
  function yR(t, e, i) {
    const r = (
      /** @type {Object} */
      i[i.length - 1]
    ), s = r.context.version;
    r.srsName = e.srsName;
    const o = Wx[s];
    Gd(s, t, e.geometryName), o.prototype.writeGeometryElement(t, e.extent, i);
  }
  function Bue(t, e, i) {
    t.setAttribute(
      "rid",
      /** @type {string} */
      e.rid
    );
  }
  function tA(t, e, i) {
    const r = (
      /** @type {Object} */
      i[i.length - 1]
    ), s = r.context.version;
    r.srsName = e.srsName;
    const o = Wx[s];
    Gd(s, t, e.geometryName), o.prototype.writeGeometryElement(t, e.geometry, i);
  }
  function BR(t, e, i) {
    const s = /** @type {Object} */ i[i.length - 1].context.version;
    tA(t, e, i);
    const o = Bt(UB(s), "Distance");
    tr(o, e.distance.toString()), s === "2.0.0" ? o.setAttribute("uom", e.unit) : o.setAttribute("units", e.unit), t.appendChild(o);
  }
  function wR(t, e, i) {
    const s = /** @type {Object} */ i[i.length - 1].context.version;
    KE(Vx[s], "ValueReference", t, e.propertyName);
    const o = Bt(wa, "TimePeriod");
    t.appendChild(o);
    const a = Bt(wa, "begin");
    o.appendChild(a), vR(a, e.begin);
    const A = Bt(wa, "end");
    o.appendChild(A), vR(A, e.end);
  }
  function Dp(t, e, i) {
    const n = /** @type {Object} */ i[i.length - 1].context, s = { node: t };
    Object.assign(s, { context: n });
    const o = e.conditions;
    for (let a = 0, A = o.length; a < A; ++a) {
      const l = o[a];
      Ni(
        s,
        NB,
        Ln(l.getTagName()),
        [l],
        i
      );
    }
  }
  function CR(t, e, i) {
    const n = /** @type {Object} */ i[i.length - 1].context, s = { node: t };
    Object.assign(s, { context: n });
    const o = e.condition;
    Ni(
      s,
      NB,
      Ln(o.getTagName()),
      [o],
      i
    );
  }
  function Xn(t, e, i) {
    const s = /** @type {Object} */ i[i.length - 1].context.version;
    e.matchCase !== void 0 && t.setAttribute("matchCase", e.matchCase.toString()), Gd(s, t, e.propertyName), XE(s, t, "" + e.expression);
  }
  function bR(t, e, i) {
    const s = /** @type {Object} */ i[i.length - 1].context.version;
    Gd(s, t, e.propertyName);
  }
  function MR(t, e, i) {
    const s = /** @type {Object} */ i[i.length - 1].context.version, o = UB(s);
    Gd(s, t, e.propertyName);
    const a = Bt(o, "LowerBoundary");
    t.appendChild(a), XE(s, a, "" + e.lowerBoundary);
    const A = Bt(o, "UpperBoundary");
    t.appendChild(A), XE(s, A, "" + e.upperBoundary);
  }
  function IR(t, e, i) {
    const s = /** @type {Object} */ i[i.length - 1].context.version;
    t.setAttribute("wildCard", e.wildCard), t.setAttribute("singleChar", e.singleChar), t.setAttribute("escapeChar", e.escapeChar), e.matchCase !== void 0 && t.setAttribute("matchCase", e.matchCase.toString()), Gd(s, t, e.propertyName), XE(s, t, "" + e.pattern);
  }
  function KE(t, e, i, r) {
    const n = Bt(t, e);
    tr(n, r), i.appendChild(n);
  }
  function XE(t, e, i) {
    KE(UB(t), "Literal", e, i);
  }
  function Gd(t, e, i) {
    t === "2.0.0" ? KE(Vx[t], "ValueReference", e, i) : KE(Jx[t], "PropertyName", e, i);
  }
  function vR(t, e) {
    const i = Bt(wa, "TimeInstant");
    t.appendChild(i);
    const r = Bt(wa, "timePosition");
    i.appendChild(r), tr(r, e);
  }
  function xR(t, e, i) {
    const r = (
      /** @type {Object} */
      i[i.length - 1]
    ), n = (
      /** @type {import("../xml.js").NodeStackItem} */
      Object.assign({}, r)
    );
    n.node = t, Ni(
      n,
      NB,
      Ln("Query"),
      e,
      i
    );
  }
  function UB(t) {
    let e;
    return t === "2.0.0" ? e = Vx[t] : e = Jx[t], e;
  }
  function wue(t, e) {
    const i = ["1.0.0", "1.1.0", "2.0.0"];
    let r = e.version || t.version;
    return i.includes(r) || (r = i[1], console.warn(`The "${t.typ}" layer with the id: "${t.id}" is configured in version: ${r}. OpenLayers accepts "${t.typ}" only in the versions: ${i}, It tries to load the layer with the id: "${t.id}" in version ${i[1]}!`)), r;
  }
  function Gh(t, e = {}, i) {
    throw e.onLoadingError && e.onLoadingError(t), i(t), Error(t);
  }
  function Xx(t, e, i, r, n, s = {}) {
    let o = e;
    try {
      s.featuresFilter && (o = s.featuresFilter(e)), t.addFeatures(o), s.afterLoading && s.afterLoading(o), r(o);
    } catch (a) {
      console.error(a), i(a, s, n);
    }
  }
  function EP(t, e, i, r) {
    return t.ok ? t : e(`Request to wfs-filter failed. Response status is ${t.status}`, i, r);
  }
  function Cue(t) {
    return {
      method: "POST",
      headers: {
        "Content-Type": "text/xml"
      },
      body: t
    };
  }
  function yP(t, e, i, { onErrorFn: r, success: n, failure: s }, o) {
    fetch(t, e).then((a) => EP(a, r, o, s)).then((a) => a.text()).then((a) => i.getFormat().readFeatures(a)).then((a) => Xx(i, a, r, n, s, o)).catch((a) => {
      console.error(a);
    });
  }
  function bue(t, e, i, { onErrorFn: r, success: n, failure: s }, o) {
    fetch(t).then((a) => EP(a, r, o, s)).then((a) => a.text()).then((a) => yP(e, Cue(a), i, { onErrorFn: r, success: n, failure: s }, o)).catch((a) => {
      console.error(a);
    });
  }
  function BP(t, e, i, r) {
    const n = new URL(t.url);
    return n.searchParams.set("service", "WFS"), n.searchParams.set("version", e), n.searchParams.set("request", "GetFeature"), n.searchParams.set("srsName", i.getCode()), e === "1.0.0" || e === "1.1.0" ? n.searchParams.set("typeName", t.featureType) : e === "2.0.0" && n.searchParams.set("typeNames", t.featureType), `${n.toString()}${r}`;
  }
  function uM(t, e = {}) {
    e.loadingStrategy || (e.loadingStrategy = Du);
    const i = wue(t, e), r = new pP({
      featureNS: t.featureNS,
      version: i
    });
    let n = null;
    function s(o, a, A, l, c) {
      if (e.doNotLoadInitially)
        Xx(n, [], Gh, l, c, e);
      else if (e.wfsFilter)
        bue(e.wfsFilter, t.url, n, { onErrorFn: Gh, success: l, failure: c }, e);
      else {
        const u = e.loadingStrategy === Du ? `&bbox=${o.join(",")},${A.getCode()}` : "";
        let d = BP(t, i, A, u), h = {};
        if (e.loadingParams)
          for (const g in e.loadingParams) {
            if (g === "xhrParameters") {
              h = e.loadingParams.xhrParameters;
              continue;
            }
            const f = Array.isArray(e.loadingParams[g]) ? e.loadingParams[g].join(",") : e.loadingParams[g];
            f !== void 0 && g === "bbox" ? d += `&${g}=${f},${A.getCode()}` : f !== void 0 && (d += `&${g}=${f}`);
          }
        yP(d, h, n, { onErrorFn: Gh, success: l, failure: c }, e);
      }
    }
    return r.featureType = t.featureType, n = Ox(s, e.loadingStrategy, r), e.beforeLoading && n.once("featuresloadstart", () => e.beforeLoading()), t.clusterDistance ? Gx(n, t.clusterDistance, e.clusterGeometryFunction) : (t.renderer === "webgl" && (e.loadingStrategy === Du ? n.on("featuresloadend", (o) => {
      hd(o == null ? void 0 : o.features, t.styleId, t.excludeTypesFromParsing, t.isPointLayer);
    }) : n.once("featuresloadend", (o) => {
      hd(o == null ? void 0 : o.features, t.styleId, t.excludeTypesFromParsing, t.isPointLayer);
    })), n);
  }
  function Mue(t = {}, { layerParams: e = {}, options: i = {} } = {}) {
    let r, n;
    return e.renderer === "webgl" ? (n = uM({
      ...t,
      renderer: e.renderer,
      styleId: e.styleId,
      excludeTypesFromParsing: e.excludeTypesFromParsing,
      isPointLayer: e.isPointLayer
    }, i), r = kB({
      ...t,
      ...e,
      source: n
    }), r) : (n = uM(t, i), r = new Bs(Object.assign({
      source: n,
      id: t.id
    }, e)), i.style ? r.setStyle(i.style) : t.style && r.setStyle(t.style), r);
  }
  function wP(t, e, i, r = "1.1.0") {
    const n = {
      insert: 0,
      selectedUpdate: 1,
      delete: 2
    }, s = [[], [], []];
    if (i !== "insert" && i !== "delete" && i !== "selectedUpdate")
      throw new Error('transactionMethod has to be "insert", "selectedUpdate" or "delete".');
    return s[n[i]].push(t), new XMLSerializer().serializeToString(new pP({ version: r }).writeTransaction(...s, e));
  }
  function Iue(t) {
    const e = { code: null, message: "genericFailedTransaction" }, i = t.getElementsByTagName(`${t.getElementsByTagName("Exception").length === 0 ? "ows:" : ""}Exception`)[0], r = i.getElementsByTagName(`${t.getElementsByTagName("ExceptionText").length === 0 ? "ows:" : ""}ExceptionText`)[0];
    return r !== void 0 ? (e.message = r.textContent, console.error("WfsTransaction: An error occurred when sending the transaction to the service.", r.textContent)) : (e.message = "WfsTransaction: An unkown error occurred when sending the transaction to the service.", console.error(e.message)), (i != null && i.attributes.getNamedItem("code") || i != null && i.attributes.getNamedItem("exceptionCode")) && (e.code = i.attributes.getNamedItem(`${i != null && i.attributes.getNamedItem("code") ? "c" : "exceptionC"}ode`).textContent), e;
  }
  async function vue(t, e, i, r, n) {
    let s, o, a = null, A = null, l = null;
    const c = new URL(i), { featureNS: u, featurePrefix: d, featureType: h, version: g } = r;
    try {
      if (o = await fetch(c, {
        method: "POST",
        headers: { "Content-Type": "text/xml" },
        credentials: r.isSecured ? "include" : "omit",
        body: wP(
          e,
          { featureNS: u, featurePrefix: d, featureType: h, version: g, srsName: t },
          n,
          g
        ),
        responseType: "text"
      }), l = await o.text(), a = new DOMParser().parseFromString(l, "text/xml"), A = a.getElementsByTagName("wfs:TransactionSummary"), A.length === 0 && (A = a.getElementsByTagName("TransactionSummary")), A.length === 0)
        throw s = Iue(a), new Error(s.code ? s.code + ": " + s.message : s.message);
    } catch (f) {
      throw console.error(f), f;
    }
    return e;
  }
  function CP(t, e) {
    const i = new DOMParser().parseFromString(t, "application/xml");
    let r = "", n = null;
    if (i.getElementsByTagName("xsd:element").length > 0 ? r = "xsd:" : i.getElementsByTagName("xs:element").length > 0 && (r = "xs"), n = Object.values(i.getElementsByTagName(r + "element")).find((s) => s.getAttribute("name") === e), n) {
      let s;
      n.hasChildNodes() ? s = Object.values(n.getElementsByTagName(r + "sequence")) : s = Object.values(i.getElementsByTagName(r + "sequence"));
      const o = [];
      return s.forEach((a) => {
        o.push(...Object.values(a.getElementsByTagName(r + "element")));
      }), o.map((a) => Object.values(a.attributes).reduce((A, l) => {
        if (l.localName === "minOccurs")
          A.required = l.value === "1";
        else if (l.localName === "type")
          if (l.value.trim().startsWith("gml"))
            A.type = "geometry";
          else {
            let c = l.value;
            switch (r.length > 0 && (c = c.replace(r, "")), c) {
              case "long":
                A.type = "integer";
                break;
              default:
                A.type = c;
            }
          }
        else l.localName === "name" && (A.label = A.key = l.value);
        return A;
      }, {
        label: "",
        key: "",
        value: null,
        type: "string",
        required: !0
      }));
    }
    return [];
  }
  function bP(t, e, i) {
    const r = new URL(decodeURI(t));
    return r.searchParams.set("SERVICE", "WFS"), r.searchParams.set("REQUEST", "DescribeFeatureType"), r.searchParams.set("TYPENAME", i), !r.searchParams.has("VERSION") && !r.searchParams.has("version") && r.searchParams.set("VERSION", e), r;
  }
  async function xue(t, e, i, r) {
    const n = bP(t, e, i);
    let s = null;
    try {
      return s = await fetch(n, {
        responseType: "text/xml",
        credentials: r ? "include" : "omit"
      }), CP(await s.text(), i);
    } catch (o) {
      throw console.error(o), o;
    }
  }
  function Que(t, e) {
    const i = BP(t, t.version, { getCode: () => t.crs }, "");
    fetch(i, e).then((r) => r.text()).then((r) => {
      e.addFeatures(e.getFormat().readFeatures(r));
    }).catch((r) => {
      console.error(r);
    });
  }
  const Fue = { createLayerSource: uM, createLayer: Mue, createReceivePossiblePropertiesUrl: bP, sendTransaction: vue, receivePossibleProperties: xue, parseDescribeFeatureTypeResponse: CP, writeTransactionBody: wP, loadFeaturesManually: Que };
  class Zx extends DB {
    /**
     * @param {!Options<FeatureType>} options Vector tile options.
     */
    constructor(e) {
      const i = e.projection || "EPSG:3857", r = e.extent || bf(i), n = e.tileGrid || vx({
        extent: r,
        maxResolution: e.maxResolution,
        maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 22,
        minZoom: e.minZoom,
        tileSize: e.tileSize || 512
      });
      super({
        attributions: e.attributions,
        attributionsCollapsible: e.attributionsCollapsible,
        cacheSize: e.cacheSize,
        interpolate: !0,
        projection: i,
        state: e.state,
        tileGrid: n,
        tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : MP,
        tileUrlFunction: e.tileUrlFunction,
        url: e.url,
        urls: e.urls,
        wrapX: e.wrapX === void 0 ? !0 : e.wrapX,
        transition: e.transition,
        zDirection: e.zDirection === void 0 ? 1 : e.zDirection
      }), this.format_ = e.format ? e.format : null, this.tileKeysBySourceTileUrl_ = {}, this.sourceTiles_ = {}, this.overlaps_ = e.overlaps == null ? !0 : e.overlaps, this.tileClass = e.tileClass ? e.tileClass : BL, this.tileGrids_ = {};
    }
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    getOverlaps() {
      return this.overlaps_;
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection").default} projection Projection.
     * @param {VectorRenderTile} tile Vector render tile.
     * @return {Array<import("../VectorTile").default>} Tile keys.
     */
    getSourceTiles(e, i, r) {
      if (r.getState() === pe.IDLE) {
        r.setState(pe.LOADING);
        const n = r.wrappedTileCoord, s = this.getTileGridForProjection(i), o = s.getTileCoordExtent(n), a = n[0], A = s.getResolution(a);
        $r(o, -A, o);
        const l = this.tileGrid, c = l.getExtent();
        c && fr(o, c, o);
        const u = l.getZForResolution(
          A,
          this.zDirection
        );
        l.forEachTileCoord(o, u, (d) => {
          const h = this.tileUrlFunction(
            d,
            e,
            i
          );
          this.sourceTiles_[h] || (this.sourceTiles_[h] = new this.tileClass(
            d,
            h ? pe.IDLE : pe.EMPTY,
            h,
            this.format_,
            this.tileLoadFunction
          ));
          const g = this.sourceTiles_[h];
          r.sourceTiles.push(g), this.tileKeysBySourceTileUrl_[h] || (this.tileKeysBySourceTileUrl_[h] = []), this.tileKeysBySourceTileUrl_[h].push(r.getKey());
          const f = g.getState();
          if (f < pe.LOADED) {
            const p = (m) => {
              this.handleTileChange(m);
              const E = g.getState();
              if (E === pe.LOADED || E === pe.ERROR) {
                const y = g.getKey();
                y in r.errorTileKeys ? g.getState() === pe.LOADED && delete r.errorTileKeys[y] : r.loadingSourceTiles--, E === pe.ERROR ? r.errorTileKeys[y] = !0 : g.removeEventListener(Ge.CHANGE, p), r.loadingSourceTiles === 0 && r.setState(
                  vA(r.errorTileKeys) ? pe.LOADED : pe.ERROR
                );
              }
            };
            g.addEventListener(Ge.CHANGE, p), r.loadingSourceTiles++;
          }
          f === pe.IDLE && (g.extent = l.getTileCoordExtent(d), g.projection = i, g.resolution = l.getResolution(
            d[0]
          ), g.load());
        }), r.loadingSourceTiles || r.setState(
          r.sourceTiles.some(
            (d) => d.getState() === pe.ERROR
          ) ? pe.ERROR : pe.LOADED
        );
      }
      return r.sourceTiles;
    }
    /**
     * @param {VectorRenderTile} tile Vector render tile.
     */
    removeSourceTiles(e) {
      const i = e.sourceTiles;
      for (let r = 0, n = i.length; r < n; ++r) {
        const s = i[r].getTileUrl(), o = this.getKey();
        if (!this.tileKeysBySourceTileUrl_[s])
          return;
        const a = this.tileKeysBySourceTileUrl_[s][o];
        a !== -1 && (this.tileKeysBySourceTileUrl_[s].splice(a, 1), this.tileKeysBySourceTileUrl_[s].length === 0 && (delete this.tileKeysBySourceTileUrl_[s], delete this.sourceTiles_[s]));
      }
    }
    /**
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!VectorRenderTile} Tile.
     * @override
     */
    getTile(e, i, r, n, s) {
      const o = [e, i, r];
      let a = this.getTileCoordForTileUrlFunction(
        o,
        s
      );
      const A = this.getTileGrid().getExtent(), l = this.getTileGridForProjection(s);
      if (a && A) {
        const d = l.getTileCoordExtent(a);
        $r(d, -l.getResolution(e), d), Yi(A, d) || (a = null);
      }
      let c = !0;
      if (a !== null) {
        const d = this.tileGrid, h = l.getResolution(e), g = d.getZForResolution(h, 1), f = l.getTileCoordExtent(a);
        $r(f, -h, f), d.forEachTileCoord(f, g, (p) => {
          c = c && !this.tileUrlFunction(p, n, s);
        });
      }
      const u = new Cie(
        o,
        c ? pe.EMPTY : pe.IDLE,
        a,
        this.getSourceTiles.bind(this, n, s),
        this.removeSourceTiles.bind(this)
      );
      return u.key = this.getKey(), u;
    }
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     * @override
     */
    getTileGridForProjection(e) {
      const i = e.getCode();
      let r = this.tileGrids_[i];
      if (!r) {
        const n = this.tileGrid, s = n.getResolutions().slice(), o = s.map(function(l, c) {
          return n.getOrigin(c);
        }), a = s.map(function(l, c) {
          return n.getTileSize(c);
        }), A = NU + 1;
        for (let l = s.length; l < A; ++l)
          s.push(s[l - 1] / 2), o.push(o[l - 1]), a.push(a[l - 1]);
        r = new dc({
          extent: n.getExtent(),
          origins: o,
          resolutions: s,
          tileSizes: a
        }), this.tileGrids_[i] = r;
      }
      return r;
    }
    /**
     * Get the tile pixel ratio for this source.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     * @override
     */
    getTilePixelRatio(e) {
      return e;
    }
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     * @override
     */
    getTilePixelSize(e, i, r) {
      const n = this.getTileGridForProjection(r), s = mr(n.getTileSize(e), this.tmpSize);
      return [
        Math.round(s[0] * i),
        Math.round(s[1] * i)
      ];
    }
    /**
     * @param {boolean} overlaps The source has overlapping geometries.
     */
    setOverlaps(e) {
      this.overlaps_ = e, this.changed();
    }
  }
  function MP(t, e) {
    t.setLoader(
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      function(i, r, n) {
        rL(
          e,
          t.getFormat(),
          i,
          r,
          n,
          t.onLoad.bind(t),
          t.onError.bind(t)
        );
      }
    );
  }
  var Sue = 8, Due = {
    version: {
      required: !0,
      type: "enum",
      values: [
        8
      ]
    },
    name: {
      type: "string"
    },
    metadata: {
      type: "*"
    },
    center: {
      type: "array",
      value: "number"
    },
    centerAltitude: {
      type: "number"
    },
    zoom: {
      type: "number"
    },
    bearing: {
      type: "number",
      default: 0,
      period: 360,
      units: "degrees"
    },
    pitch: {
      type: "number",
      default: 0,
      units: "degrees"
    },
    roll: {
      type: "number",
      default: 0,
      units: "degrees"
    },
    light: {
      type: "light"
    },
    sky: {
      type: "sky"
    },
    projection: {
      type: "projection"
    },
    terrain: {
      type: "terrain"
    },
    sources: {
      required: !0,
      type: "sources"
    },
    sprite: {
      type: "sprite"
    },
    glyphs: {
      type: "string"
    },
    transition: {
      type: "transition"
    },
    layers: {
      required: !0,
      type: "array",
      value: "layer"
    }
  }, Tue = {
    "*": {
      type: "source"
    }
  }, Rue = [
    "source_vector",
    "source_raster",
    "source_raster_dem",
    "source_geojson",
    "source_video",
    "source_image"
  ], _ue = {
    type: {
      required: !0,
      type: "enum",
      values: {
        vector: {}
      }
    },
    url: {
      type: "string"
    },
    tiles: {
      type: "array",
      value: "string"
    },
    bounds: {
      type: "array",
      value: "number",
      length: 4,
      default: [
        -180,
        -85.051129,
        180,
        85.051129
      ]
    },
    scheme: {
      type: "enum",
      values: {
        xyz: {},
        tms: {}
      },
      default: "xyz"
    },
    minzoom: {
      type: "number",
      default: 0
    },
    maxzoom: {
      type: "number",
      default: 22
    },
    attribution: {
      type: "string"
    },
    promoteId: {
      type: "promoteId"
    },
    volatile: {
      type: "boolean",
      default: !1
    },
    "*": {
      type: "*"
    }
  }, kue = {
    type: {
      required: !0,
      type: "enum",
      values: {
        raster: {}
      }
    },
    url: {
      type: "string"
    },
    tiles: {
      type: "array",
      value: "string"
    },
    bounds: {
      type: "array",
      value: "number",
      length: 4,
      default: [
        -180,
        -85.051129,
        180,
        85.051129
      ]
    },
    minzoom: {
      type: "number",
      default: 0
    },
    maxzoom: {
      type: "number",
      default: 22
    },
    tileSize: {
      type: "number",
      default: 512,
      units: "pixels"
    },
    scheme: {
      type: "enum",
      values: {
        xyz: {},
        tms: {}
      },
      default: "xyz"
    },
    attribution: {
      type: "string"
    },
    volatile: {
      type: "boolean",
      default: !1
    },
    "*": {
      type: "*"
    }
  }, Yue = {
    type: {
      required: !0,
      type: "enum",
      values: {
        "raster-dem": {}
      }
    },
    url: {
      type: "string"
    },
    tiles: {
      type: "array",
      value: "string"
    },
    bounds: {
      type: "array",
      value: "number",
      length: 4,
      default: [
        -180,
        -85.051129,
        180,
        85.051129
      ]
    },
    minzoom: {
      type: "number",
      default: 0
    },
    maxzoom: {
      type: "number",
      default: 22
    },
    tileSize: {
      type: "number",
      default: 512,
      units: "pixels"
    },
    attribution: {
      type: "string"
    },
    encoding: {
      type: "enum",
      values: {
        terrarium: {},
        mapbox: {},
        custom: {}
      },
      default: "mapbox"
    },
    redFactor: {
      type: "number",
      default: 1
    },
    blueFactor: {
      type: "number",
      default: 1
    },
    greenFactor: {
      type: "number",
      default: 1
    },
    baseShift: {
      type: "number",
      default: 0
    },
    volatile: {
      type: "boolean",
      default: !1
    },
    "*": {
      type: "*"
    }
  }, Nue = {
    type: {
      required: !0,
      type: "enum",
      values: {
        geojson: {}
      }
    },
    data: {
      required: !0,
      type: "*"
    },
    maxzoom: {
      type: "number",
      default: 18
    },
    attribution: {
      type: "string"
    },
    buffer: {
      type: "number",
      default: 128,
      maximum: 512,
      minimum: 0
    },
    filter: {
      type: "*"
    },
    tolerance: {
      type: "number",
      default: 0.375
    },
    cluster: {
      type: "boolean",
      default: !1
    },
    clusterRadius: {
      type: "number",
      default: 50,
      minimum: 0
    },
    clusterMaxZoom: {
      type: "number"
    },
    clusterMinPoints: {
      type: "number"
    },
    clusterProperties: {
      type: "*"
    },
    lineMetrics: {
      type: "boolean",
      default: !1
    },
    generateId: {
      type: "boolean",
      default: !1
    },
    promoteId: {
      type: "promoteId"
    }
  }, Uue = {
    type: {
      required: !0,
      type: "enum",
      values: {
        video: {}
      }
    },
    urls: {
      required: !0,
      type: "array",
      value: "string"
    },
    coordinates: {
      required: !0,
      type: "array",
      length: 4,
      value: {
        type: "array",
        length: 2,
        value: "number"
      }
    }
  }, Lue = {
    type: {
      required: !0,
      type: "enum",
      values: {
        image: {}
      }
    },
    url: {
      required: !0,
      type: "string"
    },
    coordinates: {
      required: !0,
      type: "array",
      length: 4,
      value: {
        type: "array",
        length: 2,
        value: "number"
      }
    }
  }, zue = {
    id: {
      type: "string",
      required: !0
    },
    type: {
      type: "enum",
      values: {
        fill: {},
        line: {},
        symbol: {},
        circle: {},
        heatmap: {},
        "fill-extrusion": {},
        raster: {},
        hillshade: {},
        background: {}
      },
      required: !0
    },
    metadata: {
      type: "*"
    },
    source: {
      type: "string"
    },
    "source-layer": {
      type: "string"
    },
    minzoom: {
      type: "number",
      minimum: 0,
      maximum: 24
    },
    maxzoom: {
      type: "number",
      minimum: 0,
      maximum: 24
    },
    filter: {
      type: "filter"
    },
    layout: {
      type: "layout"
    },
    paint: {
      type: "paint"
    }
  }, Pue = [
    "layout_fill",
    "layout_line",
    "layout_circle",
    "layout_heatmap",
    "layout_fill-extrusion",
    "layout_symbol",
    "layout_raster",
    "layout_hillshade",
    "layout_background"
  ], Oue = {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, Gue = {
    "fill-sort-key": {
      type: "number",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, jue = {
    "circle-sort-key": {
      type: "number",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, Hue = {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, Jue = {
    "line-cap": {
      type: "enum",
      values: {
        butt: {},
        round: {},
        square: {}
      },
      default: "butt",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "line-join": {
      type: "enum",
      values: {
        bevel: {},
        round: {},
        miter: {}
      },
      default: "miter",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "line-miter-limit": {
      type: "number",
      default: 2,
      requires: [
        {
          "line-join": "miter"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "line-round-limit": {
      type: "number",
      default: 1.05,
      requires: [
        {
          "line-join": "round"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "line-sort-key": {
      type: "number",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, Vue = {
    "symbol-placement": {
      type: "enum",
      values: {
        point: {},
        line: {},
        "line-center": {}
      },
      default: "point",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "symbol-spacing": {
      type: "number",
      default: 250,
      minimum: 1,
      units: "pixels",
      requires: [
        {
          "symbol-placement": "line"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "symbol-avoid-edges": {
      type: "boolean",
      default: !1,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "symbol-sort-key": {
      type: "number",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "symbol-z-order": {
      type: "enum",
      values: {
        auto: {},
        "viewport-y": {},
        source: {}
      },
      default: "auto",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-allow-overlap": {
      type: "boolean",
      default: !1,
      requires: [
        "icon-image",
        {
          "!": "icon-overlap"
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-overlap": {
      type: "enum",
      values: {
        never: {},
        always: {},
        cooperative: {}
      },
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-ignore-placement": {
      type: "boolean",
      default: !1,
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-optional": {
      type: "boolean",
      default: !1,
      requires: [
        "icon-image",
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-rotation-alignment": {
      type: "enum",
      values: {
        map: {},
        viewport: {},
        auto: {}
      },
      default: "auto",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-size": {
      type: "number",
      default: 1,
      minimum: 0,
      units: "factor of the original icon size",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-text-fit": {
      type: "enum",
      values: {
        none: {},
        width: {},
        height: {},
        both: {}
      },
      default: "none",
      requires: [
        "icon-image",
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-text-fit-padding": {
      type: "array",
      value: "number",
      length: 4,
      default: [
        0,
        0,
        0,
        0
      ],
      units: "pixels",
      requires: [
        "icon-image",
        "text-field",
        {
          "icon-text-fit": [
            "both",
            "width",
            "height"
          ]
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-image": {
      type: "resolvedImage",
      tokens: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-rotate": {
      type: "number",
      default: 0,
      period: 360,
      units: "degrees",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-padding": {
      type: "padding",
      default: [
        2
      ],
      units: "pixels",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-keep-upright": {
      type: "boolean",
      default: !1,
      requires: [
        "icon-image",
        {
          "icon-rotation-alignment": "map"
        },
        {
          "symbol-placement": [
            "line",
            "line-center"
          ]
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-offset": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-anchor": {
      type: "enum",
      values: {
        center: {},
        left: {},
        right: {},
        top: {},
        bottom: {},
        "top-left": {},
        "top-right": {},
        "bottom-left": {},
        "bottom-right": {}
      },
      default: "center",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-pitch-alignment": {
      type: "enum",
      values: {
        map: {},
        viewport: {},
        auto: {}
      },
      default: "auto",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-pitch-alignment": {
      type: "enum",
      values: {
        map: {},
        viewport: {},
        auto: {}
      },
      default: "auto",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-rotation-alignment": {
      type: "enum",
      values: {
        map: {},
        viewport: {},
        "viewport-glyph": {},
        auto: {}
      },
      default: "auto",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-field": {
      type: "formatted",
      default: "",
      tokens: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-font": {
      type: "array",
      value: "string",
      default: [
        "Open Sans Regular",
        "Arial Unicode MS Regular"
      ],
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-size": {
      type: "number",
      default: 16,
      minimum: 0,
      units: "pixels",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-max-width": {
      type: "number",
      default: 10,
      minimum: 0,
      units: "ems",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-line-height": {
      type: "number",
      default: 1.2,
      units: "ems",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-letter-spacing": {
      type: "number",
      default: 0,
      units: "ems",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-justify": {
      type: "enum",
      values: {
        auto: {},
        left: {},
        center: {},
        right: {}
      },
      default: "center",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-radial-offset": {
      type: "number",
      units: "ems",
      default: 0,
      requires: [
        "text-field"
      ],
      "property-type": "data-driven",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      }
    },
    "text-variable-anchor": {
      type: "array",
      value: "enum",
      values: {
        center: {},
        left: {},
        right: {},
        top: {},
        bottom: {},
        "top-left": {},
        "top-right": {},
        "bottom-left": {},
        "bottom-right": {}
      },
      requires: [
        "text-field",
        {
          "symbol-placement": [
            "point"
          ]
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-variable-anchor-offset": {
      type: "variableAnchorOffsetCollection",
      requires: [
        "text-field",
        {
          "symbol-placement": [
            "point"
          ]
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-anchor": {
      type: "enum",
      values: {
        center: {},
        left: {},
        right: {},
        top: {},
        bottom: {},
        "top-left": {},
        "top-right": {},
        "bottom-left": {},
        "bottom-right": {}
      },
      default: "center",
      requires: [
        "text-field",
        {
          "!": "text-variable-anchor"
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-max-angle": {
      type: "number",
      default: 45,
      units: "degrees",
      requires: [
        "text-field",
        {
          "symbol-placement": [
            "line",
            "line-center"
          ]
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-writing-mode": {
      type: "array",
      value: "enum",
      values: {
        horizontal: {},
        vertical: {}
      },
      requires: [
        "text-field",
        {
          "symbol-placement": [
            "point"
          ]
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-rotate": {
      type: "number",
      default: 0,
      period: 360,
      units: "degrees",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-padding": {
      type: "number",
      default: 2,
      minimum: 0,
      units: "pixels",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-keep-upright": {
      type: "boolean",
      default: !0,
      requires: [
        "text-field",
        {
          "text-rotation-alignment": "map"
        },
        {
          "symbol-placement": [
            "line",
            "line-center"
          ]
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-transform": {
      type: "enum",
      values: {
        none: {},
        uppercase: {},
        lowercase: {}
      },
      default: "none",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-offset": {
      type: "array",
      value: "number",
      units: "ems",
      length: 2,
      default: [
        0,
        0
      ],
      requires: [
        "text-field",
        {
          "!": "text-radial-offset"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "data-driven"
    },
    "text-allow-overlap": {
      type: "boolean",
      default: !1,
      requires: [
        "text-field",
        {
          "!": "text-overlap"
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-overlap": {
      type: "enum",
      values: {
        never: {},
        always: {},
        cooperative: {}
      },
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-ignore-placement": {
      type: "boolean",
      default: !1,
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-optional": {
      type: "boolean",
      default: !1,
      requires: [
        "text-field",
        "icon-image"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, Wue = {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, Kue = {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  }, Xue = {
    type: "array",
    value: "*"
  }, Zue = {
    type: "enum",
    values: {
      "==": {},
      "!=": {},
      ">": {},
      ">=": {},
      "<": {},
      "<=": {},
      in: {},
      "!in": {},
      all: {},
      any: {},
      none: {},
      has: {},
      "!has": {}
    }
  }, que = {
    type: "enum",
    values: {
      Point: {},
      LineString: {},
      Polygon: {}
    }
  }, $ue = {
    type: "array",
    minimum: 0,
    maximum: 24,
    value: [
      "number",
      "color"
    ],
    length: 2
  }, ede = {
    type: "array",
    value: "*",
    minimum: 1
  }, tde = {
    anchor: {
      type: "enum",
      default: "viewport",
      values: {
        map: {},
        viewport: {}
      },
      "property-type": "data-constant",
      transition: !1,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      }
    },
    position: {
      type: "array",
      default: [
        1.15,
        210,
        30
      ],
      length: 3,
      value: "number",
      "property-type": "data-constant",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      }
    },
    color: {
      type: "color",
      "property-type": "data-constant",
      default: "#ffffff",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    },
    intensity: {
      type: "number",
      "property-type": "data-constant",
      default: 0.5,
      minimum: 0,
      maximum: 1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    }
  }, ide = {
    "sky-color": {
      type: "color",
      "property-type": "data-constant",
      default: "#88C6FC",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    },
    "horizon-color": {
      type: "color",
      "property-type": "data-constant",
      default: "#ffffff",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    },
    "fog-color": {
      type: "color",
      "property-type": "data-constant",
      default: "#ffffff",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    },
    "fog-ground-blend": {
      type: "number",
      "property-type": "data-constant",
      default: 0.5,
      minimum: 0,
      maximum: 1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    },
    "horizon-fog-blend": {
      type: "number",
      "property-type": "data-constant",
      default: 0.8,
      minimum: 0,
      maximum: 1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    },
    "sky-horizon-blend": {
      type: "number",
      "property-type": "data-constant",
      default: 0.8,
      minimum: 0,
      maximum: 1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    },
    "atmosphere-blend": {
      type: "number",
      "property-type": "data-constant",
      default: 0.8,
      minimum: 0,
      maximum: 1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      transition: !0
    }
  }, rde = {
    source: {
      type: "string",
      required: !0
    },
    exaggeration: {
      type: "number",
      minimum: 0,
      default: 1
    }
  }, nde = {
    type: {
      type: "projectionDefinition",
      default: "mercator",
      "property-type": "data-constant",
      transition: !1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      }
    }
  }, sde = [
    "paint_fill",
    "paint_line",
    "paint_circle",
    "paint_heatmap",
    "paint_fill-extrusion",
    "paint_symbol",
    "paint_raster",
    "paint_hillshade",
    "paint_background"
  ], ode = {
    "fill-antialias": {
      type: "boolean",
      default: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      requires: [
        {
          "!": "fill-pattern"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-outline-color": {
      type: "color",
      transition: !0,
      requires: [
        {
          "!": "fill-pattern"
        },
        {
          "fill-antialias": !0
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "fill-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-pattern": {
      type: "resolvedImage",
      transition: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "cross-faded-data-driven"
    }
  }, ade = {
    "line-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "line-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      requires: [
        {
          "!": "line-pattern"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "line-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "line-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "line-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "line-width": {
      type: "number",
      default: 1,
      minimum: 0,
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "line-gap-width": {
      type: "number",
      default: 0,
      minimum: 0,
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "line-offset": {
      type: "number",
      default: 0,
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "line-blur": {
      type: "number",
      default: 0,
      minimum: 0,
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "line-dasharray": {
      type: "array",
      value: "number",
      minimum: 0,
      transition: !0,
      units: "line widths",
      requires: [
        {
          "!": "line-pattern"
        }
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "cross-faded"
    },
    "line-pattern": {
      type: "resolvedImage",
      transition: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "cross-faded-data-driven"
    },
    "line-gradient": {
      type: "color",
      transition: !1,
      requires: [
        {
          "!": "line-dasharray"
        },
        {
          "!": "line-pattern"
        },
        {
          source: "geojson",
          has: {
            lineMetrics: !0
          }
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "line-progress"
        ]
      },
      "property-type": "color-ramp"
    }
  }, Ade = {
    "circle-radius": {
      type: "number",
      default: 5,
      minimum: 0,
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "circle-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "circle-blur": {
      type: "number",
      default: 0,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "circle-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "circle-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "circle-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "circle-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "circle-pitch-scale": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "circle-pitch-alignment": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "viewport",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "circle-stroke-width": {
      type: "number",
      default: 0,
      minimum: 0,
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "circle-stroke-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "circle-stroke-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    }
  }, lde = {
    "heatmap-radius": {
      type: "number",
      default: 30,
      minimum: 1,
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "heatmap-weight": {
      type: "number",
      default: 1,
      minimum: 0,
      transition: !1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "heatmap-intensity": {
      type: "number",
      default: 1,
      minimum: 0,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "heatmap-color": {
      type: "color",
      default: [
        "interpolate",
        [
          "linear"
        ],
        [
          "heatmap-density"
        ],
        0,
        "rgba(0, 0, 255, 0)",
        0.1,
        "royalblue",
        0.3,
        "cyan",
        0.5,
        "lime",
        0.7,
        "yellow",
        1,
        "red"
      ],
      transition: !1,
      expression: {
        interpolated: !0,
        parameters: [
          "heatmap-density"
        ]
      },
      "property-type": "color-ramp"
    },
    "heatmap-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  }, cde = {
    "icon-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-halo-color": {
      type: "color",
      default: "rgba(0, 0, 0, 0)",
      transition: !0,
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-halo-width": {
      type: "number",
      default: 0,
      minimum: 0,
      transition: !0,
      units: "pixels",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-halo-blur": {
      type: "number",
      default: 0,
      minimum: 0,
      transition: !0,
      units: "pixels",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "icon-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      requires: [
        "icon-image"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "icon-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "icon-image",
        "icon-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "text-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      overridable: !0,
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "text-halo-color": {
      type: "color",
      default: "rgba(0, 0, 0, 0)",
      transition: !0,
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "text-halo-width": {
      type: "number",
      default: 0,
      minimum: 0,
      transition: !0,
      units: "pixels",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "text-halo-blur": {
      type: "number",
      default: 0,
      minimum: 0,
      transition: !0,
      units: "pixels",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "text-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      requires: [
        "text-field"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "text-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "text-field",
        "text-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  }, ude = {
    "raster-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "raster-hue-rotate": {
      type: "number",
      default: 0,
      period: 360,
      transition: !0,
      units: "degrees",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "raster-brightness-min": {
      type: "number",
      default: 0,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "raster-brightness-max": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "raster-saturation": {
      type: "number",
      default: 0,
      minimum: -1,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "raster-contrast": {
      type: "number",
      default: 0,
      minimum: -1,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "raster-resampling": {
      type: "enum",
      values: {
        linear: {},
        nearest: {}
      },
      default: "linear",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "raster-fade-duration": {
      type: "number",
      default: 300,
      minimum: 0,
      transition: !1,
      units: "milliseconds",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  }, dde = {
    "hillshade-illumination-direction": {
      type: "number",
      default: 335,
      minimum: 0,
      maximum: 359,
      transition: !1,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "hillshade-illumination-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "viewport",
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "hillshade-exaggeration": {
      type: "number",
      default: 0.5,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "hillshade-shadow-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "hillshade-highlight-color": {
      type: "color",
      default: "#FFFFFF",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "hillshade-accent-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  }, hde = {
    "background-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      requires: [
        {
          "!": "background-pattern"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "background-pattern": {
      type: "resolvedImage",
      transition: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "cross-faded"
    },
    "background-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  }, gde = {
    duration: {
      type: "number",
      default: 300,
      minimum: 0,
      units: "milliseconds"
    },
    delay: {
      type: "number",
      default: 0,
      minimum: 0,
      units: "milliseconds"
    }
  }, fde = {
    "*": {
      type: "string"
    }
  }, pde = {
    $version: Sue,
    $root: Due,
    sources: Tue,
    source: Rue,
    source_vector: _ue,
    source_raster: kue,
    source_raster_dem: Yue,
    source_geojson: Nue,
    source_video: Uue,
    source_image: Lue,
    layer: zue,
    layout: Pue,
    layout_background: Oue,
    layout_fill: Gue,
    layout_circle: jue,
    layout_heatmap: Hue,
    "layout_fill-extrusion": {
      visibility: {
        type: "enum",
        values: {
          visible: {},
          none: {}
        },
        default: "visible",
        "property-type": "constant"
      }
    },
    layout_line: Jue,
    layout_symbol: Vue,
    layout_raster: Wue,
    layout_hillshade: Kue,
    filter: Xue,
    filter_operator: Zue,
    geometry_type: que,
    function: {
      expression: {
        type: "expression"
      },
      stops: {
        type: "array",
        value: "function_stop"
      },
      base: {
        type: "number",
        default: 1,
        minimum: 0
      },
      property: {
        type: "string",
        default: "$zoom"
      },
      type: {
        type: "enum",
        values: {
          identity: {},
          exponential: {},
          interval: {},
          categorical: {}
        },
        default: "exponential"
      },
      colorSpace: {
        type: "enum",
        values: {
          rgb: {},
          lab: {},
          hcl: {}
        },
        default: "rgb"
      },
      default: {
        type: "*",
        required: !1
      }
    },
    function_stop: $ue,
    expression: ede,
    light: tde,
    sky: ide,
    terrain: rde,
    projection: nde,
    paint: sde,
    paint_fill: ode,
    "paint_fill-extrusion": {
      "fill-extrusion-opacity": {
        type: "number",
        default: 1,
        minimum: 0,
        maximum: 1,
        transition: !0,
        expression: {
          interpolated: !0,
          parameters: [
            "zoom"
          ]
        },
        "property-type": "data-constant"
      },
      "fill-extrusion-color": {
        type: "color",
        default: "#000000",
        transition: !0,
        requires: [
          {
            "!": "fill-extrusion-pattern"
          }
        ],
        expression: {
          interpolated: !0,
          parameters: [
            "zoom",
            "feature",
            "feature-state"
          ]
        },
        "property-type": "data-driven"
      },
      "fill-extrusion-translate": {
        type: "array",
        value: "number",
        length: 2,
        default: [
          0,
          0
        ],
        transition: !0,
        units: "pixels",
        expression: {
          interpolated: !0,
          parameters: [
            "zoom"
          ]
        },
        "property-type": "data-constant"
      },
      "fill-extrusion-translate-anchor": {
        type: "enum",
        values: {
          map: {},
          viewport: {}
        },
        default: "map",
        requires: [
          "fill-extrusion-translate"
        ],
        expression: {
          interpolated: !1,
          parameters: [
            "zoom"
          ]
        },
        "property-type": "data-constant"
      },
      "fill-extrusion-pattern": {
        type: "resolvedImage",
        transition: !0,
        expression: {
          interpolated: !1,
          parameters: [
            "zoom",
            "feature"
          ]
        },
        "property-type": "cross-faded-data-driven"
      },
      "fill-extrusion-height": {
        type: "number",
        default: 0,
        minimum: 0,
        units: "meters",
        transition: !0,
        expression: {
          interpolated: !0,
          parameters: [
            "zoom",
            "feature",
            "feature-state"
          ]
        },
        "property-type": "data-driven"
      },
      "fill-extrusion-base": {
        type: "number",
        default: 0,
        minimum: 0,
        units: "meters",
        transition: !0,
        requires: [
          "fill-extrusion-height"
        ],
        expression: {
          interpolated: !0,
          parameters: [
            "zoom",
            "feature",
            "feature-state"
          ]
        },
        "property-type": "data-driven"
      },
      "fill-extrusion-vertical-gradient": {
        type: "boolean",
        default: !0,
        transition: !1,
        expression: {
          interpolated: !1,
          parameters: [
            "zoom"
          ]
        },
        "property-type": "data-constant"
      }
    },
    paint_line: ade,
    paint_circle: Ade,
    paint_heatmap: lde,
    paint_symbol: cde,
    paint_raster: ude,
    paint_hillshade: dde,
    paint_background: hde,
    transition: gde,
    "property-type": {
      "data-driven": {
        type: "property-type"
      },
      "cross-faded": {
        type: "property-type"
      },
      "cross-faded-data-driven": {
        type: "property-type"
      },
      "color-ramp": {
        type: "property-type"
      },
      "data-constant": {
        type: "property-type"
      },
      constant: {
        type: "property-type"
      }
    },
    promoteId: fde
  };
  const mde = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
  function Ede(t, e) {
    const i = {};
    for (const r in t)
      r !== "ref" && (i[r] = t[r]);
    return mde.forEach((r) => {
      r in e && (i[r] = e[r]);
    }), i;
  }
  function IP(t) {
    t = t.slice();
    const e = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < t.length; i++)
      e[t[i].id] = t[i];
    for (let i = 0; i < t.length; i++)
      "ref" in t[i] && (t[i] = Ede(t[i], e[t[i].ref]));
    return t;
  }
  class Co extends Error {
    constructor(e, i) {
      super(i), this.message = i, this.key = e;
    }
  }
  class qx {
    constructor(e, i = []) {
      this.parent = e, this.bindings = {};
      for (const [r, n] of i)
        this.bindings[r] = n;
    }
    concat(e) {
      return new qx(this, e);
    }
    get(e) {
      if (this.bindings[e])
        return this.bindings[e];
      if (this.parent)
        return this.parent.get(e);
      throw new Error(`${e} not found in scope.`);
    }
    has(e) {
      return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;
    }
  }
  const LB = { kind: "null" }, xe = { kind: "number" }, Dt = { kind: "string" }, Et = { kind: "boolean" }, To = { kind: "color" }, zB = { kind: "projectionDefinition" }, Yu = { kind: "object" }, yt = { kind: "value" }, yde = { kind: "error" }, PB = { kind: "collator" }, OB = { kind: "formatted" }, GB = { kind: "padding" }, xf = { kind: "resolvedImage" }, jB = { kind: "variableAnchorOffsetCollection" };
  function Yn(t, e) {
    return {
      kind: "array",
      itemType: t,
      N: e
    };
  }
  function Si(t) {
    if (t.kind === "array") {
      const e = Si(t.itemType);
      return typeof t.N == "number" ? `array<${e}, ${t.N}>` : t.itemType.kind === "value" ? "array" : `array<${e}>`;
    } else
      return t.kind;
  }
  const Bde = [
    LB,
    xe,
    Dt,
    Et,
    To,
    zB,
    OB,
    Yu,
    Yn(yt),
    GB,
    xf,
    jB
  ];
  function Ig(t, e) {
    if (e.kind === "error")
      return null;
    if (t.kind === "array") {
      if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Ig(t.itemType, e.itemType)) && (typeof t.N != "number" || t.N === e.N))
        return null;
    } else {
      if (t.kind === e.kind)
        return null;
      if (t.kind === "value") {
        for (const i of Bde)
          if (!Ig(i, e))
            return null;
      }
    }
    return `Expected ${Si(t)} but found ${Si(e)} instead.`;
  }
  function $x(t, e) {
    return e.some((i) => i.kind === t.kind);
  }
  function Dl(t, e) {
    return e.some((i) => i === "null" ? t === null : i === "array" ? Array.isArray(t) : i === "object" ? t && !Array.isArray(t) && typeof t == "object" : i === typeof t);
  }
  function Uc(t, e) {
    return t.kind === "array" && e.kind === "array" ? t.itemType.kind === e.itemType.kind && typeof t.N == "number" : t.kind === e.kind;
  }
  const vP = 0.96422, xP = 1, QP = 0.82521, FP = 4 / 29, Nu = 6 / 29, SP = 3 * Nu * Nu, wde = Nu * Nu * Nu, Cde = Math.PI / 180, bde = 180 / Math.PI;
  function DP(t) {
    return t = t % 360, t < 0 && (t += 360), t;
  }
  function TP([t, e, i, r]) {
    t = aC(t), e = aC(e), i = aC(i);
    let n, s;
    const o = AC((0.2225045 * t + 0.7168786 * e + 0.0606169 * i) / xP);
    t === e && e === i ? n = s = o : (n = AC((0.4360747 * t + 0.3850649 * e + 0.1430804 * i) / vP), s = AC((0.0139322 * t + 0.0971045 * e + 0.7141733 * i) / QP));
    const a = 116 * o - 16;
    return [a < 0 ? 0 : a, 500 * (n - o), 200 * (o - s), r];
  }
  function aC(t) {
    return t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  function AC(t) {
    return t > wde ? Math.pow(t, 1 / 3) : t / SP + FP;
  }
  function RP([t, e, i, r]) {
    let n = (t + 16) / 116, s = isNaN(e) ? n : n + e / 500, o = isNaN(i) ? n : n - i / 200;
    return n = xP * cC(n), s = vP * cC(s), o = QP * cC(o), [
      lC(3.1338561 * s - 1.6168667 * n - 0.4906146 * o),
      // D50 -> sRGB
      lC(-0.9787684 * s + 1.9161415 * n + 0.033454 * o),
      lC(0.0719453 * s - 0.2289914 * n + 1.4052427 * o),
      r
    ];
  }
  function lC(t) {
    return t = t <= 304e-5 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055, t < 0 ? 0 : t > 1 ? 1 : t;
  }
  function cC(t) {
    return t > Nu ? t * t * t : SP * (t - FP);
  }
  function Mde(t) {
    const [e, i, r, n] = TP(t), s = Math.sqrt(i * i + r * r);
    return [Math.round(s * 1e4) ? DP(Math.atan2(r, i) * bde) : NaN, s, e, n];
  }
  function Ide([t, e, i, r]) {
    return t = isNaN(t) ? 0 : t * Cde, RP([i, Math.cos(t) * e, Math.sin(t) * e, r]);
  }
  function vde([t, e, i, r]) {
    t = DP(t), e /= 100, i /= 100;
    function n(s) {
      const o = (s + t / 30) % 12, a = e * Math.min(i, 1 - i);
      return i - a * Math.max(-1, Math.min(o - 3, 9 - o, 1));
    }
    return [n(0), n(8), n(4), r];
  }
  function xde(t) {
    if (t = t.toLowerCase().trim(), t === "transparent")
      return [0, 0, 0, 0];
    const e = Qde[t];
    if (e) {
      const [n, s, o] = e;
      return [n / 255, s / 255, o / 255, 1];
    }
    if (t.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t)) {
      const s = t.length < 6 ? 1 : 2;
      let o = 1;
      return [
        Tp(t.slice(o, o += s)),
        Tp(t.slice(o, o += s)),
        Tp(t.slice(o, o += s)),
        Tp(t.slice(o, o + s) || "ff")
      ];
    }
    if (t.startsWith("rgb")) {
      const n = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, s = t.match(n);
      if (s) {
        const [
          o,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          a,
          // <numeric>
          A,
          // %         (optional)
          l,
          // ,         (optional)
          c,
          // <numeric>
          u,
          // %         (optional)
          d,
          // ,         (optional)
          h,
          // <numeric>
          g,
          // %         (optional)
          f,
          // ,|/       (optional)
          p,
          // <numeric> (optional)
          m
          // %         (optional)
        ] = s, E = [l || " ", d || " ", f].join("");
        if (E === "  " || E === "  /" || E === ",," || E === ",,,") {
          const y = [A, u, g].join(""), C = y === "%%%" ? 100 : y === "" ? 255 : 0;
          if (C) {
            const w = [
              Zc(+a / C, 0, 1),
              Zc(+c / C, 0, 1),
              Zc(+h / C, 0, 1),
              p ? QR(+p, m) : 1
            ];
            if (FR(w))
              return w;
          }
        }
        return;
      }
    }
    const i = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, r = t.match(i);
    if (r) {
      const [
        n,
        // eslint-disable-line @typescript-eslint/no-unused-vars
        s,
        // <numeric>
        o,
        // ,         (optional)
        a,
        // <numeric>
        A,
        // ,         (optional)
        l,
        // <numeric>
        c,
        // ,|/       (optional)
        u,
        // <numeric> (optional)
        d
        // %         (optional)
      ] = r, h = [o || " ", A || " ", c].join("");
      if (h === "  " || h === "  /" || h === ",," || h === ",,,") {
        const g = [
          +s,
          Zc(+a, 0, 100),
          Zc(+l, 0, 100),
          u ? QR(+u, d) : 1
        ];
        if (FR(g))
          return vde(g);
      }
    }
  }
  function Tp(t) {
    return parseInt(t.padEnd(2, t), 16) / 255;
  }
  function QR(t, e) {
    return Zc(e ? t / 100 : t, 0, 1);
  }
  function Zc(t, e, i) {
    return Math.min(Math.max(e, t), i);
  }
  function FR(t) {
    return !t.some(Number.isNaN);
  }
  const Qde = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  function Tl(t, e, i) {
    return t + i * (e - t);
  }
  function ZE(t, e, i) {
    return t.map((r, n) => Tl(r, e[n], i));
  }
  class fi {
    /**
     * @param r Red component premultiplied by `alpha` 0..1
     * @param g Green component premultiplied by `alpha` 0..1
     * @param b Blue component premultiplied by `alpha` 0..1
     * @param [alpha=1] Alpha component 0..1
     * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
     * been multiplied by alpha. If `true` nothing happens if `false` then they will
     * be multiplied automatically.
     */
    constructor(e, i, r, n = 1, s = !0) {
      this.r = e, this.g = i, this.b = r, this.a = n, s || (this.r *= n, this.g *= n, this.b *= n, n || this.overwriteGetter("rgb", [e, i, r, n]));
    }
    /**
     * Parses CSS color strings and converts colors to sRGB color space if needed.
     * Officially supported color formats:
     * - keyword, e.g. 'aquamarine' or 'steelblue'
     * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
     * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
     * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
     *
     * @param input CSS color string to parse.
     * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
     */
    static parse(e) {
      if (e instanceof fi)
        return e;
      if (typeof e != "string")
        return;
      const i = xde(e);
      if (i)
        return new fi(...i, !1);
    }
    /**
     * Used in color interpolation and by 'to-rgba' expression.
     *
     * @returns Gien color, with reversed alpha blending, in sRGB color space.
     */
    get rgb() {
      const { r: e, g: i, b: r, a: n } = this, s = n || 1 / 0;
      return this.overwriteGetter("rgb", [e / s, i / s, r / s, n]);
    }
    /**
     * Used in color interpolation.
     *
     * @returns Gien color, with reversed alpha blending, in HCL color space.
     */
    get hcl() {
      return this.overwriteGetter("hcl", Mde(this.rgb));
    }
    /**
     * Used in color interpolation.
     *
     * @returns Gien color, with reversed alpha blending, in LAB color space.
     */
    get lab() {
      return this.overwriteGetter("lab", TP(this.rgb));
    }
    /**
     * Lazy getter pattern. When getter is called for the first time lazy value
     * is calculated and then overwrites getter function in given object instance.
     *
     * @example:
     * const redColor = Color.parse('red');
     * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
     * // the value of red in HCL space and invoke this `overwriteGetter` function
     * // which in turn will set a field with a key 'hcl' in the `redColor` object.
     * // In other words it will override `get hcl()` from its `Color` prototype
     * // with its own property: hcl = [calculated red value in hcl].
     * let y = redColor.hcl; // next call will no longer invoke getter but simply
     * // return the previously calculated value
     * x === y; // true - `x` is exactly the same object as `y`
     *
     * @param getterKey Getter key
     * @param lazyValue Lazily calculated value to be memoized by current instance
     * @private
     */
    overwriteGetter(e, i) {
      return Object.defineProperty(this, e, { value: i }), i;
    }
    /**
     * Used by 'to-string' expression.
     *
     * @returns Serialized color in format `rgba(r,g,b,a)`
     * where r,g,b are numbers within 0..255 and alpha is number within 1..0
     *
     * @example
     * var purple = new Color.parse('purple');
     * purple.toString; // = "rgba(128,0,128,1)"
     * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
     * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
     */
    toString() {
      const [e, i, r, n] = this.rgb;
      return `rgba(${[e, i, r].map((s) => Math.round(s * 255)).join(",")},${n})`;
    }
    static interpolate(e, i, r, n = "rgb") {
      switch (n) {
        case "rgb": {
          const [s, o, a, A] = ZE(e.rgb, i.rgb, r);
          return new fi(s, o, a, A, !1);
        }
        case "hcl": {
          const [s, o, a, A] = e.hcl, [l, c, u, d] = i.hcl;
          let h, g;
          if (!isNaN(s) && !isNaN(l)) {
            let y = l - s;
            l > s && y > 180 ? y -= 360 : l < s && s - l > 180 && (y += 360), h = s + r * y;
          } else isNaN(s) ? isNaN(l) ? h = NaN : (h = l, (a === 1 || a === 0) && (g = c)) : (h = s, (u === 1 || u === 0) && (g = o));
          const [f, p, m, E] = Ide([
            h,
            g ?? Tl(o, c, r),
            Tl(a, u, r),
            Tl(A, d, r)
          ]);
          return new fi(f, p, m, E, !1);
        }
        case "lab": {
          const [s, o, a, A] = RP(ZE(e.lab, i.lab, r));
          return new fi(s, o, a, A, !1);
        }
      }
    }
  }
  fi.black = new fi(0, 0, 0, 1);
  fi.white = new fi(1, 1, 1, 1);
  fi.transparent = new fi(0, 0, 0, 0);
  fi.red = new fi(1, 0, 0, 1);
  class e1 {
    constructor(e, i, r) {
      e ? this.sensitivity = i ? "variant" : "case" : this.sensitivity = i ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
    }
    compare(e, i) {
      return this.collator.compare(e, i);
    }
    resolvedLocale() {
      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
    }
  }
  const Fde = ["bottom", "center", "top"];
  class dM {
    constructor(e, i, r, n, s, o) {
      this.text = e, this.image = i, this.scale = r, this.fontStack = n, this.textColor = s, this.verticalAlign = o;
    }
  }
  class Ca {
    constructor(e) {
      this.sections = e;
    }
    static fromString(e) {
      return new Ca([new dM(e, null, null, null, null, null)]);
    }
    isEmpty() {
      return this.sections.length === 0 ? !0 : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
    }
    static factory(e) {
      return e instanceof Ca ? e : Ca.fromString(e);
    }
    toString() {
      return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
    }
  }
  class Ls {
    constructor(e) {
      this.values = e.slice();
    }
    /**
     * Numeric padding values
     * @param input A padding value
     * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
     */
    static parse(e) {
      if (e instanceof Ls)
        return e;
      if (typeof e == "number")
        return new Ls([e, e, e, e]);
      if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
        for (const i of e)
          if (typeof i != "number")
            return;
        switch (e.length) {
          case 1:
            e = [e[0], e[0], e[0], e[0]];
            break;
          case 2:
            e = [e[0], e[1], e[0], e[1]];
            break;
          case 3:
            e = [e[0], e[1], e[2], e[1]];
            break;
        }
        return new Ls(e);
      }
    }
    toString() {
      return JSON.stringify(this.values);
    }
    static interpolate(e, i, r) {
      return new Ls(ZE(e.values, i.values, r));
    }
  }
  class Ji {
    constructor(e) {
      this.name = "ExpressionEvaluationError", this.message = e;
    }
    toJSON() {
      return this.message;
    }
  }
  const Sde = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
  class Ro {
    constructor(e) {
      this.values = e.slice();
    }
    static parse(e) {
      if (e instanceof Ro)
        return e;
      if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
        for (let i = 0; i < e.length; i += 2) {
          const r = e[i], n = e[i + 1];
          if (typeof r != "string" || !Sde.has(r) || !Array.isArray(n) || n.length !== 2 || typeof n[0] != "number" || typeof n[1] != "number")
            return;
        }
        return new Ro(e);
      }
    }
    toString() {
      return JSON.stringify(this.values);
    }
    static interpolate(e, i, r) {
      const n = e.values, s = i.values;
      if (n.length !== s.length)
        throw new Ji(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${i.toString()}`);
      const o = [];
      for (let a = 0; a < n.length; a += 2) {
        if (n[a] !== s[a])
          throw new Ji(`Cannot interpolate values containing mismatched anchors. from[${a}]: ${n[a]}, to[${a}]: ${s[a]}`);
        o.push(n[a]);
        const [A, l] = n[a + 1], [c, u] = s[a + 1];
        o.push([Tl(A, c, r), Tl(l, u, r)]);
      }
      return new Ro(o);
    }
  }
  class WA {
    constructor(e) {
      this.name = e.name, this.available = e.available;
    }
    toString() {
      return this.name;
    }
    static fromString(e) {
      return e ? new WA({ name: e, available: !1 }) : null;
    }
  }
  class Rs {
    constructor(e, i, r) {
      this.from = e, this.to = i, this.transition = r;
    }
    static interpolate(e, i, r) {
      return new Rs(e, i, r);
    }
    static parse(e) {
      if (e instanceof Rs)
        return e;
      if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number")
        return new Rs(e[0], e[1], e[2]);
      if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number")
        return new Rs(e.from, e.to, e.transition);
      if (typeof e == "string")
        return new Rs(e, e, 1);
    }
  }
  function _P(t, e, i, r) {
    return typeof t == "number" && t >= 0 && t <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? typeof r > "u" || typeof r == "number" && r >= 0 && r <= 1 ? null : `Invalid rgba value [${[t, e, i, r].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof r == "number" ? [t, e, i, r] : [t, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
  }
  function vg(t) {
    if (t === null || typeof t == "string" || typeof t == "boolean" || typeof t == "number" || t instanceof Rs || t instanceof fi || t instanceof e1 || t instanceof Ca || t instanceof Ls || t instanceof Ro || t instanceof WA)
      return !0;
    if (Array.isArray(t)) {
      for (const e of t)
        if (!vg(e))
          return !1;
      return !0;
    } else if (typeof t == "object") {
      for (const e in t)
        if (!vg(t[e]))
          return !1;
      return !0;
    } else
      return !1;
  }
  function ar(t) {
    if (t === null)
      return LB;
    if (typeof t == "string")
      return Dt;
    if (typeof t == "boolean")
      return Et;
    if (typeof t == "number")
      return xe;
    if (t instanceof fi)
      return To;
    if (t instanceof Rs)
      return zB;
    if (t instanceof e1)
      return PB;
    if (t instanceof Ca)
      return OB;
    if (t instanceof Ls)
      return GB;
    if (t instanceof Ro)
      return jB;
    if (t instanceof WA)
      return xf;
    if (Array.isArray(t)) {
      const e = t.length;
      let i;
      for (const r of t) {
        const n = ar(r);
        if (!i)
          i = n;
        else {
          if (i === n)
            continue;
          i = yt;
          break;
        }
      }
      return Yn(i || yt, e);
    } else
      return Yu;
  }
  function jh(t) {
    const e = typeof t;
    return t === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(t) : t instanceof fi || t instanceof Rs || t instanceof Ca || t instanceof Ls || t instanceof Ro || t instanceof WA ? t.toString() : JSON.stringify(t);
  }
  class gd {
    constructor(e, i) {
      this.type = e, this.value = i;
    }
    static parse(e, i) {
      if (e.length !== 2)
        return i.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
      if (!vg(e[1]))
        return i.error("invalid value");
      const r = e[1];
      let n = ar(r);
      const s = i.expectedType;
      return n.kind === "array" && n.N === 0 && s && s.kind === "array" && (typeof s.N != "number" || s.N === 0) && (n = s), new gd(n, r);
    }
    evaluate() {
      return this.value;
    }
    eachChild() {
    }
    outputDefined() {
      return !0;
    }
  }
  const Rp = {
    string: Dt,
    number: xe,
    boolean: Et,
    object: Yu
  };
  class _s {
    constructor(e, i) {
      this.type = e, this.args = i;
    }
    static parse(e, i) {
      if (e.length < 2)
        return i.error("Expected at least one argument.");
      let r = 1, n;
      const s = e[0];
      if (s === "array") {
        let a;
        if (e.length > 2) {
          const l = e[1];
          if (typeof l != "string" || !(l in Rp) || l === "object")
            return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
          a = Rp[l], r++;
        } else
          a = yt;
        let A;
        if (e.length > 3) {
          if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
            return i.error('The length argument to "array" must be a positive integer literal', 2);
          A = e[2], r++;
        }
        n = Yn(a, A);
      } else {
        if (!Rp[s])
          throw new Error(`Types doesn't contain name = ${s}`);
        n = Rp[s];
      }
      const o = [];
      for (; r < e.length; r++) {
        const a = i.parse(e[r], r, yt);
        if (!a)
          return null;
        o.push(a);
      }
      return new _s(n, o);
    }
    evaluate(e) {
      for (let i = 0; i < this.args.length; i++) {
        const r = this.args[i].evaluate(e);
        if (Ig(this.type, ar(r))) {
          if (i === this.args.length - 1)
            throw new Ji(`Expected value to be of type ${Si(this.type)}, but found ${Si(ar(r))} instead.`);
        } else return r;
      }
      throw new Error();
    }
    eachChild(e) {
      this.args.forEach(e);
    }
    outputDefined() {
      return this.args.every((e) => e.outputDefined());
    }
  }
  const SR = {
    "to-boolean": Et,
    "to-color": To,
    "to-number": xe,
    "to-string": Dt
  };
  class mA {
    constructor(e, i) {
      this.type = e, this.args = i;
    }
    static parse(e, i) {
      if (e.length < 2)
        return i.error("Expected at least one argument.");
      const r = e[0];
      if (!SR[r])
        throw new Error(`Can't parse ${r} as it is not part of the known types`);
      if ((r === "to-boolean" || r === "to-string") && e.length !== 2)
        return i.error("Expected one argument.");
      const n = SR[r], s = [];
      for (let o = 1; o < e.length; o++) {
        const a = i.parse(e[o], o, yt);
        if (!a)
          return null;
        s.push(a);
      }
      return new mA(n, s);
    }
    evaluate(e) {
      switch (this.type.kind) {
        case "boolean":
          return !!this.args[0].evaluate(e);
        case "color": {
          let i, r;
          for (const n of this.args) {
            if (i = n.evaluate(e), r = null, i instanceof fi)
              return i;
            if (typeof i == "string") {
              const s = e.parseColor(i);
              if (s)
                return s;
            } else if (Array.isArray(i) && (i.length < 3 || i.length > 4 ? r = `Invalid rgba value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : r = _P(i[0], i[1], i[2], i[3]), !r))
              return new fi(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
          }
          throw new Ji(r || `Could not parse color from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
        }
        case "padding": {
          let i;
          for (const r of this.args) {
            i = r.evaluate(e);
            const n = Ls.parse(i);
            if (n)
              return n;
          }
          throw new Ji(`Could not parse padding from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
        }
        case "variableAnchorOffsetCollection": {
          let i;
          for (const r of this.args) {
            i = r.evaluate(e);
            const n = Ro.parse(i);
            if (n)
              return n;
          }
          throw new Ji(`Could not parse variableAnchorOffsetCollection from value '${typeof i == "string" ? i : JSON.stringify(i)}'`);
        }
        case "number": {
          let i = null;
          for (const r of this.args) {
            if (i = r.evaluate(e), i === null)
              return 0;
            const n = Number(i);
            if (!isNaN(n))
              return n;
          }
          throw new Ji(`Could not convert ${JSON.stringify(i)} to number.`);
        }
        case "formatted":
          return Ca.fromString(jh(this.args[0].evaluate(e)));
        case "resolvedImage":
          return WA.fromString(jh(this.args[0].evaluate(e)));
        case "projectionDefinition":
          return this.args[0].evaluate(e);
        default:
          return jh(this.args[0].evaluate(e));
      }
    }
    eachChild(e) {
      this.args.forEach(e);
    }
    outputDefined() {
      return this.args.every((e) => e.outputDefined());
    }
  }
  const Dde = ["Unknown", "Point", "LineString", "Polygon"];
  class kP {
    constructor() {
      this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
    }
    id() {
      return this.feature && "id" in this.feature ? this.feature.id : null;
    }
    geometryType() {
      return this.feature ? typeof this.feature.type == "number" ? Dde[this.feature.type] : this.feature.type : null;
    }
    geometry() {
      return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
    }
    canonicalID() {
      return this.canonical;
    }
    properties() {
      return this.feature && this.feature.properties || {};
    }
    parseColor(e) {
      let i = this._parseColorCache[e];
      return i || (i = this._parseColorCache[e] = fi.parse(e)), i;
    }
  }
  class HB {
    constructor(e, i, r = [], n, s = new qx(), o = []) {
      this.registry = e, this.path = r, this.key = r.map((a) => `[${a}]`).join(""), this.scope = s, this.errors = o, this.expectedType = n, this._isConstant = i;
    }
    /**
     * @param expr the JSON expression to parse
     * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
     * @param options
     * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
     * @private
     */
    parse(e, i, r, n, s = {}) {
      return i ? this.concat(i, r, n)._parse(e, s) : this._parse(e, s);
    }
    _parse(e, i) {
      (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
      function r(n, s, o) {
        return o === "assert" ? new _s(s, [n]) : o === "coerce" ? new mA(s, [n]) : n;
      }
      if (Array.isArray(e)) {
        if (e.length === 0)
          return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
        const n = e[0];
        if (typeof n != "string")
          return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
        const s = this.registry[n];
        if (s) {
          let o = s.parse(e, this);
          if (!o)
            return null;
          if (this.expectedType) {
            const a = this.expectedType, A = o.type;
            if ((a.kind === "string" || a.kind === "number" || a.kind === "boolean" || a.kind === "object" || a.kind === "array") && A.kind === "value")
              o = r(o, a, i.typeAnnotation || "assert");
            else if (a.kind === "projectionDefinition" && (A.kind === "string" || A.kind === "array"))
              o = r(o, a, i.typeAnnotation || "coerce");
            else if ((a.kind === "color" || a.kind === "formatted" || a.kind === "resolvedImage") && (A.kind === "value" || A.kind === "string"))
              o = r(o, a, i.typeAnnotation || "coerce");
            else if (a.kind === "padding" && (A.kind === "value" || A.kind === "number" || A.kind === "array"))
              o = r(o, a, i.typeAnnotation || "coerce");
            else if (a.kind === "variableAnchorOffsetCollection" && (A.kind === "value" || A.kind === "array"))
              o = r(o, a, i.typeAnnotation || "coerce");
            else if (this.checkSubtype(a, A))
              return null;
          }
          if (!(o instanceof gd) && o.type.kind !== "resolvedImage" && this._isConstant(o)) {
            const a = new kP();
            try {
              o = new gd(o.type, o.evaluate(a));
            } catch (A) {
              return this.error(A.message), null;
            }
          }
          return o;
        }
        return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
      } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
    }
    /**
     * Returns a copy of this context suitable for parsing the subexpression at
     * index `index`, optionally appending to 'let' binding map.
     *
     * Note that `errors` property, intended for collecting errors while
     * parsing, is copied by reference rather than cloned.
     * @private
     */
    concat(e, i, r) {
      const n = typeof e == "number" ? this.path.concat(e) : this.path, s = r ? this.scope.concat(r) : this.scope;
      return new HB(this.registry, this._isConstant, n, i || null, s, this.errors);
    }
    /**
     * Push a parsing (or type checking) error into the `this.errors`
     * @param error The message
     * @param keys Optionally specify the source of the error at a child
     * of the current expression at `this.key`.
     * @private
     */
    error(e, ...i) {
      const r = `${this.key}${i.map((n) => `[${n}]`).join("")}`;
      this.errors.push(new Co(r, e));
    }
    /**
     * Returns null if `t` is a subtype of `expected`; otherwise returns an
     * error message and also pushes it to `this.errors`.
     * @param expected The expected type
     * @param t The actual type
     * @returns null if `t` is a subtype of `expected`; otherwise returns an error message
     */
    checkSubtype(e, i) {
      const r = Ig(e, i);
      return r && this.error(r), r;
    }
  }
  class JB {
    constructor(e, i) {
      this.type = i.type, this.bindings = [].concat(e), this.result = i;
    }
    evaluate(e) {
      return this.result.evaluate(e);
    }
    eachChild(e) {
      for (const i of this.bindings)
        e(i[1]);
      e(this.result);
    }
    static parse(e, i) {
      if (e.length < 4)
        return i.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
      const r = [];
      for (let s = 1; s < e.length - 1; s += 2) {
        const o = e[s];
        if (typeof o != "string")
          return i.error(`Expected string, but found ${typeof o} instead.`, s);
        if (/[^a-zA-Z0-9_]/.test(o))
          return i.error("Variable names must contain only alphanumeric characters or '_'.", s);
        const a = i.parse(e[s + 1], s + 1);
        if (!a)
          return null;
        r.push([o, a]);
      }
      const n = i.parse(e[e.length - 1], e.length - 1, i.expectedType, r);
      return n ? new JB(r, n) : null;
    }
    outputDefined() {
      return this.result.outputDefined();
    }
  }
  class VB {
    constructor(e, i) {
      this.type = i.type, this.name = e, this.boundExpression = i;
    }
    static parse(e, i) {
      if (e.length !== 2 || typeof e[1] != "string")
        return i.error("'var' expression requires exactly one string literal argument.");
      const r = e[1];
      return i.scope.has(r) ? new VB(r, i.scope.get(r)) : i.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
    }
    evaluate(e) {
      return this.boundExpression.evaluate(e);
    }
    eachChild() {
    }
    outputDefined() {
      return !1;
    }
  }
  class t1 {
    constructor(e, i, r) {
      this.type = e, this.index = i, this.input = r;
    }
    static parse(e, i) {
      if (e.length !== 3)
        return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
      const r = i.parse(e[1], 1, xe), n = i.parse(e[2], 2, Yn(i.expectedType || yt));
      if (!r || !n)
        return null;
      const s = n.type;
      return new t1(s.itemType, r, n);
    }
    evaluate(e) {
      const i = this.index.evaluate(e), r = this.input.evaluate(e);
      if (i < 0)
        throw new Ji(`Array index out of bounds: ${i} < 0.`);
      if (i >= r.length)
        throw new Ji(`Array index out of bounds: ${i} > ${r.length - 1}.`);
      if (i !== Math.floor(i))
        throw new Ji(`Array index must be an integer, but found ${i} instead.`);
      return r[i];
    }
    eachChild(e) {
      e(this.index), e(this.input);
    }
    outputDefined() {
      return !1;
    }
  }
  class i1 {
    constructor(e, i) {
      this.type = Et, this.needle = e, this.haystack = i;
    }
    static parse(e, i) {
      if (e.length !== 3)
        return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
      const r = i.parse(e[1], 1, yt), n = i.parse(e[2], 2, yt);
      return !r || !n ? null : $x(r.type, [Et, Dt, xe, LB, yt]) ? new i1(r, n) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Si(r.type)} instead`);
    }
    evaluate(e) {
      const i = this.needle.evaluate(e), r = this.haystack.evaluate(e);
      if (!r)
        return !1;
      if (!Dl(i, ["boolean", "string", "number", "null"]))
        throw new Ji(`Expected first argument to be of type boolean, string, number or null, but found ${Si(ar(i))} instead.`);
      if (!Dl(r, ["string", "array"]))
        throw new Ji(`Expected second argument to be of type array or string, but found ${Si(ar(r))} instead.`);
      return r.indexOf(i) >= 0;
    }
    eachChild(e) {
      e(this.needle), e(this.haystack);
    }
    outputDefined() {
      return !0;
    }
  }
  class qE {
    constructor(e, i, r) {
      this.type = xe, this.needle = e, this.haystack = i, this.fromIndex = r;
    }
    static parse(e, i) {
      if (e.length <= 2 || e.length >= 5)
        return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
      const r = i.parse(e[1], 1, yt), n = i.parse(e[2], 2, yt);
      if (!r || !n)
        return null;
      if (!$x(r.type, [Et, Dt, xe, LB, yt]))
        return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Si(r.type)} instead`);
      if (e.length === 4) {
        const s = i.parse(e[3], 3, xe);
        return s ? new qE(r, n, s) : null;
      } else
        return new qE(r, n);
    }
    evaluate(e) {
      const i = this.needle.evaluate(e), r = this.haystack.evaluate(e);
      if (!Dl(i, ["boolean", "string", "number", "null"]))
        throw new Ji(`Expected first argument to be of type boolean, string, number or null, but found ${Si(ar(i))} instead.`);
      let n;
      if (this.fromIndex && (n = this.fromIndex.evaluate(e)), Dl(r, ["string"])) {
        const s = r.indexOf(i, n);
        return s === -1 ? -1 : [...r.slice(0, s)].length;
      } else {
        if (Dl(r, ["array"]))
          return r.indexOf(i, n);
        throw new Ji(`Expected second argument to be of type array or string, but found ${Si(ar(r))} instead.`);
      }
    }
    eachChild(e) {
      e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
    }
    outputDefined() {
      return !1;
    }
  }
  class r1 {
    constructor(e, i, r, n, s, o) {
      this.inputType = e, this.type = i, this.input = r, this.cases = n, this.outputs = s, this.otherwise = o;
    }
    static parse(e, i) {
      if (e.length < 5)
        return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
      if (e.length % 2 !== 1)
        return i.error("Expected an even number of arguments.");
      let r, n;
      i.expectedType && i.expectedType.kind !== "value" && (n = i.expectedType);
      const s = {}, o = [];
      for (let l = 2; l < e.length - 1; l += 2) {
        let c = e[l];
        const u = e[l + 1];
        Array.isArray(c) || (c = [c]);
        const d = i.concat(l);
        if (c.length === 0)
          return d.error("Expected at least one branch label.");
        for (const g of c) {
          if (typeof g != "number" && typeof g != "string")
            return d.error("Branch labels must be numbers or strings.");
          if (typeof g == "number" && Math.abs(g) > Number.MAX_SAFE_INTEGER)
            return d.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
          if (typeof g == "number" && Math.floor(g) !== g)
            return d.error("Numeric branch labels must be integer values.");
          if (!r)
            r = ar(g);
          else if (d.checkSubtype(r, ar(g)))
            return null;
          if (typeof s[String(g)] < "u")
            return d.error("Branch labels must be unique.");
          s[String(g)] = o.length;
        }
        const h = i.parse(u, l, n);
        if (!h)
          return null;
        n = n || h.type, o.push(h);
      }
      const a = i.parse(e[1], 1, yt);
      if (!a)
        return null;
      const A = i.parse(e[e.length - 1], e.length - 1, n);
      return !A || a.type.kind !== "value" && i.concat(1).checkSubtype(r, a.type) ? null : new r1(r, n, a, s, o, A);
    }
    evaluate(e) {
      const i = this.input.evaluate(e);
      return (ar(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(e);
    }
    eachChild(e) {
      e(this.input), this.outputs.forEach(e), e(this.otherwise);
    }
    outputDefined() {
      return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
    }
  }
  class n1 {
    constructor(e, i, r) {
      this.type = e, this.branches = i, this.otherwise = r;
    }
    static parse(e, i) {
      if (e.length < 4)
        return i.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
      if (e.length % 2 !== 0)
        return i.error("Expected an odd number of arguments.");
      let r;
      i.expectedType && i.expectedType.kind !== "value" && (r = i.expectedType);
      const n = [];
      for (let o = 1; o < e.length - 1; o += 2) {
        const a = i.parse(e[o], o, Et);
        if (!a)
          return null;
        const A = i.parse(e[o + 1], o + 1, r);
        if (!A)
          return null;
        n.push([a, A]), r = r || A.type;
      }
      const s = i.parse(e[e.length - 1], e.length - 1, r);
      if (!s)
        return null;
      if (!r)
        throw new Error("Can't infer output type");
      return new n1(r, n, s);
    }
    evaluate(e) {
      for (const [i, r] of this.branches)
        if (i.evaluate(e))
          return r.evaluate(e);
      return this.otherwise.evaluate(e);
    }
    eachChild(e) {
      for (const [i, r] of this.branches)
        e(i), e(r);
      e(this.otherwise);
    }
    outputDefined() {
      return this.branches.every(([e, i]) => i.outputDefined()) && this.otherwise.outputDefined();
    }
  }
  class $E {
    constructor(e, i, r, n) {
      this.type = e, this.input = i, this.beginIndex = r, this.endIndex = n;
    }
    static parse(e, i) {
      if (e.length <= 2 || e.length >= 5)
        return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
      const r = i.parse(e[1], 1, yt), n = i.parse(e[2], 2, xe);
      if (!r || !n)
        return null;
      if (!$x(r.type, [Yn(yt), Dt, yt]))
        return i.error(`Expected first argument to be of type array or string, but found ${Si(r.type)} instead`);
      if (e.length === 4) {
        const s = i.parse(e[3], 3, xe);
        return s ? new $E(r.type, r, n, s) : null;
      } else
        return new $E(r.type, r, n);
    }
    evaluate(e) {
      const i = this.input.evaluate(e), r = this.beginIndex.evaluate(e);
      let n;
      if (this.endIndex && (n = this.endIndex.evaluate(e)), Dl(i, ["string"]))
        return [...i].slice(r, n).join("");
      if (Dl(i, ["array"]))
        return i.slice(r, n);
      throw new Ji(`Expected first argument to be of type array or string, but found ${Si(ar(i))} instead.`);
    }
    eachChild(e) {
      e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
    }
    outputDefined() {
      return !1;
    }
  }
  function YP(t, e) {
    const i = t.length - 1;
    let r = 0, n = i, s = 0, o, a;
    for (; r <= n; )
      if (s = Math.floor((r + n) / 2), o = t[s], a = t[s + 1], o <= e) {
        if (s === i || e < a)
          return s;
        r = s + 1;
      } else if (o > e)
        n = s - 1;
      else
        throw new Ji("Input is not a number.");
    return 0;
  }
  class WB {
    constructor(e, i, r) {
      this.type = e, this.input = i, this.labels = [], this.outputs = [];
      for (const [n, s] of r)
        this.labels.push(n), this.outputs.push(s);
    }
    static parse(e, i) {
      if (e.length - 1 < 4)
        return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
      if ((e.length - 1) % 2 !== 0)
        return i.error("Expected an even number of arguments.");
      const r = i.parse(e[1], 1, xe);
      if (!r)
        return null;
      const n = [];
      let s = null;
      i.expectedType && i.expectedType.kind !== "value" && (s = i.expectedType);
      for (let o = 1; o < e.length; o += 2) {
        const a = o === 1 ? -1 / 0 : e[o], A = e[o + 1], l = o, c = o + 1;
        if (typeof a != "number")
          return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', l);
        if (n.length && n[n.length - 1][0] >= a)
          return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', l);
        const u = i.parse(A, c, s);
        if (!u)
          return null;
        s = s || u.type, n.push([a, u]);
      }
      return new WB(s, r, n);
    }
    evaluate(e) {
      const i = this.labels, r = this.outputs;
      if (i.length === 1)
        return r[0].evaluate(e);
      const n = this.input.evaluate(e);
      if (n <= i[0])
        return r[0].evaluate(e);
      const s = i.length;
      if (n >= i[s - 1])
        return r[s - 1].evaluate(e);
      const o = YP(i, n);
      return r[o].evaluate(e);
    }
    eachChild(e) {
      e(this.input);
      for (const i of this.outputs)
        e(i);
    }
    outputDefined() {
      return this.outputs.every((e) => e.outputDefined());
    }
  }
  function Tde(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  var uC, DR;
  function Rde() {
    if (DR) return uC;
    DR = 1, uC = t;
    function t(e, i, r, n) {
      this.cx = 3 * e, this.bx = 3 * (r - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (n - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = i, this.p2x = r, this.p2y = n;
    }
    return t.prototype = {
      sampleCurveX: function(e) {
        return ((this.ax * e + this.bx) * e + this.cx) * e;
      },
      sampleCurveY: function(e) {
        return ((this.ay * e + this.by) * e + this.cy) * e;
      },
      sampleCurveDerivativeX: function(e) {
        return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
      },
      solveCurveX: function(e, i) {
        if (i === void 0 && (i = 1e-6), e < 0) return 0;
        if (e > 1) return 1;
        for (var r = e, n = 0; n < 8; n++) {
          var s = this.sampleCurveX(r) - e;
          if (Math.abs(s) < i) return r;
          var o = this.sampleCurveDerivativeX(r);
          if (Math.abs(o) < 1e-6) break;
          r = r - s / o;
        }
        var a = 0, A = 1;
        for (r = e, n = 0; n < 20 && (s = this.sampleCurveX(r), !(Math.abs(s - e) < i)); n++)
          e > s ? a = r : A = r, r = (A - a) * 0.5 + a;
        return r;
      },
      solve: function(e, i) {
        return this.sampleCurveY(this.solveCurveX(e, i));
      }
    }, uC;
  }
  var _de = Rde(), kde = /* @__PURE__ */ Tde(_de);
  class _o {
    constructor(e, i, r, n, s) {
      this.type = e, this.operator = i, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];
      for (const [o, a] of s)
        this.labels.push(o), this.outputs.push(a);
    }
    static interpolationFactor(e, i, r, n) {
      let s = 0;
      if (e.name === "exponential")
        s = dC(i, e.base, r, n);
      else if (e.name === "linear")
        s = dC(i, 1, r, n);
      else if (e.name === "cubic-bezier") {
        const o = e.controlPoints;
        s = new kde(o[0], o[1], o[2], o[3]).solve(dC(i, 1, r, n));
      }
      return s;
    }
    static parse(e, i) {
      let [r, n, s, ...o] = e;
      if (!Array.isArray(n) || n.length === 0)
        return i.error("Expected an interpolation type expression.", 1);
      if (n[0] === "linear")
        n = { name: "linear" };
      else if (n[0] === "exponential") {
        const l = n[1];
        if (typeof l != "number")
          return i.error("Exponential interpolation requires a numeric base.", 1, 1);
        n = {
          name: "exponential",
          base: l
        };
      } else if (n[0] === "cubic-bezier") {
        const l = n.slice(1);
        if (l.length !== 4 || l.some((c) => typeof c != "number" || c < 0 || c > 1))
          return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
        n = {
          name: "cubic-bezier",
          controlPoints: l
        };
      } else
        return i.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
      if (e.length - 1 < 4)
        return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
      if ((e.length - 1) % 2 !== 0)
        return i.error("Expected an even number of arguments.");
      if (s = i.parse(s, 2, xe), !s)
        return null;
      const a = [];
      let A = null;
      r === "interpolate-hcl" || r === "interpolate-lab" ? A = To : i.expectedType && i.expectedType.kind !== "value" && (A = i.expectedType);
      for (let l = 0; l < o.length; l += 2) {
        const c = o[l], u = o[l + 1], d = l + 3, h = l + 4;
        if (typeof c != "number")
          return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', d);
        if (a.length && a[a.length - 1][0] >= c)
          return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', d);
        const g = i.parse(u, h, A);
        if (!g)
          return null;
        A = A || g.type, a.push([c, g]);
      }
      return !Uc(A, xe) && !Uc(A, zB) && !Uc(A, To) && !Uc(A, GB) && !Uc(A, jB) && !Uc(A, Yn(xe)) ? i.error(`Type ${Si(A)} is not interpolatable.`) : new _o(A, r, n, s, a);
    }
    evaluate(e) {
      const i = this.labels, r = this.outputs;
      if (i.length === 1)
        return r[0].evaluate(e);
      const n = this.input.evaluate(e);
      if (n <= i[0])
        return r[0].evaluate(e);
      const s = i.length;
      if (n >= i[s - 1])
        return r[s - 1].evaluate(e);
      const o = YP(i, n), a = i[o], A = i[o + 1], l = _o.interpolationFactor(this.interpolation, n, a, A), c = r[o].evaluate(e), u = r[o + 1].evaluate(e);
      switch (this.operator) {
        case "interpolate":
          switch (this.type.kind) {
            case "number":
              return Tl(c, u, l);
            case "color":
              return fi.interpolate(c, u, l);
            case "padding":
              return Ls.interpolate(c, u, l);
            case "variableAnchorOffsetCollection":
              return Ro.interpolate(c, u, l);
            case "array":
              return ZE(c, u, l);
            case "projectionDefinition":
              return Rs.interpolate(c, u, l);
          }
        case "interpolate-hcl":
          return fi.interpolate(c, u, l, "hcl");
        case "interpolate-lab":
          return fi.interpolate(c, u, l, "lab");
      }
    }
    eachChild(e) {
      e(this.input);
      for (const i of this.outputs)
        e(i);
    }
    outputDefined() {
      return this.outputs.every((e) => e.outputDefined());
    }
  }
  function dC(t, e, i, r) {
    const n = r - i, s = t - i;
    return n === 0 ? 0 : e === 1 ? s / n : (Math.pow(e, s) - 1) / (Math.pow(e, n) - 1);
  }
  class xg {
    constructor(e, i) {
      this.type = e, this.args = i;
    }
    static parse(e, i) {
      if (e.length < 2)
        return i.error("Expected at least one argument.");
      let r = null;
      const n = i.expectedType;
      n && n.kind !== "value" && (r = n);
      const s = [];
      for (const a of e.slice(1)) {
        const A = i.parse(a, 1 + s.length, r, void 0, { typeAnnotation: "omit" });
        if (!A)
          return null;
        r = r || A.type, s.push(A);
      }
      if (!r)
        throw new Error("No output type");
      return n && s.some((a) => Ig(n, a.type)) ? new xg(yt, s) : new xg(r, s);
    }
    evaluate(e) {
      let i = null, r = 0, n;
      for (const s of this.args)
        if (r++, i = s.evaluate(e), i && i instanceof WA && !i.available && (n || (n = i.name), i = null, r === this.args.length && (i = n)), i !== null)
          break;
      return i;
    }
    eachChild(e) {
      this.args.forEach(e);
    }
    outputDefined() {
      return this.args.every((e) => e.outputDefined());
    }
  }
  function TR(t, e) {
    return t === "==" || t === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
  }
  function Yde(t, e, i) {
    return e === i;
  }
  function Nde(t, e, i) {
    return e !== i;
  }
  function Ude(t, e, i) {
    return e < i;
  }
  function Lde(t, e, i) {
    return e > i;
  }
  function zde(t, e, i) {
    return e <= i;
  }
  function Pde(t, e, i) {
    return e >= i;
  }
  function NP(t, e, i, r) {
    return r.compare(e, i) === 0;
  }
  function Ode(t, e, i, r) {
    return !NP(t, e, i, r);
  }
  function Gde(t, e, i, r) {
    return r.compare(e, i) < 0;
  }
  function jde(t, e, i, r) {
    return r.compare(e, i) > 0;
  }
  function Hde(t, e, i, r) {
    return r.compare(e, i) <= 0;
  }
  function Jde(t, e, i, r) {
    return r.compare(e, i) >= 0;
  }
  function jd(t, e, i) {
    const r = t !== "==" && t !== "!=";
    return class UP {
      constructor(s, o, a) {
        this.type = Et, this.lhs = s, this.rhs = o, this.collator = a, this.hasUntypedArgument = s.type.kind === "value" || o.type.kind === "value";
      }
      static parse(s, o) {
        if (s.length !== 3 && s.length !== 4)
          return o.error("Expected two or three arguments.");
        const a = s[0];
        let A = o.parse(s[1], 1, yt);
        if (!A)
          return null;
        if (!TR(a, A.type))
          return o.concat(1).error(`"${a}" comparisons are not supported for type '${Si(A.type)}'.`);
        let l = o.parse(s[2], 2, yt);
        if (!l)
          return null;
        if (!TR(a, l.type))
          return o.concat(2).error(`"${a}" comparisons are not supported for type '${Si(l.type)}'.`);
        if (A.type.kind !== l.type.kind && A.type.kind !== "value" && l.type.kind !== "value")
          return o.error(`Cannot compare types '${Si(A.type)}' and '${Si(l.type)}'.`);
        r && (A.type.kind === "value" && l.type.kind !== "value" ? A = new _s(l.type, [A]) : A.type.kind !== "value" && l.type.kind === "value" && (l = new _s(A.type, [l])));
        let c = null;
        if (s.length === 4) {
          if (A.type.kind !== "string" && l.type.kind !== "string" && A.type.kind !== "value" && l.type.kind !== "value")
            return o.error("Cannot use collator to compare non-string types.");
          if (c = o.parse(s[3], 3, PB), !c)
            return null;
        }
        return new UP(A, l, c);
      }
      evaluate(s) {
        const o = this.lhs.evaluate(s), a = this.rhs.evaluate(s);
        if (r && this.hasUntypedArgument) {
          const A = ar(o), l = ar(a);
          if (A.kind !== l.kind || !(A.kind === "string" || A.kind === "number"))
            throw new Ji(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${A.kind}, ${l.kind}) instead.`);
        }
        if (this.collator && !r && this.hasUntypedArgument) {
          const A = ar(o), l = ar(a);
          if (A.kind !== "string" || l.kind !== "string")
            return e(s, o, a);
        }
        return this.collator ? i(s, o, a, this.collator.evaluate(s)) : e(s, o, a);
      }
      eachChild(s) {
        s(this.lhs), s(this.rhs), this.collator && s(this.collator);
      }
      outputDefined() {
        return !0;
      }
    };
  }
  const Vde = jd("==", Yde, NP), Wde = jd("!=", Nde, Ode), Kde = jd("<", Ude, Gde), Xde = jd(">", Lde, jde), Zde = jd("<=", zde, Hde), qde = jd(">=", Pde, Jde);
  class KB {
    constructor(e, i, r) {
      this.type = PB, this.locale = r, this.caseSensitive = e, this.diacriticSensitive = i;
    }
    static parse(e, i) {
      if (e.length !== 2)
        return i.error("Expected one argument.");
      const r = e[1];
      if (typeof r != "object" || Array.isArray(r))
        return i.error("Collator options argument must be an object.");
      const n = i.parse(r["case-sensitive"] === void 0 ? !1 : r["case-sensitive"], 1, Et);
      if (!n)
        return null;
      const s = i.parse(r["diacritic-sensitive"] === void 0 ? !1 : r["diacritic-sensitive"], 1, Et);
      if (!s)
        return null;
      let o = null;
      return r.locale && (o = i.parse(r.locale, 1, Dt), !o) ? null : new KB(n, s, o);
    }
    evaluate(e) {
      return new e1(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
    }
    eachChild(e) {
      e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
    }
    outputDefined() {
      return !1;
    }
  }
  class s1 {
    constructor(e, i, r, n, s) {
      this.type = Dt, this.number = e, this.locale = i, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = s;
    }
    static parse(e, i) {
      if (e.length !== 3)
        return i.error("Expected two arguments.");
      const r = i.parse(e[1], 1, xe);
      if (!r)
        return null;
      const n = e[2];
      if (typeof n != "object" || Array.isArray(n))
        return i.error("NumberFormat options argument must be an object.");
      let s = null;
      if (n.locale && (s = i.parse(n.locale, 1, Dt), !s))
        return null;
      let o = null;
      if (n.currency && (o = i.parse(n.currency, 1, Dt), !o))
        return null;
      let a = null;
      if (n["min-fraction-digits"] && (a = i.parse(n["min-fraction-digits"], 1, xe), !a))
        return null;
      let A = null;
      return n["max-fraction-digits"] && (A = i.parse(n["max-fraction-digits"], 1, xe), !A) ? null : new s1(r, s, o, a, A);
    }
    evaluate(e) {
      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
        style: this.currency ? "currency" : "decimal",
        currency: this.currency ? this.currency.evaluate(e) : void 0,
        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
      }).format(this.number.evaluate(e));
    }
    eachChild(e) {
      e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
    }
    outputDefined() {
      return !1;
    }
  }
  class o1 {
    constructor(e) {
      this.type = OB, this.sections = e;
    }
    static parse(e, i) {
      if (e.length < 2)
        return i.error("Expected at least one argument.");
      const r = e[1];
      if (!Array.isArray(r) && typeof r == "object")
        return i.error("First argument must be an image or text section.");
      const n = [];
      let s = !1;
      for (let o = 1; o <= e.length - 1; ++o) {
        const a = e[o];
        if (s && typeof a == "object" && !Array.isArray(a)) {
          s = !1;
          let A = null;
          if (a["font-scale"] && (A = i.parse(a["font-scale"], 1, xe), !A))
            return null;
          let l = null;
          if (a["text-font"] && (l = i.parse(a["text-font"], 1, Yn(Dt)), !l))
            return null;
          let c = null;
          if (a["text-color"] && (c = i.parse(a["text-color"], 1, To), !c))
            return null;
          let u = null;
          if (a["vertical-align"]) {
            if (typeof a["vertical-align"] == "string" && !Fde.includes(a["vertical-align"]))
              return i.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${a["vertical-align"]}' instead.`);
            if (u = i.parse(a["vertical-align"], 1, Dt), !u)
              return null;
          }
          const d = n[n.length - 1];
          d.scale = A, d.font = l, d.textColor = c, d.verticalAlign = u;
        } else {
          const A = i.parse(e[o], 1, yt);
          if (!A)
            return null;
          const l = A.type.kind;
          if (l !== "string" && l !== "value" && l !== "null" && l !== "resolvedImage")
            return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
          s = !0, n.push({ content: A, scale: null, font: null, textColor: null, verticalAlign: null });
        }
      }
      return new o1(n);
    }
    evaluate(e) {
      const i = (r) => {
        const n = r.content.evaluate(e);
        return ar(n) === xf ? new dM("", n, null, null, null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null) : new dM(jh(n), null, r.scale ? r.scale.evaluate(e) : null, r.font ? r.font.evaluate(e).join(",") : null, r.textColor ? r.textColor.evaluate(e) : null, r.verticalAlign ? r.verticalAlign.evaluate(e) : null);
      };
      return new Ca(this.sections.map(i));
    }
    eachChild(e) {
      for (const i of this.sections)
        e(i.content), i.scale && e(i.scale), i.font && e(i.font), i.textColor && e(i.textColor), i.verticalAlign && e(i.verticalAlign);
    }
    outputDefined() {
      return !1;
    }
  }
  class a1 {
    constructor(e) {
      this.type = xf, this.input = e;
    }
    static parse(e, i) {
      if (e.length !== 2)
        return i.error("Expected two arguments.");
      const r = i.parse(e[1], 1, Dt);
      return r ? new a1(r) : i.error("No image name provided.");
    }
    evaluate(e) {
      const i = this.input.evaluate(e), r = WA.fromString(i);
      return r && e.availableImages && (r.available = e.availableImages.indexOf(i) > -1), r;
    }
    eachChild(e) {
      e(this.input);
    }
    outputDefined() {
      return !1;
    }
  }
  class A1 {
    constructor(e) {
      this.type = xe, this.input = e;
    }
    static parse(e, i) {
      if (e.length !== 2)
        return i.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
      const r = i.parse(e[1], 1);
      return r ? r.type.kind !== "array" && r.type.kind !== "string" && r.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${Si(r.type)} instead.`) : new A1(r) : null;
    }
    evaluate(e) {
      const i = this.input.evaluate(e);
      if (typeof i == "string")
        return [...i].length;
      if (Array.isArray(i))
        return i.length;
      throw new Ji(`Expected value to be of type string or array, but found ${Si(ar(i))} instead.`);
    }
    eachChild(e) {
      e(this.input);
    }
    outputDefined() {
      return !1;
    }
  }
  const ko = 8192;
  function $de(t, e) {
    const i = ehe(t[0]), r = ihe(t[1]), n = Math.pow(2, e.z);
    return [Math.round(i * n * ko), Math.round(r * n * ko)];
  }
  function l1(t, e) {
    const i = Math.pow(2, e.z), r = (t[0] / ko + e.x) / i, n = (t[1] / ko + e.y) / i;
    return [the(r), rhe(n)];
  }
  function ehe(t) {
    return (180 + t) / 360;
  }
  function the(t) {
    return t * 360 - 180;
  }
  function ihe(t) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;
  }
  function rhe(t) {
    return 360 / Math.PI * Math.atan(Math.exp((180 - t * 360) * Math.PI / 180)) - 90;
  }
  function Qf(t, e) {
    t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);
  }
  function Qg(t, e) {
    return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);
  }
  function nhe(t, e, i) {
    return e[1] > t[1] != i[1] > t[1] && t[0] < (i[0] - e[0]) * (t[1] - e[1]) / (i[1] - e[1]) + e[0];
  }
  function she(t, e, i) {
    const r = t[0] - e[0], n = t[1] - e[1], s = t[0] - i[0], o = t[1] - i[1];
    return r * o - s * n === 0 && r * s <= 0 && n * o <= 0;
  }
  function XB(t, e, i, r) {
    const n = [e[0] - t[0], e[1] - t[1]], s = [r[0] - i[0], r[1] - i[1]];
    return lhe(s, n) === 0 ? !1 : !!(RR(t, e, i, r) && RR(i, r, t, e));
  }
  function ohe(t, e, i) {
    for (const r of i)
      for (let n = 0; n < r.length - 1; ++n)
        if (XB(t, e, r[n], r[n + 1]))
          return !0;
    return !1;
  }
  function Hd(t, e, i = !1) {
    let r = !1;
    for (const n of e)
      for (let s = 0; s < n.length - 1; s++) {
        if (she(t, n[s], n[s + 1]))
          return i;
        nhe(t, n[s], n[s + 1]) && (r = !r);
      }
    return r;
  }
  function ahe(t, e) {
    for (const i of e)
      if (Hd(t, i))
        return !0;
    return !1;
  }
  function LP(t, e) {
    for (const i of t)
      if (!Hd(i, e))
        return !1;
    for (let i = 0; i < t.length - 1; ++i)
      if (ohe(t[i], t[i + 1], e))
        return !1;
    return !0;
  }
  function Ahe(t, e) {
    for (const i of e)
      if (LP(t, i))
        return !0;
    return !1;
  }
  function lhe(t, e) {
    return t[0] * e[1] - t[1] * e[0];
  }
  function RR(t, e, i, r) {
    const n = t[0] - i[0], s = t[1] - i[1], o = e[0] - i[0], a = e[1] - i[1], A = r[0] - i[0], l = r[1] - i[1], c = n * l - A * s, u = o * l - A * a;
    return c > 0 && u < 0 || c < 0 && u > 0;
  }
  function c1(t, e, i) {
    const r = [];
    for (let n = 0; n < t.length; n++) {
      const s = [];
      for (let o = 0; o < t[n].length; o++) {
        const a = $de(t[n][o], i);
        Qf(e, a), s.push(a);
      }
      r.push(s);
    }
    return r;
  }
  function zP(t, e, i) {
    const r = [];
    for (let n = 0; n < t.length; n++) {
      const s = c1(t[n], e, i);
      r.push(s);
    }
    return r;
  }
  function PP(t, e, i, r) {
    if (t[0] < i[0] || t[0] > i[2]) {
      const n = r * 0.5;
      let s = t[0] - i[0] > n ? -r : i[0] - t[0] > n ? r : 0;
      s === 0 && (s = t[0] - i[2] > n ? -r : i[2] - t[0] > n ? r : 0), t[0] += s;
    }
    Qf(e, t);
  }
  function che(t) {
    t[0] = t[1] = 1 / 0, t[2] = t[3] = -1 / 0;
  }
  function _R(t, e, i, r) {
    const n = Math.pow(2, r.z) * ko, s = [r.x * ko, r.y * ko], o = [];
    for (const a of t)
      for (const A of a) {
        const l = [A.x + s[0], A.y + s[1]];
        PP(l, e, i, n), o.push(l);
      }
    return o;
  }
  function kR(t, e, i, r) {
    const n = Math.pow(2, r.z) * ko, s = [r.x * ko, r.y * ko], o = [];
    for (const a of t) {
      const A = [];
      for (const l of a) {
        const c = [l.x + s[0], l.y + s[1]];
        Qf(e, c), A.push(c);
      }
      o.push(A);
    }
    if (e[2] - e[0] <= n / 2) {
      che(e);
      for (const a of o)
        for (const A of a)
          PP(A, e, i, n);
    }
    return o;
  }
  function uhe(t, e) {
    const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = t.canonicalID();
    if (e.type === "Polygon") {
      const s = c1(e.coordinates, r, n), o = _R(t.geometry(), i, r, n);
      if (!Qg(i, r))
        return !1;
      for (const a of o)
        if (!Hd(a, s))
          return !1;
    }
    if (e.type === "MultiPolygon") {
      const s = zP(e.coordinates, r, n), o = _R(t.geometry(), i, r, n);
      if (!Qg(i, r))
        return !1;
      for (const a of o)
        if (!ahe(a, s))
          return !1;
    }
    return !0;
  }
  function dhe(t, e) {
    const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = t.canonicalID();
    if (e.type === "Polygon") {
      const s = c1(e.coordinates, r, n), o = kR(t.geometry(), i, r, n);
      if (!Qg(i, r))
        return !1;
      for (const a of o)
        if (!LP(a, s))
          return !1;
    }
    if (e.type === "MultiPolygon") {
      const s = zP(e.coordinates, r, n), o = kR(t.geometry(), i, r, n);
      if (!Qg(i, r))
        return !1;
      for (const a of o)
        if (!Ahe(a, s))
          return !1;
    }
    return !0;
  }
  class Rl {
    constructor(e, i) {
      this.type = Et, this.geojson = e, this.geometries = i;
    }
    static parse(e, i) {
      if (e.length !== 2)
        return i.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
      if (vg(e[1])) {
        const r = e[1];
        if (r.type === "FeatureCollection") {
          const n = [];
          for (const s of r.features) {
            const { type: o, coordinates: a } = s.geometry;
            o === "Polygon" && n.push(a), o === "MultiPolygon" && n.push(...a);
          }
          if (n.length) {
            const s = {
              type: "MultiPolygon",
              coordinates: n
            };
            return new Rl(r, s);
          }
        } else if (r.type === "Feature") {
          const n = r.geometry.type;
          if (n === "Polygon" || n === "MultiPolygon")
            return new Rl(r, r.geometry);
        } else if (r.type === "Polygon" || r.type === "MultiPolygon")
          return new Rl(r, r);
      }
      return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
    }
    evaluate(e) {
      if (e.geometry() != null && e.canonicalID() != null) {
        if (e.geometryType() === "Point")
          return uhe(e, this.geometries);
        if (e.geometryType() === "LineString")
          return dhe(e, this.geometries);
      }
      return !1;
    }
    eachChild() {
    }
    outputDefined() {
      return !0;
    }
  }
  class OP {
    constructor(e = [], i = (r, n) => r < n ? -1 : r > n ? 1 : 0) {
      if (this.data = e, this.length = this.data.length, this.compare = i, this.length > 0)
        for (let r = (this.length >> 1) - 1; r >= 0; r--) this._down(r);
    }
    push(e) {
      this.data.push(e), this._up(this.length++);
    }
    pop() {
      if (this.length === 0) return;
      const e = this.data[0], i = this.data.pop();
      return --this.length > 0 && (this.data[0] = i, this._down(0)), e;
    }
    peek() {
      return this.data[0];
    }
    _up(e) {
      const { data: i, compare: r } = this, n = i[e];
      for (; e > 0; ) {
        const s = e - 1 >> 1, o = i[s];
        if (r(n, o) >= 0) break;
        i[e] = o, e = s;
      }
      i[e] = n;
    }
    _down(e) {
      const { data: i, compare: r } = this, n = this.length >> 1, s = i[e];
      for (; e < n; ) {
        let o = (e << 1) + 1;
        const a = o + 1;
        if (a < this.length && r(i[a], i[o]) < 0 && (o = a), r(i[o], s) >= 0) break;
        i[e] = i[o], e = o;
      }
      i[e] = s;
    }
  }
  function hhe(t, e) {
    if (t.length <= 1)
      return [t];
    const r = [];
    let n, s;
    for (const o of t) {
      const a = ghe(o);
      a !== 0 && (o.area = Math.abs(a), s === void 0 && (s = a < 0), s === a < 0 ? (n && r.push(n), n = [o]) : n.push(o));
    }
    return n && r.push(n), r;
  }
  function ghe(t) {
    let e = 0;
    for (let i = 0, r = t.length, n = r - 1, s, o; i < r; n = i++)
      s = t[i], o = t[n], e += (o.x - s.x) * (s.y + o.y);
    return e;
  }
  const fhe = 6378.137, YR = 1 / 298.257223563, NR = YR * (2 - YR), UR = Math.PI / 180;
  class u1 {
    constructor(e) {
      const i = UR * fhe * 1e3, r = Math.cos(e * UR), n = 1 / (1 - NR * (1 - r * r)), s = Math.sqrt(n);
      this.kx = i * s * r, this.ky = i * s * n * (1 - NR);
    }
    /**
     * Given two points of the form [longitude, latitude], returns the distance.
     *
     * @param a - point [longitude, latitude]
     * @param b - point [longitude, latitude]
     * @returns distance
     * @example
     * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
     * //=distance
     */
    distance(e, i) {
      const r = this.wrap(e[0] - i[0]) * this.kx, n = (e[1] - i[1]) * this.ky;
      return Math.sqrt(r * r + n * n);
    }
    /**
     * Returns an object of the form {point, index, t}, where point is closest point on the line
     * from the given point, index is the start index of the segment with the closest point,
     * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
     *
     * @param line - an array of points that form the line
     * @param p - point [longitude, latitude]
     * @returns the nearest point, its index in the array and the proportion along the line
     * @example
     * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
     * //=point
     */
    pointOnLine(e, i) {
      let r = 1 / 0, n, s, o, a;
      for (let A = 0; A < e.length - 1; A++) {
        let l = e[A][0], c = e[A][1], u = this.wrap(e[A + 1][0] - l) * this.kx, d = (e[A + 1][1] - c) * this.ky, h = 0;
        (u !== 0 || d !== 0) && (h = (this.wrap(i[0] - l) * this.kx * u + (i[1] - c) * this.ky * d) / (u * u + d * d), h > 1 ? (l = e[A + 1][0], c = e[A + 1][1]) : h > 0 && (l += u / this.kx * h, c += d / this.ky * h)), u = this.wrap(i[0] - l) * this.kx, d = (i[1] - c) * this.ky;
        const g = u * u + d * d;
        g < r && (r = g, n = l, s = c, o = A, a = h);
      }
      return {
        point: [n, s],
        index: o,
        t: Math.max(0, Math.min(1, a))
      };
    }
    wrap(e) {
      for (; e < -180; )
        e += 360;
      for (; e > 180; )
        e -= 360;
      return e;
    }
  }
  const hM = 100, gM = 50;
  function GP(t, e) {
    return e[0] - t[0];
  }
  function ey(t) {
    return t[1] - t[0] + 1;
  }
  function _a(t, e) {
    return t[1] >= t[0] && t[1] < e;
  }
  function fM(t, e) {
    if (t[0] > t[1])
      return [null, null];
    const i = ey(t);
    if (e) {
      if (i === 2)
        return [t, null];
      const n = Math.floor(i / 2);
      return [
        [t[0], t[0] + n],
        [t[0] + n, t[1]]
      ];
    }
    if (i === 1)
      return [t, null];
    const r = Math.floor(i / 2) - 1;
    return [
      [t[0], t[0] + r],
      [t[0] + r + 1, t[1]]
    ];
  }
  function pM(t, e) {
    if (!_a(e, t.length))
      return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    for (let r = e[0]; r <= e[1]; ++r)
      Qf(i, t[r]);
    return i;
  }
  function mM(t) {
    const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    for (const i of t)
      for (const r of i)
        Qf(e, r);
    return e;
  }
  function LR(t) {
    return t[0] !== -1 / 0 && t[1] !== -1 / 0 && t[2] !== 1 / 0 && t[3] !== 1 / 0;
  }
  function d1(t, e, i) {
    if (!LR(t) || !LR(e))
      return NaN;
    let r = 0, n = 0;
    return t[2] < e[0] && (r = e[0] - t[2]), t[0] > e[2] && (r = t[0] - e[2]), t[1] > e[3] && (n = t[1] - e[3]), t[3] < e[1] && (n = e[1] - t[3]), i.distance([0, 0], [r, n]);
  }
  function bl(t, e, i) {
    const r = i.pointOnLine(e, t);
    return i.distance(t, r.point);
  }
  function h1(t, e, i, r, n) {
    const s = Math.min(bl(t, [i, r], n), bl(e, [i, r], n)), o = Math.min(bl(i, [t, e], n), bl(r, [t, e], n));
    return Math.min(s, o);
  }
  function phe(t, e, i, r, n) {
    if (!(_a(e, t.length) && _a(r, i.length)))
      return 1 / 0;
    let o = 1 / 0;
    for (let a = e[0]; a < e[1]; ++a) {
      const A = t[a], l = t[a + 1];
      for (let c = r[0]; c < r[1]; ++c) {
        const u = i[c], d = i[c + 1];
        if (XB(A, l, u, d))
          return 0;
        o = Math.min(o, h1(A, l, u, d, n));
      }
    }
    return o;
  }
  function mhe(t, e, i, r, n) {
    if (!(_a(e, t.length) && _a(r, i.length)))
      return NaN;
    let o = 1 / 0;
    for (let a = e[0]; a <= e[1]; ++a)
      for (let A = r[0]; A <= r[1]; ++A)
        if (o = Math.min(o, n.distance(t[a], i[A])), o === 0)
          return o;
    return o;
  }
  function Ehe(t, e, i) {
    if (Hd(t, e, !0))
      return 0;
    let r = 1 / 0;
    for (const n of e) {
      const s = n[0], o = n[n.length - 1];
      if (s !== o && (r = Math.min(r, bl(t, [o, s], i)), r === 0))
        return r;
      const a = i.pointOnLine(n, t);
      if (r = Math.min(r, i.distance(t, a.point)), r === 0)
        return r;
    }
    return r;
  }
  function yhe(t, e, i, r) {
    if (!_a(e, t.length))
      return NaN;
    for (let s = e[0]; s <= e[1]; ++s)
      if (Hd(t[s], i, !0))
        return 0;
    let n = 1 / 0;
    for (let s = e[0]; s < e[1]; ++s) {
      const o = t[s], a = t[s + 1];
      for (const A of i)
        for (let l = 0, c = A.length, u = c - 1; l < c; u = l++) {
          const d = A[u], h = A[l];
          if (XB(o, a, d, h))
            return 0;
          n = Math.min(n, h1(o, a, d, h, r));
        }
    }
    return n;
  }
  function zR(t, e) {
    for (const i of t)
      for (const r of i)
        if (Hd(r, e, !0))
          return !0;
    return !1;
  }
  function Bhe(t, e, i, r = 1 / 0) {
    const n = mM(t), s = mM(e);
    if (r !== 1 / 0 && d1(n, s, i) >= r)
      return r;
    if (Qg(n, s)) {
      if (zR(t, e))
        return 0;
    } else if (zR(e, t))
      return 0;
    let o = 1 / 0;
    for (const a of t)
      for (let A = 0, l = a.length, c = l - 1; A < l; c = A++) {
        const u = a[c], d = a[A];
        for (const h of e)
          for (let g = 0, f = h.length, p = f - 1; g < f; p = g++) {
            const m = h[p], E = h[g];
            if (XB(u, d, m, E))
              return 0;
            o = Math.min(o, h1(u, d, m, E, i));
          }
      }
    return o;
  }
  function PR(t, e, i, r, n, s) {
    if (!s)
      return;
    const o = d1(pM(r, s), n, i);
    o < e && t.push([o, s, [0, 0]]);
  }
  function _p(t, e, i, r, n, s, o) {
    if (!s || !o)
      return;
    const a = d1(pM(r, s), pM(n, o), i);
    a < e && t.push([a, s, o]);
  }
  function ty(t, e, i, r, n = 1 / 0) {
    let s = Math.min(r.distance(t[0], i[0][0]), n);
    if (s === 0)
      return s;
    const o = new OP([[0, [0, t.length - 1], [0, 0]]], GP), a = mM(i);
    for (; o.length > 0; ) {
      const A = o.pop();
      if (A[0] >= s)
        continue;
      const l = A[1], c = e ? gM : hM;
      if (ey(l) <= c) {
        if (!_a(l, t.length))
          return NaN;
        if (e) {
          const u = yhe(t, l, i, r);
          if (isNaN(u) || u === 0)
            return u;
          s = Math.min(s, u);
        } else
          for (let u = l[0]; u <= l[1]; ++u) {
            const d = Ehe(t[u], i, r);
            if (s = Math.min(s, d), s === 0)
              return 0;
          }
      } else {
        const u = fM(l, e);
        PR(o, s, r, t, a, u[0]), PR(o, s, r, t, a, u[1]);
      }
    }
    return s;
  }
  function iy(t, e, i, r, n, s = 1 / 0) {
    let o = Math.min(s, n.distance(t[0], i[0]));
    if (o === 0)
      return o;
    const a = new OP([[0, [0, t.length - 1], [0, i.length - 1]]], GP);
    for (; a.length > 0; ) {
      const A = a.pop();
      if (A[0] >= o)
        continue;
      const l = A[1], c = A[2], u = e ? gM : hM, d = r ? gM : hM;
      if (ey(l) <= u && ey(c) <= d) {
        if (!_a(l, t.length) && _a(c, i.length))
          return NaN;
        let h;
        if (e && r)
          h = phe(t, l, i, c, n), o = Math.min(o, h);
        else if (e && !r) {
          const g = t.slice(l[0], l[1] + 1);
          for (let f = c[0]; f <= c[1]; ++f)
            if (h = bl(i[f], g, n), o = Math.min(o, h), o === 0)
              return o;
        } else if (!e && r) {
          const g = i.slice(c[0], c[1] + 1);
          for (let f = l[0]; f <= l[1]; ++f)
            if (h = bl(t[f], g, n), o = Math.min(o, h), o === 0)
              return o;
        } else
          h = mhe(t, l, i, c, n), o = Math.min(o, h);
      } else {
        const h = fM(l, e), g = fM(c, r);
        _p(a, o, n, t, i, h[0], g[0]), _p(a, o, n, t, i, h[0], g[1]), _p(a, o, n, t, i, h[1], g[0]), _p(a, o, n, t, i, h[1], g[1]);
      }
    }
    return o;
  }
  function whe(t, e) {
    const i = t.geometry(), r = i.flat().map((o) => l1([o.x, o.y], t.canonical));
    if (i.length === 0)
      return NaN;
    const n = new u1(r[0][1]);
    let s = 1 / 0;
    for (const o of e) {
      switch (o.type) {
        case "Point":
          s = Math.min(s, iy(r, !1, [o.coordinates], !1, n, s));
          break;
        case "LineString":
          s = Math.min(s, iy(r, !1, o.coordinates, !0, n, s));
          break;
        case "Polygon":
          s = Math.min(s, ty(r, !1, o.coordinates, n, s));
          break;
      }
      if (s === 0)
        return s;
    }
    return s;
  }
  function Che(t, e) {
    const i = t.geometry(), r = i.flat().map((o) => l1([o.x, o.y], t.canonical));
    if (i.length === 0)
      return NaN;
    const n = new u1(r[0][1]);
    let s = 1 / 0;
    for (const o of e) {
      switch (o.type) {
        case "Point":
          s = Math.min(s, iy(r, !0, [o.coordinates], !1, n, s));
          break;
        case "LineString":
          s = Math.min(s, iy(r, !0, o.coordinates, !0, n, s));
          break;
        case "Polygon":
          s = Math.min(s, ty(r, !0, o.coordinates, n, s));
          break;
      }
      if (s === 0)
        return s;
    }
    return s;
  }
  function bhe(t, e) {
    const i = t.geometry();
    if (i.length === 0 || i[0].length === 0)
      return NaN;
    const r = hhe(i).map((o) => o.map((a) => a.map((A) => l1([A.x, A.y], t.canonical)))), n = new u1(r[0][0][0][1]);
    let s = 1 / 0;
    for (const o of e)
      for (const a of r) {
        switch (o.type) {
          case "Point":
            s = Math.min(s, ty([o.coordinates], !1, a, n, s));
            break;
          case "LineString":
            s = Math.min(s, ty(o.coordinates, !0, a, n, s));
            break;
          case "Polygon":
            s = Math.min(s, Bhe(a, o.coordinates, n, s));
            break;
        }
        if (s === 0)
          return s;
      }
    return s;
  }
  function hC(t) {
    return t.type === "MultiPolygon" ? t.coordinates.map((e) => ({
      type: "Polygon",
      coordinates: e
    })) : t.type === "MultiLineString" ? t.coordinates.map((e) => ({
      type: "LineString",
      coordinates: e
    })) : t.type === "MultiPoint" ? t.coordinates.map((e) => ({
      type: "Point",
      coordinates: e
    })) : [t];
  }
  class _l {
    constructor(e, i) {
      this.type = xe, this.geojson = e, this.geometries = i;
    }
    static parse(e, i) {
      if (e.length !== 2)
        return i.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
      if (vg(e[1])) {
        const r = e[1];
        if (r.type === "FeatureCollection")
          return new _l(r, r.features.map((n) => hC(n.geometry)).flat());
        if (r.type === "Feature")
          return new _l(r, hC(r.geometry));
        if ("type" in r && "coordinates" in r)
          return new _l(r, hC(r));
      }
      return i.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
    }
    evaluate(e) {
      if (e.geometry() != null && e.canonicalID() != null) {
        if (e.geometryType() === "Point")
          return whe(e, this.geometries);
        if (e.geometryType() === "LineString")
          return Che(e, this.geometries);
        if (e.geometryType() === "Polygon")
          return bhe(e, this.geometries);
      }
      return NaN;
    }
    eachChild() {
    }
    outputDefined() {
      return !0;
    }
  }
  const g1 = {
    // special forms
    "==": Vde,
    "!=": Wde,
    ">": Xde,
    "<": Kde,
    ">=": qde,
    "<=": Zde,
    array: _s,
    at: t1,
    boolean: _s,
    case: n1,
    coalesce: xg,
    collator: KB,
    format: o1,
    image: a1,
    in: i1,
    "index-of": qE,
    interpolate: _o,
    "interpolate-hcl": _o,
    "interpolate-lab": _o,
    length: A1,
    let: JB,
    literal: gd,
    match: r1,
    number: _s,
    "number-format": s1,
    object: _s,
    slice: $E,
    step: WB,
    string: _s,
    "to-boolean": mA,
    "to-color": mA,
    "to-number": mA,
    "to-string": mA,
    var: VB,
    within: Rl,
    distance: _l
  };
  class zs {
    constructor(e, i, r, n) {
      this.name = e, this.type = i, this._evaluate = r, this.args = n;
    }
    evaluate(e) {
      return this._evaluate(e, this.args);
    }
    eachChild(e) {
      this.args.forEach(e);
    }
    outputDefined() {
      return !1;
    }
    static parse(e, i) {
      const r = e[0], n = zs.definitions[r];
      if (!n)
        return i.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
      const s = Array.isArray(n) ? n[0] : n.type, o = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads, a = o.filter(([l]) => !Array.isArray(l) || // varags
      l.length === e.length - 1);
      let A = null;
      for (const [l, c] of a) {
        A = new HB(i.registry, ry, i.path, null, i.scope);
        const u = [];
        let d = !1;
        for (let h = 1; h < e.length; h++) {
          const g = e[h], f = Array.isArray(l) ? l[h - 1] : l.type, p = A.parse(g, 1 + u.length, f);
          if (!p) {
            d = !0;
            break;
          }
          u.push(p);
        }
        if (!d) {
          if (Array.isArray(l) && l.length !== u.length) {
            A.error(`Expected ${l.length} arguments, but found ${u.length} instead.`);
            continue;
          }
          for (let h = 0; h < u.length; h++) {
            const g = Array.isArray(l) ? l[h] : l.type, f = u[h];
            A.concat(h + 1).checkSubtype(g, f.type);
          }
          if (A.errors.length === 0)
            return new zs(r, s, c, u);
        }
      }
      if (a.length === 1)
        i.errors.push(...A.errors);
      else {
        const c = (a.length ? a : o).map(([d]) => Ihe(d)).join(" | "), u = [];
        for (let d = 1; d < e.length; d++) {
          const h = i.parse(e[d], 1 + u.length);
          if (!h)
            return null;
          u.push(Si(h.type));
        }
        i.error(`Expected arguments of type ${c}, but found (${u.join(", ")}) instead.`);
      }
      return null;
    }
    static register(e, i) {
      zs.definitions = i;
      for (const r in i)
        e[r] = zs;
    }
  }
  function OR(t, [e, i, r, n]) {
    e = e.evaluate(t), i = i.evaluate(t), r = r.evaluate(t);
    const s = n ? n.evaluate(t) : 1, o = _P(e, i, r, s);
    if (o)
      throw new Ji(o);
    return new fi(e / 255, i / 255, r / 255, s, !1);
  }
  function GR(t, e) {
    return t in e;
  }
  function gC(t, e) {
    const i = e[t];
    return typeof i > "u" ? null : i;
  }
  function Mhe(t, e, i, r) {
    for (; i <= r; ) {
      const n = i + r >> 1;
      if (e[n] === t)
        return !0;
      e[n] > t ? r = n - 1 : i = n + 1;
    }
    return !1;
  }
  function rl(t) {
    return { type: t };
  }
  zs.register(g1, {
    error: [
      yde,
      [Dt],
      (t, [e]) => {
        throw new Ji(e.evaluate(t));
      }
    ],
    typeof: [
      Dt,
      [yt],
      (t, [e]) => Si(ar(e.evaluate(t)))
    ],
    "to-rgba": [
      Yn(xe, 4),
      [To],
      (t, [e]) => {
        const [i, r, n, s] = e.evaluate(t).rgb;
        return [i * 255, r * 255, n * 255, s];
      }
    ],
    rgb: [
      To,
      [xe, xe, xe],
      OR
    ],
    rgba: [
      To,
      [xe, xe, xe, xe],
      OR
    ],
    has: {
      type: Et,
      overloads: [
        [
          [Dt],
          (t, [e]) => GR(e.evaluate(t), t.properties())
        ],
        [
          [Dt, Yu],
          (t, [e, i]) => GR(e.evaluate(t), i.evaluate(t))
        ]
      ]
    },
    get: {
      type: yt,
      overloads: [
        [
          [Dt],
          (t, [e]) => gC(e.evaluate(t), t.properties())
        ],
        [
          [Dt, Yu],
          (t, [e, i]) => gC(e.evaluate(t), i.evaluate(t))
        ]
      ]
    },
    "feature-state": [
      yt,
      [Dt],
      (t, [e]) => gC(e.evaluate(t), t.featureState || {})
    ],
    properties: [
      Yu,
      [],
      (t) => t.properties()
    ],
    "geometry-type": [
      Dt,
      [],
      (t) => t.geometryType()
    ],
    id: [
      yt,
      [],
      (t) => t.id()
    ],
    zoom: [
      xe,
      [],
      (t) => t.globals.zoom
    ],
    "heatmap-density": [
      xe,
      [],
      (t) => t.globals.heatmapDensity || 0
    ],
    "line-progress": [
      xe,
      [],
      (t) => t.globals.lineProgress || 0
    ],
    accumulated: [
      yt,
      [],
      (t) => t.globals.accumulated === void 0 ? null : t.globals.accumulated
    ],
    "+": [
      xe,
      rl(xe),
      (t, e) => {
        let i = 0;
        for (const r of e)
          i += r.evaluate(t);
        return i;
      }
    ],
    "*": [
      xe,
      rl(xe),
      (t, e) => {
        let i = 1;
        for (const r of e)
          i *= r.evaluate(t);
        return i;
      }
    ],
    "-": {
      type: xe,
      overloads: [
        [
          [xe, xe],
          (t, [e, i]) => e.evaluate(t) - i.evaluate(t)
        ],
        [
          [xe],
          (t, [e]) => -e.evaluate(t)
        ]
      ]
    },
    "/": [
      xe,
      [xe, xe],
      (t, [e, i]) => e.evaluate(t) / i.evaluate(t)
    ],
    "%": [
      xe,
      [xe, xe],
      (t, [e, i]) => e.evaluate(t) % i.evaluate(t)
    ],
    ln2: [
      xe,
      [],
      () => Math.LN2
    ],
    pi: [
      xe,
      [],
      () => Math.PI
    ],
    e: [
      xe,
      [],
      () => Math.E
    ],
    "^": [
      xe,
      [xe, xe],
      (t, [e, i]) => Math.pow(e.evaluate(t), i.evaluate(t))
    ],
    sqrt: [
      xe,
      [xe],
      (t, [e]) => Math.sqrt(e.evaluate(t))
    ],
    log10: [
      xe,
      [xe],
      (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10
    ],
    ln: [
      xe,
      [xe],
      (t, [e]) => Math.log(e.evaluate(t))
    ],
    log2: [
      xe,
      [xe],
      (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2
    ],
    sin: [
      xe,
      [xe],
      (t, [e]) => Math.sin(e.evaluate(t))
    ],
    cos: [
      xe,
      [xe],
      (t, [e]) => Math.cos(e.evaluate(t))
    ],
    tan: [
      xe,
      [xe],
      (t, [e]) => Math.tan(e.evaluate(t))
    ],
    asin: [
      xe,
      [xe],
      (t, [e]) => Math.asin(e.evaluate(t))
    ],
    acos: [
      xe,
      [xe],
      (t, [e]) => Math.acos(e.evaluate(t))
    ],
    atan: [
      xe,
      [xe],
      (t, [e]) => Math.atan(e.evaluate(t))
    ],
    min: [
      xe,
      rl(xe),
      (t, e) => Math.min(...e.map((i) => i.evaluate(t)))
    ],
    max: [
      xe,
      rl(xe),
      (t, e) => Math.max(...e.map((i) => i.evaluate(t)))
    ],
    abs: [
      xe,
      [xe],
      (t, [e]) => Math.abs(e.evaluate(t))
    ],
    round: [
      xe,
      [xe],
      (t, [e]) => {
        const i = e.evaluate(t);
        return i < 0 ? -Math.round(-i) : Math.round(i);
      }
    ],
    floor: [
      xe,
      [xe],
      (t, [e]) => Math.floor(e.evaluate(t))
    ],
    ceil: [
      xe,
      [xe],
      (t, [e]) => Math.ceil(e.evaluate(t))
    ],
    "filter-==": [
      Et,
      [Dt, yt],
      (t, [e, i]) => t.properties()[e.value] === i.value
    ],
    "filter-id-==": [
      Et,
      [yt],
      (t, [e]) => t.id() === e.value
    ],
    "filter-type-==": [
      Et,
      [Dt],
      (t, [e]) => t.geometryType() === e.value
    ],
    "filter-<": [
      Et,
      [Dt, yt],
      (t, [e, i]) => {
        const r = t.properties()[e.value], n = i.value;
        return typeof r == typeof n && r < n;
      }
    ],
    "filter-id-<": [
      Et,
      [yt],
      (t, [e]) => {
        const i = t.id(), r = e.value;
        return typeof i == typeof r && i < r;
      }
    ],
    "filter->": [
      Et,
      [Dt, yt],
      (t, [e, i]) => {
        const r = t.properties()[e.value], n = i.value;
        return typeof r == typeof n && r > n;
      }
    ],
    "filter-id->": [
      Et,
      [yt],
      (t, [e]) => {
        const i = t.id(), r = e.value;
        return typeof i == typeof r && i > r;
      }
    ],
    "filter-<=": [
      Et,
      [Dt, yt],
      (t, [e, i]) => {
        const r = t.properties()[e.value], n = i.value;
        return typeof r == typeof n && r <= n;
      }
    ],
    "filter-id-<=": [
      Et,
      [yt],
      (t, [e]) => {
        const i = t.id(), r = e.value;
        return typeof i == typeof r && i <= r;
      }
    ],
    "filter->=": [
      Et,
      [Dt, yt],
      (t, [e, i]) => {
        const r = t.properties()[e.value], n = i.value;
        return typeof r == typeof n && r >= n;
      }
    ],
    "filter-id->=": [
      Et,
      [yt],
      (t, [e]) => {
        const i = t.id(), r = e.value;
        return typeof i == typeof r && i >= r;
      }
    ],
    "filter-has": [
      Et,
      [yt],
      (t, [e]) => e.value in t.properties()
    ],
    "filter-has-id": [
      Et,
      [],
      (t) => t.id() !== null && t.id() !== void 0
    ],
    "filter-type-in": [
      Et,
      [Yn(Dt)],
      (t, [e]) => e.value.indexOf(t.geometryType()) >= 0
    ],
    "filter-id-in": [
      Et,
      [Yn(yt)],
      (t, [e]) => e.value.indexOf(t.id()) >= 0
    ],
    "filter-in-small": [
      Et,
      [Dt, Yn(yt)],
      // assumes v is an array literal
      (t, [e, i]) => i.value.indexOf(t.properties()[e.value]) >= 0
    ],
    "filter-in-large": [
      Et,
      [Dt, Yn(yt)],
      // assumes v is a array literal with values sorted in ascending order and of a single type
      (t, [e, i]) => Mhe(t.properties()[e.value], i.value, 0, i.value.length - 1)
    ],
    all: {
      type: Et,
      overloads: [
        [
          [Et, Et],
          (t, [e, i]) => e.evaluate(t) && i.evaluate(t)
        ],
        [
          rl(Et),
          (t, e) => {
            for (const i of e)
              if (!i.evaluate(t))
                return !1;
            return !0;
          }
        ]
      ]
    },
    any: {
      type: Et,
      overloads: [
        [
          [Et, Et],
          (t, [e, i]) => e.evaluate(t) || i.evaluate(t)
        ],
        [
          rl(Et),
          (t, e) => {
            for (const i of e)
              if (i.evaluate(t))
                return !0;
            return !1;
          }
        ]
      ]
    },
    "!": [
      Et,
      [Et],
      (t, [e]) => !e.evaluate(t)
    ],
    "is-supported-script": [
      Et,
      [Dt],
      // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
      (t, [e]) => {
        const i = t.globals && t.globals.isSupportedScript;
        return i ? i(e.evaluate(t)) : !0;
      }
    ],
    upcase: [
      Dt,
      [Dt],
      (t, [e]) => e.evaluate(t).toUpperCase()
    ],
    downcase: [
      Dt,
      [Dt],
      (t, [e]) => e.evaluate(t).toLowerCase()
    ],
    concat: [
      Dt,
      rl(yt),
      (t, e) => e.map((i) => jh(i.evaluate(t))).join("")
    ],
    "resolved-locale": [
      Dt,
      [PB],
      (t, [e]) => e.evaluate(t).resolvedLocale()
    ]
  });
  function Ihe(t) {
    return Array.isArray(t) ? `(${t.map(Si).join(", ")})` : `(${Si(t.type)}...)`;
  }
  function ry(t) {
    if (t instanceof VB)
      return ry(t.boundExpression);
    if (t instanceof zs && t.name === "error")
      return !1;
    if (t instanceof KB)
      return !1;
    if (t instanceof Rl)
      return !1;
    if (t instanceof _l)
      return !1;
    const e = t instanceof mA || t instanceof _s;
    let i = !0;
    return t.eachChild((r) => {
      e ? i = i && ry(r) : i = i && r instanceof gd;
    }), i ? f1(t) && m1(t, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) : !1;
  }
  function f1(t) {
    if (t instanceof zs) {
      if (t.name === "get" && t.args.length === 1)
        return !1;
      if (t.name === "feature-state")
        return !1;
      if (t.name === "has" && t.args.length === 1)
        return !1;
      if (t.name === "properties" || t.name === "geometry-type" || t.name === "id")
        return !1;
      if (/^filter-/.test(t.name))
        return !1;
    }
    if (t instanceof Rl || t instanceof _l)
      return !1;
    let e = !0;
    return t.eachChild((i) => {
      e && !f1(i) && (e = !1);
    }), e;
  }
  function p1(t) {
    if (t instanceof zs && t.name === "feature-state")
      return !1;
    let e = !0;
    return t.eachChild((i) => {
      e && !p1(i) && (e = !1);
    }), e;
  }
  function m1(t, e) {
    if (t instanceof zs && e.indexOf(t.name) >= 0)
      return !1;
    let i = !0;
    return t.eachChild((r) => {
      i && !m1(r, e) && (i = !1);
    }), i;
  }
  function EM(t) {
    return { result: "success", value: t };
  }
  function qc(t) {
    return { result: "error", value: t };
  }
  function vhe(t) {
    return t["property-type"] === "data-driven" || t["property-type"] === "cross-faded-data-driven";
  }
  function xhe(t) {
    return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;
  }
  function Qhe(t) {
    return !!t.expression && t.expression.interpolated;
  }
  function jP(t) {
    return typeof t == "object" && t !== null && !Array.isArray(t);
  }
  class Fhe {
    constructor(e, i) {
      this.expression = e, this._warningHistory = {}, this._evaluator = new kP(), this._defaultValue = i ? Rhe(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null;
    }
    evaluateWithoutErrorHandling(e, i, r, n, s, o) {
      return this._evaluator.globals = e, this._evaluator.feature = i, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = o, this.expression.evaluate(this._evaluator);
    }
    evaluate(e, i, r, n, s, o) {
      this._evaluator.globals = e, this._evaluator.feature = i || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = o || null;
      try {
        const a = this.expression.evaluate(this._evaluator);
        if (a == null || typeof a == "number" && a !== a)
          return this._defaultValue;
        if (this._enumValues && !(a in this._enumValues))
          throw new Ji(`Expected value to be one of ${Object.keys(this._enumValues).map((A) => JSON.stringify(A)).join(", ")}, but found ${JSON.stringify(a)} instead.`);
        return a;
      } catch (a) {
        return this._warningHistory[a.message] || (this._warningHistory[a.message] = !0, typeof console < "u" && console.warn(a.message)), this._defaultValue;
      }
    }
  }
  function She(t) {
    return Array.isArray(t) && t.length > 0 && typeof t[0] == "string" && t[0] in g1;
  }
  function HP(t, e) {
    const i = new HB(g1, ry, [], e ? The(e) : void 0), r = i.parse(t, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
    return r ? EM(new Fhe(r, e)) : qc(i.errors);
  }
  class jR {
    constructor(e, i) {
      this.kind = e, this._styleExpression = i, this.isStateDependent = e !== "constant" && !p1(i.expression);
    }
    evaluateWithoutErrorHandling(e, i, r, n, s, o) {
      return this._styleExpression.evaluateWithoutErrorHandling(e, i, r, n, s, o);
    }
    evaluate(e, i, r, n, s, o) {
      return this._styleExpression.evaluate(e, i, r, n, s, o);
    }
  }
  class HR {
    constructor(e, i, r, n) {
      this.kind = e, this.zoomStops = r, this._styleExpression = i, this.isStateDependent = e !== "camera" && !p1(i.expression), this.interpolationType = n;
    }
    evaluateWithoutErrorHandling(e, i, r, n, s, o) {
      return this._styleExpression.evaluateWithoutErrorHandling(e, i, r, n, s, o);
    }
    evaluate(e, i, r, n, s, o) {
      return this._styleExpression.evaluate(e, i, r, n, s, o);
    }
    interpolationFactor(e, i, r) {
      return this.interpolationType ? _o.interpolationFactor(this.interpolationType, e, i, r) : 0;
    }
  }
  function Dhe(t, e) {
    const i = HP(t, e);
    if (i.result === "error")
      return i;
    const r = i.value.expression, n = f1(r);
    if (!n && !vhe(e))
      return qc([new Co("", "data expressions not supported")]);
    const s = m1(r, ["zoom"]);
    if (!s && !xhe(e))
      return qc([new Co("", "zoom expressions not supported")]);
    const o = dm(r);
    if (!o && !s)
      return qc([new Co("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    if (o instanceof Co)
      return qc([o]);
    if (o instanceof _o && !Qhe(e))
      return qc([new Co("", '"interpolate" expressions cannot be used with this property')]);
    if (!o)
      return EM(n ? new jR("constant", i.value) : new jR("source", i.value));
    const a = o instanceof _o ? o.interpolation : void 0;
    return EM(n ? new HR("camera", i.value, o.labels, a) : new HR("composite", i.value, o.labels, a));
  }
  function dm(t) {
    let e = null;
    if (t instanceof JB)
      e = dm(t.result);
    else if (t instanceof xg) {
      for (const i of t.args)
        if (e = dm(i), e)
          break;
    } else (t instanceof WB || t instanceof _o) && t.input instanceof zs && t.input.name === "zoom" && (e = t);
    return e instanceof Co || t.eachChild((i) => {
      const r = dm(i);
      r instanceof Co ? e = r : !e && r ? e = new Co("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && r && e !== r && (e = new Co("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
    }), e;
  }
  function The(t) {
    const e = {
      color: To,
      string: Dt,
      number: xe,
      enum: Dt,
      boolean: Et,
      formatted: OB,
      padding: GB,
      projectionDefinition: zB,
      resolvedImage: xf,
      variableAnchorOffsetCollection: jB
    };
    return t.type === "array" ? Yn(e[t.value] || yt, t.length) : e[t.type];
  }
  function Rhe(t) {
    return t.type === "color" && jP(t.default) ? new fi(0, 0, 0, 0) : t.type === "color" ? fi.parse(t.default) || null : t.type === "padding" ? Ls.parse(t.default) || null : t.type === "variableAnchorOffsetCollection" ? Ro.parse(t.default) || null : t.type === "projectionDefinition" ? Rs.parse(t.default) || null : t.default === void 0 ? null : t.default;
  }
  function JP(t) {
    if (t === !0 || t === !1)
      return !0;
    if (!Array.isArray(t) || t.length === 0)
      return !1;
    switch (t[0]) {
      case "has":
        return t.length >= 2 && t[1] !== "$id" && t[1] !== "$type";
      case "in":
        return t.length >= 3 && (typeof t[1] != "string" || Array.isArray(t[2]));
      case "!in":
      case "!has":
      case "none":
        return !1;
      case "==":
      case "!=":
      case ">":
      case ">=":
      case "<":
      case "<=":
        return t.length !== 3 || Array.isArray(t[1]) || Array.isArray(t[2]);
      case "any":
      case "all":
        for (const e of t.slice(1))
          if (!JP(e) && typeof e != "boolean")
            return !1;
        return !0;
      default:
        return !0;
    }
  }
  const _he = {
    type: "boolean",
    default: !1,
    transition: !1,
    "property-type": "data-driven",
    expression: {
      interpolated: !1,
      parameters: ["zoom", "feature"]
    }
  };
  function khe(t) {
    if (t == null)
      return { filter: () => !0, needGeometry: !1 };
    JP(t) || (t = ny(t));
    const e = HP(t, _he);
    if (e.result === "error")
      throw new Error(e.value.map((i) => `${i.key}: ${i.message}`).join(", "));
    {
      const i = VP(t);
      return {
        filter: (r, n, s) => e.value.evaluate(r, n, {}, s),
        needGeometry: i
      };
    }
  }
  function Yhe(t, e) {
    return t < e ? -1 : t > e ? 1 : 0;
  }
  function VP(t) {
    if (!Array.isArray(t))
      return !1;
    if (t[0] === "within" || t[0] === "distance")
      return !0;
    for (let e = 1; e < t.length; e++)
      if (VP(t[e]))
        return !0;
    return !1;
  }
  function ny(t) {
    if (!t)
      return !0;
    const e = t[0];
    return t.length <= 1 ? e !== "any" : e === "==" ? fC(t[1], t[2], "==") : e === "!=" ? kp(fC(t[1], t[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? fC(t[1], t[2], e) : e === "any" ? Nhe(t.slice(1)) : e === "all" ? ["all"].concat(t.slice(1).map(ny)) : e === "none" ? ["all"].concat(t.slice(1).map(ny).map(kp)) : e === "in" ? JR(t[1], t.slice(2)) : e === "!in" ? kp(JR(t[1], t.slice(2))) : e === "has" ? VR(t[1]) : e === "!has" ? kp(VR(t[1])) : !0;
  }
  function fC(t, e, i) {
    switch (t) {
      case "$type":
        return [`filter-type-${i}`, e];
      case "$id":
        return [`filter-id-${i}`, e];
      default:
        return [`filter-${i}`, t, e];
    }
  }
  function Nhe(t) {
    return ["any"].concat(t.map(ny));
  }
  function JR(t, e) {
    if (e.length === 0)
      return !1;
    switch (t) {
      case "$type":
        return ["filter-type-in", ["literal", e]];
      case "$id":
        return ["filter-id-in", ["literal", e]];
      default:
        return e.length > 200 && !e.some((i) => typeof i != typeof e[0]) ? ["filter-in-large", t, ["literal", e.sort(Yhe)]] : ["filter-in-small", t, ["literal", e]];
    }
  }
  function VR(t) {
    switch (t) {
      case "$type":
        return !0;
      case "$id":
        return ["filter-has-id"];
      default:
        return ["filter-has", t];
    }
  }
  function kp(t) {
    return ["!", t];
  }
  function Fg(t) {
    return typeof t == "object" ? ["literal", t] : t;
  }
  function Uhe(t, e) {
    let i = t.stops;
    if (!i)
      return Lhe(t, e);
    const r = i && typeof i[0][0] == "object", n = r || t.property !== void 0, s = r || !n;
    return i = i.map((o) => !n && e.tokens && typeof o[1] == "string" ? [o[0], Ghe(o[1])] : [o[0], Fg(o[1])]), r ? zhe(t, e, i) : s ? Ohe(t, e, i) : yM(t, e, i);
  }
  function Lhe(t, e) {
    const i = ["get", t.property];
    if (t.default === void 0)
      return e.type === "string" ? ["string", i] : i;
    if (e.type === "enum")
      return [
        "match",
        i,
        Object.keys(e.values),
        i,
        t.default
      ];
    {
      const r = [e.type === "color" ? "to-color" : e.type, i, Fg(t.default)];
      return e.type === "array" && r.splice(1, 0, e.value, e.length || null), r;
    }
  }
  function E1(t) {
    switch (t.colorSpace) {
      case "hcl":
        return "interpolate-hcl";
      case "lab":
        return "interpolate-lab";
      default:
        return "interpolate";
    }
  }
  function zhe(t, e, i) {
    const r = {}, n = {}, s = [];
    for (let a = 0; a < i.length; a++) {
      const A = i[a], l = A[0].zoom;
      r[l] === void 0 && (r[l] = {
        zoom: l,
        type: t.type,
        property: t.property,
        default: t.default
      }, n[l] = [], s.push(l)), n[l].push([A[0].value, A[1]]);
    }
    if (B1({}, e) === "exponential") {
      const a = [E1(t), ["linear"], ["zoom"]];
      for (const A of s) {
        const l = yM(r[A], e, n[A]);
        Uu(a, A, l, !1);
      }
      return a;
    } else {
      const a = ["step", ["zoom"]];
      for (const A of s) {
        const l = yM(r[A], e, n[A]);
        Uu(a, A, l, !0);
      }
      return y1(a), a;
    }
  }
  function Phe(t, e) {
    if (t !== void 0)
      return t;
    if (e !== void 0)
      return e;
  }
  function WR(t, e) {
    const i = Fg(Phe(t.default, e.default));
    return i === void 0 && e.type === "resolvedImage" ? "" : i;
  }
  function yM(t, e, i) {
    const r = B1(t, e), n = ["get", t.property];
    if (r === "categorical" && typeof i[0][0] == "boolean") {
      const s = ["case"];
      for (const o of i)
        s.push(["==", n, o[0]], o[1]);
      return s.push(WR(t, e)), s;
    } else if (r === "categorical") {
      const s = ["match", n];
      for (const o of i)
        Uu(s, o[0], o[1], !1);
      return s.push(WR(t, e)), s;
    } else if (r === "interval") {
      const s = ["step", ["number", n]];
      for (const o of i)
        Uu(s, o[0], o[1], !0);
      return y1(s), t.default === void 0 ? s : [
        "case",
        ["==", ["typeof", n], "number"],
        s,
        Fg(t.default)
      ];
    } else if (r === "exponential") {
      const s = t.base !== void 0 ? t.base : 1, o = [
        E1(t),
        s === 1 ? ["linear"] : ["exponential", s],
        ["number", n]
      ];
      for (const a of i)
        Uu(o, a[0], a[1], !1);
      return t.default === void 0 ? o : [
        "case",
        ["==", ["typeof", n], "number"],
        o,
        Fg(t.default)
      ];
    } else
      throw new Error(`Unknown property function type ${r}`);
  }
  function Ohe(t, e, i, r = ["zoom"]) {
    const n = B1(t, e);
    let s, o = !1;
    if (n === "interval")
      s = ["step", r], o = !0;
    else if (n === "exponential") {
      const a = t.base !== void 0 ? t.base : 1;
      s = [E1(t), a === 1 ? ["linear"] : ["exponential", a], r];
    } else
      throw new Error(`Unknown zoom function type "${n}"`);
    for (const a of i)
      Uu(s, a[0], a[1], o);
    return y1(s), s;
  }
  function y1(t) {
    t[0] === "step" && t.length === 3 && (t.push(0), t.push(t[3]));
  }
  function Uu(t, e, i, r) {
    t.length > 3 && e === t[t.length - 2] || (r && t.length === 2 || t.push(e), t.push(i));
  }
  function B1(t, e) {
    return t.type ? t.type : e.expression.interpolated ? "exponential" : "interval";
  }
  function Ghe(t) {
    const e = ["concat"], i = /{([^{}]+)}/g;
    let r = 0;
    for (let n = i.exec(t); n !== null; n = i.exec(t)) {
      const s = t.slice(r, i.lastIndex - n[0].length);
      r = i.lastIndex, s.length > 0 && e.push(s), e.push(["get", n[1]]);
    }
    if (e.length === 1)
      return t;
    if (r < t.length)
      e.push(t.slice(r));
    else if (e.length === 2)
      return ["to-string", e[1]];
    return e;
  }
  const jhe = pde;
  var KR = {
    thin: 100,
    hairline: 100,
    "ultra-light": 200,
    "extra-light": 200,
    light: 300,
    book: 300,
    regular: 400,
    normal: 400,
    plain: 400,
    roman: 400,
    standard: 400,
    medium: 500,
    "semi-bold": 600,
    "demi-bold": 600,
    bold: 700,
    "extra-bold": 800,
    "ultra-bold": 800,
    heavy: 900,
    black: 900,
    "heavy-black": 900,
    fat: 900,
    poster: 900,
    "ultra-black": 950,
    "extra-black": 950
  }, ch = " ", XR = /(italic|oblique)$/i, ZR = {};
  function BM(t, e, i) {
    var r = ZR[t];
    if (!r) {
      Array.isArray(t) || (t = [t]);
      for (var n = 400, s = "normal", o = [], a, A, l = 0, c = t.length; l < c; ++l) {
        var u = t[l], d = u.split(" "), h = d[d.length - 1].toLowerCase();
        h == "normal" || h == "italic" || h == "oblique" ? (s = A ? s : h, A = !0, d.pop(), h = d[d.length - 1].toLowerCase()) : XR.test(h) && (h = h.replace(XR, ""), s = A ? s : d[d.length - 1].replace(h, ""), A = !0);
        for (var g in KR) {
          var f = d.length > 1 ? d[d.length - 2].toLowerCase() : "";
          if (h == g || h == g.replace("-", "") || f + "-" + h == g) {
            n = a ? n : KR[g], d.pop(), f && g.startsWith(f) && d.pop();
            break;
          }
        }
        !a && typeof h == "number" && (n = h, a = !0);
        var p = d.join(ch).replace("Klokantech Noto Sans", "Noto Sans");
        p.indexOf(ch) !== -1 && (p = '"' + p + '"'), o.push(p);
      }
      r = ZR[t] = [s, n, o];
    }
    return r[0] + ch + r[1] + ch + e + "px" + (i ? "/" + i : "") + ch + r[2];
  }
  const WP = "https://api.mapbox.com";
  function w1(t) {
    const e = "mapbox://";
    return t.indexOf(e) !== 0 ? "" : t.slice(e.length);
  }
  function Hhe(t, e, i) {
    const r = w1(t);
    if (!r)
      return decodeURI(new URL(t, i).href);
    const n = "sprites/";
    if (r.indexOf(n) !== 0)
      throw new Error(`unexpected sprites url: ${t}`);
    const s = r.slice(n.length);
    return `${WP}/styles/v1/${s}/sprite?access_token=${e}`;
  }
  function sy(t, e) {
    const i = w1(t);
    if (!i)
      return decodeURI(new URL(t, location.href).href);
    const r = "styles/";
    if (i.indexOf(r) !== 0)
      throw new Error(`unexpected style url: ${t}`);
    const n = i.slice(r.length);
    return `${WP}/styles/v1/${n}?&access_token=${e}`;
  }
  const Jhe = ["a", "b", "c", "d"];
  function hm(t, e, i, r) {
    const n = new URL(t, r || location.href), s = w1(t);
    if (!s)
      return e ? (n.searchParams.has(i) || n.searchParams.set(i, e), [decodeURI(n.href)]) : [decodeURI(n.href)];
    if (s === "mapbox.satellite") {
      const o = window.devicePixelRatio >= 1.5 ? "@2x" : "";
      return [
        `https://api.mapbox.com/v4/${s}/{z}/{x}/{y}${o}.webp?access_token=${e}`
      ];
    }
    return Jhe.map(
      (o) => `https://${o}.tiles.mapbox.com/v4/${s}/{z}/{x}/{y}.vector.pbf?access_token=${e}`
    );
  }
  const qR = {}, $R = {};
  let Vhe = 0;
  function C1(t) {
    return t.id || (t.id = Vhe++), t.id;
  }
  function Whe(t, e) {
    return C1(t) + "." + ve(e);
  }
  function KP(t) {
    let e = qR[t.id];
    return e || (e = {}, qR[C1(t)] = e), e;
  }
  function Khe(t) {
    let e = $R[t.id];
    return e || (e = {}, $R[C1(t)] = e), e;
  }
  function pC(t) {
    return t * Math.PI / 180;
  }
  const Yo = function() {
    const t = [];
    for (let e = 78271.51696402048; t.length <= 24; e /= 2)
      t.push(e);
    return t;
  }();
  function ZB(t, e) {
    if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof OffscreenCanvas < "u")
      return (
        /** @type {?} */
        new OffscreenCanvas(t, e)
      );
    const i = document.createElement("canvas");
    return i.width = t, i.height = e, i;
  }
  function b1(t, e) {
    let i = 0;
    const r = e.length;
    for (; i < r; ++i)
      if (e[i] < t && i + 1 < r) {
        const s = e[i] / e[i + 1];
        return i + Math.log(e[i] / t) / Math.log(s);
      }
    return r - 1;
  }
  function bh(t, e) {
    const i = Math.floor(t), r = Math.pow(2, t - i);
    return e[i] / r;
  }
  const Lc = {};
  function fd(t, e, i = {}, r) {
    if (e in Lc)
      return r && (r.url = Lc[e][0].url), Lc[e][1];
    const n = i.transformRequest && i.transformRequest(e, t) || e, s = function(A) {
      return delete Lc[e], Promise.reject(new Error("Error fetching source " + e));
    }, o = function(A) {
      return delete Lc[e], A.ok ? A.json() : Promise.reject(new Error("Error fetching source " + e));
    }, a = ed(() => n).then((A) => A instanceof Response ? (r && (r.url = A.url), o(A)) : (A instanceof Request || (A = new Request(A)), A.headers.get("Accept") || A.headers.set("Accept", "application/json"), r && (r.url = A.url), fetch(A).then(o).catch(s))).catch(s);
    return Lc[e] = [n, a], a;
  }
  function XP(t, e) {
    if (typeof t == "string")
      if (t.trim().startsWith("{"))
        try {
          const i = JSON.parse(t);
          return Promise.resolve(i);
        } catch (i) {
          return Promise.reject(i);
        }
      else
        return t = sy(t, e.accessToken), fd("Style", t, e);
    else
      return Promise.resolve(t);
  }
  const e_ = {};
  function ZP(t, e, i = {}) {
    const r = [e, JSON.stringify(t)].toString();
    let n = e_[r];
    if (!n || i.transformRequest) {
      let s;
      i.transformRequest && (s = (a, A) => {
        const l = i.transformRequest && i.transformRequest(A, "Tiles") || A;
        if (a instanceof BL)
          a.setLoader((c, u, d) => {
            const h = function(g) {
              g.arrayBuffer().then((f) => {
                const m = a.getFormat().readFeatures(f, {
                  extent: c,
                  featureProjection: d
                });
                a.setFeatures(m);
              });
            };
            ed(() => l).then((g) => {
              if (g instanceof Response)
                return h(g);
              fetch(g).then(h).catch((f) => a.setState(pe.ERROR));
            }).catch((g) => a.setState(pe.ERROR));
          });
        else {
          const c = a.getImage();
          ed(() => l).then((u) => {
            if (typeof u == "string") {
              c.src = u;
              return;
            }
            const d = (h) => h.blob().then((g) => {
              const f = URL.createObjectURL(g);
              c.addEventListener("load", () => URL.revokeObjectURL(f)), c.addEventListener("error", () => URL.revokeObjectURL(f)), c.src = f;
            });
            if (u instanceof Response)
              return d(u);
            fetch(u).then(d).catch((h) => a.setState(pe.ERROR));
          }).catch((u) => a.setState(pe.ERROR));
        }
      });
      const o = t.url;
      if (o && !t.tiles) {
        const a = hm(
          o,
          i.accessToken,
          i.accessTokenParam || "access_token",
          e || location.href
        );
        if (o.startsWith("mapbox://"))
          n = Promise.resolve({
            tileJson: Object.assign({}, t, {
              url: void 0,
              tiles: a
            }),
            tileLoadFunction: s
          });
        else {
          const A = {};
          n = fd(
            "Source",
            a[0],
            i,
            A
          ).then(function(l) {
            return l.tiles = l.tiles.map(function(c) {
              return l.scheme === "tms" && (c = c.replace("{y}", "{-y}")), hm(
                c,
                i.accessToken,
                i.accessTokenParam || "access_token",
                A.url
              )[0];
            }), Promise.resolve({ tileJson: l, tileLoadFunction: s });
          });
        }
      } else
        t = Object.assign({}, t, {
          tiles: t.tiles.map(function(a) {
            return t.scheme === "tms" && (a = a.replace("{y}", "{-y}")), hm(
              a,
              i.accessToken,
              i.accessTokenParam || "access_token",
              e || location.href
            )[0];
          })
        }), n = Promise.resolve({
          tileJson: Object.assign({}, t),
          tileLoadFunction: s
        });
      e_[r] = n;
    }
    return n;
  }
  function t_(t, e, i, r) {
    const n = [
      2 * i * e.pixelRatio + e.width,
      2 * i * e.pixelRatio + e.height
    ], s = ZB(n[0], n[1]), o = s.getContext("2d");
    o.drawImage(
      t,
      e.x,
      e.y,
      e.width,
      e.height,
      i * e.pixelRatio,
      i * e.pixelRatio,
      e.width,
      e.height
    );
    const a = o.getImageData(0, 0, n[0], n[1]);
    o.globalCompositeOperation = "destination-over", o.fillStyle = `rgba(${r.r * 255},${r.g * 255},${r.b * 255},${r.a})`;
    const A = a.data;
    for (let l = 0, c = a.width; l < c; ++l)
      for (let u = 0, d = a.height; u < d; ++u) {
        const h = (u * c + l) * 4;
        A[h + 3] > 0 && o.arc(
          l,
          u,
          i * e.pixelRatio,
          0,
          2 * Math.PI
        );
      }
    return o.fill(), s;
  }
  function Xhe(t, e, i) {
    const r = Math.max(0, Math.min(1, (i - t) / (e - t)));
    return r * r * (3 - 2 * r);
  }
  function i_(t, e, i) {
    const r = ZB(e.width, e.height), n = r.getContext("2d");
    n.drawImage(
      t,
      e.x,
      e.y,
      e.width,
      e.height,
      0,
      0,
      e.width,
      e.height
    );
    const s = n.getImageData(0, 0, e.width, e.height), o = s.data;
    for (let a = 0, A = s.width; a < A; ++a)
      for (let l = 0, c = s.height; l < c; ++l) {
        const u = (l * A + a) * 4, d = o[u + 3] / 255, h = 0.75, g = 0.1, f = Xhe(h - g, h + g, d);
        f > 0 ? (o[u + 0] = Math.round(255 * i.r * f), o[u + 1] = Math.round(255 * i.g * f), o[u + 2] = Math.round(255 * i.b * f), o[u + 3] = Math.round(255 * f)) : o[u + 3] = 0;
      }
    return n.putImageData(s, 0, 0), r;
  }
  const Zhe = Array(256).join(" ");
  function wM(t, e) {
    if (e >= 0.05) {
      let i = "";
      const r = t.split(`
`), n = Zhe.slice(
        0,
        Math.round(e / 0.1)
      );
      for (let s = 0, o = r.length; s < o; ++s)
        s > 0 && (i += `
`), i += r[s].split("").join(n);
      return i;
    }
    return t;
  }
  let mC;
  function qP() {
    return mC || (mC = ZB(1, 1).getContext("2d")), mC;
  }
  function nl(t, e) {
    return qP().measureText(t).width + (t.length - 1) * e;
  }
  const r_ = {};
  function CM(t, e, i, r) {
    if (t.indexOf(`
`) !== -1) {
      const o = t.split(`
`), a = [];
      for (let A = 0, l = o.length; A < l; ++A)
        a.push(CM(o[A], e, i, r));
      return a.join(`
`);
    }
    const n = i + "," + e + "," + t + "," + r;
    let s = r_[n];
    if (!s) {
      const o = t.split(" ");
      if (o.length > 1) {
        const a = qP();
        a.font = e;
        const l = a.measureText("M").width * i;
        let c = "";
        const u = [];
        for (let d = 0, h = o.length; d < h; ++d) {
          const g = o[d], f = c + (c ? " " : "") + g;
          nl(f, r) <= l ? c = f : (c && u.push(c), c = g);
        }
        c && u.push(c);
        for (let d = 0, h = u.length; d < h && h > 1; ++d) {
          const g = u[d];
          if (nl(g, r) < l * 0.35) {
            const f = d > 0 ? nl(u[d - 1], r) : 1 / 0, p = d < h - 1 ? nl(u[d + 1], r) : 1 / 0;
            u.splice(d, 1), h -= 1, f < p ? (u[d - 1] += " " + g, d -= 1) : u[d] = g + " " + u[d];
          }
        }
        for (let d = 0, h = u.length - 1; d < h; ++d) {
          const g = u[d], f = u[d + 1];
          if (nl(g, r) > l * 0.7 && nl(f, r) < l * 0.6) {
            const p = g.split(" "), m = p.pop();
            nl(m, r) < l * 0.2 && (u[d] = p.join(" "), u[d + 1] = m + " " + f), h -= 1;
          }
        }
        s = u.join(`
`);
      } else
        s = t;
      s = wM(s, r), r_[n] = s;
    }
    return s;
  }
  const qhe = /font-family: ?([^;]*);/, $he = /("|')/g;
  let Yp;
  function ege(t) {
    if (!Yp) {
      Yp = {};
      const e = document.styleSheets;
      for (let i = 0, r = e.length; i < r; ++i) {
        const n = (
          /** @type {CSSStyleSheet} */
          e[i]
        );
        try {
          const s = n.rules || n.cssRules;
          if (s)
            for (let o = 0, a = s.length; o < a; ++o) {
              const A = s[o];
              if (A.type == 5) {
                const l = A.cssText.match(qhe);
                Yp[l[1].replace($he, "")] = !0;
              }
            }
        } catch {
        }
      }
    }
    return t in Yp;
  }
  const EC = {};
  function tge(t, e = "https://cdn.jsdelivr.net/npm/@fontsource/{font-family}/{fontweight}{-fontstyle}.css") {
    const i = t.toString();
    if (i in EC)
      return EC[i];
    const r = [];
    for (let n = 0, s = t.length; n < s; ++n) {
      t[n] = t[n].replace("Arial Unicode MS", "Arial");
      const o = t[n], a = BM(o, 1);
      RU(a);
      const A = a.split(" ");
      r.push([
        A.slice(3).join(" ").replace(/"/g, ""),
        A[1],
        A[0]
      ]);
    }
    for (let n = 0, s = r.length; n < s; ++n) {
      const o = r[n], a = o[0];
      if (!ege(a) && mo.get(
        `${o[2]}
${o[1]} 
${a}`
      ) !== 100) {
        const A = e.replace("{font-family}", a.replace(/ /g, "-").toLowerCase()).replace("{Font+Family}", a.replace(/ /g, "+")).replace("{fontweight}", o[1]).replace(
          "{-fontstyle}",
          o[2].replace("normal", "").replace(/(.+)/, "-$1")
        ).replace("{fontstyle}", o[2]);
        if (!document.querySelector('link[href="' + A + '"]')) {
          const l = document.createElement("link");
          l.href = A, l.rel = "stylesheet", document.head.appendChild(l);
        }
      }
    }
    return EC[i] = t, t;
  }
  const ige = {
    Point: 1,
    MultiPoint: 1,
    LineString: 2,
    MultiLineString: 2,
    Polygon: 3,
    MultiPolygon: 3
  }, rge = {
    center: [0.5, 0.5],
    left: [0, 0.5],
    right: [1, 0.5],
    top: [0.5, 0],
    bottom: [0.5, 1],
    "top-left": [0, 0],
    "top-right": [1, 0],
    "bottom-left": [0, 1],
    "bottom-right": [1, 1]
  }, nge = function(t, e) {
    const i = Dhe(
      t,
      e
    );
    if (i.result === "error")
      throw new Error(
        i.value.map((r) => `${r.key}: ${r.message}`).join(", ")
      );
    return i.value;
  }, bM = {}, oy = { zoom: 0 };
  let Np, yC;
  function Je(t, e, i, r, n, s, o) {
    const a = t.id;
    s || (s = {}, console.warn("No functionCache provided to getValue()")), s[a] || (s[a] = {});
    const A = s[a];
    if (!A[i]) {
      let l = (t[e] || bM)[i];
      const c = jhe[`${e}_${t.type}`][i];
      l === void 0 && (l = c.default);
      let u = She(l);
      if (!u && jP(l) && (l = Uhe(l, c), u = !0), u) {
        const d = nge(l, c);
        A[i] = d.evaluate.bind(d);
      } else
        c.type == "color" && (l = fi.parse(l)), A[i] = function() {
          return l;
        };
    }
    return oy.zoom = r, A[i](oy, n, o);
  }
  function n_(t, e, i, r, n) {
    return Je(
      t,
      "layout",
      `${r}-allow-overlap`,
      e,
      i,
      n
    ) ? Je(
      t,
      "layout",
      `${r}-ignore-placement`,
      e,
      i,
      n
    ) ? "none" : "obstacle" : "declutter";
  }
  function sge(t, e, i, r, n) {
    return n || console.warn("No filterCache provided to evaluateFilter()"), t in n || (n[t] = khe(e).filter), oy.zoom = r, n[t](oy, i);
  }
  function iA(t, e) {
    if (t) {
      if (t.a === 0 || e === 0)
        return;
      const i = t.a;
      return e = e === void 0 ? 1 : e, i === 0 ? "transparent" : "rgba(" + Math.round(t.r * 255 / i) + "," + Math.round(t.g * 255 / i) + "," + Math.round(t.b * 255 / i) + "," + i * e + ")";
    }
    return t;
  }
  const oge = /\{[^{}}]*\}/g;
  function BC(t, e) {
    return t.replace(oge, function(i) {
      return e[i.slice(1, -1)] || "";
    });
  }
  const age = {};
  function $P(t, e, i, r = Yo, n = void 0, s = void 0, o = void 0, a = void 0) {
    if (typeof e == "string" && (e = JSON.parse(e)), e.version != 8)
      throw new Error("glStyle version 8 required.");
    age[Whe(e, t)] = Array.from(arguments);
    let A, l, c;
    s && ed(() => s).then(async (I) => {
      let b;
      if (typeof Image < "u") {
        const B = new Image();
        if (typeof I == "string")
          B.crossOrigin = "anonymous", B.src = I;
        else {
          let x;
          I instanceof Request ? x = await fetch(I) : I instanceof Response && (x = I);
          const Q = await x.blob();
          b = URL.createObjectURL(Q), B.src = b;
        }
        B.addEventListener("load", function x() {
          B.removeEventListener("load", x), A = B, l = [B.width, B.height], t.changed(), b && URL.revokeObjectURL(b);
        }), B.addEventListener("error", function x() {
          URL.revokeObjectURL(b), B.removeEventListener("error", x);
        });
      } else if (typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope) {
        const B = (
          /** @type {*} */
          self
        );
        B.postMessage({
          action: "loadImage",
          src: I
        }), B.addEventListener("message", function(Q) {
          Q.data.action === "imageLoaded" && Q.data.src === I && (A = Q.data.image, l = [A.width, A.height]);
        });
      }
    });
    const u = IP(e.layers), d = {}, h = [], g = {}, f = {}, p = KP(e), m = Khe(e);
    let E;
    for (let I = 0, b = u.length; I < b; ++I) {
      const B = u[I], x = B.id;
      if (typeof i == "string" && B.source == i || Array.isArray(i) && i.indexOf(x) !== -1) {
        const Q = B["source-layer"];
        if (E) {
          if (B.source !== E)
            throw new Error(
              `Layer "${x}" does not use source "${E}`
            );
        } else {
          E = B.source;
          const T = e.sources[E];
          if (!T)
            throw new Error(`Source "${E}" is not defined`);
          const S = T.type;
          if (S !== "vector" && S !== "geojson")
            throw new Error(
              `Source "${E}" is not of type "vector" or "geojson", but "${S}"`
            );
        }
        let v = d[Q];
        v || (v = [], d[Q] = v), v.push({
          layer: B,
          index: I
        }), h.push(x);
      }
    }
    const y = new pr(), C = new vr(), w = [], M = function(I, b, B) {
      const x = I.getProperties(), Q = d[x.layer];
      if (!Q)
        return;
      let v = r.indexOf(b);
      v == -1 && (v = b1(b, r));
      const T = ige[I.getGeometry().getType()], S = {
        id: I.getId(),
        properties: x,
        type: T
      }, D = t.get("mapbox-featurestate")[I.getId()];
      let F = -1;
      for (let R = 0, Y = Q.length; R < Y; ++R) {
        const L = Q[R], N = L.layer, H = N.id;
        if (B !== void 0 && B !== H)
          continue;
        const P = N.layout || bM, ie = N.paint || bM;
        if (P.visibility === "none" || "minzoom" in N && v < N.minzoom || "maxzoom" in N && v >= N.maxzoom)
          continue;
        const V = N.filter;
        if (!V || sge(H, V, S, v, m)) {
          let Z, se, k, _, q, U;
          const J = L.index;
          if (T == 3 && (N.type == "fill" || N.type == "fill-extrusion"))
            if (se = Je(
              N,
              "paint",
              N.type + "-opacity",
              v,
              S,
              p,
              D
            ), N.type + "-pattern" in ie) {
              const rt = Je(
                N,
                "paint",
                N.type + "-pattern",
                v,
                S,
                p,
                D
              );
              if (rt) {
                const Ke = typeof rt == "string" ? BC(rt, x) : rt.toString();
                if (A && n && n[Ke]) {
                  ++F, U = w[F], (!U || !U.getFill() || U.getStroke() || U.getText()) && (U = new hi({
                    fill: new vr()
                  }), w[F] = U), k = U.getFill(), U.setZIndex(J);
                  const Qt = Ke + "." + se;
                  let Ht = f[Qt];
                  if (!Ht) {
                    const lt = n[Ke], Ft = ZB(
                      lt.width,
                      lt.height
                    ), si = (
                      /** @type {CanvasRenderingContext2D} */
                      Ft.getContext("2d")
                    );
                    si.globalAlpha = se, si.drawImage(
                      A,
                      lt.x,
                      lt.y,
                      lt.width,
                      lt.height,
                      0,
                      0,
                      lt.width,
                      lt.height
                    ), Ht = si.createPattern(Ft, "repeat"), f[Qt] = Ht;
                  }
                  k.setColor(Ht);
                }
              }
            } else
              Z = iA(
                Je(
                  N,
                  "paint",
                  N.type + "-color",
                  v,
                  S,
                  p,
                  D
                ),
                se
              ), N.type + "-outline-color" in ie && (q = iA(
                Je(
                  N,
                  "paint",
                  N.type + "-outline-color",
                  v,
                  S,
                  p,
                  D
                ),
                se
              )), q || (q = Z), (Z || q) && (++F, U = w[F], (!U || Z && !U.getFill() || !Z && U.getFill() || q && !U.getStroke() || !q && U.getStroke() || U.getText()) && (U = new hi({
                fill: Z ? new vr() : void 0,
                stroke: q ? new pr() : void 0
              }), w[F] = U), Z && (k = U.getFill(), k.setColor(Z)), q && (_ = U.getStroke(), _.setColor(q), _.setWidth(0.5)), U.setZIndex(J));
          if (T != 1 && N.type == "line") {
            "line-pattern" in ie ? Z = void 0 : Z = iA(
              Je(
                N,
                "paint",
                "line-color",
                v,
                S,
                p,
                D
              ),
              Je(
                N,
                "paint",
                "line-opacity",
                v,
                S,
                p,
                D
              )
            );
            const rt = Je(
              N,
              "paint",
              "line-width",
              v,
              S,
              p,
              D
            );
            Z && rt > 0 && (++F, U = w[F], (!U || !U.getStroke() || U.getFill() || U.getText()) && (U = new hi({
              stroke: new pr()
            }), w[F] = U), _ = U.getStroke(), _.setLineCap(
              Je(
                N,
                "layout",
                "line-cap",
                v,
                S,
                p,
                D
              )
            ), _.setLineJoin(
              Je(
                N,
                "layout",
                "line-join",
                v,
                S,
                p,
                D
              )
            ), _.setMiterLimit(
              Je(
                N,
                "layout",
                "line-miter-limit",
                v,
                S,
                p,
                D
              )
            ), _.setColor(Z), _.setWidth(rt), _.setLineDash(
              ie["line-dasharray"] ? Je(
                N,
                "paint",
                "line-dasharray",
                v,
                S,
                p,
                D
              ).map(function(Ke) {
                return Ke * rt;
              }) : null
            ), U.setZIndex(J));
          }
          let ae = !1, $ = null, Ce = 0, Re, Oe, K;
          if ((T == 1 || T == 2) && "icon-image" in P) {
            const rt = Je(
              N,
              "layout",
              "icon-image",
              v,
              S,
              p,
              D
            );
            if (rt) {
              Re = typeof rt == "string" ? BC(rt, x) : rt.toString();
              let Ke;
              const Qt = a ? a(t, Re) : void 0;
              if (A && n && n[Re] || Qt) {
                const Ht = Je(
                  N,
                  "layout",
                  "icon-rotation-alignment",
                  v,
                  S,
                  p,
                  D
                );
                if (T == 2) {
                  const lt = (
                    /** @type {*} */
                    I.getGeometry()
                  );
                  if (lt.getFlatMidpoint || lt.getFlatMidpoints) {
                    const Ft = lt.getExtent();
                    if (Math.sqrt(
                      Math.max(
                        Math.pow((Ft[2] - Ft[0]) / b, 2),
                        Math.pow((Ft[3] - Ft[1]) / b, 2)
                      )
                    ) > 150) {
                      const pi = lt.getType() === "MultiLineString" ? lt.getFlatMidpoints() : lt.getFlatMidpoint();
                      if (yC || (Np = [NaN, NaN], yC = new Ir(
                        "Point",
                        Np,
                        [],
                        2,
                        {},
                        void 0
                      )), Ke = yC, Np[0] = pi[0], Np[1] = pi[1], Je(
                        N,
                        "layout",
                        "symbol-placement",
                        v,
                        S,
                        p,
                        D
                      ) === "line" && Ht === "map") {
                        const Li = lt.getStride(), zi = lt.getFlatCoordinates();
                        for (let Ri = 0, ei = zi.length - Li; Ri < ei; Ri += Li) {
                          const oi = zi[Ri], Wi = zi[Ri + 1], Ki = zi[Ri + Li], Ut = zi[Ri + Li + 1], zr = Math.min(oi, Ki), an = Math.max(oi, Ki), An = pi[0], Wn = pi[1], oe = (Ut - Wi) * (An - oi) - (Ki - oi) * (Wn - Wi);
                          if (Math.abs(oe) < 1e-3 && //midpoint is aligned with the segment
                          An <= an && An >= zr) {
                            Ce = Math.atan2(Wi - Ut, Ki - oi);
                            break;
                          }
                        }
                      }
                    }
                  }
                }
                if (T !== 2 || Ke) {
                  const lt = Je(
                    N,
                    "layout",
                    "icon-size",
                    v,
                    S,
                    p,
                    D
                  ), Ft = ie["icon-color"] !== void 0 ? Je(
                    N,
                    "paint",
                    "icon-color",
                    v,
                    S,
                    p,
                    D
                  ) : null;
                  if (!Ft || Ft.a !== 0) {
                    const si = Je(
                      N,
                      "paint",
                      "icon-halo-color",
                      v,
                      S,
                      p,
                      D
                    ), pi = Je(
                      N,
                      "paint",
                      "icon-halo-width",
                      v,
                      S,
                      p,
                      D
                    );
                    let Ti = `${Re}.${lt}.${pi}.${si}`;
                    if (Ft !== null && (Ti += `.${Ft}`), Oe = g[Ti], !Oe) {
                      const Li = n_(
                        N,
                        v,
                        S,
                        "icon",
                        p
                      );
                      let zi;
                      "icon-offset" in P && (zi = Je(
                        N,
                        "layout",
                        "icon-offset",
                        v,
                        S,
                        p,
                        D
                      ).slice(0), zi[0] *= lt, zi[1] *= -lt);
                      let Ri = Ft ? [
                        Ft.r * 255,
                        Ft.g * 255,
                        Ft.b * 255,
                        Ft.a
                      ] : void 0;
                      if (Qt) {
                        const ei = {
                          color: Ri,
                          rotateWithView: Ht === "map",
                          displacement: zi,
                          declutterMode: Li,
                          scale: lt
                        };
                        typeof Qt == "string" ? ei.src = Qt : (ei.img = Qt, ei.imgSize = [
                          Qt.width,
                          Qt.height
                        ]), Oe = new Ol(ei);
                      } else {
                        const ei = n[Re];
                        let oi, Wi, Ki;
                        pi ? ei.sdf ? (oi = t_(
                          i_(
                            A,
                            ei,
                            Ft || [0, 0, 0, 1]
                          ),
                          {
                            x: 0,
                            y: 0,
                            width: ei.width,
                            height: ei.height,
                            pixelRatio: ei.pixelRatio
                          },
                          pi,
                          si
                        ), Ri = void 0) : oi = t_(
                          A,
                          ei,
                          pi,
                          si
                        ) : (ei.sdf ? (c || (c = i_(
                          A,
                          {
                            x: 0,
                            y: 0,
                            width: l[0],
                            height: l[1]
                          },
                          { r: 1, g: 1, b: 1 }
                        )), oi = c) : oi = A, Wi = [ei.width, ei.height], Ki = [ei.x, ei.y]), Oe = new Ol({
                          color: Ri,
                          img: oi,
                          // @ts-ignore
                          imgSize: l,
                          size: Wi,
                          offset: Ki,
                          rotateWithView: Ht === "map",
                          scale: lt / ei.pixelRatio,
                          displacement: zi,
                          declutterMode: Li
                        });
                      }
                      g[Ti] = Oe;
                    }
                  }
                  Oe && (++F, U = w[F], (!U || !U.getImage() || U.getFill() || U.getStroke()) && (U = new hi(), w[F] = U), U.setGeometry(Ke), Oe.setRotation(
                    Ce + pC(
                      Je(
                        N,
                        "layout",
                        "icon-rotate",
                        v,
                        S,
                        p,
                        D
                      )
                    )
                  ), Oe.setOpacity(
                    Je(
                      N,
                      "paint",
                      "icon-opacity",
                      v,
                      S,
                      p,
                      D
                    )
                  ), Oe.setAnchor(
                    rge[Je(
                      N,
                      "layout",
                      "icon-anchor",
                      v,
                      S,
                      p,
                      D
                    )]
                  ), U.setImage(Oe), $ = U.getText(), U.setText(void 0), U.setZIndex(J), ae = !0, K = !1);
                } else
                  K = !0;
              }
            }
          }
          if (T == 1 && N.type === "circle") {
            ++F, U = w[F], (!U || !U.getImage() || U.getFill() || U.getStroke()) && (U = new hi(), w[F] = U);
            const rt = "circle-radius" in ie ? Je(
              N,
              "paint",
              "circle-radius",
              v,
              S,
              p,
              D
            ) : 5, Ke = iA(
              Je(
                N,
                "paint",
                "circle-stroke-color",
                v,
                S,
                p,
                D
              ),
              Je(
                N,
                "paint",
                "circle-stroke-opacity",
                v,
                S,
                p,
                D
              )
            ), Qt = Je(
              N,
              "paint",
              "circle-translate",
              v,
              S,
              p,
              D
            ), Ht = iA(
              Je(
                N,
                "paint",
                "circle-color",
                v,
                S,
                p,
                D
              ),
              Je(
                N,
                "paint",
                "circle-opacity",
                v,
                S,
                p,
                D
              )
            ), lt = Je(
              N,
              "paint",
              "circle-stroke-width",
              v,
              S,
              p,
              D
            ), Ft = rt + "." + Ke + "." + Ht + "." + lt + "." + Qt[0] + "." + Qt[1];
            Oe = g[Ft], Oe || (Oe = new Sa({
              radius: rt,
              displacement: [Qt[0], -Qt[1]],
              stroke: Ke && lt > 0 ? new pr({
                width: lt,
                color: Ke
              }) : void 0,
              fill: Ht ? new vr({
                color: Ht
              }) : void 0,
              declutterMode: "none"
            }), g[Ft] = Oe), U.setImage(Oe), $ = U.getText(), U.setText(void 0), U.setGeometry(void 0), U.setZIndex(J), ae = !0;
          }
          let Ae, ut, Me, Fe, jt, Rt;
          if ("text-field" in P) {
            Fe = Math.round(
              Je(
                N,
                "layout",
                "text-size",
                v,
                S,
                p,
                D
              )
            );
            const rt = Je(
              N,
              "layout",
              "text-font",
              v,
              S,
              p,
              D
            );
            Me = Je(
              N,
              "layout",
              "text-line-height",
              v,
              S,
              p,
              D
            ), ut = BM(
              o ? o(
                rt,
                e.metadata ? e.metadata["ol:webfonts"] : void 0
              ) : rt,
              Fe,
              Me
            ), ut.includes("sans-serif") || (ut += ",sans-serif"), jt = Je(
              N,
              "layout",
              "text-letter-spacing",
              v,
              S,
              p,
              D
            ), Rt = Je(
              N,
              "layout",
              "text-max-width",
              v,
              S,
              p,
              D
            );
            const Ke = Je(
              N,
              "layout",
              "text-field",
              v,
              S,
              p,
              D
            );
            typeof Ke == "object" && Ke.sections ? Ke.sections.length === 1 ? Ae = Ke.toString() : Ae = Ke.sections.reduce((Qt, Ht, lt) => {
              const Ft = Ht.fontStack ? Ht.fontStack.split(",") : rt, si = BM(
                o ? o(Ft) : Ft,
                Fe * (Ht.scale || 1),
                Me
              );
              let pi = Ht.text;
              if (pi === `
`)
                return Qt.push(`
`, ""), Qt;
              if (T == 2)
                return Qt.push(wM(pi, jt), si), Qt;
              pi = CM(
                pi,
                si,
                Rt,
                jt
              ).split(`
`);
              for (let Ti = 0, Li = pi.length; Ti < Li; ++Ti)
                Ti > 0 && Qt.push(`
`, ""), Qt.push(pi[Ti], si);
              return Qt;
            }, []) : Ae = BC(Ke, x).trim(), se = Je(
              N,
              "paint",
              "text-opacity",
              v,
              S,
              p,
              D
            );
          }
          if (Ae && se && !K) {
            ae || (++F, U = w[F], (!U || !U.getText() || U.getFill() || U.getStroke()) && (U = new hi(), w[F] = U), U.setImage(void 0), U.setGeometry(void 0));
            const rt = n_(
              N,
              v,
              S,
              "text",
              p
            );
            U.getText() || U.setText($), $ = U.getText(), (!$ || "getDeclutterMode" in $ && $.getDeclutterMode() !== rt) && ($ = new pB({
              padding: [2, 2, 2, 2],
              // @ts-ignore
              declutterMode: rt
            }), U.setText($));
            const Ke = Je(
              N,
              "layout",
              "text-transform",
              v,
              S,
              p,
              D
            );
            Ke == "uppercase" ? Ae = Array.isArray(Ae) ? Ae.map((Ut, zr) => zr % 2 ? Ut : Ut.toUpperCase()) : Ae.toUpperCase() : Ke == "lowercase" && (Ae = Array.isArray(Ae) ? Ae.map((Ut, zr) => zr % 2 ? Ut : Ut.toLowerCase()) : Ae.toLowerCase());
            const Qt = Array.isArray(Ae) ? Ae : T == 2 ? wM(Ae, jt) : CM(Ae, ut, Rt, jt);
            if ($.setText(Qt), $.setFont(ut), $.setRotation(
              pC(
                Je(
                  N,
                  "layout",
                  "text-rotate",
                  v,
                  S,
                  p,
                  D
                )
              )
            ), typeof $.setKeepUpright == "function") {
              const Ut = Je(
                N,
                "layout",
                "text-keep-upright",
                v,
                S,
                p,
                D
              );
              $.setKeepUpright(Ut);
            }
            const Ht = Je(
              N,
              "layout",
              "text-anchor",
              v,
              S,
              p,
              D
            ), lt = ae || T == 1 ? "point" : Je(
              N,
              "layout",
              "symbol-placement",
              v,
              S,
              p,
              D
            );
            let Ft;
            if (lt === "line-center" ? ($.setPlacement("line"), Ft = "center") : $.setPlacement(lt), lt === "line" && typeof $.setRepeat == "function") {
              const Ut = Je(
                N,
                "layout",
                "symbol-spacing",
                v,
                S,
                p,
                D
              );
              $.setRepeat(Ut * 2);
            }
            $.setOverflow(lt === "point");
            let si = Je(
              N,
              "paint",
              "text-halo-width",
              v,
              S,
              p,
              D
            );
            const pi = Je(
              N,
              "layout",
              "text-offset",
              v,
              S,
              p,
              D
            ), Ti = Je(
              N,
              "paint",
              "text-translate",
              v,
              S,
              p,
              D
            );
            let Li = 0, zi = 0;
            if (lt == "point") {
              Ft = "center", Ht.indexOf("left") !== -1 ? (Ft = "left", zi = si) : Ht.indexOf("right") !== -1 && (Ft = "right", zi = -si);
              const Ut = Je(
                N,
                "layout",
                "text-rotation-alignment",
                v,
                S,
                p,
                D
              );
              $.setRotateWithView(Ut == "map");
            } else
              $.setMaxAngle(
                pC(
                  Je(
                    N,
                    "layout",
                    "text-max-angle",
                    v,
                    S,
                    p,
                    D
                  )
                ) * Ae.length / Qt.length
              ), $.setRotateWithView(!1);
            $.setTextAlign(Ft);
            let Ri = "middle";
            Ht.indexOf("bottom") == 0 ? (Ri = "bottom", Li = -si - 0.5 * (Me - 1) * Fe) : Ht.indexOf("top") == 0 && (Ri = "top", Li = si + 0.5 * (Me - 1) * Fe), $.setTextBaseline(Ri);
            const ei = Je(
              N,
              "layout",
              "text-justify",
              v,
              S,
              p,
              D
            );
            $.setJustify(ei === "auto" ? void 0 : ei), $.setOffsetX(
              pi[0] * Fe + zi + Ti[0]
            ), $.setOffsetY(
              pi[1] * Fe + Li + Ti[1]
            ), C.setColor(
              iA(
                Je(
                  N,
                  "paint",
                  "text-color",
                  v,
                  S,
                  p,
                  D
                ),
                se
              )
            ), $.setFill(C);
            const oi = iA(
              Je(
                N,
                "paint",
                "text-halo-color",
                v,
                S,
                p,
                D
              ),
              se
            );
            if (oi && si > 0) {
              y.setColor(oi), si *= 2;
              const Ut = 0.5 * Fe;
              y.setWidth(
                si <= Ut ? si : Ut
              ), $.setStroke(y);
            } else
              $.setStroke(void 0);
            const Wi = Je(
              N,
              "layout",
              "text-padding",
              v,
              S,
              p,
              D
            ), Ki = $.getPadding();
            Wi !== Ki[0] && (Ki[0] = Wi, Ki[1] = Wi, Ki[2] = Wi, Ki[3] = Wi), U.setZIndex(J);
          }
        }
      }
      if (F > -1)
        return w.length = F + 1, w;
    };
    return t.setStyle(M), t.set("mapbox-source", E), t.set("mapbox-layers", h), t.set("mapbox-featurestate", t.get("mapbox-featurestate") || {}), M;
  }
  function e4(t) {
    return function(e) {
      const i = e.buffers, r = e.meta, n = e.imageOps, s = e.width, o = e.height, a = i.length, A = i[0].byteLength;
      if (n) {
        const d = new Array(a);
        for (let g = 0; g < a; ++g)
          d[g] = new ImageData(
            new Uint8ClampedArray(i[g]),
            s,
            o
          );
        return t(d, r).data.buffer;
      }
      const l = new Uint8ClampedArray(A), c = new Array(a), u = new Array(a);
      for (let d = 0; d < a; ++d)
        c[d] = new Uint8ClampedArray(i[d]), u[d] = [0, 0, 0, 0];
      for (let d = 0; d < A; d += 4) {
        for (let g = 0; g < a; ++g) {
          const f = c[g];
          u[g][0] = f[d], u[g][1] = f[d + 1], u[g][2] = f[d + 2], u[g][3] = f[d + 3];
        }
        const h = t(u, r);
        l[d] = h[0], l[d + 1] = h[1], l[d + 2] = h[2], l[d + 3] = h[3];
      }
      return l.buffer;
    };
  }
  function Age(t, e) {
    const r = Object.keys(t.lib || {}).map(function(s) {
      return "const " + s + " = " + t.lib[s].toString() + ";";
    }).concat([
      "const __minion__ = (" + e4.toString() + ")(",
      t.operation.toString(),
      ");",
      'self.addEventListener("message", function(event) {',
      "  const buffer = __minion__(event.data);",
      "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);",
      "});"
    ]), n = new Worker(
      typeof Blob > "u" ? "data:text/javascript;base64," + Buffer.from(r.join(`
`), "binary").toString("base64") : URL.createObjectURL(new Blob(r, { type: "text/javascript" }))
    );
    return n.addEventListener("message", e), n;
  }
  function lge(t, e) {
    const i = e4(t.operation);
    let r = !1;
    return {
      postMessage: function(n) {
        setTimeout(function() {
          r || e({ data: { buffer: i(n), meta: n.meta } });
        }, 0);
      },
      terminate: function() {
        r = !0;
      }
    };
  }
  class cge extends Td {
    /**
     * @param {ProcessorOptions} config Configuration.
     */
    constructor(e) {
      super(), this.imageOps_ = !!e.imageOps;
      let i;
      e.threads === 0 ? i = 0 : this.imageOps_ ? i = 1 : i = e.threads || 1;
      const r = new Array(i);
      if (i)
        for (let n = 0; n < i; ++n)
          r[n] = Age(e, this.onWorkerMessage_.bind(this, n));
      else
        r[0] = lge(
          e,
          this.onWorkerMessage_.bind(this, 0)
        );
      this.workers_ = r, this.queue_ = [], this.maxQueueLength_ = e.queue || 1 / 0, this.running_ = 0, this.dataLookup_ = {}, this.job_ = null;
    }
    /**
     * Run operation on input data.
     * @param {Array<ImageData>} inputs Array of image data.
     * @param {Object} meta A user data object.  This is passed to all operations
     *     and must be serializable.
     * @param {function(Error, ImageData, Object): void} callback Called when work
     *     completes.  The first argument is any error.  The second is the ImageData
     *     generated by operations.  The third is the user data object.
     */
    process(e, i, r) {
      this.enqueue_({
        inputs: e,
        meta: i,
        callback: r
      }), this.dispatch_();
    }
    /**
     * Add a job to the queue.
     * @param {Job} job The job.
     */
    enqueue_(e) {
      for (this.queue_.push(e); this.queue_.length > this.maxQueueLength_; )
        this.queue_.shift().callback(null, null);
    }
    /**
     * Dispatch a job.
     */
    dispatch_() {
      if (this.running_ || this.queue_.length === 0)
        return;
      const e = this.queue_.shift();
      this.job_ = e;
      const i = e.inputs[0].width, r = e.inputs[0].height, n = e.inputs.map(function(A) {
        return A.data.buffer;
      }), s = this.workers_.length;
      if (this.running_ = s, s === 1) {
        this.workers_[0].postMessage(
          {
            buffers: n,
            meta: e.meta,
            imageOps: this.imageOps_,
            width: i,
            height: r
          },
          n
        );
        return;
      }
      const o = e.inputs[0].data.length, a = 4 * Math.ceil(o / 4 / s);
      for (let A = 0; A < s; ++A) {
        const l = A * a, c = [];
        for (let u = 0, d = n.length; u < d; ++u)
          c.push(n[u].slice(l, l + a));
        this.workers_[A].postMessage(
          {
            buffers: c,
            meta: e.meta,
            imageOps: this.imageOps_,
            width: i,
            height: r
          },
          c
        );
      }
    }
    /**
     * Handle messages from the worker.
     * @param {number} index The worker index.
     * @param {MessageEvent} event The message event.
     */
    onWorkerMessage_(e, i) {
      this.disposed || (this.dataLookup_[e] = i.data, --this.running_, this.running_ === 0 && this.resolveJob_());
    }
    /**
     * Resolve a job.  If there are no more worker threads, the processor callback
     * will be called.
     */
    resolveJob_() {
      const e = this.job_, i = this.workers_.length;
      let r, n;
      if (i === 1)
        r = new Uint8ClampedArray(this.dataLookup_[0].buffer), n = this.dataLookup_[0].meta;
      else {
        const s = e.inputs[0].data.length;
        r = new Uint8ClampedArray(s), n = new Array(i);
        const o = 4 * Math.ceil(s / 4 / i);
        for (let a = 0; a < i; ++a) {
          const A = this.dataLookup_[a].buffer, l = a * o;
          r.set(new Uint8ClampedArray(A), l), n[a] = this.dataLookup_[a].meta;
        }
      }
      this.job_ = null, this.dataLookup_ = {}, e.callback(
        null,
        new ImageData(r, e.inputs[0].width, e.inputs[0].height),
        n
      ), this.dispatch_();
    }
    /**
     * Terminate all workers associated with the processor.
     * @override
     */
    disposeInternal() {
      for (let e = 0; e < this.workers_.length; ++e)
        this.workers_[e].terminate();
      this.workers_.length = 0;
    }
  }
  const s_ = {
    /**
     * Triggered before operations are run.  Listeners will receive an event object with
     * a `data` property that can be used to make data available to operations.
     * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations
     * @api
     */
    BEFOREOPERATIONS: "beforeoperations",
    /**
     * Triggered after operations are run.  Listeners will receive an event object with
     * a `data` property.  If more than one thread is used, `data` will be an array of
     * objects.  If a single thread is used, `data` will be a single object.
     * @event module:ol/source/Raster.RasterSourceEvent#afteroperations
     * @api
     */
    AFTEROPERATIONS: "afteroperations"
  };
  class o_ extends on {
    /**
     * @param {string} type Type.
     * @param {import("../Map.js").FrameState} frameState The frame state.
     * @param {Object|Array<Object>} data An object made available to operations.  For "afteroperations" evenets
     * this will be an array of objects if more than one thread is used.
     */
    constructor(e, i, r) {
      super(e), this.extent = i.extent, this.resolution = i.viewState.resolution / i.pixelRatio, this.data = r;
    }
  }
  class t4 extends Qx {
    /**
     * @param {Options} options Options.
     */
    constructor(e) {
      super({
        projection: null
      }), this.on, this.once, this.un, this.processor_ = null, this.operationType_ = e.operationType !== void 0 ? e.operationType : "pixel", this.threads_ = e.threads !== void 0 ? e.threads : 1, this.layers_ = hge(e.sources);
      const i = this.changed.bind(this);
      for (let r = 0, n = this.layers_.length; r < n; ++r)
        this.layers_[r].addEventListener(Ge.CHANGE, i);
      this.useResolutions_ = e.resolutions !== null, this.tileQueue_ = new nL(function() {
        return 1;
      }, this.processSources_.bind(this)), this.requestedFrameState_, this.renderedImageCanvas_ = null, this.renderedRevision_, this.frameState_ = {
        animate: !1,
        coordinateToPixelTransform: ri(),
        declutter: null,
        extent: null,
        index: 0,
        layerIndex: 0,
        layerStatesArray: dge(this.layers_),
        pixelRatio: 1,
        pixelToCoordinateTransform: ri(),
        postRenderFunctions: [],
        size: [0, 0],
        tileQueue: this.tileQueue_,
        time: Date.now(),
        usedTiles: {},
        viewState: (
          /** @type {import("../View.js").State} */
          {
            rotation: 0
          }
        ),
        viewHints: [],
        wantedTiles: {},
        mapId: ve(this),
        renderTargets: {}
      }, this.setAttributions(function(r) {
        var s;
        const n = [];
        for (let o = 0, a = e.sources.length; o < a; ++o) {
          const A = e.sources[o], l = A instanceof Nd ? A : A.getSource();
          if (!l)
            continue;
          const c = (s = l.getAttributions()) == null ? void 0 : s(r);
          typeof c == "string" ? n.push(c) : c !== void 0 && n.push(...c);
        }
        return n;
      }), e.operation !== void 0 && this.setOperation(e.operation, e.lib);
    }
    /**
     * Set the operation.
     * @param {Operation} operation New operation.
     * @param {Object} [lib] Functions that will be available to operations run
     *     in a worker.
     * @api
     */
    setOperation(e, i) {
      this.processor_ && this.processor_.dispose(), this.processor_ = new cge({
        operation: e,
        imageOps: this.operationType_ === "image",
        queue: 1,
        lib: i,
        threads: this.threads_
      }), this.changed();
    }
    /**
     * Update the stored frame state.
     * @param {import("../extent.js").Extent} extent The view extent (in map units).
     * @param {number} resolution The view resolution.
     * @param {import("../proj/Projection.js").default} projection The view projection.
     * @return {import("../Map.js").FrameState} The updated frame state.
     * @private
     */
    updateFrameState_(e, i, r) {
      const n = (
        /** @type {import("../Map.js").FrameState} */
        Object.assign({}, this.frameState_)
      );
      n.viewState = /** @type {import("../View.js").State} */
      Object.assign({}, n.viewState);
      const s = xn(e);
      n.size[0] = Math.ceil(mt(e) / i), n.size[1] = Math.ceil(Fi(e) / i), n.extent = [
        s[0] - n.size[0] * i / 2,
        s[1] - n.size[1] * i / 2,
        s[0] + n.size[0] * i / 2,
        s[1] + n.size[1] * i / 2
      ], n.time = Date.now();
      const o = n.viewState;
      return o.center = s, o.projection = r, o.resolution = i, n;
    }
    /**
     * Determine if all sources are ready.
     * @return {boolean} All sources are ready.
     * @private
     */
    allSourcesReady_() {
      let e = !0, i;
      for (let r = 0, n = this.layers_.length; r < n; ++r)
        if (i = this.layers_[r].getSource(), !i || i.getState() !== "ready") {
          e = !1;
          break;
        }
      return e;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../ImageCanvas.js").default} Single image.
     * @override
     */
    getImage(e, i, r, n) {
      if (!this.allSourcesReady_())
        return null;
      this.tileQueue_.loadMoreTiles(16, 16), i = this.findNearestResolution(i);
      const s = this.updateFrameState_(e, i, n);
      if (this.requestedFrameState_ = s, this.renderedImageCanvas_) {
        const o = this.renderedImageCanvas_.getResolution(), a = this.renderedImageCanvas_.getExtent();
        (i !== o || !Zs(s.extent, a)) && (this.renderedImageCanvas_ = null);
      }
      return (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) && this.processSources_(), s.animate && requestAnimationFrame(this.changed.bind(this)), this.renderedImageCanvas_;
    }
    /**
     * Start processing source data.
     * @private
     */
    processSources_() {
      const e = this.requestedFrameState_, i = this.layers_.length, r = new Array(i);
      for (let s = 0; s < i; ++s) {
        e.layerIndex = s, e.renderTargets = {};
        const o = uge(this.layers_[s], e);
        if (o)
          r[s] = o;
        else
          return;
      }
      const n = {};
      this.dispatchEvent(
        new o_(s_.BEFOREOPERATIONS, e, n)
      ), this.processor_.process(
        r,
        n,
        this.onWorkerComplete_.bind(this, e)
      );
    }
    /**
     * Called when pixel processing is complete.
     * @param {import("../Map.js").FrameState} frameState The frame state.
     * @param {Error} err Any error during processing.
     * @param {ImageData} output The output image data.
     * @param {Object|Array<Object>} data The user data (or an array if more than one thread).
     * @private
     */
    onWorkerComplete_(e, i, r, n) {
      if (i || !r)
        return;
      const s = e.extent, o = e.viewState.resolution;
      if (o !== this.requestedFrameState_.viewState.resolution || !Zs(s, this.requestedFrameState_.extent))
        return;
      let a;
      if (this.renderedImageCanvas_)
        a = this.renderedImageCanvas_.getImage().getContext("2d");
      else {
        const A = Math.round(mt(s) / o), l = Math.round(Fi(s) / o);
        a = Di(A, l), this.renderedImageCanvas_ = new Jte(
          s,
          o,
          1,
          a.canvas
        );
      }
      a.putImageData(r, 0, 0), e.animate ? requestAnimationFrame(this.changed.bind(this)) : this.changed(), this.renderedRevision_ = this.getRevision(), this.dispatchEvent(
        new o_(s_.AFTEROPERATIONS, e, n)
      );
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     * @override
     */
    getResolutions(e) {
      if (!this.useResolutions_)
        return null;
      let i = super.getResolutions();
      if (!i)
        for (let r = 0, n = this.layers_.length; r < n && (i = this.layers_[r].getSource().getResolutions(e), !i); ++r)
          ;
      return i;
    }
    /**
     * @override
     */
    disposeInternal() {
      this.processor_ && this.processor_.dispose(), super.disposeInternal();
    }
  }
  t4.prototype.dispose;
  let sl = null;
  function uge(t, e) {
    const i = t.getRenderer();
    if (!i)
      throw new Error("Unsupported layer type: " + t);
    if (!i.prepareFrame(e))
      return null;
    const r = e.size[0], n = e.size[1];
    if (r === 0 || n === 0)
      return null;
    const s = i.renderFrame(e, null);
    let o;
    if (s instanceof HTMLCanvasElement)
      o = s;
    else {
      if (s && (o = s.firstElementChild), !(o instanceof HTMLCanvasElement))
        throw new Error("Unsupported rendered element: " + o);
      if (o.width === r && o.height === n)
        return o.getContext("2d").getImageData(0, 0, r, n);
    }
    if (!sl)
      sl = Di(r, n, void 0, {
        willReadFrequently: !0
      });
    else {
      const a = sl.canvas;
      a.width !== r || a.height !== n ? sl = Di(r, n, void 0, {
        willReadFrequently: !0
      }) : sl.clearRect(0, 0, r, n);
    }
    return sl.drawImage(o, 0, 0, r, n), sl.getImageData(0, 0, r, n);
  }
  function dge(t) {
    return t.map(function(e) {
      return e.getLayerState();
    });
  }
  function hge(t) {
    const e = t.length, i = new Array(e);
    for (let r = 0; r < e; ++r)
      i[r] = gge(t[r]);
    return i;
  }
  function gge(t) {
    let e;
    return t instanceof Nd ? t instanceof vz ? e = new SB({ source: t }) : t instanceof Qx && (e = new Ix({ source: t })) : e = t, e;
  }
  function fge(t, e, i, r) {
    const n = document.createElement("script"), s = "olc_" + ve(e);
    function o() {
      delete window[s], n.parentNode.removeChild(n);
    }
    n.async = !0, n.src = t + (t.includes("?") ? "&" : "?") + "callback=" + s;
    const a = setTimeout(function() {
      o(), i && i();
    }, 1e4);
    window[s] = function(A) {
      clearTimeout(a), o(), e(A);
    }, document.head.appendChild(n);
  }
  class i4 extends xx {
    /**
     * @param {Options} options TileJSON options.
     */
    constructor(e) {
      if (super({
        attributions: e.attributions,
        cacheSize: e.cacheSize,
        crossOrigin: e.crossOrigin,
        interpolate: e.interpolate,
        projection: Xe("EPSG:3857"),
        reprojectionErrorThreshold: e.reprojectionErrorThreshold,
        state: "loading",
        tileLoadFunction: e.tileLoadFunction,
        wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
        transition: e.transition,
        zDirection: e.zDirection
      }), this.tileJSON_ = null, this.tileSize_ = e.tileSize, e.url)
        if (e.jsonp)
          fge(
            e.url,
            this.handleTileJSONResponse.bind(this),
            this.handleTileJSONError.bind(this)
          );
        else {
          const i = new XMLHttpRequest();
          i.addEventListener("load", this.onXHRLoad_.bind(this)), i.addEventListener("error", this.onXHRError_.bind(this)), i.open("GET", e.url), i.send();
        }
      else if (e.tileJSON)
        this.handleTileJSONResponse(e.tileJSON);
      else
        throw new Error("Either `url` or `tileJSON` options must be provided");
    }
    /**
     * @private
     * @param {Event} event The load event.
     */
    onXHRLoad_(e) {
      const i = (
        /** @type {XMLHttpRequest} */
        e.target
      );
      if (!i.status || i.status >= 200 && i.status < 300) {
        let r;
        try {
          r = /** @type {Config} */
          JSON.parse(i.responseText);
        } catch {
          this.handleTileJSONError();
          return;
        }
        this.handleTileJSONResponse(r);
      } else
        this.handleTileJSONError();
    }
    /**
     * @private
     * @param {Event} event The error event.
     */
    onXHRError_(e) {
      this.handleTileJSONError();
    }
    /**
     * @return {Config} The tilejson object.
     * @api
     */
    getTileJSON() {
      return this.tileJSON_;
    }
    /**
     * @protected
     * @param {Config} tileJSON Tile JSON.
     */
    handleTileJSONResponse(e) {
      const i = Xe("EPSG:4326"), r = this.getProjection();
      let n;
      if (e.bounds !== void 0) {
        const l = Af(
          i,
          r
        );
        n = qN(e.bounds, l);
      }
      const s = bf(r), o = e.minzoom || 0, a = e.maxzoom || 22, A = vx({
        extent: s,
        maxZoom: a,
        minZoom: o,
        tileSize: this.tileSize_
      });
      if (this.tileGrid = A, this.tileUrlFunction = Qz(e.tiles, A), e.attribution && !this.getAttributions()) {
        const l = n !== void 0 ? n : s;
        this.setAttributions(function(c) {
          return Yi(l, c.extent) ? [e.attribution] : null;
        });
      }
      this.tileJSON_ = e, this.setState("ready");
    }
    /**
     * @protected
     */
    handleTileJSONError() {
      this.setState("error");
    }
  }
  function pge(t, e) {
    const i = t[0], r = i.width, n = i.height, s = i.data, o = new Uint8ClampedArray(s.length), a = e.resolution * 2, A = r - 1, l = n - 1, c = [0, 0, 0, 0], u = 2 * Math.PI, d = Math.PI / 2, h = Math.PI * e.sunEl / 180, g = Math.PI * e.sunAz / 180, f = Math.cos(h), p = Math.sin(h), m = e.highlightColor, E = e.shadowColor, y = e.accentColor, C = e.encoding;
    let w, M, I, b, B, x, Q, v, T, S, D, F, R, Y, L, N, H, P, ie, V, Z, se;
    function k(_, q = "mapbox") {
      if (q === "mapbox")
        return (_[0] * 256 * 256 + _[1] * 256 + _[2]) * 0.1 - 1e4;
      if (q === "terrarium")
        return _[0] * 256 + _[1] + _[2] / 256 - 32768;
    }
    for (M = 0; M <= l; ++M)
      for (B = M === 0 ? 0 : M - 1, x = M === l ? l : M + 1, w = 0; w <= A; ++w)
        I = w === 0 ? 0 : w - 1, b = w === A ? A : w + 1, Q = (M * r + I) * 4, c[0] = s[Q], c[1] = s[Q + 1], c[2] = s[Q + 2], c[3] = s[Q + 3], v = e.vert * k(c, C), Q = (M * r + b) * 4, c[0] = s[Q], c[1] = s[Q + 1], c[2] = s[Q + 2], c[3] = s[Q + 3], T = e.vert * k(c, C), S = (T - v) / a, Q = (B * r + w) * 4, c[0] = s[Q], c[1] = s[Q + 1], c[2] = s[Q + 2], c[3] = s[Q + 3], v = e.vert * k(c, C), Q = (x * r + w) * 4, c[0] = s[Q], c[1] = s[Q + 1], c[2] = s[Q + 2], c[3] = s[Q + 3], T = e.vert * k(c, C), D = (T - v) / a, R = Math.atan2(D, -S), R < 0 ? R = d - R : R > d ? R = u - R + d : R = d - R, F = Math.atan(Math.sqrt(S * S + D * D)), se = p * Math.cos(F) + f * Math.sin(F) * Math.cos(g - R), Y = Math.cos(F), L = 255 * se, ie = Math.min(Math.max(2 * e.sunEl, 0), 1), V = 1.875 - e.opacity * 1.75, Z = e.opacity !== 0.5 ? d * ((Math.pow(V, F) - 1) / (Math.pow(V, d) - 1)) : F, H = {
          r: (1 - Y) * y.r * ie * 255,
          g: (1 - Y) * y.g * ie * 255,
          b: (1 - Y) * y.b * ie * 255,
          a: (1 - Y) * y.a * ie * 255
        }, N = Math.abs(((R + g) / Math.PI + 0.5) % 2 - 1), P = {
          r: (m.r * (1 - N) + E.r * N) * L,
          g: (m.g * (1 - N) + E.g * N) * L,
          b: (m.b * (1 - N) + E.b * N) * L,
          a: (m.a * (1 - N) + E.a * N) * L
        }, Q = (M * r + w) * 4, o[Q] = H.r * (1 - N) + P.r, o[Q + 1] = H.g * (1 - N) + P.g, o[Q + 2] = H.b * (1 - N) + P.b, o[Q + 3] = s[Q + 3] * e.opacity * ie * Math.sin(Z);
    return new ImageData(o, r, n);
  }
  function mge(t, e = 512) {
    return t.getExtent() ? vx({
      extent: t.getExtent(),
      tileSize: e,
      maxZoom: 22
    }).getResolutions() : Yo;
  }
  function r4(t, e) {
    return e.accessToken || (e = Object.assign({}, e), new URL(t).searchParams.forEach((r, n) => {
      e.accessToken = r, e.accessTokenParam = n;
    })), e;
  }
  function Ege(t, e, i = "", r = {}, n = void 0) {
    let s, o, a, A, l = !0;
    return typeof i != "string" && !Array.isArray(i) ? (a = i, A = a.source || a.layers, r = a) : A = i, typeof r == "string" ? (s = r, a = {}) : (s = r.styleUrl, a = r), a.updateSource === !1 && (l = !1), n || (n = a.resolutions), !s && typeof e == "string" && !e.trim().startsWith("{") && (s = e), s && (s = s.startsWith("data:") ? location.href : sy(s, a.accessToken), a = r4(s, a)), new Promise(function(c, u) {
      XP(e, a).then(function(d) {
        if (d.version != 8)
          return u(new Error("glStyle version 8 required."));
        if (!(t instanceof Bs || t instanceof Sl))
          return u(
            new Error("Can only apply to VectorLayer or VectorTileLayer")
          );
        const h = t instanceof Sl ? "vector" : "geojson";
        if (A ? Array.isArray(A) ? o = d.layers.find(function(C) {
          return C.id === A[0];
        }).source : o = A : (o = Object.keys(d.sources).find(function(C) {
          return d.sources[C].type === h;
        }), A = o), !o)
          return u(new Error(`No ${h} source found in the glStyle.`));
        function g() {
          if (!l)
            return Promise.resolve();
          if (t instanceof Sl)
            return o4(
              d.sources[o],
              s,
              a
            ).then(function(I) {
              const b = t.getSource();
              b ? I !== b && (b.setTileUrlFunction(I.getTileUrlFunction()), typeof b.setUrls == "function" && typeof I.getUrls == "function" && b.setUrls(I.getUrls()), b.format_ || (b.format_ = I.format_), b.getAttributions() || b.setAttributions(I.getAttributions()), b.getTileLoadFunction() === MP && b.setTileLoadFunction(
                I.getTileLoadFunction()
              ), Fo(
                b.getProjection(),
                I.getProjection()
              ) && (b.tileGrid = I.getTileGrid())) : t.setSource(I);
              const B = t.getSource().getTileGrid();
              !isFinite(t.getMaxResolution()) && !isFinite(t.getMinZoom()) && B.getMinZoom() > 0 && t.setMaxResolution(
                bh(
                  Math.max(0, B.getMinZoom() - 1e-12),
                  B.getResolutions()
                )
              );
            });
          const C = d.sources[o];
          let w = t.getSource();
          (!w || w.get("mapbox-source") !== C) && (w = l4(C, s, a));
          const M = (
            /** @type {VectorSource} */
            t.getSource()
          );
          return M ? w !== M && (M.getAttributions() || M.setAttributions(w.getAttributions()), M.format_ || (M.format_ = w.getFormat()), M.url_ = w.getUrl()) : t.setSource(w), Promise.resolve();
        }
        let f, p, m, E;
        function y() {
          if (!E && (!d.sprite || p)) {
            if (a.projection && !n) {
              const w = Xe(a.projection).getUnits();
              w !== "m" && (n = Yo.map(
                (M) => M / Fa[w]
              ));
            }
            E = $P(
              t,
              d,
              A,
              n,
              p,
              m,
              (C, w = a.webfonts) => tge(C, w),
              a.getImage
            ), t.getStyle() ? g().then(c).catch(u) : u(new Error(`Nothing to show for source [${o}]`));
          } else E ? (t.setStyle(E), g().then(c).catch(u)) : u(new Error("Something went wrong trying to apply style."));
        }
        if (d.sprite) {
          const C = new URL(
            Hhe(
              d.sprite,
              a.accessToken,
              s || location.href
            )
          );
          f = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
          const w = f == 0.5 ? "@2x" : "";
          let M = C.origin + C.pathname + w + ".json" + C.search;
          new Promise(function(I, b) {
            fd("Sprite", M, a).then(I).catch(function(B) {
              M = C.origin + C.pathname + ".json" + C.search, fd("Sprite", M, a).then(I).catch(b);
            });
          }).then(function(I) {
            if (I === void 0 && u(new Error("No sprites found.")), p = I, m = C.origin + C.pathname + w + ".png" + C.search, a.transformRequest) {
              const b = a.transformRequest(m, "SpriteImage") || m;
              (b instanceof Request || b instanceof Promise) && (m = b);
            }
            y();
          }).catch(function(I) {
            u(
              new Error(
                `Sprites cannot be loaded: ${M}: ${I.message}`
              )
            );
          });
        } else
          y();
      }).catch(u);
    });
  }
  const aA = {};
  function n4(t, e) {
    let i;
    return t.some(function(r) {
      if (r.id == e)
        return i = r.source, !0;
    }), i;
  }
  function yge(t, e) {
    const i = t.bounds;
    if (i) {
      const r = yE([i[0], i[1]], e), n = yE([i[2], i[3]], e);
      return [r[0], r[1], n[0], n[1]];
    }
    return Xe(e).getExtent();
  }
  function s4(t, e, i) {
    const r = new i4({
      tileJSON: e,
      tileSize: t.tileSize || e.tileSize || 512
    }), n = r.getTileJSON(), s = r.getTileGrid(), o = Xe(i.projection || "EPSG:3857"), a = yge(n, o), A = o.getExtent(), l = n.minzoom || 0, c = n.maxzoom || 22, u = {
      attributions: r.getAttributions(),
      projection: o,
      tileGrid: new dc({
        origin: A ? qs(A) : s.getOrigin(0),
        extent: a || s.getExtent(),
        minZoom: l,
        resolutions: mge(o, e.tileSize).slice(
          0,
          c + 1
        ),
        tileSize: s.getTileSize(0)
      })
    };
    return Array.isArray(n.tiles) ? u.urls = n.tiles : u.url = n.tiles, u;
  }
  function Bge(t, e, i, r) {
    const n = {
      id: t.id,
      type: t.type
    }, s = t.layout || {}, o = t.paint || {};
    n.paint = o;
    const a = b1(
      e,
      i.resolutions || Yo
    );
    let A;
    const l = Je(
      n,
      "paint",
      "background-color",
      a,
      aA,
      r
    );
    return o["background-opacity"] !== void 0 && (A = Je(
      n,
      "paint",
      "background-opacity",
      a,
      aA,
      r
    )), s.visibility == "none" ? void 0 : iA(l, A);
  }
  function wge(t, e, i) {
    const r = document.createElement("div");
    return r.className = "ol-mapbox-style-background", r.style.position = "absolute", r.style.width = "100%", r.style.height = "100%", new HA({
      source: new Nd({}),
      render(n) {
        const s = Bge(
          t,
          n.viewState.resolution,
          e,
          i
        );
        return r.style.backgroundColor = s, r;
      }
    });
  }
  function o4(t, e, i) {
    return new Promise(function(r, n) {
      ZP(t, e, i).then(function({ tileJson: s, tileLoadFunction: o }) {
        const a = s4(
          t,
          s,
          i
        );
        a.tileLoadFunction = o, a.format = new dP(), r(new Zx(a));
      }).catch(n);
    });
  }
  function Cge(t, e, i) {
    const r = new Sl({
      declutter: !0,
      visible: !1
    });
    return o4(t, e, i).then(function(n) {
      n.set("mapbox-source", t), r.setSource(n);
    }).catch(function(n) {
      r.setSource(void 0);
    }), r;
  }
  function a4(t) {
    return `{bbox-${(t ? t.getCode() : "EPSG:3857").toLowerCase().replace(/[^a-z0-9]/g, "-")}}`;
  }
  function bge(t, e, i) {
    return new Promise(function(r, n) {
      ZP(t, e, i).then(function({ tileJson: s, tileLoadFunction: o }) {
        const a = new i4({
          interpolate: i.interpolate === void 0 ? !0 : i.interpolate,
          transition: 0,
          crossOrigin: "anonymous",
          tileJSON: s
        });
        a.tileGrid = s4(
          t,
          s,
          i
        ).tileGrid, i.projection && (a.projection = Xe(i.projection));
        const A = a.getTileUrlFunction();
        o && a.setTileLoadFunction(o), a.setTileUrlFunction(function(l, c, u) {
          const d = a4(u);
          let h = A(l, c, u);
          if (h.indexOf(d) != -1) {
            const g = a.getTileGrid().getTileCoordExtent(l);
            h = h.replace(d, g.toString());
          }
          return h;
        }), a.set("mapbox-source", t), r(a);
      }).catch(function(s) {
        n(s);
      });
    });
  }
  function A4(t, e, i) {
    const r = new SB();
    return bge(t, e, i).then(function(n) {
      r.setSource(n);
    }).catch(function() {
      r.setSource(void 0);
    }), r;
  }
  function Mge(t, e, i) {
    const r = A4(t, e, i);
    return new Ix({
      source: new t4({
        operationType: "image",
        operation: pge,
        sources: [r]
      })
    });
  }
  function l4(t, e, i) {
    const r = i.projection ? new ld({ dataProjection: i.projection }) : new ld(), n = t.data, s = {};
    if (typeof n == "string") {
      const [a] = hm(
        n,
        i.accessToken,
        i.accessTokenParam || "access_token",
        e || location.href
      );
      if (/\{bbox-[0-9a-z-]+\}/.test(a)) {
        const l = (u, d, h) => {
          const g = a4(h);
          return a.replace(g, `${u.join(",")}`);
        }, c = new Do({
          attributions: t.attribution,
          format: r,
          loader: (u, d, h, g, f) => {
            const p = typeof l == "function" ? l(u, d, h) : l;
            fd("GeoJSON", p, i).then((m) => {
              const E = (
                /** @type {*} */
                c.getFormat().readFeatures(m, { featureProjection: h })
              );
              c.addFeatures(E), g(E);
            }).catch((m) => {
              c.removeLoadedExtent(u), f();
            });
          },
          strategy: Du
        });
        return c.set("mapbox-source", t), c;
      }
      const A = new Do({
        attributions: t.attribution,
        format: r,
        url: a,
        loader: (l, c, u, d, h) => {
          fd("GeoJSON", a, i).then((g) => {
            const f = (
              /** @type {*} */
              A.getFormat().readFeatures(g, { featureProjection: u })
            );
            A.addFeatures(f), d(f);
          }).catch((g) => {
            A.removeLoadedExtent(l), h();
          });
        }
      });
      return A;
    }
    s.features = r.readFeatures(n, {
      featureProjection: "EPSG:3857"
    });
    const o = new Do(
      Object.assign(
        {
          attributions: t.attribution,
          format: r
        },
        s
      )
    );
    return o.set("mapbox-source", t), /** @type {VectorSource} */
    o;
  }
  function Ige(t, e, i) {
    return new Bs({
      declutter: !0,
      source: l4(t, e, i),
      visible: !1
    });
  }
  function vge(t, e, i) {
    let r = null;
    return function(n) {
      t.paint && "raster-opacity" in t.paint && n.frameState.viewState.zoom !== r && (r = n.frameState.viewState.zoom, delete i[t.id], xge(t, e, r, i));
    };
  }
  function xge(t, e, i, r) {
    const n = Je(
      t,
      "paint",
      "raster-opacity",
      i,
      aA,
      r
    );
    e.setOpacity(n);
  }
  function Qge(t, e) {
    function i() {
      const r = e.get("mapbox-style");
      if (!r)
        return;
      const n = IP(r.layers), s = t.get("mapbox-layers"), o = n.filter(function(a) {
        return s.includes(a.id);
      }).some(function(a) {
        return !a.layout || !a.layout.visibility || a.layout.visibility === "visible";
      });
      t.get("visible") !== o && t.setVisible(o);
    }
    t.on("change", i), i();
  }
  function Fge(t, e, i, r) {
    const n = KP(t), s = t.layers, o = i.type, a = i.source || n4(s, i.ref), A = t.sources[a];
    let l;
    if (o == "background")
      l = wge(i, r, n);
    else if (A.type == "vector")
      l = Cge(A, e, r);
    else if (A.type == "raster")
      l = A4(A, e, r), l.setVisible(
        i.layout ? i.layout.visibility !== "none" : !0
      ), l.on("prerender", vge(i, l, n));
    else if (A.type == "geojson")
      l = Ige(A, e, r);
    else if (A.type == "raster-dem" && i.type == "hillshade") {
      const u = Mge(A, e, r);
      l = u, u.getSource().on("beforeoperations", function(d) {
        const h = d.data;
        h.resolution = lg(
          r.projection || "EPSG:3857",
          d.resolution,
          xn(d.extent),
          "m"
        );
        const g = b1(
          d.resolution,
          r.resolutions || Yo
        );
        h.encoding = A.encoding, h.vert = 5 * Je(
          i,
          "paint",
          "hillshade-exaggeration",
          g,
          aA,
          n
        ), h.sunAz = Je(
          i,
          "paint",
          "hillshade-illumination-direction",
          g,
          aA,
          n
        ), h.sunEl = 35, h.opacity = 0.3, h.highlightColor = Je(
          i,
          "paint",
          "hillshade-highlight-color",
          g,
          aA,
          n
        ), h.shadowColor = Je(
          i,
          "paint",
          "hillshade-shadow-color",
          g,
          aA,
          n
        ), h.accentColor = Je(
          i,
          "paint",
          "hillshade-accent-color",
          g,
          aA,
          n
        );
      }), l.setVisible(
        i.layout ? i.layout.visibility !== "none" : !0
      );
    }
    const c = a;
    return l && l.set("mapbox-source", c), l;
  }
  function a_(t, e, i, r) {
    const n = [];
    let s = null;
    if (e instanceof Ef) {
      if (s = e.getView(), !s.isDef() && !s.getRotation() && !s.getResolutions()) {
        const u = r.projection ? Xe(r.projection) : s.getProjection();
        s = new Ds(
          Object.assign(s.getProperties(), {
            maxResolution: Yo[0] / Fa[u.getUnits()],
            projection: r.projection || s.getProjection()
          })
        ), e.setView(s);
      }
      "center" in t && !s.getCenter() && s.setCenter(yE(t.center, s.getProjection())), "zoom" in t && s.getZoom() === void 0 && s.setResolution(
        Yo[0] / Fa[s.getProjection().getUnits()] / Math.pow(2, t.zoom)
      ), (!s.getCenter() || s.getZoom() === void 0) && s.fit(s.getProjection().getExtent(), {
        nearest: !0,
        size: e.getSize()
      });
    }
    e.set("mapbox-style", t), e.set("mapbox-metadata", { styleUrl: i, options: r });
    const o = t.layers;
    let a = [], A, l, c;
    for (let u = 0, d = o.length; u < d; ++u) {
      const h = o[u], g = h.type;
      if (g == "heatmap") {
        console.debug(`layers[${u}].type "${g}" not supported`);
        continue;
      } else
        c = h.source || n4(o, h.ref), (!c || c != l) && (a.length && (n.push(
          A_(
            A,
            a,
            t,
            i,
            e,
            r
          )
        ), a = []), A = Fge(t, i, h, r), A instanceof Bs || A instanceof Sl || (a = []), l = A.get("mapbox-source")), a.push(h.id);
    }
    return n.push(
      A_(A, a, t, i, e, r)
    ), Promise.all(n);
  }
  function Sge(t, e, i = {}) {
    let r, n;
    if (typeof t == "string" || t instanceof HTMLElement ? n = new Ef({
      target: t
    }) : n = t, typeof e == "string") {
      const s = e.startsWith("data:") ? location.href : sy(e, i.accessToken);
      i = r4(s, i), r = new Promise(function(o, a) {
        XP(e, i).then(function(A) {
          a_(A, n, s, i).then(function() {
            o(n);
          }).catch(a);
        }).catch(function(A) {
          a(new Error(`Could not load ${e}: ${A.message}`));
        });
      });
    } else
      r = new Promise(function(s, o) {
        a_(
          e,
          n,
          !i.styleUrl || i.styleUrl.startsWith("data:") ? location.href : sy(i.styleUrl, i.accessToken),
          i
        ).then(function() {
          s(n);
        }).catch(o);
      });
    return r;
  }
  function A_(t, e, i, r, n, s = {}) {
    let o = 24, a = 0;
    const A = i.layers;
    for (let l = 0, c = A.length; l < c; ++l) {
      const u = A[l];
      e.indexOf(u.id) !== -1 && (o = Math.min("minzoom" in u ? u.minzoom : 0, o), a = Math.max("maxzoom" in u ? u.maxzoom : 24, a));
    }
    return new Promise(function(l, c) {
      const u = function() {
        const h = t.getSource();
        if (!h || h.getState() === "error") {
          c(
            new Error(
              "Error accessing data for source " + t.get("mapbox-source")
            )
          );
          return;
        }
        if ("getTileGrid" in h) {
          const g = (
            /** @type {import("ol/source/Tile.js").default|import("ol/source/VectorTile.js").default} */
            h.getTileGrid()
          );
          if (g) {
            const f = g.getMinZoom();
            (o > 0 || f > 0) && t.setMaxResolution(
              Math.min(
                bh(
                  Math.max(0, o - 1e-12),
                  Yo
                ),
                bh(
                  Math.max(0, f - 1e-12),
                  g.getResolutions()
                )
              )
            ), a < 24 && t.setMinResolution(
              bh(a, Yo)
            );
          }
        } else
          o > 0 && t.setMaxResolution(
            bh(
              Math.max(0, o - 1e-12),
              Yo
            )
          );
        h instanceof Do || h instanceof Zx ? Ege(
          /** @type {import("ol/layer/Vector").default|import("ol/layer/VectorTile").default} */
          t,
          i,
          e,
          Object.assign({ styleUrl: r }, s)
        ).then(function() {
          Qge(t, n), l();
        }).catch(c) : l();
      };
      t.set("mapbox-layers", e);
      const d = n.getLayers();
      d.getArray().indexOf(t) === -1 && d.push(t), t.getSource() ? u() : t.once("change:source", u);
    });
  }
  const Dge = "EPSG:3857";
  function c4(t = {}) {
    const e = t.epsg ? t.epsg : rn.epsg, i = t.extent ? t.extent : bf(e), r = t.tileSize ? t.tileSize : 512, n = t.resolutions ? t.resolutions : rn.options.map((o) => o.resolution), s = {
      extent: i,
      resolutions: n,
      minZoom: t.minZoom,
      tileSize: new Array(2).fill(r)
    };
    return t.origins ? s.origins = t.origins : s.origin = t.origin ? t.origin : [s.extent[0], s.extent[3]], new dc(s);
  }
  function Tge(t = {}) {
    const e = [t.extent, t.tileSize, t.resolutions, t.origin, t.origins, t.minZoom], i = t.epsg ? t.epsg.toUpperCase() : t.epsg;
    return !e.every((r) => typeof r > "u") || i !== Dge;
  }
  function MM(t, e = {}) {
    e.epsg = e.epsg ? e.epsg : rn.epsg;
    const i = {
      projection: e.epsg,
      format: new dP(),
      url: t,
      tileSize: e.tileSize,
      zDirection: e.zDirection,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom
    };
    return Tge(e) && (i.tileGrid = c4(e)), new Zx(i);
  }
  function Rge(t = {}, { layerParams: e = {}, options: i = {} } = {}) {
    if ([t.id, t.name, t.url].some((s) => typeof s > "u")) {
      console.error(`Cancelled creation of layer "${t.id}"(${t.name}) because of missing required parameters`);
      return;
    }
    let r, n;
    return e.renderer === "webgl" ? (n = MM(t.url, {
      ...t,
      renderer: e.renderer,
      styleId: e.styleId,
      excludeTypesFromParsing: e.excludeTypesFromParsing
    }), r = kB({
      extent: n.getTileGrid().getExtent(),
      ...t,
      ...e,
      source: n
    }), r) : (n = MM(t.url, t), r = new Sl(Object.assign({
      id: t.id,
      name: t.name,
      attribution: t.olAttribution,
      extent: n.getTileGrid().getExtent(),
      minZoom: t.minZoom,
      maxZoom: t.maxZoom,
      source: n,
      declutter: !0
    }, e)), i.style && t.renderer !== "webgl" && r.setStyle(i.style), r);
  }
  function _ge(t, e, { options: i = {} } = {}, r) {
    Object.keys(e.sources).forEach((n) => {
      const s = n;
      if (e.sources[n].type !== "vector" && e.sources[n].type !== "geojson") {
        const o = t.get("map");
        Sge(o, r);
      } else
        $P(
          t,
          e,
          i.sourceId ? i.sourceId : s,
          i.resolutions,
          i.spriteData,
          i.spriteImageUrl,
          i.getFonts
        );
    });
  }
  const kge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    createLayer: Rge,
    createLayerSource: MM,
    createTileGrid: c4,
    setStyle: _ge
  }, Symbol.toStringTag, { value: "Module" }));
  function Yge(t, e, i, r) {
    return t.ok ? t : e(`Request to wfs-filter failed. Response status is ${t.statusText}`, i, r);
  }
  function Nge(t) {
    if (typeof t != "object" || t === null || !Array.isArray(t.links))
      return !1;
    for (let e = 0; e < t.links.length; e++)
      if (typeof t.links[e] == "object" && t.links[e] !== null && typeof t.links[e].href == "string" && t.links[e].rel === "next" && t.links[e].type === "application/geo+json")
        return t.links[e].href;
    return !1;
  }
  function u4(t, e, { onErrorFn: i, success: r, failure: n }, s, o = []) {
    fetch(t, {
      headers: {
        Accept: "application/geo+json"
      },
      method: "GET"
    }).then((A) => Yge(A, i, s, n)).then((A) => A.json()).then((A) => {
      const l = Nge(A);
      if (A.features.forEach((c) => o.push(c)), typeof l == "string") {
        u4(l, e, { onErrorFn: Gh, success: r, failure: n }, s, o);
        return;
      }
      A.features = o, A.numberReturned = A.numberMatched, Xx(e, e.getFormat().readFeatures(A), i, r, n, s);
    }).catch((A) => {
      i(A, s, n);
    });
  }
  function M1(t, e) {
    const i = (e == null ? void 0 : e.bbox) || t.bbox, r = t.url;
    let n = typeof i == "string" && i.length ? i : null, s = null;
    return s = new URL(r), typeof t.collection == "string" && (s.pathname.endsWith("/") ? s.pathname = "collections/" + t.collection + "/items" : s.pathname += "/collections/" + t.collection + "/items"), typeof t.limit == "number" && s.searchParams.set("limit", t.limit), Array.isArray(i) && i.length === 4 && (n = i.join(",")), n && (s.searchParams.set("bbox", i), typeof t.bboxCrs == "string" && t.bboxCrs !== "" && s.searchParams.set("bbox-crs", t.bboxCrs)), typeof t.crs == "string" && s.searchParams.set("crs", t.crs), typeof t.datetime == "string" && t.datetime !== "" && s.searchParams.set("datetime", t.datetime), typeof t.params == "object" && Object.keys(t.params).length && Object.entries(t.params).forEach(([o, a]) => {
      s.searchParams.set(o, a);
    }), s;
  }
  function Uge(t, e) {
    const i = new ld();
    let r = null;
    function n(s, o, a, A, l) {
      const c = e.loadingStrategy === Du ? s : e.loadingParams.bbox, u = M1(t, {
        ...e.loadingParams,
        bbox: c
      });
      u4(u, r, { onErrorFn: Gh, success: A, failure: l }, e);
    }
    return r = Ox(n, e.loadingStrategy, i), e.beforeLoading && r.once("featuresloadstart", () => e.beforeLoading()), t.clusterDistance ? Gx(r, t.clusterDistance, e.clusterGeometryFunction) : r;
  }
  function IM(t, e = {}) {
    e.loadingStrategy || (e.loadingStrategy = Du);
    const i = Uge(t, e);
    return t.renderer === "webgl" && i.once("featuresloadend", (r) => {
      hd(r == null ? void 0 : r.features, t.styleId, t.excludeTypesFromParsing, t.isPointLayer);
    }), i;
  }
  function Lge(t = {}, { layerParams: e = {}, options: i = {} } = {}) {
    let r, n;
    return e.renderer === "webgl" ? (n = IM({
      ...t,
      renderer: e.renderer,
      styleId: e.styleId,
      excludeTypesFromParsing: e.excludeTypesFromParsing,
      isPointLayer: e.isPointLayer
    }, i), r = kB({
      ...t,
      ...e,
      source: n
    }), r) : (n = IM(t, i), r = new Bs(Object.assign({
      source: n,
      id: t.id
    }, e)), i.style ? r.setStyle(i.style) : t.style && r.setStyle(t.style), r);
  }
  function zge(t, e) {
    const i = M1(t, t.version);
    fetch(i, e).then((r) => r.text()).then((r) => {
      e.addFeatures(e.getFormat().readFeatures(r));
    }).catch((r) => {
      console.error(r);
    });
  }
  const Pge = { createLayer: Lge, createLayerSource: IM, createUrl: M1, loadFeaturesManually: zge };
  function Oge(t = {}, e = rn) {
    const i = {
      startZoomLevel: void 0,
      startResolution: void 0
    };
    return Object.prototype.hasOwnProperty.call(t, "startZoomLevel") && !Object.prototype.hasOwnProperty.call(t, "startResolution") ? i.startZoomLevel = e.startZoomLevel : i.startResolution = e.startResolution, i;
  }
  function Gge(t) {
    const e = Object.assign({}, rn, t), i = Oge(t, e);
    return new Ds({
      projection: e.epsg,
      center: e.startCenter,
      extent: e.extent,
      zoom: i.startZoomLevel,
      options: e.options,
      resolution: i.startResolution,
      resolutions: e.options.map((r) => r.resolution),
      constrainResolution: !0,
      constrainOnlyCenter: !0,
      backgroundImage: e.backgroundImage
    });
  }
  function jge(t) {
    t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
    for (var e = 1; e <= 60; ++e)
      t("EPSG:" + (32600 + e), "+proj=utm +zone=" + e + " +datum=WGS84 +units=m"), t("EPSG:" + (32700 + e), "+proj=utm +zone=" + e + " +south +datum=WGS84 +units=m");
    t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"];
  }
  var Hl = 1, Jl = 2, Lu = 3, Hge = 4, vM = 5, l_ = 6378137, Jge = 6356752314e-3, c_ = 0.0066943799901413165, Hh = 484813681109536e-20, Be = Math.PI / 2, Vge = 0.16666666666666666, Wge = 0.04722222222222222, Kge = 0.022156084656084655, Se = 1e-10, Cr = 0.017453292519943295, vo = 57.29577951308232, ti = Math.PI / 4, Sg = Math.PI * 2, br = 3.14159265359, Fn = {};
  Fn.greenwich = 0;
  Fn.lisbon = -9.131906111111;
  Fn.paris = 2.337229166667;
  Fn.bogota = -74.080916666667;
  Fn.madrid = -3.687938888889;
  Fn.rome = 12.452333333333;
  Fn.bern = 7.439583333333;
  Fn.jakarta = 106.807719444444;
  Fn.ferro = -17.666666666667;
  Fn.brussels = 4.367975;
  Fn.stockholm = 18.058277777778;
  Fn.athens = 23.7163375;
  Fn.oslo = 10.722916666667;
  const Xge = {
    mm: { to_meter: 1e-3 },
    cm: { to_meter: 0.01 },
    ft: { to_meter: 0.3048 },
    "us-ft": { to_meter: 1200 / 3937 },
    fath: { to_meter: 1.8288 },
    kmi: { to_meter: 1852 },
    "us-ch": { to_meter: 20.1168402336805 },
    "us-mi": { to_meter: 1609.34721869444 },
    km: { to_meter: 1e3 },
    "ind-ft": { to_meter: 0.30479841 },
    "ind-yd": { to_meter: 0.91439523 },
    mi: { to_meter: 1609.344 },
    yd: { to_meter: 0.9144 },
    ch: { to_meter: 20.1168 },
    link: { to_meter: 0.201168 },
    dm: { to_meter: 0.01 },
    in: { to_meter: 0.0254 },
    "ind-ch": { to_meter: 20.11669506 },
    "us-in": { to_meter: 0.025400050800101 },
    "us-yd": { to_meter: 0.914401828803658 }
  };
  var u_ = /[\s_\-\/\(\)]/g;
  function RA(t, e) {
    if (t[e])
      return t[e];
    for (var i = Object.keys(t), r = e.toLowerCase().replace(u_, ""), n = -1, s, o; ++n < i.length; )
      if (s = i[n], o = s.toLowerCase().replace(u_, ""), o === r)
        return t[s];
  }
  function xM(t) {
    var e = {}, i = t.split("+").map(function(a) {
      return a.trim();
    }).filter(function(a) {
      return a;
    }).reduce(function(a, A) {
      var l = A.split("=");
      return l.push(!0), a[l[0].toLowerCase()] = l[1], a;
    }, {}), r, n, s, o = {
      proj: "projName",
      datum: "datumCode",
      rf: function(a) {
        e.rf = parseFloat(a);
      },
      lat_0: function(a) {
        e.lat0 = a * Cr;
      },
      lat_1: function(a) {
        e.lat1 = a * Cr;
      },
      lat_2: function(a) {
        e.lat2 = a * Cr;
      },
      lat_ts: function(a) {
        e.lat_ts = a * Cr;
      },
      lon_0: function(a) {
        e.long0 = a * Cr;
      },
      lon_1: function(a) {
        e.long1 = a * Cr;
      },
      lon_2: function(a) {
        e.long2 = a * Cr;
      },
      alpha: function(a) {
        e.alpha = parseFloat(a) * Cr;
      },
      gamma: function(a) {
        e.rectified_grid_angle = parseFloat(a);
      },
      lonc: function(a) {
        e.longc = a * Cr;
      },
      x_0: function(a) {
        e.x0 = parseFloat(a);
      },
      y_0: function(a) {
        e.y0 = parseFloat(a);
      },
      k_0: function(a) {
        e.k0 = parseFloat(a);
      },
      k: function(a) {
        e.k0 = parseFloat(a);
      },
      a: function(a) {
        e.a = parseFloat(a);
      },
      b: function(a) {
        e.b = parseFloat(a);
      },
      r: function(a) {
        e.a = e.b = parseFloat(a);
      },
      r_a: function() {
        e.R_A = !0;
      },
      zone: function(a) {
        e.zone = parseInt(a, 10);
      },
      south: function() {
        e.utmSouth = !0;
      },
      towgs84: function(a) {
        e.datum_params = a.split(",").map(function(A) {
          return parseFloat(A);
        });
      },
      to_meter: function(a) {
        e.to_meter = parseFloat(a);
      },
      units: function(a) {
        e.units = a;
        var A = RA(Xge, a);
        A && (e.to_meter = A.to_meter);
      },
      from_greenwich: function(a) {
        e.from_greenwich = a * Cr;
      },
      pm: function(a) {
        var A = RA(Fn, a);
        e.from_greenwich = (A || parseFloat(a)) * Cr;
      },
      nadgrids: function(a) {
        a === "@null" ? e.datumCode = "none" : e.nadgrids = a;
      },
      axis: function(a) {
        var A = "ewnsud";
        a.length === 3 && A.indexOf(a.substr(0, 1)) !== -1 && A.indexOf(a.substr(1, 1)) !== -1 && A.indexOf(a.substr(2, 1)) !== -1 && (e.axis = a);
      },
      approx: function() {
        e.approx = !0;
      }
    };
    for (r in i)
      n = i[r], r in o ? (s = o[r], typeof s == "function" ? s(n) : e[s] = n) : e[r] = n;
    return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
  }
  var Dg = 1, d4 = 2, h4 = 3, ay = 4, g4 = 5, I1 = -1, Zge = /\s/, qge = /[A-Za-z]/, $ge = /[A-Za-z84_]/, qB = /[,\]]/, f4 = /[\d\.E\-\+]/;
  function ja(t) {
    if (typeof t != "string")
      throw new Error("not a string");
    this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Dg;
  }
  ja.prototype.readCharicter = function() {
    var t = this.text[this.place++];
    if (this.state !== ay)
      for (; Zge.test(t); ) {
        if (this.place >= this.text.length)
          return;
        t = this.text[this.place++];
      }
    switch (this.state) {
      case Dg:
        return this.neutral(t);
      case d4:
        return this.keyword(t);
      case ay:
        return this.quoted(t);
      case g4:
        return this.afterquote(t);
      case h4:
        return this.number(t);
      case I1:
        return;
    }
  };
  ja.prototype.afterquote = function(t) {
    if (t === '"') {
      this.word += '"', this.state = ay;
      return;
    }
    if (qB.test(t)) {
      this.word = this.word.trim(), this.afterItem(t);
      return;
    }
    throw new Error(`havn't handled "` + t + '" in afterquote yet, index ' + this.place);
  };
  ja.prototype.afterItem = function(t) {
    if (t === ",") {
      this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Dg;
      return;
    }
    if (t === "]") {
      this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Dg, this.currentObject = this.stack.pop(), this.currentObject || (this.state = I1);
      return;
    }
  };
  ja.prototype.number = function(t) {
    if (f4.test(t)) {
      this.word += t;
      return;
    }
    if (qB.test(t)) {
      this.word = parseFloat(this.word), this.afterItem(t);
      return;
    }
    throw new Error(`havn't handled "` + t + '" in number yet, index ' + this.place);
  };
  ja.prototype.quoted = function(t) {
    if (t === '"') {
      this.state = g4;
      return;
    }
    this.word += t;
  };
  ja.prototype.keyword = function(t) {
    if ($ge.test(t)) {
      this.word += t;
      return;
    }
    if (t === "[") {
      var e = [];
      e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = Dg;
      return;
    }
    if (qB.test(t)) {
      this.afterItem(t);
      return;
    }
    throw new Error(`havn't handled "` + t + '" in keyword yet, index ' + this.place);
  };
  ja.prototype.neutral = function(t) {
    if (qge.test(t)) {
      this.word = t, this.state = d4;
      return;
    }
    if (t === '"') {
      this.word = "", this.state = ay;
      return;
    }
    if (f4.test(t)) {
      this.word = t, this.state = h4;
      return;
    }
    if (qB.test(t)) {
      this.afterItem(t);
      return;
    }
    throw new Error(`havn't handled "` + t + '" in neutral yet, index ' + this.place);
  };
  ja.prototype.output = function() {
    for (; this.place < this.text.length; )
      this.readCharicter();
    if (this.state === I1)
      return this.root;
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
  };
  function efe(t) {
    var e = new ja(t);
    return e.output();
  }
  function wC(t, e, i) {
    Array.isArray(e) && (i.unshift(e), e = null);
    var r = e ? {} : t, n = i.reduce(function(s, o) {
      return mu(o, s), s;
    }, r);
    e && (t[e] = n);
  }
  function mu(t, e) {
    if (!Array.isArray(t)) {
      e[t] = !0;
      return;
    }
    var i = t.shift();
    if (i === "PARAMETER" && (i = t.shift()), t.length === 1) {
      if (Array.isArray(t[0])) {
        e[i] = {}, mu(t[0], e[i]);
        return;
      }
      e[i] = t[0];
      return;
    }
    if (!t.length) {
      e[i] = !0;
      return;
    }
    if (i === "TOWGS84") {
      e[i] = t;
      return;
    }
    if (i === "AXIS") {
      i in e || (e[i] = []), e[i].push(t);
      return;
    }
    Array.isArray(i) || (e[i] = {});
    var r;
    switch (i) {
      case "UNIT":
      case "PRIMEM":
      case "VERT_DATUM":
        e[i] = {
          name: t[0].toLowerCase(),
          convert: t[1]
        }, t.length === 3 && mu(t[2], e[i]);
        return;
      case "SPHEROID":
      case "ELLIPSOID":
        e[i] = {
          name: t[0],
          a: t[1],
          rf: t[2]
        }, t.length === 4 && mu(t[3], e[i]);
        return;
      case "EDATUM":
      case "ENGINEERINGDATUM":
      case "LOCAL_DATUM":
      case "DATUM":
      case "VERT_CS":
      case "VERTCRS":
      case "VERTICALCRS":
        t[0] = ["name", t[0]], wC(e, i, t);
        return;
      case "COMPD_CS":
      case "COMPOUNDCRS":
      case "FITTED_CS":
      // the followings are the crs defined in
      // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
      case "PROJECTEDCRS":
      case "PROJCRS":
      case "GEOGCS":
      case "GEOCCS":
      case "PROJCS":
      case "LOCAL_CS":
      case "GEODCRS":
      case "GEODETICCRS":
      case "GEODETICDATUM":
      case "ENGCRS":
      case "ENGINEERINGCRS":
        t[0] = ["name", t[0]], wC(e, i, t), e[i].type = i;
        return;
      default:
        for (r = -1; ++r < t.length; )
          if (!Array.isArray(t[r]))
            return mu(t, e[i]);
        return wC(e, i, t);
    }
  }
  var tfe = 0.017453292519943295, ife = [
    "PROJECTEDCRS",
    "PROJCRS",
    "GEOGCS",
    "GEOCCS",
    "PROJCS",
    "LOCAL_CS",
    "GEODCRS",
    "GEODETICCRS",
    "GEODETICDATUM",
    "ENGCRS",
    "ENGINEERINGCRS"
  ];
  function rfe(t, e) {
    var i = e[0], r = e[1];
    !(i in t) && r in t && (t[i] = t[r], e.length === 3 && (t[i] = e[2](t[i])));
  }
  function uo(t) {
    return t * tfe;
  }
  function p4(t) {
    for (var e = Object.keys(t), i = 0, r = e.length; i < r; ++i) {
      var n = e[i];
      ife.indexOf(n) !== -1 && nfe(t[n]), typeof t[n] == "object" && p4(t[n]);
    }
  }
  function nfe(t) {
    if (t.AUTHORITY) {
      var e = Object.keys(t.AUTHORITY)[0];
      e && e in t.AUTHORITY && (t.title = e + ":" + t.AUTHORITY[e]);
    }
    if (t.type === "GEOGCS" ? t.projName = "longlat" : t.type === "LOCAL_CS" ? (t.projName = "identity", t.local = !0) : typeof t.PROJECTION == "object" ? t.projName = Object.keys(t.PROJECTION)[0] : t.projName = t.PROJECTION, t.AXIS) {
      for (var i = "", r = 0, n = t.AXIS.length; r < n; ++r) {
        var s = [t.AXIS[r][0].toLowerCase(), t.AXIS[r][1].toLowerCase()];
        s[0].indexOf("north") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "north" ? i += "n" : s[0].indexOf("south") !== -1 || (s[0] === "y" || s[0] === "lat") && s[1] === "south" ? i += "s" : s[0].indexOf("east") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "east" ? i += "e" : (s[0].indexOf("west") !== -1 || (s[0] === "x" || s[0] === "lon") && s[1] === "west") && (i += "w");
      }
      i.length === 2 && (i += "u"), i.length === 3 && (t.axis = i);
    }
    t.UNIT && (t.units = t.UNIT.name.toLowerCase(), t.units === "metre" && (t.units = "meter"), t.UNIT.convert && (t.type === "GEOGCS" ? t.DATUM && t.DATUM.SPHEROID && (t.to_meter = t.UNIT.convert * t.DATUM.SPHEROID.a) : t.to_meter = t.UNIT.convert));
    var o = t.GEOGCS;
    t.type === "GEOGCS" && (o = t), o && (o.DATUM ? t.datumCode = o.DATUM.name.toLowerCase() : t.datumCode = o.name.toLowerCase(), t.datumCode.slice(0, 2) === "d_" && (t.datumCode = t.datumCode.slice(2)), t.datumCode === "new_zealand_1949" && (t.datumCode = "nzgd49"), (t.datumCode === "wgs_1984" || t.datumCode === "world_geodetic_system_1984") && (t.PROJECTION === "Mercator_Auxiliary_Sphere" && (t.sphere = !0), t.datumCode = "wgs84"), t.datumCode === "belge_1972" && (t.datumCode = "rnb72"), o.DATUM && o.DATUM.SPHEROID && (t.ellps = o.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), t.ellps.toLowerCase().slice(0, 13) === "international" && (t.ellps = "intl"), t.a = o.DATUM.SPHEROID.a, t.rf = parseFloat(o.DATUM.SPHEROID.rf, 10)), o.DATUM && o.DATUM.TOWGS84 && (t.datum_params = o.DATUM.TOWGS84), ~t.datumCode.indexOf("osgb_1936") && (t.datumCode = "osgb36"), ~t.datumCode.indexOf("osni_1952") && (t.datumCode = "osni52"), (~t.datumCode.indexOf("tm65") || ~t.datumCode.indexOf("geodetic_datum_of_1965")) && (t.datumCode = "ire65"), t.datumCode === "ch1903+" && (t.datumCode = "ch1903"), ~t.datumCode.indexOf("israel") && (t.datumCode = "isr93")), t.b && !isFinite(t.b) && (t.b = t.a);
    function a(c) {
      var u = t.to_meter || 1;
      return c * u;
    }
    var A = function(c) {
      return rfe(t, c);
    }, l = [
      ["standard_parallel_1", "Standard_Parallel_1"],
      ["standard_parallel_1", "Latitude of 1st standard parallel"],
      ["standard_parallel_2", "Standard_Parallel_2"],
      ["standard_parallel_2", "Latitude of 2nd standard parallel"],
      ["false_easting", "False_Easting"],
      ["false_easting", "False easting"],
      ["false-easting", "Easting at false origin"],
      ["false_northing", "False_Northing"],
      ["false_northing", "False northing"],
      ["false_northing", "Northing at false origin"],
      ["central_meridian", "Central_Meridian"],
      ["central_meridian", "Longitude of natural origin"],
      ["central_meridian", "Longitude of false origin"],
      ["latitude_of_origin", "Latitude_Of_Origin"],
      ["latitude_of_origin", "Central_Parallel"],
      ["latitude_of_origin", "Latitude of natural origin"],
      ["latitude_of_origin", "Latitude of false origin"],
      ["scale_factor", "Scale_Factor"],
      ["k0", "scale_factor"],
      ["latitude_of_center", "Latitude_Of_Center"],
      ["latitude_of_center", "Latitude_of_center"],
      ["lat0", "latitude_of_center", uo],
      ["longitude_of_center", "Longitude_Of_Center"],
      ["longitude_of_center", "Longitude_of_center"],
      ["longc", "longitude_of_center", uo],
      ["x0", "false_easting", a],
      ["y0", "false_northing", a],
      ["long0", "central_meridian", uo],
      ["lat0", "latitude_of_origin", uo],
      ["lat0", "standard_parallel_1", uo],
      ["lat1", "standard_parallel_1", uo],
      ["lat2", "standard_parallel_2", uo],
      ["azimuth", "Azimuth"],
      ["alpha", "azimuth", uo],
      ["srsCode", "name"]
    ];
    l.forEach(A), !t.long0 && t.longc && (t.projName === "Albers_Conic_Equal_Area" || t.projName === "Lambert_Azimuthal_Equal_Area") && (t.long0 = t.longc), !t.lat_ts && t.lat1 && (t.projName === "Stereographic_South_Pole" || t.projName === "Polar Stereographic (variant B)") ? (t.lat0 = uo(t.lat1 > 0 ? 90 : -90), t.lat_ts = t.lat1) : !t.lat_ts && t.lat0 && t.projName === "Polar_Stereographic" && (t.lat_ts = t.lat0, t.lat0 = uo(t.lat0 > 0 ? 90 : -90));
  }
  function m4(t) {
    var e = efe(t), i = e[0], r = {};
    return mu(e, r), p4(r), r[i];
  }
  function Vr(t) {
    var e = this;
    if (arguments.length === 2) {
      var i = arguments[1];
      typeof i == "string" ? i.charAt(0) === "+" ? Vr[t] = xM(arguments[1]) : Vr[t] = m4(arguments[1]) : Vr[t] = i;
    } else if (arguments.length === 1) {
      if (Array.isArray(t))
        return t.map(function(r) {
          Array.isArray(r) ? Vr.apply(e, r) : Vr(r);
        });
      if (typeof t == "string") {
        if (t in Vr)
          return Vr[t];
      } else "EPSG" in t ? Vr["EPSG:" + t.EPSG] = t : "ESRI" in t ? Vr["ESRI:" + t.ESRI] = t : "IAU2000" in t ? Vr["IAU2000:" + t.IAU2000] = t : console.log(t);
      return;
    }
  }
  jge(Vr);
  function sfe(t) {
    return typeof t == "string";
  }
  function ofe(t) {
    return t in Vr;
  }
  var afe = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
  function Afe(t) {
    return afe.some(function(e) {
      return t.indexOf(e) > -1;
    });
  }
  var lfe = ["3857", "900913", "3785", "102113"];
  function cfe(t) {
    var e = RA(t, "authority");
    if (e) {
      var i = RA(e, "epsg");
      return i && lfe.indexOf(i) > -1;
    }
  }
  function ufe(t) {
    var e = RA(t, "extension");
    if (e)
      return RA(e, "proj4");
  }
  function dfe(t) {
    return t[0] === "+";
  }
  function hfe(t) {
    if (sfe(t)) {
      if (ofe(t))
        return Vr[t];
      if (Afe(t)) {
        var e = m4(t);
        if (cfe(e))
          return Vr["EPSG:3857"];
        var i = ufe(e);
        return i ? xM(i) : e;
      }
      if (dfe(t))
        return xM(t);
    } else
      return t;
  }
  function d_(t, e) {
    t = t || {};
    var i, r;
    if (!e)
      return t;
    for (r in e)
      i = e[r], i !== void 0 && (t[r] = i);
    return t;
  }
  function Po(t, e, i) {
    var r = t * e;
    return i / Math.sqrt(1 - r * r);
  }
  function Ff(t) {
    return t < 0 ? -1 : 1;
  }
  function Te(t) {
    return Math.abs(t) <= br ? t : t - Ff(t) * Sg;
  }
  function Vs(t, e, i) {
    var r = t * i, n = 0.5 * t;
    return r = Math.pow((1 - r) / (1 + r), n), Math.tan(0.5 * (Be - e)) / r;
  }
  function Tg(t, e) {
    for (var i = 0.5 * t, r, n, s = Be - 2 * Math.atan(e), o = 0; o <= 15; o++)
      if (r = t * Math.sin(s), n = Be - 2 * Math.atan(e * Math.pow((1 - r) / (1 + r), i)) - s, s += n, Math.abs(n) <= 1e-10)
        return s;
    return -9999;
  }
  function gfe() {
    var t = this.b / this.a;
    this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = Po(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
  }
  function ffe(t) {
    var e = t.x, i = t.y;
    if (i * vo > 90 && i * vo < -90 && e * vo > 180 && e * vo < -180)
      return null;
    var r, n;
    if (Math.abs(Math.abs(i) - Be) <= Se)
      return null;
    if (this.sphere)
      r = this.x0 + this.a * this.k0 * Te(e - this.long0), n = this.y0 + this.a * this.k0 * Math.log(Math.tan(ti + 0.5 * i));
    else {
      var s = Math.sin(i), o = Vs(this.e, i, s);
      r = this.x0 + this.a * this.k0 * Te(e - this.long0), n = this.y0 - this.a * this.k0 * Math.log(o);
    }
    return t.x = r, t.y = n, t;
  }
  function pfe(t) {
    var e = t.x - this.x0, i = t.y - this.y0, r, n;
    if (this.sphere)
      n = Be - 2 * Math.atan(Math.exp(-i / (this.a * this.k0)));
    else {
      var s = Math.exp(-i / (this.a * this.k0));
      if (n = Tg(this.e, s), n === -9999)
        return null;
    }
    return r = Te(this.long0 + e / (this.a * this.k0)), t.x = r, t.y = n, t;
  }
  var mfe = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  const Efe = {
    init: gfe,
    forward: ffe,
    inverse: pfe,
    names: mfe
  };
  function yfe() {
  }
  function h_(t) {
    return t;
  }
  var Bfe = ["longlat", "identity"];
  const wfe = {
    init: yfe,
    forward: h_,
    inverse: h_,
    names: Bfe
  };
  var Cfe = [Efe, wfe], gm = {}, Ay = [];
  function E4(t, e) {
    var i = Ay.length;
    return t.names ? (Ay[i] = t, t.names.forEach(function(r) {
      gm[r.toLowerCase()] = i;
    }), this) : (console.log(e), !0);
  }
  function bfe(t) {
    if (!t)
      return !1;
    var e = t.toLowerCase();
    if (typeof gm[e] < "u" && Ay[gm[e]])
      return Ay[gm[e]];
  }
  function Mfe() {
    Cfe.forEach(E4);
  }
  const Ife = {
    start: Mfe,
    add: E4,
    get: bfe
  };
  var ft = {};
  ft.MERIT = {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };
  ft.SGS85 = {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };
  ft.GRS80 = {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };
  ft.IAU76 = {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };
  ft.airy = {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  };
  ft.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };
  ft.NWL9D = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };
  ft.mod_airy = {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  };
  ft.andrae = {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };
  ft.aust_SA = {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };
  ft.GRS67 = {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  };
  ft.bessel = {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };
  ft.bess_nam = {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };
  ft.clrk66 = {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  };
  ft.clrk80 = {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };
  ft.clrk80ign = {
    a: 63782492e-1,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  };
  ft.clrk58 = {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };
  ft.CPM = {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };
  ft.delmbr = {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };
  ft.engelis = {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };
  ft.evrst30 = {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };
  ft.evrst48 = {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };
  ft.evrst56 = {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };
  ft.evrst69 = {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };
  ft.evrstSS = {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };
  ft.fschr60 = {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };
  ft.fschr60m = {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };
  ft.fschr68 = {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };
  ft.helmert = {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };
  ft.hough = {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  };
  ft.intl = {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  };
  ft.kaula = {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };
  ft.lerch = {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };
  ft.mprts = {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  };
  ft.new_intl = {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  };
  ft.plessis = {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  };
  ft.krass = {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };
  ft.SEasia = {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  };
  ft.walbeck = {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  };
  ft.WGS60 = {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  };
  ft.WGS66 = {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  };
  ft.WGS7 = {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  };
  var vfe = ft.WGS84 = {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };
  ft.sphere = {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  };
  function xfe(t, e, i, r) {
    var n = t * t, s = e * e, o = (n - s) / n, a = 0;
    r ? (t *= 1 - o * (Vge + o * (Wge + o * Kge)), n = t * t, o = 0) : a = Math.sqrt(o);
    var A = (n - s) / s;
    return {
      es: o,
      e: a,
      ep2: A
    };
  }
  function Qfe(t, e, i, r, n) {
    if (!t) {
      var s = RA(ft, r);
      s || (s = vfe), t = s.a, e = s.b, i = s.rf;
    }
    return i && !e && (e = (1 - 1 / i) * t), (i === 0 || Math.abs(t - e) < Se) && (n = !0, e = t), {
      a: t,
      b: e,
      rf: i,
      sphere: n
    };
  }
  var fm = {
    wgs84: {
      towgs84: "0,0,0",
      ellipse: "WGS84",
      datumName: "WGS84"
    },
    ch1903: {
      towgs84: "674.374,15.056,405.346",
      ellipse: "bessel",
      datumName: "swiss"
    },
    ggrs87: {
      towgs84: "-199.87,74.79,246.62",
      ellipse: "GRS80",
      datumName: "Greek_Geodetic_Reference_System_1987"
    },
    nad83: {
      towgs84: "0,0,0",
      ellipse: "GRS80",
      datumName: "North_American_Datum_1983"
    },
    nad27: {
      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
      ellipse: "clrk66",
      datumName: "North_American_Datum_1927"
    },
    potsdam: {
      towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
      ellipse: "bessel",
      datumName: "Potsdam Rauenberg 1950 DHDN"
    },
    carthage: {
      towgs84: "-263.0,6.0,431.0",
      ellipse: "clark80",
      datumName: "Carthage 1934 Tunisia"
    },
    hermannskogel: {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Hermannskogel"
    },
    mgi: {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Militar-Geographische Institut"
    },
    osni52: {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "airy",
      datumName: "Irish National"
    },
    ire65: {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "mod_airy",
      datumName: "Ireland 1965"
    },
    rassadiran: {
      towgs84: "-133.63,-157.5,-158.62",
      ellipse: "intl",
      datumName: "Rassadiran"
    },
    nzgd49: {
      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
      ellipse: "intl",
      datumName: "New Zealand Geodetic Datum 1949"
    },
    osgb36: {
      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
      ellipse: "airy",
      datumName: "Ordnance Survey of Great Britain 1936"
    },
    s_jtsk: {
      towgs84: "589,76,480",
      ellipse: "bessel",
      datumName: "S-JTSK (Ferro)"
    },
    beduaram: {
      towgs84: "-106,-87,188",
      ellipse: "clrk80",
      datumName: "Beduaram"
    },
    gunung_segara: {
      towgs84: "-403,684,41",
      ellipse: "bessel",
      datumName: "Gunung Segara Jakarta"
    },
    rnb72: {
      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
      ellipse: "intl",
      datumName: "Reseau National Belge 1972"
    }
  };
  for (var Ffe in fm) {
    var g_ = fm[Ffe];
    fm[g_.datumName] = g_;
  }
  function Sfe(t, e, i, r, n, s, o) {
    var a = {};
    return t === void 0 || t === "none" ? a.datum_type = vM : a.datum_type = Hge, e && (a.datum_params = e.map(parseFloat), (a.datum_params[0] !== 0 || a.datum_params[1] !== 0 || a.datum_params[2] !== 0) && (a.datum_type = Hl), a.datum_params.length > 3 && (a.datum_params[3] !== 0 || a.datum_params[4] !== 0 || a.datum_params[5] !== 0 || a.datum_params[6] !== 0) && (a.datum_type = Jl, a.datum_params[3] *= Hh, a.datum_params[4] *= Hh, a.datum_params[5] *= Hh, a.datum_params[6] = a.datum_params[6] / 1e6 + 1)), o && (a.datum_type = Lu, a.grids = o), a.a = i, a.b = r, a.es = n, a.ep2 = s, a;
  }
  var y4 = {};
  function Dfe(t, e) {
    var i = new DataView(e), r = _fe(i), n = kfe(i, r), s = Yfe(i, n, r), o = { header: n, subgrids: s };
    return y4[t] = o, o;
  }
  function Tfe(t) {
    if (t === void 0)
      return null;
    var e = t.split(",");
    return e.map(Rfe);
  }
  function Rfe(t) {
    if (t.length === 0)
      return null;
    var e = t[0] === "@";
    return e && (t = t.slice(1)), t === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
      name: t,
      mandatory: !e,
      grid: y4[t] || null,
      isNull: !1
    };
  }
  function Eu(t) {
    return t / 3600 * Math.PI / 180;
  }
  function _fe(t) {
    var e = t.getInt32(8, !1);
    return e === 11 ? !1 : (e = t.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
  }
  function kfe(t, e) {
    return {
      nFields: t.getInt32(8, e),
      nSubgridFields: t.getInt32(24, e),
      nSubgrids: t.getInt32(40, e),
      shiftType: QM(t, 56, 64).trim(),
      fromSemiMajorAxis: t.getFloat64(120, e),
      fromSemiMinorAxis: t.getFloat64(136, e),
      toSemiMajorAxis: t.getFloat64(152, e),
      toSemiMinorAxis: t.getFloat64(168, e)
    };
  }
  function QM(t, e, i) {
    return String.fromCharCode.apply(null, new Uint8Array(t.buffer.slice(e, i)));
  }
  function Yfe(t, e, i) {
    for (var r = 176, n = [], s = 0; s < e.nSubgrids; s++) {
      var o = Ufe(t, r, i), a = Lfe(t, r, o, i), A = Math.round(
        1 + (o.upperLongitude - o.lowerLongitude) / o.longitudeInterval
      ), l = Math.round(
        1 + (o.upperLatitude - o.lowerLatitude) / o.latitudeInterval
      );
      n.push({
        ll: [Eu(o.lowerLongitude), Eu(o.lowerLatitude)],
        del: [Eu(o.longitudeInterval), Eu(o.latitudeInterval)],
        lim: [A, l],
        count: o.gridNodeCount,
        cvs: Nfe(a)
      }), r += 176 + o.gridNodeCount * 16;
    }
    return n;
  }
  function Nfe(t) {
    return t.map(function(e) {
      return [Eu(e.longitudeShift), Eu(e.latitudeShift)];
    });
  }
  function Ufe(t, e, i) {
    return {
      name: QM(t, e + 8, e + 16).trim(),
      parent: QM(t, e + 24, e + 24 + 8).trim(),
      lowerLatitude: t.getFloat64(e + 72, i),
      upperLatitude: t.getFloat64(e + 88, i),
      lowerLongitude: t.getFloat64(e + 104, i),
      upperLongitude: t.getFloat64(e + 120, i),
      latitudeInterval: t.getFloat64(e + 136, i),
      longitudeInterval: t.getFloat64(e + 152, i),
      gridNodeCount: t.getInt32(e + 168, i)
    };
  }
  function Lfe(t, e, i, r) {
    for (var n = e + 176, s = 16, o = [], a = 0; a < i.gridNodeCount; a++) {
      var A = {
        latitudeShift: t.getFloat32(n + a * s, r),
        longitudeShift: t.getFloat32(n + a * s + 4, r),
        latitudeAccuracy: t.getFloat32(n + a * s + 8, r),
        longitudeAccuracy: t.getFloat32(n + a * s + 12, r)
      };
      o.push(A);
    }
    return o;
  }
  function No(t, e) {
    if (!(this instanceof No))
      return new No(t);
    e = e || function(l) {
      if (l)
        throw l;
    };
    var i = hfe(t);
    if (typeof i != "object") {
      e("Could not parse to valid json: " + t);
      return;
    }
    var r = No.projections.get(i.projName);
    if (!r) {
      e("Could not get projection name from: " + t);
      return;
    }
    if (i.datumCode && i.datumCode !== "none") {
      var n = RA(fm, i.datumCode);
      n && (i.datum_params = i.datum_params || (n.towgs84 ? n.towgs84.split(",") : null), i.ellps = n.ellipse, i.datumName = n.datumName ? n.datumName : i.datumCode);
    }
    i.k0 = i.k0 || 1, i.axis = i.axis || "enu", i.ellps = i.ellps || "wgs84", i.lat1 = i.lat1 || i.lat0;
    var s = Qfe(i.a, i.b, i.rf, i.ellps, i.sphere), o = xfe(s.a, s.b, s.rf, i.R_A), a = Tfe(i.nadgrids), A = i.datum || Sfe(
      i.datumCode,
      i.datum_params,
      s.a,
      s.b,
      o.es,
      o.ep2,
      a
    );
    d_(this, i), d_(this, r), this.a = s.a, this.b = s.b, this.rf = s.rf, this.sphere = s.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = A, this.init(), e(null, this);
  }
  No.projections = Ife;
  No.projections.start();
  function zfe(t, e) {
    return t.datum_type !== e.datum_type || t.a !== e.a || Math.abs(t.es - e.es) > 5e-11 ? !1 : t.datum_type === Hl ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : t.datum_type === Jl ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6] : !0;
  }
  function B4(t, e, i) {
    var r = t.x, n = t.y, s = t.z ? t.z : 0, o, a, A, l;
    if (n < -Be && n > -1.001 * Be)
      n = -Be;
    else if (n > Be && n < 1.001 * Be)
      n = Be;
    else {
      if (n < -Be)
        return { x: -1 / 0, y: -1 / 0, z: t.z };
      if (n > Be)
        return { x: 1 / 0, y: 1 / 0, z: t.z };
    }
    return r > Math.PI && (r -= 2 * Math.PI), a = Math.sin(n), l = Math.cos(n), A = a * a, o = i / Math.sqrt(1 - e * A), {
      x: (o + s) * l * Math.cos(r),
      y: (o + s) * l * Math.sin(r),
      z: (o * (1 - e) + s) * a
    };
  }
  function w4(t, e, i, r) {
    var n = 1e-12, s = n * n, o = 30, a, A, l, c, u, d, h, g, f, p, m, E, y, C = t.x, w = t.y, M = t.z ? t.z : 0, I, b, B;
    if (a = Math.sqrt(C * C + w * w), A = Math.sqrt(C * C + w * w + M * M), a / i < n) {
      if (I = 0, A / i < n)
        return b = Be, B = -r, {
          x: t.x,
          y: t.y,
          z: t.z
        };
    } else
      I = Math.atan2(w, C);
    l = M / A, c = a / A, u = 1 / Math.sqrt(1 - e * (2 - e) * c * c), g = c * (1 - e) * u, f = l * u, y = 0;
    do
      y++, h = i / Math.sqrt(1 - e * f * f), B = a * g + M * f - h * (1 - e * f * f), d = e * h / (h + B), u = 1 / Math.sqrt(1 - d * (2 - d) * c * c), p = c * (1 - d) * u, m = l * u, E = m * g - p * f, g = p, f = m;
    while (E * E > s && y < o);
    return b = Math.atan(m / Math.abs(p)), {
      x: I,
      y: b,
      z: B
    };
  }
  function Pfe(t, e, i) {
    if (e === Hl)
      return {
        x: t.x + i[0],
        y: t.y + i[1],
        z: t.z + i[2]
      };
    if (e === Jl) {
      var r = i[0], n = i[1], s = i[2], o = i[3], a = i[4], A = i[5], l = i[6];
      return {
        x: l * (t.x - A * t.y + a * t.z) + r,
        y: l * (A * t.x + t.y - o * t.z) + n,
        z: l * (-a * t.x + o * t.y + t.z) + s
      };
    }
  }
  function Ofe(t, e, i) {
    if (e === Hl)
      return {
        x: t.x - i[0],
        y: t.y - i[1],
        z: t.z - i[2]
      };
    if (e === Jl) {
      var r = i[0], n = i[1], s = i[2], o = i[3], a = i[4], A = i[5], l = i[6], c = (t.x - r) / l, u = (t.y - n) / l, d = (t.z - s) / l;
      return {
        x: c + A * u - a * d,
        y: -A * c + u + o * d,
        z: a * c - o * u + d
      };
    }
  }
  function Up(t) {
    return t === Hl || t === Jl;
  }
  function Gfe(t, e, i) {
    if (zfe(t, e) || t.datum_type === vM || e.datum_type === vM)
      return i;
    var r = t.a, n = t.es;
    if (t.datum_type === Lu) {
      var s = f_(t, !1, i);
      if (s !== 0)
        return;
      r = l_, n = c_;
    }
    var o = e.a, a = e.b, A = e.es;
    if (e.datum_type === Lu && (o = l_, a = Jge, A = c_), n === A && r === o && !Up(t.datum_type) && !Up(e.datum_type))
      return i;
    if (i = B4(i, n, r), Up(t.datum_type) && (i = Pfe(i, t.datum_type, t.datum_params)), Up(e.datum_type) && (i = Ofe(i, e.datum_type, e.datum_params)), i = w4(i, A, o, a), e.datum_type === Lu) {
      var l = f_(e, !0, i);
      if (l !== 0)
        return;
    }
    return i;
  }
  function f_(t, e, i) {
    if (t.grids === null || t.grids.length === 0)
      return console.log("Grid shift grids not found"), -1;
    var r = { x: -i.x, y: i.y }, n = { x: Number.NaN, y: Number.NaN }, s = [];
    e:
      for (var o = 0; o < t.grids.length; o++) {
        var a = t.grids[o];
        if (s.push(a.name), a.isNull) {
          n = r;
          break;
        }
        if (a.mandatory, a.grid === null) {
          if (a.mandatory)
            return console.log("Unable to find mandatory grid '" + a.name + "'"), -1;
          continue;
        }
        for (var A = a.grid.subgrids, l = 0, c = A.length; l < c; l++) {
          var u = A[l], d = (Math.abs(u.del[1]) + Math.abs(u.del[0])) / 1e4, h = u.ll[0] - d, g = u.ll[1] - d, f = u.ll[0] + (u.lim[0] - 1) * u.del[0] + d, p = u.ll[1] + (u.lim[1] - 1) * u.del[1] + d;
          if (!(g > r.y || h > r.x || p < r.y || f < r.x) && (n = jfe(r, e, u), !isNaN(n.x)))
            break e;
        }
      }
    return isNaN(n.x) ? (console.log("Failed to find a grid shift table for location '" + -r.x * vo + " " + r.y * vo + " tried: '" + s + "'"), -1) : (i.x = -n.x, i.y = n.y, 0);
  }
  function jfe(t, e, i) {
    var r = { x: Number.NaN, y: Number.NaN };
    if (isNaN(t.x))
      return r;
    var n = { x: t.x, y: t.y };
    n.x -= i.ll[0], n.y -= i.ll[1], n.x = Te(n.x - Math.PI) + Math.PI;
    var s = p_(n, i);
    if (e) {
      if (isNaN(s.x))
        return r;
      s.x = n.x - s.x, s.y = n.y - s.y;
      var o = 9, a = 1e-12, A, l;
      do {
        if (l = p_(s, i), isNaN(l.x)) {
          console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
          break;
        }
        A = { x: n.x - (l.x + s.x), y: n.y - (l.y + s.y) }, s.x += A.x, s.y += A.y;
      } while (o-- && Math.abs(A.x) > a && Math.abs(A.y) > a);
      if (o < 0)
        return console.log("Inverse grid shift iterator failed to converge."), r;
      r.x = Te(s.x + i.ll[0]), r.y = s.y + i.ll[1];
    } else
      isNaN(s.x) || (r.x = t.x + s.x, r.y = t.y + s.y);
    return r;
  }
  function p_(t, e) {
    var i = { x: t.x / e.del[0], y: t.y / e.del[1] }, r = { x: Math.floor(i.x), y: Math.floor(i.y) }, n = { x: i.x - 1 * r.x, y: i.y - 1 * r.y }, s = { x: Number.NaN, y: Number.NaN }, o;
    if (r.x < 0 || r.x >= e.lim[0] || r.y < 0 || r.y >= e.lim[1])
      return s;
    o = r.y * e.lim[0] + r.x;
    var a = { x: e.cvs[o][0], y: e.cvs[o][1] };
    o++;
    var A = { x: e.cvs[o][0], y: e.cvs[o][1] };
    o += e.lim[0];
    var l = { x: e.cvs[o][0], y: e.cvs[o][1] };
    o--;
    var c = { x: e.cvs[o][0], y: e.cvs[o][1] }, u = n.x * n.y, d = n.x * (1 - n.y), h = (1 - n.x) * (1 - n.y), g = (1 - n.x) * n.y;
    return s.x = h * a.x + d * A.x + g * c.x + u * l.x, s.y = h * a.y + d * A.y + g * c.y + u * l.y, s;
  }
  function m_(t, e, i) {
    var r = i.x, n = i.y, s = i.z || 0, o, a, A, l = {};
    for (A = 0; A < 3; A++)
      if (!(e && A === 2 && i.z === void 0))
        switch (A === 0 ? (o = r, "ew".indexOf(t.axis[A]) !== -1 ? a = "x" : a = "y") : A === 1 ? (o = n, "ns".indexOf(t.axis[A]) !== -1 ? a = "y" : a = "x") : (o = s, a = "z"), t.axis[A]) {
          case "e":
            l[a] = o;
            break;
          case "w":
            l[a] = -o;
            break;
          case "n":
            l[a] = o;
            break;
          case "s":
            l[a] = -o;
            break;
          case "u":
            i[a] !== void 0 && (l.z = o);
            break;
          case "d":
            i[a] !== void 0 && (l.z = -o);
            break;
          default:
            return null;
        }
    return l;
  }
  function C4(t) {
    var e = {
      x: t[0],
      y: t[1]
    };
    return t.length > 2 && (e.z = t[2]), t.length > 3 && (e.m = t[3]), e;
  }
  function Hfe(t) {
    E_(t.x), E_(t.y);
  }
  function E_(t) {
    if (typeof Number.isFinite == "function") {
      if (Number.isFinite(t))
        return;
      throw new TypeError("coordinates must be finite numbers");
    }
    if (typeof t != "number" || t !== t || !isFinite(t))
      throw new TypeError("coordinates must be finite numbers");
  }
  function Jfe(t, e) {
    return (t.datum.datum_type === Hl || t.datum.datum_type === Jl || t.datum.datum_type === Lu) && e.datumCode !== "WGS84" || (e.datum.datum_type === Hl || e.datum.datum_type === Jl || e.datum.datum_type === Lu) && t.datumCode !== "WGS84";
  }
  function ly(t, e, i, r) {
    var n;
    Array.isArray(i) ? i = C4(i) : i = {
      x: i.x,
      y: i.y,
      z: i.z,
      m: i.m
    };
    var s = i.z !== void 0;
    if (Hfe(i), t.datum && e.datum && Jfe(t, e) && (n = new No("WGS84"), i = ly(t, n, i, r), t = n), r && t.axis !== "enu" && (i = m_(t, !1, i)), t.projName === "longlat")
      i = {
        x: i.x * Cr,
        y: i.y * Cr,
        z: i.z || 0
      };
    else if (t.to_meter && (i = {
      x: i.x * t.to_meter,
      y: i.y * t.to_meter,
      z: i.z || 0
    }), i = t.inverse(i), !i)
      return;
    if (t.from_greenwich && (i.x += t.from_greenwich), i = Gfe(t.datum, e.datum, i), !!i)
      return e.from_greenwich && (i = {
        x: i.x - e.from_greenwich,
        y: i.y,
        z: i.z || 0
      }), e.projName === "longlat" ? i = {
        x: i.x * vo,
        y: i.y * vo,
        z: i.z || 0
      } : (i = e.forward(i), e.to_meter && (i = {
        x: i.x / e.to_meter,
        y: i.y / e.to_meter,
        z: i.z || 0
      })), r && e.axis !== "enu" ? m_(e, !0, i) : (i && !s && delete i.z, i);
  }
  var y_ = No("WGS84");
  function CC(t, e, i, r) {
    var n, s, o;
    return Array.isArray(i) ? (n = ly(t, e, i, r) || { x: NaN, y: NaN }, i.length > 2 ? typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof n.z == "number" ? [n.x, n.y, n.z].concat(i.slice(3)) : [n.x, n.y, i[2]].concat(i.slice(3)) : [n.x, n.y].concat(i.slice(2)) : [n.x, n.y]) : (s = ly(t, e, i, r), o = Object.keys(i), o.length === 2 || o.forEach(function(a) {
      if (typeof t.name < "u" && t.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
        if (a === "x" || a === "y" || a === "z")
          return;
      } else if (a === "x" || a === "y")
        return;
      s[a] = i[a];
    }), s);
  }
  function B_(t) {
    return t instanceof No ? t : t.oProj ? t.oProj : No(t);
  }
  function Vi(t, e, i) {
    t = B_(t);
    var r = !1, n;
    return typeof e > "u" ? (e = t, t = y_, r = !0) : (typeof e.x < "u" || Array.isArray(e)) && (i = e, e = t, t = y_, r = !0), e = B_(e), i ? CC(t, e, i) : (n = {
      forward: function(s, o) {
        return CC(t, e, s, o);
      },
      inverse: function(s, o) {
        return CC(e, t, s, o);
      }
    }, r && (n.oProj = e), n);
  }
  var w_ = 6, b4 = "AJSAJS", M4 = "AFAFAF", yu = 65, dn = 73, $n = 79, Mh = 86, Ih = 90;
  const Vfe = {
    forward: I4,
    inverse: Wfe,
    toPoint: v4
  };
  function I4(t, e) {
    return e = e || 5, Zfe(Kfe({
      lat: t[1],
      lon: t[0]
    }), e);
  }
  function Wfe(t) {
    var e = v1(Q4(t.toUpperCase()));
    return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
  }
  function v4(t) {
    var e = v1(Q4(t.toUpperCase()));
    return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
  }
  function bC(t) {
    return t * (Math.PI / 180);
  }
  function C_(t) {
    return 180 * (t / Math.PI);
  }
  function Kfe(t) {
    var e = t.lat, i = t.lon, r = 6378137, n = 669438e-8, s = 0.9996, o, a, A, l, c, u, d, h = bC(e), g = bC(i), f, p;
    p = Math.floor((i + 180) / 6) + 1, i === 180 && (p = 60), e >= 56 && e < 64 && i >= 3 && i < 12 && (p = 32), e >= 72 && e < 84 && (i >= 0 && i < 9 ? p = 31 : i >= 9 && i < 21 ? p = 33 : i >= 21 && i < 33 ? p = 35 : i >= 33 && i < 42 && (p = 37)), o = (p - 1) * 6 - 180 + 3, f = bC(o), a = n / (1 - n), A = r / Math.sqrt(1 - n * Math.sin(h) * Math.sin(h)), l = Math.tan(h) * Math.tan(h), c = a * Math.cos(h) * Math.cos(h), u = Math.cos(h) * (g - f), d = r * ((1 - n / 4 - 3 * n * n / 64 - 5 * n * n * n / 256) * h - (3 * n / 8 + 3 * n * n / 32 + 45 * n * n * n / 1024) * Math.sin(2 * h) + (15 * n * n / 256 + 45 * n * n * n / 1024) * Math.sin(4 * h) - 35 * n * n * n / 3072 * Math.sin(6 * h));
    var m = s * A * (u + (1 - l + c) * u * u * u / 6 + (5 - 18 * l + l * l + 72 * c - 58 * a) * u * u * u * u * u / 120) + 5e5, E = s * (d + A * Math.tan(h) * (u * u / 2 + (5 - l + 9 * c + 4 * c * c) * u * u * u * u / 24 + (61 - 58 * l + l * l + 600 * c - 330 * a) * u * u * u * u * u * u / 720));
    return e < 0 && (E += 1e7), {
      northing: Math.round(E),
      easting: Math.round(m),
      zoneNumber: p,
      zoneLetter: Xfe(e)
    };
  }
  function v1(t) {
    var e = t.northing, i = t.easting, r = t.zoneLetter, n = t.zoneNumber;
    if (n < 0 || n > 60)
      return null;
    var s = 0.9996, o = 6378137, a = 669438e-8, A, l = (1 - Math.sqrt(1 - a)) / (1 + Math.sqrt(1 - a)), c, u, d, h, g, f, p, m, E, y = i - 5e5, C = e;
    r < "N" && (C -= 1e7), p = (n - 1) * 6 - 180 + 3, A = a / (1 - a), f = C / s, m = f / (o * (1 - a / 4 - 3 * a * a / 64 - 5 * a * a * a / 256)), E = m + (3 * l / 2 - 27 * l * l * l / 32) * Math.sin(2 * m) + (21 * l * l / 16 - 55 * l * l * l * l / 32) * Math.sin(4 * m) + 151 * l * l * l / 96 * Math.sin(6 * m), c = o / Math.sqrt(1 - a * Math.sin(E) * Math.sin(E)), u = Math.tan(E) * Math.tan(E), d = A * Math.cos(E) * Math.cos(E), h = o * (1 - a) / Math.pow(1 - a * Math.sin(E) * Math.sin(E), 1.5), g = y / (c * s);
    var w = E - c * Math.tan(E) / h * (g * g / 2 - (5 + 3 * u + 10 * d - 4 * d * d - 9 * A) * g * g * g * g / 24 + (61 + 90 * u + 298 * d + 45 * u * u - 252 * A - 3 * d * d) * g * g * g * g * g * g / 720);
    w = C_(w);
    var M = (g - (1 + 2 * u + d) * g * g * g / 6 + (5 - 2 * d + 28 * u - 3 * d * d + 8 * A + 24 * u * u) * g * g * g * g * g / 120) / Math.cos(E);
    M = p + C_(M);
    var I;
    if (t.accuracy) {
      var b = v1({
        northing: t.northing + t.accuracy,
        easting: t.easting + t.accuracy,
        zoneLetter: t.zoneLetter,
        zoneNumber: t.zoneNumber
      });
      I = {
        top: b.lat,
        right: b.lon,
        bottom: w,
        left: M
      };
    } else
      I = {
        lat: w,
        lon: M
      };
    return I;
  }
  function Xfe(t) {
    var e = "Z";
    return 84 >= t && t >= 72 ? e = "X" : 72 > t && t >= 64 ? e = "W" : 64 > t && t >= 56 ? e = "V" : 56 > t && t >= 48 ? e = "U" : 48 > t && t >= 40 ? e = "T" : 40 > t && t >= 32 ? e = "S" : 32 > t && t >= 24 ? e = "R" : 24 > t && t >= 16 ? e = "Q" : 16 > t && t >= 8 ? e = "P" : 8 > t && t >= 0 ? e = "N" : 0 > t && t >= -8 ? e = "M" : -8 > t && t >= -16 ? e = "L" : -16 > t && t >= -24 ? e = "K" : -24 > t && t >= -32 ? e = "J" : -32 > t && t >= -40 ? e = "H" : -40 > t && t >= -48 ? e = "G" : -48 > t && t >= -56 ? e = "F" : -56 > t && t >= -64 ? e = "E" : -64 > t && t >= -72 ? e = "D" : -72 > t && t >= -80 && (e = "C"), e;
  }
  function Zfe(t, e) {
    var i = "00000" + t.easting, r = "00000" + t.northing;
    return t.zoneNumber + t.zoneLetter + qfe(t.easting, t.northing, t.zoneNumber) + i.substr(i.length - 5, e) + r.substr(r.length - 5, e);
  }
  function qfe(t, e, i) {
    var r = x4(i), n = Math.floor(t / 1e5), s = Math.floor(e / 1e5) % 20;
    return $fe(n, s, r);
  }
  function x4(t) {
    var e = t % w_;
    return e === 0 && (e = w_), e;
  }
  function $fe(t, e, i) {
    var r = i - 1, n = b4.charCodeAt(r), s = M4.charCodeAt(r), o = n + t - 1, a = s + e, A = !1;
    o > Ih && (o = o - Ih + yu - 1, A = !0), (o === dn || n < dn && o > dn || (o > dn || n < dn) && A) && o++, (o === $n || n < $n && o > $n || (o > $n || n < $n) && A) && (o++, o === dn && o++), o > Ih && (o = o - Ih + yu - 1), a > Mh ? (a = a - Mh + yu - 1, A = !0) : A = !1, (a === dn || s < dn && a > dn || (a > dn || s < dn) && A) && a++, (a === $n || s < $n && a > $n || (a > $n || s < $n) && A) && (a++, a === dn && a++), a > Mh && (a = a - Mh + yu - 1);
    var l = String.fromCharCode(o) + String.fromCharCode(a);
    return l;
  }
  function Q4(t) {
    if (t && t.length === 0)
      throw "MGRSPoint coverting from nothing";
    for (var e = t.length, i = null, r = "", n, s = 0; !/[A-Z]/.test(n = t.charAt(s)); ) {
      if (s >= 2)
        throw "MGRSPoint bad conversion from: " + t;
      r += n, s++;
    }
    var o = parseInt(r, 10);
    if (s === 0 || s + 3 > e)
      throw "MGRSPoint bad conversion from: " + t;
    var a = t.charAt(s++);
    if (a <= "A" || a === "B" || a === "Y" || a >= "Z" || a === "I" || a === "O")
      throw "MGRSPoint zone letter " + a + " not handled: " + t;
    i = t.substring(s, s += 2);
    for (var A = x4(o), l = epe(i.charAt(0), A), c = tpe(i.charAt(1), A); c < ipe(a); )
      c += 2e6;
    var u = e - s;
    if (u % 2 !== 0)
      throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + t;
    var d = u / 2, h = 0, g = 0, f, p, m, E, y;
    return d > 0 && (f = 1e5 / Math.pow(10, d), p = t.substring(s, s + d), h = parseFloat(p) * f, m = t.substring(s + d), g = parseFloat(m) * f), E = h + l, y = g + c, {
      easting: E,
      northing: y,
      zoneLetter: a,
      zoneNumber: o,
      accuracy: f
    };
  }
  function epe(t, e) {
    for (var i = b4.charCodeAt(e - 1), r = 1e5, n = !1; i !== t.charCodeAt(0); ) {
      if (i++, i === dn && i++, i === $n && i++, i > Ih) {
        if (n)
          throw "Bad character: " + t;
        i = yu, n = !0;
      }
      r += 1e5;
    }
    return r;
  }
  function tpe(t, e) {
    if (t > "V")
      throw "MGRSPoint given invalid Northing " + t;
    for (var i = M4.charCodeAt(e - 1), r = 0, n = !1; i !== t.charCodeAt(0); ) {
      if (i++, i === dn && i++, i === $n && i++, i > Mh) {
        if (n)
          throw "Bad character: " + t;
        i = yu, n = !0;
      }
      r += 1e5;
    }
    return r;
  }
  function ipe(t) {
    var e;
    switch (t) {
      case "C":
        e = 11e5;
        break;
      case "D":
        e = 2e6;
        break;
      case "E":
        e = 28e5;
        break;
      case "F":
        e = 37e5;
        break;
      case "G":
        e = 46e5;
        break;
      case "H":
        e = 55e5;
        break;
      case "J":
        e = 64e5;
        break;
      case "K":
        e = 73e5;
        break;
      case "L":
        e = 82e5;
        break;
      case "M":
        e = 91e5;
        break;
      case "N":
        e = 0;
        break;
      case "P":
        e = 8e5;
        break;
      case "Q":
        e = 17e5;
        break;
      case "R":
        e = 26e5;
        break;
      case "S":
        e = 35e5;
        break;
      case "T":
        e = 44e5;
        break;
      case "U":
        e = 53e5;
        break;
      case "V":
        e = 62e5;
        break;
      case "W":
        e = 7e6;
        break;
      case "X":
        e = 79e5;
        break;
      default:
        e = -1;
    }
    if (e >= 0)
      return e;
    throw "Invalid zone letter: " + t;
  }
  function pd(t, e, i) {
    if (!(this instanceof pd))
      return new pd(t, e, i);
    if (Array.isArray(t))
      this.x = t[0], this.y = t[1], this.z = t[2] || 0;
    else if (typeof t == "object")
      this.x = t.x, this.y = t.y, this.z = t.z || 0;
    else if (typeof t == "string" && typeof e > "u") {
      var r = t.split(",");
      this.x = parseFloat(r[0], 10), this.y = parseFloat(r[1], 10), this.z = parseFloat(r[2], 10) || 0;
    } else
      this.x = t, this.y = e, this.z = i || 0;
    console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
  }
  pd.fromMGRS = function(t) {
    return new pd(v4(t));
  };
  pd.prototype.toMGRS = function(t) {
    return I4([this.x, this.y], t);
  };
  var rpe = 1, npe = 0.25, b_ = 0.046875, M_ = 0.01953125, I_ = 0.01068115234375, spe = 0.75, ope = 0.46875, ape = 0.013020833333333334, Ape = 0.007120768229166667, lpe = 0.3645833333333333, cpe = 0.005696614583333333, upe = 0.3076171875;
  function x1(t) {
    var e = [];
    e[0] = rpe - t * (npe + t * (b_ + t * (M_ + t * I_))), e[1] = t * (spe - t * (b_ + t * (M_ + t * I_)));
    var i = t * t;
    return e[2] = i * (ope - t * (ape + t * Ape)), i *= t, e[3] = i * (lpe - t * cpe), e[4] = i * t * upe, e;
  }
  function Jd(t, e, i, r) {
    return i *= e, e *= e, r[0] * t - i * (r[1] + e * (r[2] + e * (r[3] + e * r[4])));
  }
  var dpe = 20;
  function Q1(t, e, i) {
    for (var r = 1 / (1 - e), n = t, s = dpe; s; --s) {
      var o = Math.sin(n), a = 1 - e * o * o;
      if (a = (Jd(n, o, Math.cos(n), i) - t) * (a * Math.sqrt(a)) * r, n -= a, Math.abs(a) < Se)
        return n;
    }
    return n;
  }
  function hpe() {
    this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = x1(this.es), this.ml0 = Jd(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
  }
  function gpe(t) {
    var e = t.x, i = t.y, r = Te(e - this.long0), n, s, o, a = Math.sin(i), A = Math.cos(i);
    if (this.es) {
      var c = A * r, u = Math.pow(c, 2), d = this.ep2 * Math.pow(A, 2), h = Math.pow(d, 2), g = Math.abs(A) > Se ? Math.tan(i) : 0, f = Math.pow(g, 2), p = Math.pow(f, 2);
      n = 1 - this.es * Math.pow(a, 2), c = c / Math.sqrt(n);
      var m = Jd(i, a, A, this.en);
      s = this.a * (this.k0 * c * (1 + u / 6 * (1 - f + d + u / 20 * (5 - 18 * f + p + 14 * d - 58 * f * d + u / 42 * (61 + 179 * p - p * f - 479 * f))))) + this.x0, o = this.a * (this.k0 * (m - this.ml0 + a * r * c / 2 * (1 + u / 12 * (5 - f + 9 * d + 4 * h + u / 30 * (61 + p - 58 * f + 270 * d - 330 * f * d + u / 56 * (1385 + 543 * p - p * f - 3111 * f)))))) + this.y0;
    } else {
      var l = A * Math.sin(r);
      if (Math.abs(Math.abs(l) - 1) < Se)
        return 93;
      if (s = 0.5 * this.a * this.k0 * Math.log((1 + l) / (1 - l)) + this.x0, o = A * Math.cos(r) / Math.sqrt(1 - Math.pow(l, 2)), l = Math.abs(o), l >= 1) {
        if (l - 1 > Se)
          return 93;
        o = 0;
      } else
        o = Math.acos(o);
      i < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
    }
    return t.x = s, t.y = o, t;
  }
  function fpe(t) {
    var e, i, r, n, s = (t.x - this.x0) * (1 / this.a), o = (t.y - this.y0) * (1 / this.a);
    if (this.es)
      if (e = this.ml0 + o / this.k0, i = Q1(e, this.es, this.en), Math.abs(i) < Be) {
        var u = Math.sin(i), d = Math.cos(i), h = Math.abs(d) > Se ? Math.tan(i) : 0, g = this.ep2 * Math.pow(d, 2), f = Math.pow(g, 2), p = Math.pow(h, 2), m = Math.pow(p, 2);
        e = 1 - this.es * Math.pow(u, 2);
        var E = s * Math.sqrt(e) / this.k0, y = Math.pow(E, 2);
        e = e * h, r = i - e * y / (1 - this.es) * 0.5 * (1 - y / 12 * (5 + 3 * p - 9 * g * p + g - 4 * f - y / 30 * (61 + 90 * p - 252 * g * p + 45 * m + 46 * g - y / 56 * (1385 + 3633 * p + 4095 * m + 1574 * m * p)))), n = Te(this.long0 + E * (1 - y / 6 * (1 + 2 * p + g - y / 20 * (5 + 28 * p + 24 * m + 8 * g * p + 6 * g - y / 42 * (61 + 662 * p + 1320 * m + 720 * m * p)))) / d);
      } else
        r = Be * Ff(o), n = 0;
    else {
      var a = Math.exp(s / this.k0), A = 0.5 * (a - 1 / a), l = this.lat0 + o / this.k0, c = Math.cos(l);
      e = Math.sqrt((1 - Math.pow(c, 2)) / (1 + Math.pow(A, 2))), r = Math.asin(e), o < 0 && (r = -r), A === 0 && c === 0 ? n = 0 : n = Te(Math.atan2(A, c) + this.long0);
    }
    return t.x = n, t.y = r, t;
  }
  var ppe = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
  const pm = {
    init: hpe,
    forward: gpe,
    inverse: fpe,
    names: ppe
  };
  function F4(t) {
    var e = Math.exp(t);
    return e = (e - 1 / e) / 2, e;
  }
  function yn(t, e) {
    t = Math.abs(t), e = Math.abs(e);
    var i = Math.max(t, e), r = Math.min(t, e) / (i || 1);
    return i * Math.sqrt(1 + Math.pow(r, 2));
  }
  function mpe(t) {
    var e = 1 + t, i = e - 1;
    return i === 0 ? t : t * Math.log(e) / i;
  }
  function Epe(t) {
    var e = Math.abs(t);
    return e = mpe(e * (1 + e / (yn(1, e) + 1))), t < 0 ? -e : e;
  }
  function F1(t, e) {
    for (var i = 2 * Math.cos(2 * e), r = t.length - 1, n = t[r], s = 0, o; --r >= 0; )
      o = -s + i * n + t[r], s = n, n = o;
    return e + o * Math.sin(2 * e);
  }
  function ype(t, e) {
    for (var i = 2 * Math.cos(e), r = t.length - 1, n = t[r], s = 0, o; --r >= 0; )
      o = -s + i * n + t[r], s = n, n = o;
    return Math.sin(e) * o;
  }
  function Bpe(t) {
    var e = Math.exp(t);
    return e = (e + 1 / e) / 2, e;
  }
  function S4(t, e, i) {
    for (var r = Math.sin(e), n = Math.cos(e), s = F4(i), o = Bpe(i), a = 2 * n * o, A = -2 * r * s, l = t.length - 1, c = t[l], u = 0, d = 0, h = 0, g, f; --l >= 0; )
      g = d, f = u, d = c, u = h, c = -g + a * d - A * u + t[l], h = -f + A * d + a * u;
    return a = r * o, A = n * s, [a * c - A * h, a * h + A * c];
  }
  function wpe() {
    if (!this.approx && (isNaN(this.es) || this.es <= 0))
      throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
    this.approx && (pm.init.apply(this), this.forward = pm.forward, this.inverse = pm.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
    var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), i = e;
    this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), i = i * e, this.cgb[1] = i * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = i * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), i = i * e, this.cgb[2] = i * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = i * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), i = i * e, this.cgb[3] = i * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = i * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), i = i * e, this.cgb[4] = i * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = i * (-734 / 315 + e * (109598 / 31185)), i = i * e, this.cgb[5] = i * (601676 / 22275), this.cbg[5] = i * (444337 / 155925), i = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + i * (1 / 4 + i * (1 / 64 + i / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = i * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = i * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), i = i * e, this.utg[2] = i * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = i * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), i = i * e, this.utg[3] = i * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = i * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), i = i * e, this.utg[4] = i * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = i * (34729 / 80640 + e * (-3418889 / 1995840)), i = i * e, this.utg[5] = i * (-20648693 / 638668800), this.gtu[5] = i * (212378941 / 319334400);
    var r = F1(this.cbg, this.lat0);
    this.Zb = -this.Qn * (r + ype(this.gtu, 2 * r));
  }
  function Cpe(t) {
    var e = Te(t.x - this.long0), i = t.y;
    i = F1(this.cbg, i);
    var r = Math.sin(i), n = Math.cos(i), s = Math.sin(e), o = Math.cos(e);
    i = Math.atan2(r, o * n), e = Math.atan2(s * n, yn(r, n * o)), e = Epe(Math.tan(e));
    var a = S4(this.gtu, 2 * i, 2 * e);
    i = i + a[0], e = e + a[1];
    var A, l;
    return Math.abs(e) <= 2.623395162778 ? (A = this.a * (this.Qn * e) + this.x0, l = this.a * (this.Qn * i + this.Zb) + this.y0) : (A = 1 / 0, l = 1 / 0), t.x = A, t.y = l, t;
  }
  function bpe(t) {
    var e = (t.x - this.x0) * (1 / this.a), i = (t.y - this.y0) * (1 / this.a);
    i = (i - this.Zb) / this.Qn, e = e / this.Qn;
    var r, n;
    if (Math.abs(e) <= 2.623395162778) {
      var s = S4(this.utg, 2 * i, 2 * e);
      i = i + s[0], e = e + s[1], e = Math.atan(F4(e));
      var o = Math.sin(i), a = Math.cos(i), A = Math.sin(e), l = Math.cos(e);
      i = Math.atan2(o * l, yn(A, l * a)), e = Math.atan2(A, l * a), r = Te(e + this.long0), n = F1(this.cgb, i);
    } else
      r = 1 / 0, n = 1 / 0;
    return t.x = r, t.y = n, t;
  }
  var Mpe = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
  const mm = {
    init: wpe,
    forward: Cpe,
    inverse: bpe,
    names: Mpe
  };
  function Ipe(t, e) {
    if (t === void 0) {
      if (t = Math.floor((Te(e) + Math.PI) * 30 / Math.PI) + 1, t < 0)
        return 0;
      if (t > 60)
        return 60;
    }
    return t;
  }
  var vpe = "etmerc";
  function xpe() {
    var t = Ipe(this.zone, this.long0);
    if (t === void 0)
      throw new Error("unknown utm zone");
    this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * Cr, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, mm.init.apply(this), this.forward = mm.forward, this.inverse = mm.inverse;
  }
  var Qpe = ["Universal Transverse Mercator System", "utm"];
  const Fpe = {
    init: xpe,
    names: Qpe,
    dependsOn: vpe
  };
  function S1(t, e) {
    return Math.pow((1 - t) / (1 + t), e);
  }
  var Spe = 20;
  function Dpe() {
    var t = Math.sin(this.lat0), e = Math.cos(this.lat0);
    e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + ti) / (Math.pow(Math.tan(0.5 * this.lat0 + ti), this.C) * S1(this.e * t, this.ratexp));
  }
  function Tpe(t) {
    var e = t.x, i = t.y;
    return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * i + ti), this.C) * S1(this.e * Math.sin(i), this.ratexp)) - Be, t.x = this.C * e, t;
  }
  function Rpe(t) {
    for (var e = 1e-14, i = t.x / this.C, r = t.y, n = Math.pow(Math.tan(0.5 * r + ti) / this.K, 1 / this.C), s = Spe; s > 0 && (r = 2 * Math.atan(n * S1(this.e * Math.sin(t.y), -0.5 * this.e)) - Be, !(Math.abs(r - t.y) < e)); --s)
      t.y = r;
    return s ? (t.x = i, t.y = r, t) : null;
  }
  const D1 = {
    init: Dpe,
    forward: Tpe,
    inverse: Rpe
  };
  function _pe() {
    D1.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
  }
  function kpe(t) {
    var e, i, r, n;
    return t.x = Te(t.x - this.long0), D1.forward.apply(this, [t]), e = Math.sin(t.y), i = Math.cos(t.y), r = Math.cos(t.x), n = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * i * r), t.x = n * i * Math.sin(t.x), t.y = n * (this.cosc0 * e - this.sinc0 * i * r), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
  }
  function Ype(t) {
    var e, i, r, n, s;
    if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, s = yn(t.x, t.y)) {
      var o = 2 * Math.atan2(s, this.R2);
      e = Math.sin(o), i = Math.cos(o), n = Math.asin(i * this.sinc0 + t.y * e * this.cosc0 / s), r = Math.atan2(t.x * e, s * this.cosc0 * i - t.y * this.sinc0 * e);
    } else
      n = this.phic0, r = 0;
    return t.x = r, t.y = n, D1.inverse.apply(this, [t]), t.x = Te(t.x + this.long0), t;
  }
  var Npe = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
  const Upe = {
    init: _pe,
    forward: kpe,
    inverse: Ype,
    names: Npe
  };
  function Lpe(t, e, i) {
    return e *= i, Math.tan(0.5 * (Be + t)) * Math.pow((1 - e) / (1 + e), 0.5 * i);
  }
  function zpe() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Se && (this.k0 = 0.5 * (1 + Ff(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= Se && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= Se && Math.abs(Math.cos(this.lat_ts)) > Se && (this.k0 = 0.5 * this.cons * Po(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Vs(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = Po(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - Be, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
  }
  function Ppe(t) {
    var e = t.x, i = t.y, r = Math.sin(i), n = Math.cos(i), s, o, a, A, l, c, u = Te(e - this.long0);
    return Math.abs(Math.abs(e - this.long0) - Math.PI) <= Se && Math.abs(i + this.lat0) <= Se ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (s = 2 * this.k0 / (1 + this.sinlat0 * r + this.coslat0 * n * Math.cos(u)), t.x = this.a * s * n * Math.sin(u) + this.x0, t.y = this.a * s * (this.coslat0 * r - this.sinlat0 * n * Math.cos(u)) + this.y0, t) : (o = 2 * Math.atan(this.ssfn_(i, r, this.e)) - Be, A = Math.cos(o), a = Math.sin(o), Math.abs(this.coslat0) <= Se ? (l = Vs(this.e, i * this.con, this.con * r), c = 2 * this.a * this.k0 * l / this.cons, t.x = this.x0 + c * Math.sin(e - this.long0), t.y = this.y0 - this.con * c * Math.cos(e - this.long0), t) : (Math.abs(this.sinlat0) < Se ? (s = 2 * this.a * this.k0 / (1 + A * Math.cos(u)), t.y = s * a) : (s = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * a + this.cosX0 * A * Math.cos(u))), t.y = s * (this.cosX0 * a - this.sinX0 * A * Math.cos(u)) + this.y0), t.x = s * A * Math.sin(u) + this.x0, t));
  }
  function Ope(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e, i, r, n, s, o = Math.sqrt(t.x * t.x + t.y * t.y);
    if (this.sphere) {
      var a = 2 * Math.atan(o / (2 * this.a * this.k0));
      return e = this.long0, i = this.lat0, o <= Se ? (t.x = e, t.y = i, t) : (i = Math.asin(Math.cos(a) * this.sinlat0 + t.y * Math.sin(a) * this.coslat0 / o), Math.abs(this.coslat0) < Se ? this.lat0 > 0 ? e = Te(this.long0 + Math.atan2(t.x, -1 * t.y)) : e = Te(this.long0 + Math.atan2(t.x, t.y)) : e = Te(this.long0 + Math.atan2(t.x * Math.sin(a), o * this.coslat0 * Math.cos(a) - t.y * this.sinlat0 * Math.sin(a))), t.x = e, t.y = i, t);
    } else if (Math.abs(this.coslat0) <= Se) {
      if (o <= Se)
        return i = this.lat0, e = this.long0, t.x = e, t.y = i, t;
      t.x *= this.con, t.y *= this.con, r = o * this.cons / (2 * this.a * this.k0), i = this.con * Tg(this.e, r), e = this.con * Te(this.con * this.long0 + Math.atan2(t.x, -1 * t.y));
    } else
      n = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= Se ? s = this.X0 : (s = Math.asin(Math.cos(n) * this.sinX0 + t.y * Math.sin(n) * this.cosX0 / o), e = Te(this.long0 + Math.atan2(t.x * Math.sin(n), o * this.cosX0 * Math.cos(n) - t.y * this.sinX0 * Math.sin(n)))), i = -1 * Tg(this.e, Math.tan(0.5 * (Be + s)));
    return t.x = e, t.y = i, t;
  }
  var Gpe = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic"];
  const jpe = {
    init: zpe,
    forward: Ppe,
    inverse: Ope,
    names: Gpe,
    ssfn_: Lpe
  };
  function Hpe() {
    var t = this.lat0;
    this.lambda0 = this.long0;
    var e = Math.sin(t), i = this.a, r = this.rf, n = 1 / r, s = 2 * n - Math.pow(n, 2), o = this.e = Math.sqrt(s);
    this.R = this.k0 * i * Math.sqrt(1 - s) / (1 - s * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + s / (1 - s) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
    var a = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), A = Math.log(Math.tan(Math.PI / 4 + t / 2)), l = Math.log((1 + o * e) / (1 - o * e));
    this.K = a - this.alpha * A + this.alpha * o / 2 * l;
  }
  function Jpe(t) {
    var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)), i = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))), r = -this.alpha * (e + i) + this.K, n = 2 * (Math.atan(Math.exp(r)) - Math.PI / 4), s = this.alpha * (t.x - this.lambda0), o = Math.atan(Math.sin(s) / (Math.sin(this.b0) * Math.tan(n) + Math.cos(this.b0) * Math.cos(s))), a = Math.asin(Math.cos(this.b0) * Math.sin(n) - Math.sin(this.b0) * Math.cos(n) * Math.cos(s));
    return t.y = this.R / 2 * Math.log((1 + Math.sin(a)) / (1 - Math.sin(a))) + this.y0, t.x = this.R * o + this.x0, t;
  }
  function Vpe(t) {
    for (var e = t.x - this.x0, i = t.y - this.y0, r = e / this.R, n = 2 * (Math.atan(Math.exp(i / this.R)) - Math.PI / 4), s = Math.asin(Math.cos(this.b0) * Math.sin(n) + Math.sin(this.b0) * Math.cos(n) * Math.cos(r)), o = Math.atan(Math.sin(r) / (Math.cos(this.b0) * Math.cos(r) - Math.sin(this.b0) * Math.tan(n))), a = this.lambda0 + o / this.alpha, A = 0, l = s, c = -1e3, u = 0; Math.abs(l - c) > 1e-7; ) {
      if (++u > 20)
        return;
      A = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + s / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l)) / 2)), c = l, l = 2 * Math.atan(Math.exp(A)) - Math.PI / 2;
    }
    return t.x = a, t.y = l, t;
  }
  var Wpe = ["somerc"];
  const Kpe = {
    init: Hpe,
    forward: Jpe,
    inverse: Vpe,
    names: Wpe
  };
  var $c = 1e-7;
  function Xpe(t) {
    var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], i = typeof t.PROJECTION == "object" ? Object.keys(t.PROJECTION)[0] : t.PROJECTION;
    return "no_uoff" in t || "no_off" in t || e.indexOf(i) !== -1;
  }
  function Zpe() {
    var t, e, i, r, n, s, o, a, A, l, c = 0, u, d = 0, h = 0, g = 0, f = 0, p = 0, m = 0;
    this.no_off = Xpe(this), this.no_rot = "no_rot" in this;
    var E = !1;
    "alpha" in this && (E = !0);
    var y = !1;
    if ("rectified_grid_angle" in this && (y = !0), E && (m = this.alpha), y && (c = this.rectified_grid_angle * Cr), E || y)
      d = this.longc;
    else if (h = this.long1, f = this.lat1, g = this.long2, p = this.lat2, Math.abs(f - p) <= $c || (t = Math.abs(f)) <= $c || Math.abs(t - Be) <= $c || Math.abs(Math.abs(this.lat0) - Be) <= $c || Math.abs(Math.abs(p) - Be) <= $c)
      throw new Error();
    var C = 1 - this.es;
    e = Math.sqrt(C), Math.abs(this.lat0) > Se ? (a = Math.sin(this.lat0), i = Math.cos(this.lat0), t = 1 - this.es * a * a, this.B = i * i, this.B = Math.sqrt(1 + this.es * this.B * this.B / C), this.A = this.B * this.k0 * e / t, r = this.B * e / (i * Math.sqrt(t)), n = r * r - 1, n <= 0 ? n = 0 : (n = Math.sqrt(n), this.lat0 < 0 && (n = -n)), this.E = n += r, this.E *= Math.pow(Vs(this.e, this.lat0, a), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = r = n = 1), E || y ? (E ? (u = Math.asin(Math.sin(m) / r), y || (c = m)) : (u = c, m = Math.asin(r * Math.sin(u))), this.lam0 = d - Math.asin(0.5 * (n - 1 / n) * Math.tan(u)) / this.B) : (s = Math.pow(Vs(this.e, f, Math.sin(f)), this.B), o = Math.pow(Vs(this.e, p, Math.sin(p)), this.B), n = this.E / s, A = (o - s) / (o + s), l = this.E * this.E, l = (l - o * s) / (l + o * s), t = h - g, t < -Math.pi ? g -= Sg : t > Math.pi && (g += Sg), this.lam0 = Te(0.5 * (h + g) - Math.atan(l * Math.tan(0.5 * this.B * (h - g)) / A) / this.B), u = Math.atan(2 * Math.sin(this.B * Te(h - this.lam0)) / (n - 1 / n)), c = m = Math.asin(r * Math.sin(u))), this.singam = Math.sin(u), this.cosgam = Math.cos(u), this.sinrot = Math.sin(c), this.cosrot = Math.cos(c), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A * this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(r * r - 1) / Math.cos(m))), this.lat0 < 0 && (this.u_0 = -this.u_0)), n = 0.5 * u, this.v_pole_n = this.ArB * Math.log(Math.tan(ti - n)), this.v_pole_s = this.ArB * Math.log(Math.tan(ti + n));
  }
  function qpe(t) {
    var e = {}, i, r, n, s, o, a, A, l;
    if (t.x = t.x - this.lam0, Math.abs(Math.abs(t.y) - Be) > Se) {
      if (o = this.E / Math.pow(Vs(this.e, t.y, Math.sin(t.y)), this.B), a = 1 / o, i = 0.5 * (o - a), r = 0.5 * (o + a), s = Math.sin(this.B * t.x), n = (i * this.singam - s * this.cosgam) / r, Math.abs(Math.abs(n) - 1) < Se)
        throw new Error();
      l = 0.5 * this.ArB * Math.log((1 - n) / (1 + n)), a = Math.cos(this.B * t.x), Math.abs(a) < $c ? A = this.A * t.x : A = this.ArB * Math.atan2(i * this.cosgam + s * this.singam, a);
    } else
      l = t.y > 0 ? this.v_pole_n : this.v_pole_s, A = this.ArB * t.y;
    return this.no_rot ? (e.x = A, e.y = l) : (A -= this.u_0, e.x = l * this.cosrot + A * this.sinrot, e.y = A * this.cosrot - l * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
  }
  function $pe(t) {
    var e, i, r, n, s, o, a, A = {};
    if (t.x = (t.x - this.x0) * (1 / this.a), t.y = (t.y - this.y0) * (1 / this.a), this.no_rot ? (i = t.y, e = t.x) : (i = t.x * this.cosrot - t.y * this.sinrot, e = t.y * this.cosrot + t.x * this.sinrot + this.u_0), r = Math.exp(-this.BrA * i), n = 0.5 * (r - 1 / r), s = 0.5 * (r + 1 / r), o = Math.sin(this.BrA * e), a = (o * this.cosgam + n * this.singam) / s, Math.abs(Math.abs(a) - 1) < Se)
      A.x = 0, A.y = a < 0 ? -Be : Be;
    else {
      if (A.y = this.E / Math.sqrt((1 + a) / (1 - a)), A.y = Tg(this.e, Math.pow(A.y, 1 / this.B)), A.y === 1 / 0)
        throw new Error();
      A.x = -this.rB * Math.atan2(n * this.cosgam - o * this.singam, Math.cos(this.BrA * e));
    }
    return A.x += this.lam0, A;
  }
  var eme = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
  const tme = {
    init: Zpe,
    forward: qpe,
    inverse: $pe,
    names: eme
  };
  function ime() {
    if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < Se)) {
      var t = this.b / this.a;
      this.e = Math.sqrt(1 - t * t);
      var e = Math.sin(this.lat1), i = Math.cos(this.lat1), r = Po(this.e, e, i), n = Vs(this.e, this.lat1, e), s = Math.sin(this.lat2), o = Math.cos(this.lat2), a = Po(this.e, s, o), A = Vs(this.e, this.lat2, s), l = Vs(this.e, this.lat0, Math.sin(this.lat0));
      Math.abs(this.lat1 - this.lat2) > Se ? this.ns = Math.log(r / a) / Math.log(n / A) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = r / (this.ns * Math.pow(n, this.ns)), this.rh = this.a * this.f0 * Math.pow(l, this.ns), this.title || (this.title = "Lambert Conformal Conic");
    }
  }
  function rme(t) {
    var e = t.x, i = t.y;
    Math.abs(2 * Math.abs(i) - Math.PI) <= Se && (i = Ff(i) * (Be - 2 * Se));
    var r = Math.abs(Math.abs(i) - Be), n, s;
    if (r > Se)
      n = Vs(this.e, i, Math.sin(i)), s = this.a * this.f0 * Math.pow(n, this.ns);
    else {
      if (r = i * this.ns, r <= 0)
        return null;
      s = 0;
    }
    var o = this.ns * Te(e - this.long0);
    return t.x = this.k0 * (s * Math.sin(o)) + this.x0, t.y = this.k0 * (this.rh - s * Math.cos(o)) + this.y0, t;
  }
  function nme(t) {
    var e, i, r, n, s, o = (t.x - this.x0) / this.k0, a = this.rh - (t.y - this.y0) / this.k0;
    this.ns > 0 ? (e = Math.sqrt(o * o + a * a), i = 1) : (e = -Math.sqrt(o * o + a * a), i = -1);
    var A = 0;
    if (e !== 0 && (A = Math.atan2(i * o, i * a)), e !== 0 || this.ns > 0) {
      if (i = 1 / this.ns, r = Math.pow(e / (this.a * this.f0), i), n = Tg(this.e, r), n === -9999)
        return null;
    } else
      n = -Be;
    return s = Te(A / this.ns + this.long0), t.x = s, t.y = n, t;
  }
  var sme = [
    "Lambert Tangential Conformal Conic Projection",
    "Lambert_Conformal_Conic",
    "Lambert_Conformal_Conic_1SP",
    "Lambert_Conformal_Conic_2SP",
    "lcc",
    "Lambert Conic Conformal (1SP)",
    "Lambert Conic Conformal (2SP)"
  ];
  const ome = {
    init: ime,
    forward: rme,
    inverse: nme,
    names: sme
  };
  function ame() {
    this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
  }
  function Ame(t) {
    var e, i, r, n, s, o, a, A = t.x, l = t.y, c = Te(A - this.long0);
    return e = Math.pow((1 + this.e * Math.sin(l)) / (1 - this.e * Math.sin(l)), this.alfa * this.e / 2), i = 2 * (Math.atan(this.k * Math.pow(Math.tan(l / 2 + this.s45), this.alfa) / e) - this.s45), r = -c * this.alfa, n = Math.asin(Math.cos(this.ad) * Math.sin(i) + Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), s = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(n)), o = this.n * s, a = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(n / 2 + this.s45), this.n), t.y = a * Math.cos(o) / 1, t.x = a * Math.sin(o) / 1, this.czech || (t.y *= -1, t.x *= -1), t;
  }
  function lme(t) {
    var e, i, r, n, s, o, a, A, l = t.x;
    t.x = t.y, t.y = l, this.czech || (t.y *= -1, t.x *= -1), o = Math.sqrt(t.x * t.x + t.y * t.y), s = Math.atan2(t.y, t.x), n = s / Math.sin(this.s0), r = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(r) - Math.sin(this.ad) * Math.cos(r) * Math.cos(n)), i = Math.asin(Math.cos(r) * Math.sin(n) / Math.cos(e)), t.x = this.long0 - i / this.alfa, a = e, A = 0;
    var c = 0;
    do
      t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(a)) / (1 - this.e * Math.sin(a)), this.e / 2)) - this.s45), Math.abs(a - t.y) < 1e-10 && (A = 1), a = t.y, c += 1;
    while (A === 0 && c < 15);
    return c >= 15 ? null : t;
  }
  var cme = ["Krovak", "krovak"];
  const ume = {
    init: ame,
    forward: Ame,
    inverse: lme,
    names: cme
  };
  function Xr(t, e, i, r, n) {
    return t * n - e * Math.sin(2 * n) + i * Math.sin(4 * n) - r * Math.sin(6 * n);
  }
  function Sf(t) {
    return 1 - 0.25 * t * (1 + t / 16 * (3 + 1.25 * t));
  }
  function Df(t) {
    return 0.375 * t * (1 + 0.25 * t * (1 + 0.46875 * t));
  }
  function Tf(t) {
    return 0.05859375 * t * t * (1 + 0.75 * t);
  }
  function Rf(t) {
    return t * t * t * (35 / 3072);
  }
  function md(t, e, i) {
    var r = e * i;
    return t / Math.sqrt(1 - r * r);
  }
  function KA(t) {
    return Math.abs(t) < Be ? t : t - Ff(t) * Math.PI;
  }
  function cy(t, e, i, r, n) {
    var s, o;
    s = t / e;
    for (var a = 0; a < 15; a++)
      if (o = (t - (e * s - i * Math.sin(2 * s) + r * Math.sin(4 * s) - n * Math.sin(6 * s))) / (e - 2 * i * Math.cos(2 * s) + 4 * r * Math.cos(4 * s) - 6 * n * Math.cos(6 * s)), s += o, Math.abs(o) <= 1e-10)
        return s;
    return NaN;
  }
  function dme() {
    this.sphere || (this.e0 = Sf(this.es), this.e1 = Df(this.es), this.e2 = Tf(this.es), this.e3 = Rf(this.es), this.ml0 = this.a * Xr(this.e0, this.e1, this.e2, this.e3, this.lat0));
  }
  function hme(t) {
    var e, i, r = t.x, n = t.y;
    if (r = Te(r - this.long0), this.sphere)
      e = this.a * Math.asin(Math.cos(n) * Math.sin(r)), i = this.a * (Math.atan2(Math.tan(n), Math.cos(r)) - this.lat0);
    else {
      var s = Math.sin(n), o = Math.cos(n), a = md(this.a, this.e, s), A = Math.tan(n) * Math.tan(n), l = r * Math.cos(n), c = l * l, u = this.es * o * o / (1 - this.es), d = this.a * Xr(this.e0, this.e1, this.e2, this.e3, n);
      e = a * l * (1 - c * A * (1 / 6 - (8 - A + 8 * u) * c / 120)), i = d - this.ml0 + a * s / o * c * (0.5 + (5 - A + 6 * u) * c / 24);
    }
    return t.x = e + this.x0, t.y = i + this.y0, t;
  }
  function gme(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e = t.x / this.a, i = t.y / this.a, r, n;
    if (this.sphere) {
      var s = i + this.lat0;
      r = Math.asin(Math.sin(s) * Math.cos(e)), n = Math.atan2(Math.tan(e), Math.cos(s));
    } else {
      var o = this.ml0 / this.a + i, a = cy(o, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(a) - Be) <= Se)
        return t.x = this.long0, t.y = Be, i < 0 && (t.y *= -1), t;
      var A = md(this.a, this.e, Math.sin(a)), l = A * A * A / this.a / this.a * (1 - this.es), c = Math.pow(Math.tan(a), 2), u = e * this.a / A, d = u * u;
      r = a - A * Math.tan(a) / l * u * u * (0.5 - (1 + 3 * c) * u * u / 24), n = u * (1 - d * (c / 3 + (1 + 3 * c) * c * d / 15)) / Math.cos(a);
    }
    return t.x = Te(n + this.long0), t.y = KA(r), t;
  }
  var fme = ["Cassini", "Cassini_Soldner", "cass"];
  const pme = {
    init: dme,
    forward: hme,
    inverse: gme,
    names: fme
  };
  function wA(t, e) {
    var i;
    return t > 1e-7 ? (i = t * e, (1 - t * t) * (e / (1 - i * i) - 0.5 / t * Math.log((1 - i) / (1 + i)))) : 2 * e;
  }
  var mme = 1, Eme = 2, yme = 3, Bme = 4;
  function wme() {
    var t = Math.abs(this.lat0);
    if (Math.abs(t - Be) < Se ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < Se ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
      var e;
      switch (this.qp = wA(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = Sme(this.es), this.mode) {
        case this.N_POLE:
          this.dd = 1;
          break;
        case this.S_POLE:
          this.dd = 1;
          break;
        case this.EQUIT:
          this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
          break;
        case this.OBLIQ:
          this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = wA(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
          break;
      }
    } else
      this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
  }
  function Cme(t) {
    var e, i, r, n, s, o, a, A, l, c, u = t.x, d = t.y;
    if (u = Te(u - this.long0), this.sphere) {
      if (s = Math.sin(d), c = Math.cos(d), r = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if (i = this.mode === this.EQUIT ? 1 + c * r : 1 + this.sinph0 * s + this.cosph0 * c * r, i <= Se)
          return null;
        i = Math.sqrt(2 / i), e = i * c * Math.sin(u), i *= this.mode === this.EQUIT ? s : this.cosph0 * s - this.sinph0 * c * r;
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (r = -r), Math.abs(d + this.lat0) < Se)
          return null;
        i = ti - d * 0.5, i = 2 * (this.mode === this.S_POLE ? Math.cos(i) : Math.sin(i)), e = i * Math.sin(u), i *= r;
      }
    } else {
      switch (a = 0, A = 0, l = 0, r = Math.cos(u), n = Math.sin(u), s = Math.sin(d), o = wA(this.e, s), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (a = o / this.qp, A = Math.sqrt(1 - a * a)), this.mode) {
        case this.OBLIQ:
          l = 1 + this.sinb1 * a + this.cosb1 * A * r;
          break;
        case this.EQUIT:
          l = 1 + A * r;
          break;
        case this.N_POLE:
          l = Be + d, o = this.qp - o;
          break;
        case this.S_POLE:
          l = d - Be, o = this.qp + o;
          break;
      }
      if (Math.abs(l) < Se)
        return null;
      switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          l = Math.sqrt(2 / l), this.mode === this.OBLIQ ? i = this.ymf * l * (this.cosb1 * a - this.sinb1 * A * r) : i = (l = Math.sqrt(2 / (1 + A * r))) * a * this.ymf, e = this.xmf * l * A * n;
          break;
        case this.N_POLE:
        case this.S_POLE:
          o >= 0 ? (e = (l = Math.sqrt(o)) * n, i = r * (this.mode === this.S_POLE ? l : -l)) : e = i = 0;
          break;
      }
    }
    return t.x = this.a * e + this.x0, t.y = this.a * i + this.y0, t;
  }
  function bme(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e = t.x / this.a, i = t.y / this.a, r, n, s, o, a, A, l;
    if (this.sphere) {
      var c = 0, u, d = 0;
      if (u = Math.sqrt(e * e + i * i), n = u * 0.5, n > 1)
        return null;
      switch (n = 2 * Math.asin(n), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (d = Math.sin(n), c = Math.cos(n)), this.mode) {
        case this.EQUIT:
          n = Math.abs(u) <= Se ? 0 : Math.asin(i * d / u), e *= d, i = c * u;
          break;
        case this.OBLIQ:
          n = Math.abs(u) <= Se ? this.lat0 : Math.asin(c * this.sinph0 + i * d * this.cosph0 / u), e *= d * this.cosph0, i = (c - Math.sin(n) * this.sinph0) * u;
          break;
        case this.N_POLE:
          i = -i, n = Be - n;
          break;
        case this.S_POLE:
          n -= Be;
          break;
      }
      r = i === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, i);
    } else {
      if (l = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if (e /= this.dd, i *= this.dd, A = Math.sqrt(e * e + i * i), A < Se)
          return t.x = this.long0, t.y = this.lat0, t;
        o = 2 * Math.asin(0.5 * A / this.rq), s = Math.cos(o), e *= o = Math.sin(o), this.mode === this.OBLIQ ? (l = s * this.sinb1 + i * o * this.cosb1 / A, a = this.qp * l, i = A * this.cosb1 * s - i * this.sinb1 * o) : (l = i * o / A, a = this.qp * l, i = A * s);
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (i = -i), a = e * e + i * i, !a)
          return t.x = this.long0, t.y = this.lat0, t;
        l = 1 - a / this.qp, this.mode === this.S_POLE && (l = -l);
      }
      r = Math.atan2(e, i), n = Dme(Math.asin(l), this.apa);
    }
    return t.x = Te(this.long0 + r), t.y = n, t;
  }
  var Mme = 0.3333333333333333, Ime = 0.17222222222222222, vme = 0.10257936507936508, xme = 0.06388888888888888, Qme = 0.0664021164021164, Fme = 0.016415012942191543;
  function Sme(t) {
    var e, i = [];
    return i[0] = t * Mme, e = t * t, i[0] += e * Ime, i[1] = e * xme, e *= t, i[0] += e * vme, i[1] += e * Qme, i[2] = e * Fme, i;
  }
  function Dme(t, e) {
    var i = t + t;
    return t + e[0] * Math.sin(i) + e[1] * Math.sin(i + i) + e[2] * Math.sin(i + i + i);
  }
  var Tme = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  const Rme = {
    init: wme,
    forward: Cme,
    inverse: bme,
    names: Tme,
    S_POLE: mme,
    N_POLE: Eme,
    EQUIT: yme,
    OBLIQ: Bme
  };
  function _A(t) {
    return Math.abs(t) > 1 && (t = t > 1 ? 1 : -1), Math.asin(t);
  }
  function _me() {
    Math.abs(this.lat1 + this.lat2) < Se || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = Po(this.e3, this.sin_po, this.cos_po), this.qs1 = wA(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = Po(this.e3, this.sin_po, this.cos_po), this.qs2 = wA(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = wA(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > Se ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
  }
  function kme(t) {
    var e = t.x, i = t.y;
    this.sin_phi = Math.sin(i), this.cos_phi = Math.cos(i);
    var r = wA(this.e3, this.sin_phi), n = this.a * Math.sqrt(this.c - this.ns0 * r) / this.ns0, s = this.ns0 * Te(e - this.long0), o = n * Math.sin(s) + this.x0, a = this.rh - n * Math.cos(s) + this.y0;
    return t.x = o, t.y = a, t;
  }
  function Yme(t) {
    var e, i, r, n, s, o;
    return t.x -= this.x0, t.y = this.rh - t.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), r = 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), r = -1), n = 0, e !== 0 && (n = Math.atan2(r * t.x, r * t.y)), r = e * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - r * r) / (2 * this.ns0)) : (i = (this.c - r * r) / this.ns0, o = this.phi1z(this.e3, i)), s = Te(n / this.ns0 + this.long0), t.x = s, t.y = o, t;
  }
  function Nme(t, e) {
    var i, r, n, s, o, a = _A(0.5 * e);
    if (t < Se)
      return a;
    for (var A = t * t, l = 1; l <= 25; l++)
      if (i = Math.sin(a), r = Math.cos(a), n = t * i, s = 1 - n * n, o = 0.5 * s * s / r * (e / (1 - A) - i / s + 0.5 / t * Math.log((1 - n) / (1 + n))), a = a + o, Math.abs(o) <= 1e-7)
        return a;
    return null;
  }
  var Ume = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  const Lme = {
    init: _me,
    forward: kme,
    inverse: Yme,
    names: Ume,
    phi1z: Nme
  };
  function zme() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
  }
  function Pme(t) {
    var e, i, r, n, s, o, a, A, l = t.x, c = t.y;
    return r = Te(l - this.long0), e = Math.sin(c), i = Math.cos(c), n = Math.cos(r), o = this.sin_p14 * e + this.cos_p14 * i * n, s = 1, o > 0 || Math.abs(o) <= Se ? (a = this.x0 + this.a * s * i * Math.sin(r) / o, A = this.y0 + this.a * s * (this.cos_p14 * e - this.sin_p14 * i * n) / o) : (a = this.x0 + this.infinity_dist * i * Math.sin(r), A = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * i * n)), t.x = a, t.y = A, t;
  }
  function Ome(t) {
    var e, i, r, n, s, o;
    return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (n = Math.atan2(e, this.rc), i = Math.sin(n), r = Math.cos(n), o = _A(r * this.sin_p14 + t.y * i * this.cos_p14 / e), s = Math.atan2(t.x * i, e * this.cos_p14 * r - t.y * this.sin_p14 * i), s = Te(this.long0 + s)) : (o = this.phic0, s = 0), t.x = s, t.y = o, t;
  }
  var Gme = ["gnom"];
  const jme = {
    init: zme,
    forward: Pme,
    inverse: Ome,
    names: Gme
  };
  function Hme(t, e) {
    var i = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
    if (Math.abs(Math.abs(e) - i) < 1e-6)
      return e < 0 ? -1 * Be : Be;
    for (var r = Math.asin(0.5 * e), n, s, o, a, A = 0; A < 30; A++)
      if (s = Math.sin(r), o = Math.cos(r), a = t * s, n = Math.pow(1 - a * a, 2) / (2 * o) * (e / (1 - t * t) - s / (1 - a * a) + 0.5 / t * Math.log((1 - a) / (1 + a))), r += n, Math.abs(n) <= 1e-10)
        return r;
    return NaN;
  }
  function Jme() {
    this.sphere || (this.k0 = Po(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
  }
  function Vme(t) {
    var e = t.x, i = t.y, r, n, s = Te(e - this.long0);
    if (this.sphere)
      r = this.x0 + this.a * s * Math.cos(this.lat_ts), n = this.y0 + this.a * Math.sin(i) / Math.cos(this.lat_ts);
    else {
      var o = wA(this.e, Math.sin(i));
      r = this.x0 + this.a * this.k0 * s, n = this.y0 + this.a * o * 0.5 / this.k0;
    }
    return t.x = r, t.y = n, t;
  }
  function Wme(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e, i;
    return this.sphere ? (e = Te(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), i = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (i = Hme(this.e, 2 * t.y * this.k0 / this.a), e = Te(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = i, t;
  }
  var Kme = ["cea"];
  const Xme = {
    init: Jme,
    forward: Vme,
    inverse: Wme,
    names: Kme
  };
  function Zme() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
  }
  function qme(t) {
    var e = t.x, i = t.y, r = Te(e - this.long0), n = KA(i - this.lat0);
    return t.x = this.x0 + this.a * r * this.rc, t.y = this.y0 + this.a * n, t;
  }
  function $me(t) {
    var e = t.x, i = t.y;
    return t.x = Te(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = KA(this.lat0 + (i - this.y0) / this.a), t;
  }
  var eEe = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  const tEe = {
    init: Zme,
    forward: qme,
    inverse: $me,
    names: eEe
  };
  var v_ = 20;
  function iEe() {
    this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Sf(this.es), this.e1 = Df(this.es), this.e2 = Tf(this.es), this.e3 = Rf(this.es), this.ml0 = this.a * Xr(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
  function rEe(t) {
    var e = t.x, i = t.y, r, n, s, o = Te(e - this.long0);
    if (s = o * Math.sin(i), this.sphere)
      Math.abs(i) <= Se ? (r = this.a * o, n = -1 * this.a * this.lat0) : (r = this.a * Math.sin(s) / Math.tan(i), n = this.a * (KA(i - this.lat0) + (1 - Math.cos(s)) / Math.tan(i)));
    else if (Math.abs(i) <= Se)
      r = this.a * o, n = -1 * this.ml0;
    else {
      var a = md(this.a, this.e, Math.sin(i)) / Math.tan(i);
      r = a * Math.sin(s), n = this.a * Xr(this.e0, this.e1, this.e2, this.e3, i) - this.ml0 + a * (1 - Math.cos(s));
    }
    return t.x = r + this.x0, t.y = n + this.y0, t;
  }
  function nEe(t) {
    var e, i, r, n, s, o, a, A, l;
    if (r = t.x - this.x0, n = t.y - this.y0, this.sphere)
      if (Math.abs(n + this.a * this.lat0) <= Se)
        e = Te(r / this.a + this.long0), i = 0;
      else {
        o = this.lat0 + n / this.a, a = r * r / this.a / this.a + o * o, A = o;
        var c;
        for (s = v_; s; --s)
          if (c = Math.tan(A), l = -1 * (o * (A * c + 1) - A - 0.5 * (A * A + a) * c) / ((A - o) / c - 1), A += l, Math.abs(l) <= Se) {
            i = A;
            break;
          }
        e = Te(this.long0 + Math.asin(r * Math.tan(A) / this.a) / Math.sin(i));
      }
    else if (Math.abs(n + this.ml0) <= Se)
      i = 0, e = Te(this.long0 + r / this.a);
    else {
      o = (this.ml0 + n) / this.a, a = r * r / this.a / this.a + o * o, A = o;
      var u, d, h, g, f;
      for (s = v_; s; --s)
        if (f = this.e * Math.sin(A), u = Math.sqrt(1 - f * f) * Math.tan(A), d = this.a * Xr(this.e0, this.e1, this.e2, this.e3, A), h = this.e0 - 2 * this.e1 * Math.cos(2 * A) + 4 * this.e2 * Math.cos(4 * A) - 6 * this.e3 * Math.cos(6 * A), g = d / this.a, l = (o * (u * g + 1) - g - 0.5 * u * (g * g + a)) / (this.es * Math.sin(2 * A) * (g * g + a - 2 * o * g) / (4 * u) + (o - g) * (u * h - 2 / Math.sin(2 * A)) - h), A -= l, Math.abs(l) <= Se) {
          i = A;
          break;
        }
      u = Math.sqrt(1 - this.es * Math.pow(Math.sin(i), 2)) * Math.tan(i), e = Te(this.long0 + Math.asin(r * u / this.a) / Math.sin(i));
    }
    return t.x = e, t.y = i, t;
  }
  var sEe = ["Polyconic", "poly"];
  const oEe = {
    init: iEe,
    forward: rEe,
    inverse: nEe,
    names: sEe
  };
  function aEe() {
    this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
  }
  function AEe(t) {
    var e, i = t.x, r = t.y, n = r - this.lat0, s = i - this.long0, o = n / Hh * 1e-5, a = s, A = 1, l = 0;
    for (e = 1; e <= 10; e++)
      A = A * o, l = l + this.A[e] * A;
    var c = l, u = a, d = 1, h = 0, g, f, p = 0, m = 0;
    for (e = 1; e <= 6; e++)
      g = d * c - h * u, f = h * c + d * u, d = g, h = f, p = p + this.B_re[e] * d - this.B_im[e] * h, m = m + this.B_im[e] * d + this.B_re[e] * h;
    return t.x = m * this.a + this.x0, t.y = p * this.a + this.y0, t;
  }
  function lEe(t) {
    var e, i = t.x, r = t.y, n = i - this.x0, s = r - this.y0, o = s / this.a, a = n / this.a, A = 1, l = 0, c, u, d = 0, h = 0;
    for (e = 1; e <= 6; e++)
      c = A * o - l * a, u = l * o + A * a, A = c, l = u, d = d + this.C_re[e] * A - this.C_im[e] * l, h = h + this.C_im[e] * A + this.C_re[e] * l;
    for (var g = 0; g < this.iterations; g++) {
      var f = d, p = h, m, E, y = o, C = a;
      for (e = 2; e <= 6; e++)
        m = f * d - p * h, E = p * d + f * h, f = m, p = E, y = y + (e - 1) * (this.B_re[e] * f - this.B_im[e] * p), C = C + (e - 1) * (this.B_im[e] * f + this.B_re[e] * p);
      f = 1, p = 0;
      var w = this.B_re[1], M = this.B_im[1];
      for (e = 2; e <= 6; e++)
        m = f * d - p * h, E = p * d + f * h, f = m, p = E, w = w + e * (this.B_re[e] * f - this.B_im[e] * p), M = M + e * (this.B_im[e] * f + this.B_re[e] * p);
      var I = w * w + M * M;
      d = (y * w + C * M) / I, h = (C * w - y * M) / I;
    }
    var b = d, B = h, x = 1, Q = 0;
    for (e = 1; e <= 9; e++)
      x = x * b, Q = Q + this.D[e] * x;
    var v = this.lat0 + Q * Hh * 1e5, T = this.long0 + B;
    return t.x = T, t.y = v, t;
  }
  var cEe = ["New_Zealand_Map_Grid", "nzmg"];
  const uEe = {
    init: aEe,
    forward: AEe,
    inverse: lEe,
    names: cEe
  };
  function dEe() {
  }
  function hEe(t) {
    var e = t.x, i = t.y, r = Te(e - this.long0), n = this.x0 + this.a * r, s = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i / 2.5)) * 1.25;
    return t.x = n, t.y = s, t;
  }
  function gEe(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e = Te(this.long0 + t.x / this.a), i = 2.5 * (Math.atan(Math.exp(0.8 * t.y / this.a)) - Math.PI / 4);
    return t.x = e, t.y = i, t;
  }
  var fEe = ["Miller_Cylindrical", "mill"];
  const pEe = {
    init: dEe,
    forward: hEe,
    inverse: gEe,
    names: fEe
  };
  var mEe = 20;
  function EEe() {
    this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = x1(this.es);
  }
  function yEe(t) {
    var e, i, r = t.x, n = t.y;
    if (r = Te(r - this.long0), this.sphere) {
      if (!this.m)
        n = this.n !== 1 ? Math.asin(this.n * Math.sin(n)) : n;
      else
        for (var s = this.n * Math.sin(n), o = mEe; o; --o) {
          var a = (this.m * n + Math.sin(n) - s) / (this.m + Math.cos(n));
          if (n -= a, Math.abs(a) < Se)
            break;
        }
      e = this.a * this.C_x * r * (this.m + Math.cos(n)), i = this.a * this.C_y * n;
    } else {
      var A = Math.sin(n), l = Math.cos(n);
      i = this.a * Jd(n, A, l, this.en), e = this.a * r * l / Math.sqrt(1 - this.es * A * A);
    }
    return t.x = e, t.y = i, t;
  }
  function BEe(t) {
    var e, i, r, n;
    return t.x -= this.x0, r = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, r = r / (this.C_x * (this.m + Math.cos(e))), this.m ? e = _A((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = _A(Math.sin(e) / this.n)), r = Te(r + this.long0), e = KA(e)) : (e = Q1(t.y / this.a, this.es, this.en), n = Math.abs(e), n < Be ? (n = Math.sin(e), i = this.long0 + t.x * Math.sqrt(1 - this.es * n * n) / (this.a * Math.cos(e)), r = Te(i)) : n - Se < Be && (r = this.long0)), t.x = r, t.y = e, t;
  }
  var wEe = ["Sinusoidal", "sinu"];
  const CEe = {
    init: EEe,
    forward: yEe,
    inverse: BEe,
    names: wEe
  };
  function bEe() {
  }
  function MEe(t) {
    for (var e = t.x, i = t.y, r = Te(e - this.long0), n = i, s = Math.PI * Math.sin(i); ; ) {
      var o = -(n + Math.sin(n) - s) / (1 + Math.cos(n));
      if (n += o, Math.abs(o) < Se)
        break;
    }
    n /= 2, Math.PI / 2 - Math.abs(i) < Se && (r = 0);
    var a = 0.900316316158 * this.a * r * Math.cos(n) + this.x0, A = 1.4142135623731 * this.a * Math.sin(n) + this.y0;
    return t.x = a, t.y = A, t;
  }
  function IEe(t) {
    var e, i;
    t.x -= this.x0, t.y -= this.y0, i = t.y / (1.4142135623731 * this.a), Math.abs(i) > 0.999999999999 && (i = 0.999999999999), e = Math.asin(i);
    var r = Te(this.long0 + t.x / (0.900316316158 * this.a * Math.cos(e)));
    r < -Math.PI && (r = -Math.PI), r > Math.PI && (r = Math.PI), i = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(i) > 1 && (i = 1);
    var n = Math.asin(i);
    return t.x = r, t.y = n, t;
  }
  var vEe = ["Mollweide", "moll"];
  const xEe = {
    init: bEe,
    forward: MEe,
    inverse: IEe,
    names: vEe
  };
  function QEe() {
    Math.abs(this.lat1 + this.lat2) < Se || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = Sf(this.es), this.e1 = Df(this.es), this.e2 = Tf(this.es), this.e3 = Rf(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = Po(this.e, this.sinphi, this.cosphi), this.ml1 = Xr(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < Se ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = Po(this.e, this.sinphi, this.cosphi), this.ml2 = Xr(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = Xr(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
  }
  function FEe(t) {
    var e = t.x, i = t.y, r;
    if (this.sphere)
      r = this.a * (this.g - i);
    else {
      var n = Xr(this.e0, this.e1, this.e2, this.e3, i);
      r = this.a * (this.g - n);
    }
    var s = this.ns * Te(e - this.long0), o = this.x0 + r * Math.sin(s), a = this.y0 + this.rh - r * Math.cos(s);
    return t.x = o, t.y = a, t;
  }
  function SEe(t) {
    t.x -= this.x0, t.y = this.rh - t.y + this.y0;
    var e, i, r, n;
    this.ns >= 0 ? (i = Math.sqrt(t.x * t.x + t.y * t.y), e = 1) : (i = -Math.sqrt(t.x * t.x + t.y * t.y), e = -1);
    var s = 0;
    if (i !== 0 && (s = Math.atan2(e * t.x, e * t.y)), this.sphere)
      return n = Te(this.long0 + s / this.ns), r = KA(this.g - i / this.a), t.x = n, t.y = r, t;
    var o = this.g - i / this.a;
    return r = cy(o, this.e0, this.e1, this.e2, this.e3), n = Te(this.long0 + s / this.ns), t.x = n, t.y = r, t;
  }
  var DEe = ["Equidistant_Conic", "eqdc"];
  const TEe = {
    init: QEe,
    forward: FEe,
    inverse: SEe,
    names: DEe
  };
  function REe() {
    this.R = this.a;
  }
  function _Ee(t) {
    var e = t.x, i = t.y, r = Te(e - this.long0), n, s;
    Math.abs(i) <= Se && (n = this.x0 + this.R * r, s = this.y0);
    var o = _A(2 * Math.abs(i / Math.PI));
    (Math.abs(r) <= Se || Math.abs(Math.abs(i) - Be) <= Se) && (n = this.x0, i >= 0 ? s = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : s = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
    var a = 0.5 * Math.abs(Math.PI / r - r / Math.PI), A = a * a, l = Math.sin(o), c = Math.cos(o), u = c / (l + c - 1), d = u * u, h = u * (2 / l - 1), g = h * h, f = Math.PI * this.R * (a * (u - g) + Math.sqrt(A * (u - g) * (u - g) - (g + A) * (d - g))) / (g + A);
    r < 0 && (f = -f), n = this.x0 + f;
    var p = A + u;
    return f = Math.PI * this.R * (h * p - a * Math.sqrt((g + A) * (A + 1) - p * p)) / (g + A), i >= 0 ? s = this.y0 + f : s = this.y0 - f, t.x = n, t.y = s, t;
  }
  function kEe(t) {
    var e, i, r, n, s, o, a, A, l, c, u, d, h;
    return t.x -= this.x0, t.y -= this.y0, u = Math.PI * this.R, r = t.x / u, n = t.y / u, s = r * r + n * n, o = -Math.abs(n) * (1 + s), a = o - 2 * n * n + r * r, A = -2 * o + 1 + 2 * n * n + s * s, h = n * n / A + (2 * a * a * a / A / A / A - 9 * o * a / A / A) / 27, l = (o - a * a / 3 / A) / A, c = 2 * Math.sqrt(-l / 3), u = 3 * h / l / c, Math.abs(u) > 1 && (u >= 0 ? u = 1 : u = -1), d = Math.acos(u) / 3, t.y >= 0 ? i = (-c * Math.cos(d + Math.PI / 3) - a / 3 / A) * Math.PI : i = -(-c * Math.cos(d + Math.PI / 3) - a / 3 / A) * Math.PI, Math.abs(r) < Se ? e = this.long0 : e = Te(this.long0 + Math.PI * (s - 1 + Math.sqrt(1 + 2 * (r * r - n * n) + s * s)) / 2 / r), t.x = e, t.y = i, t;
  }
  var YEe = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  const NEe = {
    init: REe,
    forward: _Ee,
    inverse: kEe,
    names: YEe
  };
  function UEe() {
    this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
  }
  function LEe(t) {
    var e = t.x, i = t.y, r = Math.sin(t.y), n = Math.cos(t.y), s = Te(e - this.long0), o, a, A, l, c, u, d, h, g, f, p, m, E, y, C, w, M, I, b, B, x, Q, v;
    return this.sphere ? Math.abs(this.sin_p12 - 1) <= Se ? (t.x = this.x0 + this.a * (Be - i) * Math.sin(s), t.y = this.y0 - this.a * (Be - i) * Math.cos(s), t) : Math.abs(this.sin_p12 + 1) <= Se ? (t.x = this.x0 + this.a * (Be + i) * Math.sin(s), t.y = this.y0 + this.a * (Be + i) * Math.cos(s), t) : (I = this.sin_p12 * r + this.cos_p12 * n * Math.cos(s), w = Math.acos(I), M = w ? w / Math.sin(w) : 1, t.x = this.x0 + this.a * M * n * Math.sin(s), t.y = this.y0 + this.a * M * (this.cos_p12 * r - this.sin_p12 * n * Math.cos(s)), t) : (o = Sf(this.es), a = Df(this.es), A = Tf(this.es), l = Rf(this.es), Math.abs(this.sin_p12 - 1) <= Se ? (c = this.a * Xr(o, a, A, l, Be), u = this.a * Xr(o, a, A, l, i), t.x = this.x0 + (c - u) * Math.sin(s), t.y = this.y0 - (c - u) * Math.cos(s), t) : Math.abs(this.sin_p12 + 1) <= Se ? (c = this.a * Xr(o, a, A, l, Be), u = this.a * Xr(o, a, A, l, i), t.x = this.x0 + (c + u) * Math.sin(s), t.y = this.y0 + (c + u) * Math.cos(s), t) : (d = r / n, h = md(this.a, this.e, this.sin_p12), g = md(this.a, this.e, r), f = Math.atan((1 - this.es) * d + this.es * h * this.sin_p12 / (g * n)), p = Math.atan2(Math.sin(s), this.cos_p12 * Math.tan(f) - this.sin_p12 * Math.cos(s)), p === 0 ? b = Math.asin(this.cos_p12 * Math.sin(f) - this.sin_p12 * Math.cos(f)) : Math.abs(Math.abs(p) - Math.PI) <= Se ? b = -Math.asin(this.cos_p12 * Math.sin(f) - this.sin_p12 * Math.cos(f)) : b = Math.asin(Math.sin(s) * Math.cos(f) / Math.sin(p)), m = this.e * this.sin_p12 / Math.sqrt(1 - this.es), E = this.e * this.cos_p12 * Math.cos(p) / Math.sqrt(1 - this.es), y = m * E, C = E * E, B = b * b, x = B * b, Q = x * b, v = Q * b, w = h * b * (1 - B * C * (1 - C) / 6 + x / 8 * y * (1 - 2 * C) + Q / 120 * (C * (4 - 7 * C) - 3 * m * m * (1 - 7 * C)) - v / 48 * y), t.x = this.x0 + w * Math.sin(p), t.y = this.y0 + w * Math.cos(p), t));
  }
  function zEe(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e, i, r, n, s, o, a, A, l, c, u, d, h, g, f, p, m, E, y, C, w, M, I, b;
    return this.sphere ? (e = Math.sqrt(t.x * t.x + t.y * t.y), e > 2 * Be * this.a ? void 0 : (i = e / this.a, r = Math.sin(i), n = Math.cos(i), s = this.long0, Math.abs(e) <= Se ? o = this.lat0 : (o = _A(n * this.sin_p12 + t.y * r * this.cos_p12 / e), a = Math.abs(this.lat0) - Be, Math.abs(a) <= Se ? this.lat0 >= 0 ? s = Te(this.long0 + Math.atan2(t.x, -t.y)) : s = Te(this.long0 - Math.atan2(-t.x, t.y)) : s = Te(this.long0 + Math.atan2(t.x * r, e * this.cos_p12 * n - t.y * this.sin_p12 * r))), t.x = s, t.y = o, t)) : (A = Sf(this.es), l = Df(this.es), c = Tf(this.es), u = Rf(this.es), Math.abs(this.sin_p12 - 1) <= Se ? (d = this.a * Xr(A, l, c, u, Be), e = Math.sqrt(t.x * t.x + t.y * t.y), h = d - e, o = cy(h / this.a, A, l, c, u), s = Te(this.long0 + Math.atan2(t.x, -1 * t.y)), t.x = s, t.y = o, t) : Math.abs(this.sin_p12 + 1) <= Se ? (d = this.a * Xr(A, l, c, u, Be), e = Math.sqrt(t.x * t.x + t.y * t.y), h = e - d, o = cy(h / this.a, A, l, c, u), s = Te(this.long0 + Math.atan2(t.x, t.y)), t.x = s, t.y = o, t) : (e = Math.sqrt(t.x * t.x + t.y * t.y), p = Math.atan2(t.x, t.y), g = md(this.a, this.e, this.sin_p12), m = Math.cos(p), E = this.e * this.cos_p12 * m, y = -E * E / (1 - this.es), C = 3 * this.es * (1 - y) * this.sin_p12 * this.cos_p12 * m / (1 - this.es), w = e / g, M = w - y * (1 + y) * Math.pow(w, 3) / 6 - C * (1 + 3 * y) * Math.pow(w, 4) / 24, I = 1 - y * M * M / 2 - w * M * M * M / 6, f = Math.asin(this.sin_p12 * Math.cos(M) + this.cos_p12 * Math.sin(M) * m), s = Te(this.long0 + Math.asin(Math.sin(p) * Math.sin(M) / Math.cos(f))), b = Math.sin(f), o = Math.atan2((b - this.es * I * this.sin_p12) * Math.tan(f), b * (1 - this.es)), t.x = s, t.y = o, t));
  }
  var PEe = ["Azimuthal_Equidistant", "aeqd"];
  const OEe = {
    init: UEe,
    forward: LEe,
    inverse: zEe,
    names: PEe
  };
  function GEe() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
  }
  function jEe(t) {
    var e, i, r, n, s, o, a, A, l = t.x, c = t.y;
    return r = Te(l - this.long0), e = Math.sin(c), i = Math.cos(c), n = Math.cos(r), o = this.sin_p14 * e + this.cos_p14 * i * n, s = 1, (o > 0 || Math.abs(o) <= Se) && (a = this.a * s * i * Math.sin(r), A = this.y0 + this.a * s * (this.cos_p14 * e - this.sin_p14 * i * n)), t.x = a, t.y = A, t;
  }
  function HEe(t) {
    var e, i, r, n, s, o, a;
    return t.x -= this.x0, t.y -= this.y0, e = Math.sqrt(t.x * t.x + t.y * t.y), i = _A(e / this.a), r = Math.sin(i), n = Math.cos(i), o = this.long0, Math.abs(e) <= Se ? (a = this.lat0, t.x = o, t.y = a, t) : (a = _A(n * this.sin_p14 + t.y * r * this.cos_p14 / e), s = Math.abs(this.lat0) - Be, Math.abs(s) <= Se ? (this.lat0 >= 0 ? o = Te(this.long0 + Math.atan2(t.x, -t.y)) : o = Te(this.long0 - Math.atan2(-t.x, t.y)), t.x = o, t.y = a, t) : (o = Te(this.long0 + Math.atan2(t.x * r, e * this.cos_p14 * n - t.y * this.sin_p14 * r)), t.x = o, t.y = a, t));
  }
  var JEe = ["ortho"];
  const VEe = {
    init: GEe,
    forward: jEe,
    inverse: HEe,
    names: JEe
  };
  var ki = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
  }, ii = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
  };
  function WEe() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= Be - ti / 2 ? this.face = ki.TOP : this.lat0 <= -(Be - ti / 2) ? this.face = ki.BOTTOM : Math.abs(this.long0) <= ti ? this.face = ki.FRONT : Math.abs(this.long0) <= Be + ti ? this.face = this.long0 > 0 ? ki.RIGHT : ki.LEFT : this.face = ki.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
  }
  function KEe(t) {
    var e = { x: 0, y: 0 }, i, r, n, s, o, a, A = { value: 0 };
    if (t.x -= this.long0, this.es !== 0 ? i = Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : i = t.y, r = t.x, this.face === ki.TOP)
      s = Be - i, r >= ti && r <= Be + ti ? (A.value = ii.AREA_0, n = r - Be) : r > Be + ti || r <= -(Be + ti) ? (A.value = ii.AREA_1, n = r > 0 ? r - br : r + br) : r > -(Be + ti) && r <= -ti ? (A.value = ii.AREA_2, n = r + Be) : (A.value = ii.AREA_3, n = r);
    else if (this.face === ki.BOTTOM)
      s = Be + i, r >= ti && r <= Be + ti ? (A.value = ii.AREA_0, n = -r + Be) : r < ti && r >= -ti ? (A.value = ii.AREA_1, n = -r) : r < -ti && r >= -(Be + ti) ? (A.value = ii.AREA_2, n = -r - Be) : (A.value = ii.AREA_3, n = r > 0 ? -r + br : -r - br);
    else {
      var l, c, u, d, h, g, f;
      this.face === ki.RIGHT ? r = zu(r, +Be) : this.face === ki.BACK ? r = zu(r, 3.14159265359) : this.face === ki.LEFT && (r = zu(r, -Be)), d = Math.sin(i), h = Math.cos(i), g = Math.sin(r), f = Math.cos(r), l = h * f, c = h * g, u = d, this.face === ki.FRONT ? (s = Math.acos(l), n = Lp(s, u, c, A)) : this.face === ki.RIGHT ? (s = Math.acos(c), n = Lp(s, u, -l, A)) : this.face === ki.BACK ? (s = Math.acos(-l), n = Lp(s, u, -c, A)) : this.face === ki.LEFT ? (s = Math.acos(-c), n = Lp(s, u, l, A)) : (s = n = 0, A.value = ii.AREA_0);
    }
    return a = Math.atan(12 / br * (n + Math.acos(Math.sin(n) * Math.cos(ti)) - Be)), o = Math.sqrt((1 - Math.cos(s)) / (Math.cos(a) * Math.cos(a)) / (1 - Math.cos(Math.atan(1 / Math.cos(n))))), A.value === ii.AREA_1 ? a += Be : A.value === ii.AREA_2 ? a += br : A.value === ii.AREA_3 && (a += 1.5 * br), e.x = o * Math.cos(a), e.y = o * Math.sin(a), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, t.x = e.x, t.y = e.y, t;
  }
  function XEe(t) {
    var e = { lam: 0, phi: 0 }, i, r, n, s, o, a, A, l, c, u = { value: 0 };
    if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, r = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), i = Math.atan2(t.y, t.x), t.x >= 0 && t.x >= Math.abs(t.y) ? u.value = ii.AREA_0 : t.y >= 0 && t.y >= Math.abs(t.x) ? (u.value = ii.AREA_1, i -= Be) : t.x < 0 && -t.x >= Math.abs(t.y) ? (u.value = ii.AREA_2, i = i < 0 ? i + br : i - br) : (u.value = ii.AREA_3, i += Be), c = br / 12 * Math.tan(i), o = Math.sin(c) / (Math.cos(c) - 1 / Math.sqrt(2)), a = Math.atan(o), n = Math.cos(i), s = Math.tan(r), A = 1 - n * n * s * s * (1 - Math.cos(Math.atan(1 / Math.cos(a)))), A < -1 ? A = -1 : A > 1 && (A = 1), this.face === ki.TOP)
      l = Math.acos(A), e.phi = Be - l, u.value === ii.AREA_0 ? e.lam = a + Be : u.value === ii.AREA_1 ? e.lam = a < 0 ? a + br : a - br : u.value === ii.AREA_2 ? e.lam = a - Be : e.lam = a;
    else if (this.face === ki.BOTTOM)
      l = Math.acos(A), e.phi = l - Be, u.value === ii.AREA_0 ? e.lam = -a + Be : u.value === ii.AREA_1 ? e.lam = -a : u.value === ii.AREA_2 ? e.lam = -a - Be : e.lam = a < 0 ? -a - br : -a + br;
    else {
      var d, h, g;
      d = A, c = d * d, c >= 1 ? g = 0 : g = Math.sqrt(1 - c) * Math.sin(a), c += g * g, c >= 1 ? h = 0 : h = Math.sqrt(1 - c), u.value === ii.AREA_1 ? (c = h, h = -g, g = c) : u.value === ii.AREA_2 ? (h = -h, g = -g) : u.value === ii.AREA_3 && (c = h, h = g, g = -c), this.face === ki.RIGHT ? (c = d, d = -h, h = c) : this.face === ki.BACK ? (d = -d, h = -h) : this.face === ki.LEFT && (c = d, d = h, h = -c), e.phi = Math.acos(-g) - Be, e.lam = Math.atan2(h, d), this.face === ki.RIGHT ? e.lam = zu(e.lam, -Be) : this.face === ki.BACK ? e.lam = zu(e.lam, -3.14159265359) : this.face === ki.LEFT && (e.lam = zu(e.lam, +Be));
    }
    if (this.es !== 0) {
      var f, p, m;
      f = e.phi < 0 ? 1 : 0, p = Math.tan(e.phi), m = this.b / Math.sqrt(p * p + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - m * m) / (this.one_minus_f * m)), f && (e.phi = -e.phi);
    }
    return e.lam += this.long0, t.x = e.lam, t.y = e.phi, t;
  }
  function Lp(t, e, i, r) {
    var n;
    return t < Se ? (r.value = ii.AREA_0, n = 0) : (n = Math.atan2(e, i), Math.abs(n) <= ti ? r.value = ii.AREA_0 : n > ti && n <= Be + ti ? (r.value = ii.AREA_1, n -= Be) : n > Be + ti || n <= -(Be + ti) ? (r.value = ii.AREA_2, n = n >= 0 ? n - br : n + br) : (r.value = ii.AREA_3, n += Be)), n;
  }
  function zu(t, e) {
    var i = t + e;
    return i < -3.14159265359 ? i += Sg : i > 3.14159265359 && (i -= Sg), i;
  }
  var ZEe = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  const qEe = {
    init: WEe,
    forward: KEe,
    inverse: XEe,
    names: ZEe
  };
  var FM = [
    [1, 22199e-21, -715515e-10, 31103e-10],
    [0.9986, -482243e-9, -24897e-9, -13309e-10],
    [0.9954, -83103e-8, -448605e-10, -986701e-12],
    [0.99, -135364e-8, -59661e-9, 36777e-10],
    [0.9822, -167442e-8, -449547e-11, -572411e-11],
    [0.973, -214868e-8, -903571e-10, 18736e-12],
    [0.96, -305085e-8, -900761e-10, 164917e-11],
    [0.9427, -382792e-8, -653386e-10, -26154e-10],
    [0.9216, -467746e-8, -10457e-8, 481243e-11],
    [0.8962, -536223e-8, -323831e-10, -543432e-11],
    [0.8679, -609363e-8, -113898e-9, 332484e-11],
    [0.835, -698325e-8, -640253e-10, 934959e-12],
    [0.7986, -755338e-8, -500009e-10, 935324e-12],
    [0.7597, -798324e-8, -35971e-9, -227626e-11],
    [0.7186, -851367e-8, -701149e-10, -86303e-10],
    [0.6732, -986209e-8, -199569e-9, 191974e-10],
    [0.6213, -0.010418, 883923e-10, 624051e-11],
    [0.5722, -906601e-8, 182e-6, 624051e-11],
    [0.5322, -677797e-8, 275608e-9, 624051e-11]
  ], vh = [
    [-520417e-23, 0.0124, 121431e-23, -845284e-16],
    [0.062, 0.0124, -126793e-14, 422642e-15],
    [0.124, 0.0124, 507171e-14, -160604e-14],
    [0.186, 0.0123999, -190189e-13, 600152e-14],
    [0.248, 0.0124002, 710039e-13, -224e-10],
    [0.31, 0.0123992, -264997e-12, 835986e-13],
    [0.372, 0.0124029, 988983e-12, -311994e-12],
    [0.434, 0.0123893, -369093e-11, -435621e-12],
    [0.4958, 0.0123198, -102252e-10, -345523e-12],
    [0.5571, 0.0121916, -154081e-10, -582288e-12],
    [0.6176, 0.0119938, -241424e-10, -525327e-12],
    [0.6769, 0.011713, -320223e-10, -516405e-12],
    [0.7346, 0.0113541, -397684e-10, -609052e-12],
    [0.7903, 0.0109107, -489042e-10, -104739e-11],
    [0.8435, 0.0103431, -64615e-9, -140374e-14],
    [0.8936, 969686e-8, -64636e-9, -8547e-9],
    [0.9394, 840947e-8, -192841e-9, -42106e-10],
    [0.9761, 616527e-8, -256e-6, -42106e-10],
    [1, 328947e-8, -319159e-9, -42106e-10]
  ], D4 = 0.8487, T4 = 1.3523, R4 = vo / 5, $Ee = 1 / R4, Bu = 18, uy = function(t, e) {
    return t[0] + e * (t[1] + e * (t[2] + e * t[3]));
  }, eye = function(t, e) {
    return t[1] + e * (2 * t[2] + e * 3 * t[3]);
  };
  function tye(t, e, i, r) {
    for (var n = e; r; --r) {
      var s = t(n);
      if (n -= s, Math.abs(s) < i)
        break;
    }
    return n;
  }
  function iye() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
  }
  function rye(t) {
    var e = Te(t.x - this.long0), i = Math.abs(t.y), r = Math.floor(i * R4);
    r < 0 ? r = 0 : r >= Bu && (r = Bu - 1), i = vo * (i - $Ee * r);
    var n = {
      x: uy(FM[r], i) * e,
      y: uy(vh[r], i)
    };
    return t.y < 0 && (n.y = -n.y), n.x = n.x * this.a * D4 + this.x0, n.y = n.y * this.a * T4 + this.y0, n;
  }
  function nye(t) {
    var e = {
      x: (t.x - this.x0) / (this.a * D4),
      y: Math.abs(t.y - this.y0) / (this.a * T4)
    };
    if (e.y >= 1)
      e.x /= FM[Bu][0], e.y = t.y < 0 ? -Be : Be;
    else {
      var i = Math.floor(e.y * Bu);
      for (i < 0 ? i = 0 : i >= Bu && (i = Bu - 1); ; )
        if (vh[i][0] > e.y)
          --i;
        else if (vh[i + 1][0] <= e.y)
          ++i;
        else
          break;
      var r = vh[i], n = 5 * (e.y - r[0]) / (vh[i + 1][0] - r[0]);
      n = tye(function(s) {
        return (uy(r, s) - e.y) / eye(r, s);
      }, n, Se, 100), e.x /= uy(FM[i], n), e.y = (5 * i + n) * Cr, t.y < 0 && (e.y = -e.y);
    }
    return e.x = Te(e.x + this.long0), e;
  }
  var sye = ["Robinson", "robin"];
  const oye = {
    init: iye,
    forward: rye,
    inverse: nye,
    names: sye
  };
  function aye() {
    this.name = "geocent";
  }
  function Aye(t) {
    var e = B4(t, this.es, this.a);
    return e;
  }
  function lye(t) {
    var e = w4(t, this.es, this.a, this.b);
    return e;
  }
  var cye = ["Geocentric", "geocentric", "geocent", "Geocent"];
  const uye = {
    init: aye,
    forward: Aye,
    inverse: lye,
    names: cye
  };
  var _r = {
    N_POLE: 0,
    S_POLE: 1,
    EQUIT: 2,
    OBLIQ: 3
  }, uh = {
    h: { def: 1e5, num: !0 },
    // default is Karman line, no default in PROJ.7
    azi: { def: 0, num: !0, degrees: !0 },
    // default is North
    tilt: { def: 0, num: !0, degrees: !0 },
    // default is Nadir
    long0: { def: 0, num: !0 },
    // default is Greenwich, conversion to rad is automatic
    lat0: { def: 0, num: !0 }
    // default is Equator, conversion to rad is automatic
  };
  function dye() {
    if (Object.keys(uh).forEach((function(i) {
      if (typeof this[i] > "u")
        this[i] = uh[i].def;
      else {
        if (uh[i].num && isNaN(this[i]))
          throw new Error("Invalid parameter value, must be numeric " + i + " = " + this[i]);
        uh[i].num && (this[i] = parseFloat(this[i]));
      }
      uh[i].degrees && (this[i] = this[i] * Cr);
    }).bind(this)), Math.abs(Math.abs(this.lat0) - Be) < Se ? this.mode = this.lat0 < 0 ? _r.S_POLE : _r.N_POLE : Math.abs(this.lat0) < Se ? this.mode = _r.EQUIT : (this.mode = _r.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
      throw new Error("Invalid height");
    this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
    var t = this.tilt, e = this.azi;
    this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(t), this.sw = Math.sin(t);
  }
  function hye(t) {
    t.x -= this.long0;
    var e = Math.sin(t.y), i = Math.cos(t.y), r = Math.cos(t.x), n, s;
    switch (this.mode) {
      case _r.OBLIQ:
        s = this.sinph0 * e + this.cosph0 * i * r;
        break;
      case _r.EQUIT:
        s = i * r;
        break;
      case _r.S_POLE:
        s = -e;
        break;
      case _r.N_POLE:
        s = e;
        break;
    }
    switch (s = this.pn1 / (this.p - s), n = s * i * Math.sin(t.x), this.mode) {
      case _r.OBLIQ:
        s *= this.cosph0 * e - this.sinph0 * i * r;
        break;
      case _r.EQUIT:
        s *= e;
        break;
      case _r.N_POLE:
        s *= -(i * r);
        break;
      case _r.S_POLE:
        s *= i * r;
        break;
    }
    var o, a;
    return o = s * this.cg + n * this.sg, a = 1 / (o * this.sw * this.h1 + this.cw), n = (n * this.cg - s * this.sg) * this.cw * a, s = o * a, t.x = n * this.a, t.y = s * this.a, t;
  }
  function gye(t) {
    t.x /= this.a, t.y /= this.a;
    var e = { x: t.x, y: t.y }, i, r, n;
    n = 1 / (this.pn1 - t.y * this.sw), i = this.pn1 * t.x * n, r = this.pn1 * t.y * this.cw * n, t.x = i * this.cg + r * this.sg, t.y = r * this.cg - i * this.sg;
    var s = yn(t.x, t.y);
    if (Math.abs(s) < Se)
      e.x = 0, e.y = t.y;
    else {
      var o, a;
      switch (a = 1 - s * s * this.pfact, a = (this.p - Math.sqrt(a)) / (this.pn1 / s + s / this.pn1), o = Math.sqrt(1 - a * a), this.mode) {
        case _r.OBLIQ:
          e.y = Math.asin(o * this.sinph0 + t.y * a * this.cosph0 / s), t.y = (o - this.sinph0 * Math.sin(e.y)) * s, t.x *= a * this.cosph0;
          break;
        case _r.EQUIT:
          e.y = Math.asin(t.y * a / s), t.y = o * s, t.x *= a;
          break;
        case _r.N_POLE:
          e.y = Math.asin(o), t.y = -t.y;
          break;
        case _r.S_POLE:
          e.y = -Math.asin(o);
          break;
      }
      e.x = Math.atan2(t.x, t.y);
    }
    return t.x = e.x + this.long0, t.y = e.y, t;
  }
  var fye = ["Tilted_Perspective", "tpers"];
  const pye = {
    init: dye,
    forward: hye,
    inverse: gye,
    names: fye
  };
  function mye() {
    if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
      throw new Error();
    if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
      var t = 1 - this.es, e = 1 / t;
      this.radius_p = Math.sqrt(t), this.radius_p2 = t, this.radius_p_inv2 = e, this.shape = "ellipse";
    } else
      this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
    this.title || (this.title = "Geostationary Satellite View");
  }
  function Eye(t) {
    var e = t.x, i = t.y, r, n, s, o;
    if (e = e - this.long0, this.shape === "ellipse") {
      i = Math.atan(this.radius_p2 * Math.tan(i));
      var a = this.radius_p / yn(this.radius_p * Math.cos(i), Math.sin(i));
      if (n = a * Math.cos(e) * Math.cos(i), s = a * Math.sin(e) * Math.cos(i), o = a * Math.sin(i), (this.radius_g - n) * n - s * s - o * o * this.radius_p_inv2 < 0)
        return t.x = Number.NaN, t.y = Number.NaN, t;
      r = this.radius_g - n, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(s / yn(o, r)), t.y = this.radius_g_1 * Math.atan(o / r)) : (t.x = this.radius_g_1 * Math.atan(s / r), t.y = this.radius_g_1 * Math.atan(o / yn(s, r)));
    } else this.shape === "sphere" && (r = Math.cos(i), n = Math.cos(e) * r, s = Math.sin(e) * r, o = Math.sin(i), r = this.radius_g - n, this.flip_axis ? (t.x = this.radius_g_1 * Math.atan(s / yn(o, r)), t.y = this.radius_g_1 * Math.atan(o / r)) : (t.x = this.radius_g_1 * Math.atan(s / r), t.y = this.radius_g_1 * Math.atan(o / yn(s, r))));
    return t.x = t.x * this.a, t.y = t.y * this.a, t;
  }
  function yye(t) {
    var e = -1, i = 0, r = 0, n, s, o, a;
    if (t.x = t.x / this.a, t.y = t.y / this.a, this.shape === "ellipse") {
      this.flip_axis ? (r = Math.tan(t.y / this.radius_g_1), i = Math.tan(t.x / this.radius_g_1) * yn(1, r)) : (i = Math.tan(t.x / this.radius_g_1), r = Math.tan(t.y / this.radius_g_1) * yn(1, i));
      var A = r / this.radius_p;
      if (n = i * i + A * A + e * e, s = 2 * this.radius_g * e, o = s * s - 4 * n * this.C, o < 0)
        return t.x = Number.NaN, t.y = Number.NaN, t;
      a = (-s - Math.sqrt(o)) / (2 * n), e = this.radius_g + a * e, i *= a, r *= a, t.x = Math.atan2(i, e), t.y = Math.atan(r * Math.cos(t.x) / e), t.y = Math.atan(this.radius_p_inv2 * Math.tan(t.y));
    } else if (this.shape === "sphere") {
      if (this.flip_axis ? (r = Math.tan(t.y / this.radius_g_1), i = Math.tan(t.x / this.radius_g_1) * Math.sqrt(1 + r * r)) : (i = Math.tan(t.x / this.radius_g_1), r = Math.tan(t.y / this.radius_g_1) * Math.sqrt(1 + i * i)), n = i * i + r * r + e * e, s = 2 * this.radius_g * e, o = s * s - 4 * n * this.C, o < 0)
        return t.x = Number.NaN, t.y = Number.NaN, t;
      a = (-s - Math.sqrt(o)) / (2 * n), e = this.radius_g + a * e, i *= a, r *= a, t.x = Math.atan2(i, e), t.y = Math.atan(r * Math.cos(t.x) / e);
    }
    return t.x = t.x + this.long0, t;
  }
  var Bye = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
  const wye = {
    init: mye,
    forward: Eye,
    inverse: yye,
    names: Bye
  };
  var Jh = 1.340264, Vh = -0.081106, Wh = 893e-6, Kh = 3796e-6, dy = Math.sqrt(3) / 2;
  function Cye() {
    this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  }
  function bye(t) {
    var e = Te(t.x - this.long0), i = t.y, r = Math.asin(dy * Math.sin(i)), n = r * r, s = n * n * n;
    return t.x = e * Math.cos(r) / (dy * (Jh + 3 * Vh * n + s * (7 * Wh + 9 * Kh * n))), t.y = r * (Jh + Vh * n + s * (Wh + Kh * n)), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t;
  }
  function Mye(t) {
    t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a;
    var e = 1e-9, i = 12, r = t.y, n, s, o, a, A, l;
    for (l = 0; l < i && (n = r * r, s = n * n * n, o = r * (Jh + Vh * n + s * (Wh + Kh * n)) - t.y, a = Jh + 3 * Vh * n + s * (7 * Wh + 9 * Kh * n), r -= A = o / a, !(Math.abs(A) < e)); ++l)
      ;
    return n = r * r, s = n * n * n, t.x = dy * t.x * (Jh + 3 * Vh * n + s * (7 * Wh + 9 * Kh * n)) / Math.cos(r), t.y = Math.asin(Math.sin(r) / dy), t.x = Te(t.x + this.long0), t;
  }
  var Iye = ["eqearth", "Equal Earth", "Equal_Earth"];
  const vye = {
    init: Cye,
    forward: bye,
    inverse: Mye,
    names: Iye
  };
  var Rg = 1e-10;
  function xye() {
    var t;
    if (this.phi1 = this.lat1, Math.abs(this.phi1) < Rg)
      throw new Error();
    this.es ? (this.en = x1(this.es), this.m1 = Jd(
      this.phi1,
      this.am1 = Math.sin(this.phi1),
      t = Math.cos(this.phi1),
      this.en
    ), this.am1 = t / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = Fye, this.forward = Qye) : (Math.abs(this.phi1) + Rg >= Be ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = Dye, this.forward = Sye);
  }
  function Qye(t) {
    var e = Te(t.x - (this.long0 || 0)), i = t.y, r, n, s;
    return r = this.am1 + this.m1 - Jd(i, n = Math.sin(i), s = Math.cos(i), this.en), n = s * e / (r * Math.sqrt(1 - this.es * n * n)), t.x = r * Math.sin(n), t.y = this.am1 - r * Math.cos(n), t.x = this.a * t.x + (this.x0 || 0), t.y = this.a * t.y + (this.y0 || 0), t;
  }
  function Fye(t) {
    t.x = (t.x - (this.x0 || 0)) / this.a, t.y = (t.y - (this.y0 || 0)) / this.a;
    var e, i, r, n;
    if (i = yn(t.x, t.y = this.am1 - t.y), n = Q1(this.am1 + this.m1 - i, this.es, this.en), (e = Math.abs(n)) < Be)
      e = Math.sin(n), r = i * Math.atan2(t.x, t.y) * Math.sqrt(1 - this.es * e * e) / Math.cos(n);
    else if (Math.abs(e - Be) <= Rg)
      r = 0;
    else
      throw new Error();
    return t.x = Te(r + (this.long0 || 0)), t.y = KA(n), t;
  }
  function Sye(t) {
    var e = Te(t.x - (this.long0 || 0)), i = t.y, r, n;
    return n = this.cphi1 + this.phi1 - i, Math.abs(n) > Rg ? (t.x = n * Math.sin(r = e * Math.cos(i) / n), t.y = this.cphi1 - n * Math.cos(r)) : t.x = t.y = 0, t.x = this.a * t.x + (this.x0 || 0), t.y = this.a * t.y + (this.y0 || 0), t;
  }
  function Dye(t) {
    t.x = (t.x - (this.x0 || 0)) / this.a, t.y = (t.y - (this.y0 || 0)) / this.a;
    var e, i, r = yn(t.x, t.y = this.cphi1 - t.y);
    if (i = this.cphi1 + this.phi1 - r, Math.abs(i) > Be)
      throw new Error();
    return Math.abs(Math.abs(i) - Be) <= Rg ? e = 0 : e = r * Math.atan2(t.x, t.y) / Math.cos(i), t.x = Te(e + (this.long0 || 0)), t.y = KA(i), t;
  }
  var Tye = ["bonne", "Bonne (Werner lat_1=90)"];
  const Rye = {
    init: xye,
    names: Tye
  };
  function _ye(t) {
    t.Proj.projections.add(pm), t.Proj.projections.add(mm), t.Proj.projections.add(Fpe), t.Proj.projections.add(Upe), t.Proj.projections.add(jpe), t.Proj.projections.add(Kpe), t.Proj.projections.add(tme), t.Proj.projections.add(ome), t.Proj.projections.add(ume), t.Proj.projections.add(pme), t.Proj.projections.add(Rme), t.Proj.projections.add(Lme), t.Proj.projections.add(jme), t.Proj.projections.add(Xme), t.Proj.projections.add(tEe), t.Proj.projections.add(oEe), t.Proj.projections.add(uEe), t.Proj.projections.add(pEe), t.Proj.projections.add(CEe), t.Proj.projections.add(xEe), t.Proj.projections.add(TEe), t.Proj.projections.add(NEe), t.Proj.projections.add(OEe), t.Proj.projections.add(VEe), t.Proj.projections.add(qEe), t.Proj.projections.add(oye), t.Proj.projections.add(uye), t.Proj.projections.add(pye), t.Proj.projections.add(wye), t.Proj.projections.add(vye), t.Proj.projections.add(Rye);
  }
  Vi.defaultDatum = "WGS84";
  Vi.Proj = No;
  Vi.WGS84 = new Vi.Proj("WGS84");
  Vi.Point = pd;
  Vi.toPoint = C4;
  Vi.defs = Vr;
  Vi.nadgrid = Dfe;
  Vi.transform = ly;
  Vi.mgrs = Vfe;
  Vi.version = "__VERSION__";
  _ye(Vi);
  function _4(t) {
    const e = Object.keys(t.defs), i = e.length;
    let r, n;
    for (r = 0; r < i; ++r) {
      const s = e[r];
      if (!im(s)) {
        const o = t.defs(s);
        let a = (
          /** @type {import("./Units.js").Units} */
          o.units
        );
        !a && o.projName === "longlat" && (a = "degrees"), Ag(
          new sf({
            code: s,
            axisOrientation: o.axis,
            metersPerUnit: o.to_meter,
            units: a
          })
        );
      }
    }
    for (r = 0; r < i; ++r) {
      const s = e[r], o = im(s);
      for (n = 0; n < i; ++n) {
        const a = e[n], A = im(a);
        if (!rm(s, a))
          if (t.defs[s] === t.defs[a])
            db([o, A]);
          else {
            const l = t(s, a);
            M$(
              o,
              A,
              gD(o, A, l.forward),
              gD(A, o, l.inverse)
            );
          }
      }
    }
  }
  function kye(t) {
    const e = t.split(":")[1];
    Vi.defs("http://www.opengis.net/gml/srs/epsg.xml#" + e, Vi.defs(t)), _4(Vi);
  }
  function T1(t) {
    return Vi.defs(t);
  }
  function Yye(t = rn.namedProjections) {
    Vi.defs(t), _4(Vi), t.forEach((e) => {
      Ag(Xe(e[0])), kye(e[0]), T1(e[0]).masterportal = !0;
    });
  }
  function Nye() {
    return Object.keys(Vi.defs).map((e) => Object.assign(Vi.defs(e), { name: e })).filter(function(e, i, r) {
      return i === r.indexOf(e) && e.masterportal === !0;
    });
  }
  function R1(t) {
    return t.getView().getProjection().getCode();
  }
  function x_(t) {
    return typeof t == "string" ? T1(t) : t;
  }
  function _1(t, e, i) {
    const r = x_(t), n = x_(e);
    if (r && n && i)
      return Vi(r, n, i);
    console.error(`Cancelled coordinate transformation with invalid parameters: ${t}; ${e}; ${i}`);
  }
  function Uye(t, e, i) {
    return _1(e, R1(t), i);
  }
  function Lye(t, e, i) {
    return _1(R1(t), e, i);
  }
  const zye = {
    transformFromMapProjection: Lye,
    transformToMapProjection: Uye,
    transform: _1,
    getMapProjection: R1,
    getProjections: Nye,
    registerProjections: Yye,
    getProjection: T1
  };
  var ho = {}, zp = {}, Q_;
  function k1() {
    return Q_ || (Q_ = 1, (function() {
      zp.defaults = {
        "0.1": {
          explicitCharkey: !1,
          trim: !0,
          normalize: !0,
          normalizeTags: !1,
          attrkey: "@",
          charkey: "#",
          explicitArray: !1,
          ignoreAttrs: !1,
          mergeAttrs: !1,
          explicitRoot: !1,
          validator: null,
          xmlns: !1,
          explicitChildren: !1,
          childkey: "@@",
          charsAsChildren: !1,
          includeWhiteChars: !1,
          async: !1,
          strict: !0,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: !1,
          trim: !1,
          normalize: !1,
          normalizeTags: !1,
          attrkey: "$",
          charkey: "_",
          explicitArray: !0,
          ignoreAttrs: !1,
          mergeAttrs: !1,
          explicitRoot: !0,
          validator: null,
          xmlns: !1,
          explicitChildren: !1,
          preserveChildrenOrder: !1,
          childkey: "$$",
          charsAsChildren: !1,
          includeWhiteChars: !1,
          async: !1,
          strict: !0,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            version: "1.0",
            encoding: "UTF-8",
            standalone: !0
          },
          doctype: null,
          renderOpts: {
            pretty: !0,
            indent: "  ",
            newline: `
`
          },
          headless: !1,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: !1
        }
      };
    }).call(zp)), zp;
  }
  var Pp = {}, go = {}, fo = {}, F_;
  function Ha() {
    return F_ || (F_ = 1, (function() {
      var t, e, i, r, n, s, o, a = [].slice, A = {}.hasOwnProperty;
      t = function() {
        var l, c, u, d, h, g;
        if (g = arguments[0], h = 2 <= arguments.length ? a.call(arguments, 1) : [], n(Object.assign))
          Object.assign.apply(null, arguments);
        else
          for (l = 0, u = h.length; l < u; l++)
            if (d = h[l], d != null)
              for (c in d)
                A.call(d, c) && (g[c] = d[c]);
        return g;
      }, n = function(l) {
        return !!l && Object.prototype.toString.call(l) === "[object Function]";
      }, s = function(l) {
        var c;
        return !!l && ((c = typeof l) == "function" || c === "object");
      }, i = function(l) {
        return n(Array.isArray) ? Array.isArray(l) : Object.prototype.toString.call(l) === "[object Array]";
      }, r = function(l) {
        var c;
        if (i(l))
          return !l.length;
        for (c in l)
          if (A.call(l, c))
            return !1;
        return !0;
      }, o = function(l) {
        var c, u;
        return s(l) && (u = Object.getPrototypeOf(l)) && (c = u.constructor) && typeof c == "function" && c instanceof c && Function.prototype.toString.call(c) === Function.prototype.toString.call(Object);
      }, e = function(l) {
        return n(l.valueOf) ? l.valueOf() : l;
      }, fo.assign = t, fo.isFunction = n, fo.isObject = s, fo.isArray = i, fo.isEmpty = r, fo.isPlainObject = o, fo.getValue = e;
    }).call(fo)), fo;
  }
  var Em = { exports: {} }, Pye = Em.exports, S_;
  function k4() {
    return S_ || (S_ = 1, (function() {
      Em.exports = function() {
        function t() {
        }
        return t.prototype.hasFeature = function(e, i) {
          return !0;
        }, t.prototype.createDocumentType = function(e, i, r) {
          throw new Error("This DOM method is not implemented.");
        }, t.prototype.createDocument = function(e, i, r) {
          throw new Error("This DOM method is not implemented.");
        }, t.prototype.createHTMLDocument = function(e) {
          throw new Error("This DOM method is not implemented.");
        }, t.prototype.getFeature = function(e, i) {
          throw new Error("This DOM method is not implemented.");
        }, t;
      }();
    }).call(Pye)), Em.exports;
  }
  var ym = { exports: {} }, Bm = { exports: {} }, wm = { exports: {} }, Oye = wm.exports, D_;
  function Gye() {
    return D_ || (D_ = 1, (function() {
      wm.exports = function() {
        function t() {
        }
        return t.prototype.handleError = function(e) {
          throw new Error(e);
        }, t;
      }();
    }).call(Oye)), wm.exports;
  }
  var Cm = { exports: {} }, jye = Cm.exports, T_;
  function Hye() {
    return T_ || (T_ = 1, (function() {
      Cm.exports = function() {
        function t(e) {
          this.arr = e || [];
        }
        return Object.defineProperty(t.prototype, "length", {
          get: function() {
            return this.arr.length;
          }
        }), t.prototype.item = function(e) {
          return this.arr[e] || null;
        }, t.prototype.contains = function(e) {
          return this.arr.indexOf(e) !== -1;
        }, t;
      }();
    }).call(jye)), Cm.exports;
  }
  var Jye = Bm.exports, R_;
  function Vye() {
    return R_ || (R_ = 1, (function() {
      var t, e;
      t = Gye(), e = Hye(), Bm.exports = function() {
        function i() {
          this.defaultParams = {
            "canonical-form": !1,
            "cdata-sections": !1,
            comments: !1,
            "datatype-normalization": !1,
            "element-content-whitespace": !0,
            entities: !0,
            "error-handler": new t(),
            infoset: !0,
            "validate-if-schema": !1,
            namespaces: !0,
            "namespace-declarations": !0,
            "normalize-characters": !1,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": !0,
            validate: !1,
            "well-formed": !0
          }, this.params = Object.create(this.defaultParams);
        }
        return Object.defineProperty(i.prototype, "parameterNames", {
          get: function() {
            return new e(Object.keys(this.defaultParams));
          }
        }), i.prototype.getParameter = function(r) {
          return this.params.hasOwnProperty(r) ? this.params[r] : null;
        }, i.prototype.canSetParameter = function(r, n) {
          return !0;
        }, i.prototype.setParameter = function(r, n) {
          return n != null ? this.params[r] = n : delete this.params[r];
        }, i;
      }();
    }).call(Jye)), Bm.exports;
  }
  var bm = { exports: {} }, Mm = { exports: {} }, Im = { exports: {} }, Wye = Im.exports, __;
  function ir() {
    return __ || (__ = 1, (function() {
      Im.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(Wye)), Im.exports;
  }
  var vm = { exports: {} }, Kye = vm.exports, k_;
  function Y4() {
    return k_ || (k_ = 1, (function() {
      var t;
      t = ir(), ws(), vm.exports = function() {
        function e(i, r, n) {
          if (this.parent = i, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), r == null)
            throw new Error("Missing attribute name. " + this.debugInfo(r));
          this.name = this.stringify.name(r), this.value = this.stringify.attValue(n), this.type = t.Attribute, this.isId = !1, this.schemaTypeInfo = null;
        }
        return Object.defineProperty(e.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        }), Object.defineProperty(e.prototype, "ownerElement", {
          get: function() {
            return this.parent;
          }
        }), Object.defineProperty(e.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(i) {
            return this.value = i || "";
          }
        }), Object.defineProperty(e.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        }), Object.defineProperty(e.prototype, "prefix", {
          get: function() {
            return "";
          }
        }), Object.defineProperty(e.prototype, "localName", {
          get: function() {
            return this.name;
          }
        }), Object.defineProperty(e.prototype, "specified", {
          get: function() {
            return !0;
          }
        }), e.prototype.clone = function() {
          return Object.create(this);
        }, e.prototype.toString = function(i) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(i));
        }, e.prototype.debugInfo = function(i) {
          return i = i || this.name, i == null ? "parent: <" + this.parent.name + ">" : "attribute: {" + i + "}, parent: <" + this.parent.name + ">";
        }, e.prototype.isEqualNode = function(i) {
          return !(i.namespaceURI !== this.namespaceURI || i.prefix !== this.prefix || i.localName !== this.localName || i.value !== this.value);
        }, e;
      }();
    }).call(Kye)), vm.exports;
  }
  var xm = { exports: {} }, Xye = xm.exports, Y_;
  function Y1() {
    return Y_ || (Y_ = 1, (function() {
      xm.exports = function() {
        function t(e) {
          this.nodes = e;
        }
        return Object.defineProperty(t.prototype, "length", {
          get: function() {
            return Object.keys(this.nodes).length || 0;
          }
        }), t.prototype.clone = function() {
          return this.nodes = null;
        }, t.prototype.getNamedItem = function(e) {
          return this.nodes[e];
        }, t.prototype.setNamedItem = function(e) {
          var i;
          return i = this.nodes[e.nodeName], this.nodes[e.nodeName] = e, i || null;
        }, t.prototype.removeNamedItem = function(e) {
          var i;
          return i = this.nodes[e], delete this.nodes[e], i || null;
        }, t.prototype.item = function(e) {
          return this.nodes[Object.keys(this.nodes)[e]] || null;
        }, t.prototype.getNamedItemNS = function(e, i) {
          throw new Error("This DOM method is not implemented.");
        }, t.prototype.setNamedItemNS = function(e) {
          throw new Error("This DOM method is not implemented.");
        }, t.prototype.removeNamedItemNS = function(e, i) {
          throw new Error("This DOM method is not implemented.");
        }, t;
      }();
    }).call(Xye)), xm.exports;
  }
  var Zye = Mm.exports, N_;
  function N1() {
    return N_ || (N_ = 1, (function() {
      var t, e, i, r, n, s, o, a, A = function(c, u) {
        for (var d in u)
          l.call(u, d) && (c[d] = u[d]);
        function h() {
          this.constructor = c;
        }
        return h.prototype = u.prototype, c.prototype = new h(), c.__super__ = u.prototype, c;
      }, l = {}.hasOwnProperty;
      a = Ha(), o = a.isObject, s = a.isFunction, n = a.getValue, r = ws(), t = ir(), e = Y4(), i = Y1(), Mm.exports = function(c) {
        A(u, c);
        function u(d, h, g) {
          var f, p, m, E;
          if (u.__super__.constructor.call(this, d), h == null)
            throw new Error("Missing element name. " + this.debugInfo());
          if (this.name = this.stringify.name(h), this.type = t.Element, this.attribs = {}, this.schemaTypeInfo = null, g != null && this.attribute(g), d.type === t.Document && (this.isRoot = !0, this.documentObject = d, d.rootObject = this, d.children)) {
            for (E = d.children, p = 0, m = E.length; p < m; p++)
              if (f = E[p], f.type === t.DocType) {
                f.name = this.name;
                break;
              }
          }
        }
        return Object.defineProperty(u.prototype, "tagName", {
          get: function() {
            return this.name;
          }
        }), Object.defineProperty(u.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        }), Object.defineProperty(u.prototype, "prefix", {
          get: function() {
            return "";
          }
        }), Object.defineProperty(u.prototype, "localName", {
          get: function() {
            return this.name;
          }
        }), Object.defineProperty(u.prototype, "id", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }), Object.defineProperty(u.prototype, "className", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }), Object.defineProperty(u.prototype, "classList", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }), Object.defineProperty(u.prototype, "attributes", {
          get: function() {
            return (!this.attributeMap || !this.attributeMap.nodes) && (this.attributeMap = new i(this.attribs)), this.attributeMap;
          }
        }), u.prototype.clone = function() {
          var d, h, g, f;
          g = Object.create(this), g.isRoot && (g.documentObject = null), g.attribs = {}, f = this.attribs;
          for (h in f)
            l.call(f, h) && (d = f[h], g.attribs[h] = d.clone());
          return g.children = [], this.children.forEach(function(p) {
            var m;
            return m = p.clone(), m.parent = g, g.children.push(m);
          }), g;
        }, u.prototype.attribute = function(d, h) {
          var g, f;
          if (d != null && (d = n(d)), o(d))
            for (g in d)
              l.call(d, g) && (f = d[g], this.attribute(g, f));
          else
            s(h) && (h = h.apply()), this.options.keepNullAttributes && h == null ? this.attribs[d] = new e(this, d, "") : h != null && (this.attribs[d] = new e(this, d, h));
          return this;
        }, u.prototype.removeAttribute = function(d) {
          var h, g, f;
          if (d == null)
            throw new Error("Missing attribute name. " + this.debugInfo());
          if (d = n(d), Array.isArray(d))
            for (g = 0, f = d.length; g < f; g++)
              h = d[g], delete this.attribs[h];
          else
            delete this.attribs[d];
          return this;
        }, u.prototype.toString = function(d) {
          return this.options.writer.element(this, this.options.writer.filterOptions(d));
        }, u.prototype.att = function(d, h) {
          return this.attribute(d, h);
        }, u.prototype.a = function(d, h) {
          return this.attribute(d, h);
        }, u.prototype.getAttribute = function(d) {
          return this.attribs.hasOwnProperty(d) ? this.attribs[d].value : null;
        }, u.prototype.setAttribute = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getAttributeNode = function(d) {
          return this.attribs.hasOwnProperty(d) ? this.attribs[d] : null;
        }, u.prototype.setAttributeNode = function(d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.removeAttributeNode = function(d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getElementsByTagName = function(d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getAttributeNS = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.setAttributeNS = function(d, h, g) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.removeAttributeNS = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getAttributeNodeNS = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.setAttributeNodeNS = function(d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getElementsByTagNameNS = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.hasAttribute = function(d) {
          return this.attribs.hasOwnProperty(d);
        }, u.prototype.hasAttributeNS = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.setIdAttribute = function(d, h) {
          return this.attribs.hasOwnProperty(d) ? this.attribs[d].isId : h;
        }, u.prototype.setIdAttributeNS = function(d, h, g) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.setIdAttributeNode = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getElementsByTagName = function(d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getElementsByTagNameNS = function(d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.getElementsByClassName = function(d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, u.prototype.isEqualNode = function(d) {
          var h, g, f;
          if (!u.__super__.isEqualNode.apply(this, arguments).isEqualNode(d) || d.namespaceURI !== this.namespaceURI || d.prefix !== this.prefix || d.localName !== this.localName || d.attribs.length !== this.attribs.length)
            return !1;
          for (h = g = 0, f = this.attribs.length - 1; 0 <= f ? g <= f : g >= f; h = 0 <= f ? ++g : --g)
            if (!this.attribs[h].isEqualNode(d.attribs[h]))
              return !1;
          return !0;
        }, u;
      }(r);
    }).call(Zye)), Mm.exports;
  }
  var Qm = { exports: {} }, Fm = { exports: {} }, qye = Fm.exports, U_;
  function $B() {
    return U_ || (U_ = 1, (function() {
      var t, e = function(r, n) {
        for (var s in n)
          i.call(n, s) && (r[s] = n[s]);
        function o() {
          this.constructor = r;
        }
        return o.prototype = n.prototype, r.prototype = new o(), r.__super__ = n.prototype, r;
      }, i = {}.hasOwnProperty;
      t = ws(), Fm.exports = function(r) {
        e(n, r);
        function n(s) {
          n.__super__.constructor.call(this, s), this.value = "";
        }
        return Object.defineProperty(n.prototype, "data", {
          get: function() {
            return this.value;
          },
          set: function(s) {
            return this.value = s || "";
          }
        }), Object.defineProperty(n.prototype, "length", {
          get: function() {
            return this.value.length;
          }
        }), Object.defineProperty(n.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(s) {
            return this.value = s || "";
          }
        }), n.prototype.clone = function() {
          return Object.create(this);
        }, n.prototype.substringData = function(s, o) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, n.prototype.appendData = function(s) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, n.prototype.insertData = function(s, o) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, n.prototype.deleteData = function(s, o) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, n.prototype.replaceData = function(s, o, a) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, n.prototype.isEqualNode = function(s) {
          return !(!n.__super__.isEqualNode.apply(this, arguments).isEqualNode(s) || s.data !== this.data);
        }, n;
      }(t);
    }).call(qye)), Fm.exports;
  }
  var $ye = Qm.exports, L_;
  function U1() {
    return L_ || (L_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      t = ir(), e = $B(), Qm.exports = function(n) {
        i(s, n);
        function s(o, a) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing CDATA text. " + this.debugInfo());
          this.name = "#cdata-section", this.type = t.CData, this.value = this.stringify.cdata(a);
        }
        return s.prototype.clone = function() {
          return Object.create(this);
        }, s.prototype.toString = function(o) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(o));
        }, s;
      }(e);
    }).call($ye)), Qm.exports;
  }
  var Sm = { exports: {} }, eBe = Sm.exports, z_;
  function L1() {
    return z_ || (z_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      t = ir(), e = $B(), Sm.exports = function(n) {
        i(s, n);
        function s(o, a) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing comment text. " + this.debugInfo());
          this.name = "#comment", this.type = t.Comment, this.value = this.stringify.comment(a);
        }
        return s.prototype.clone = function() {
          return Object.create(this);
        }, s.prototype.toString = function(o) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(o));
        }, s;
      }(e);
    }).call(eBe)), Sm.exports;
  }
  var Dm = { exports: {} }, tBe = Dm.exports, P_;
  function z1() {
    return P_ || (P_ = 1, (function() {
      var t, e, i, r = function(s, o) {
        for (var a in o)
          n.call(o, a) && (s[a] = o[a]);
        function A() {
          this.constructor = s;
        }
        return A.prototype = o.prototype, s.prototype = new A(), s.__super__ = o.prototype, s;
      }, n = {}.hasOwnProperty;
      i = Ha().isObject, e = ws(), t = ir(), Dm.exports = function(s) {
        r(o, s);
        function o(a, A, l, c) {
          var u;
          o.__super__.constructor.call(this, a), i(A) && (u = A, A = u.version, l = u.encoding, c = u.standalone), A || (A = "1.0"), this.type = t.Declaration, this.version = this.stringify.xmlVersion(A), l != null && (this.encoding = this.stringify.xmlEncoding(l)), c != null && (this.standalone = this.stringify.xmlStandalone(c));
        }
        return o.prototype.toString = function(a) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(a));
        }, o;
      }(e);
    }).call(tBe)), Dm.exports;
  }
  var Tm = { exports: {} }, Rm = { exports: {} }, iBe = Rm.exports, O_;
  function P1() {
    return O_ || (O_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      e = ws(), t = ir(), Rm.exports = function(n) {
        i(s, n);
        function s(o, a, A, l, c, u) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing DTD element name. " + this.debugInfo());
          if (A == null)
            throw new Error("Missing DTD attribute name. " + this.debugInfo(a));
          if (!l)
            throw new Error("Missing DTD attribute type. " + this.debugInfo(a));
          if (!c)
            throw new Error("Missing DTD attribute default. " + this.debugInfo(a));
          if (c.indexOf("#") !== 0 && (c = "#" + c), !c.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/))
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(a));
          if (u && !c.match(/^(#FIXED|#DEFAULT)$/))
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(a));
          this.elementName = this.stringify.name(a), this.type = t.AttributeDeclaration, this.attributeName = this.stringify.name(A), this.attributeType = this.stringify.dtdAttType(l), u && (this.defaultValue = this.stringify.dtdAttDefault(u)), this.defaultValueType = c;
        }
        return s.prototype.toString = function(o) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(o));
        }, s;
      }(e);
    }).call(iBe)), Rm.exports;
  }
  var _m = { exports: {} }, rBe = _m.exports, G_;
  function O1() {
    return G_ || (G_ = 1, (function() {
      var t, e, i, r = function(s, o) {
        for (var a in o)
          n.call(o, a) && (s[a] = o[a]);
        function A() {
          this.constructor = s;
        }
        return A.prototype = o.prototype, s.prototype = new A(), s.__super__ = o.prototype, s;
      }, n = {}.hasOwnProperty;
      i = Ha().isObject, e = ws(), t = ir(), _m.exports = function(s) {
        r(o, s);
        function o(a, A, l, c) {
          if (o.__super__.constructor.call(this, a), l == null)
            throw new Error("Missing DTD entity name. " + this.debugInfo(l));
          if (c == null)
            throw new Error("Missing DTD entity value. " + this.debugInfo(l));
          if (this.pe = !!A, this.name = this.stringify.name(l), this.type = t.EntityDeclaration, !i(c))
            this.value = this.stringify.dtdEntityValue(c), this.internal = !0;
          else {
            if (!c.pubID && !c.sysID)
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(l));
            if (c.pubID && !c.sysID)
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(l));
            if (this.internal = !1, c.pubID != null && (this.pubID = this.stringify.dtdPubID(c.pubID)), c.sysID != null && (this.sysID = this.stringify.dtdSysID(c.sysID)), c.nData != null && (this.nData = this.stringify.dtdNData(c.nData)), this.pe && this.nData)
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(l));
          }
        }
        return Object.defineProperty(o.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        }), Object.defineProperty(o.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        }), Object.defineProperty(o.prototype, "notationName", {
          get: function() {
            return this.nData || null;
          }
        }), Object.defineProperty(o.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        }), Object.defineProperty(o.prototype, "xmlEncoding", {
          get: function() {
            return null;
          }
        }), Object.defineProperty(o.prototype, "xmlVersion", {
          get: function() {
            return null;
          }
        }), o.prototype.toString = function(a) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(a));
        }, o;
      }(e);
    }).call(rBe)), _m.exports;
  }
  var km = { exports: {} }, nBe = km.exports, j_;
  function G1() {
    return j_ || (j_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      e = ws(), t = ir(), km.exports = function(n) {
        i(s, n);
        function s(o, a, A) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing DTD element name. " + this.debugInfo());
          A || (A = "(#PCDATA)"), Array.isArray(A) && (A = "(" + A.join(",") + ")"), this.name = this.stringify.name(a), this.type = t.ElementDeclaration, this.value = this.stringify.dtdElementValue(A);
        }
        return s.prototype.toString = function(o) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(o));
        }, s;
      }(e);
    }).call(nBe)), km.exports;
  }
  var Ym = { exports: {} }, sBe = Ym.exports, H_;
  function j1() {
    return H_ || (H_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      e = ws(), t = ir(), Ym.exports = function(n) {
        i(s, n);
        function s(o, a, A) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing DTD notation name. " + this.debugInfo(a));
          if (!A.pubID && !A.sysID)
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(a));
          this.name = this.stringify.name(a), this.type = t.NotationDeclaration, A.pubID != null && (this.pubID = this.stringify.dtdPubID(A.pubID)), A.sysID != null && (this.sysID = this.stringify.dtdSysID(A.sysID));
        }
        return Object.defineProperty(s.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        }), Object.defineProperty(s.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        }), s.prototype.toString = function(o) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(o));
        }, s;
      }(e);
    }).call(sBe)), Ym.exports;
  }
  var oBe = Tm.exports, J_;
  function H1() {
    return J_ || (J_ = 1, (function() {
      var t, e, i, r, n, s, o, a, A = function(c, u) {
        for (var d in u)
          l.call(u, d) && (c[d] = u[d]);
        function h() {
          this.constructor = c;
        }
        return h.prototype = u.prototype, c.prototype = new h(), c.__super__ = u.prototype, c;
      }, l = {}.hasOwnProperty;
      a = Ha().isObject, o = ws(), t = ir(), e = P1(), r = O1(), i = G1(), n = j1(), s = Y1(), Tm.exports = function(c) {
        A(u, c);
        function u(d, h, g) {
          var f, p, m, E, y, C;
          if (u.__super__.constructor.call(this, d), this.type = t.DocType, d.children) {
            for (E = d.children, p = 0, m = E.length; p < m; p++)
              if (f = E[p], f.type === t.Element) {
                this.name = f.name;
                break;
              }
          }
          this.documentObject = d, a(h) && (y = h, h = y.pubID, g = y.sysID), g == null && (C = [h, g], g = C[0], h = C[1]), h != null && (this.pubID = this.stringify.dtdPubID(h)), g != null && (this.sysID = this.stringify.dtdSysID(g));
        }
        return Object.defineProperty(u.prototype, "entities", {
          get: function() {
            var d, h, g, f, p;
            for (f = {}, p = this.children, h = 0, g = p.length; h < g; h++)
              d = p[h], d.type === t.EntityDeclaration && !d.pe && (f[d.name] = d);
            return new s(f);
          }
        }), Object.defineProperty(u.prototype, "notations", {
          get: function() {
            var d, h, g, f, p;
            for (f = {}, p = this.children, h = 0, g = p.length; h < g; h++)
              d = p[h], d.type === t.NotationDeclaration && (f[d.name] = d);
            return new s(f);
          }
        }), Object.defineProperty(u.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        }), Object.defineProperty(u.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        }), Object.defineProperty(u.prototype, "internalSubset", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }), u.prototype.element = function(d, h) {
          var g;
          return g = new i(this, d, h), this.children.push(g), this;
        }, u.prototype.attList = function(d, h, g, f, p) {
          var m;
          return m = new e(this, d, h, g, f, p), this.children.push(m), this;
        }, u.prototype.entity = function(d, h) {
          var g;
          return g = new r(this, !1, d, h), this.children.push(g), this;
        }, u.prototype.pEntity = function(d, h) {
          var g;
          return g = new r(this, !0, d, h), this.children.push(g), this;
        }, u.prototype.notation = function(d, h) {
          var g;
          return g = new n(this, d, h), this.children.push(g), this;
        }, u.prototype.toString = function(d) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(d));
        }, u.prototype.ele = function(d, h) {
          return this.element(d, h);
        }, u.prototype.att = function(d, h, g, f, p) {
          return this.attList(d, h, g, f, p);
        }, u.prototype.ent = function(d, h) {
          return this.entity(d, h);
        }, u.prototype.pent = function(d, h) {
          return this.pEntity(d, h);
        }, u.prototype.not = function(d, h) {
          return this.notation(d, h);
        }, u.prototype.up = function() {
          return this.root() || this.documentObject;
        }, u.prototype.isEqualNode = function(d) {
          return !(!u.__super__.isEqualNode.apply(this, arguments).isEqualNode(d) || d.name !== this.name || d.publicId !== this.publicId || d.systemId !== this.systemId);
        }, u;
      }(o);
    }).call(oBe)), Tm.exports;
  }
  var Nm = { exports: {} }, aBe = Nm.exports, V_;
  function J1() {
    return V_ || (V_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      t = ir(), e = ws(), Nm.exports = function(n) {
        i(s, n);
        function s(o, a) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing raw text. " + this.debugInfo());
          this.type = t.Raw, this.value = this.stringify.raw(a);
        }
        return s.prototype.clone = function() {
          return Object.create(this);
        }, s.prototype.toString = function(o) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(o));
        }, s;
      }(e);
    }).call(aBe)), Nm.exports;
  }
  var Um = { exports: {} }, ABe = Um.exports, W_;
  function V1() {
    return W_ || (W_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      t = ir(), e = $B(), Um.exports = function(n) {
        i(s, n);
        function s(o, a) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing element text. " + this.debugInfo());
          this.name = "#text", this.type = t.Text, this.value = this.stringify.text(a);
        }
        return Object.defineProperty(s.prototype, "isElementContentWhitespace", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }), Object.defineProperty(s.prototype, "wholeText", {
          get: function() {
            var o, a, A;
            for (A = "", a = this.previousSibling; a; )
              A = a.data + A, a = a.previousSibling;
            for (A += this.data, o = this.nextSibling; o; )
              A = A + o.data, o = o.nextSibling;
            return A;
          }
        }), s.prototype.clone = function() {
          return Object.create(this);
        }, s.prototype.toString = function(o) {
          return this.options.writer.text(this, this.options.writer.filterOptions(o));
        }, s.prototype.splitText = function(o) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, s.prototype.replaceWholeText = function(o) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, s;
      }(e);
    }).call(ABe)), Um.exports;
  }
  var Lm = { exports: {} }, lBe = Lm.exports, K_;
  function W1() {
    return K_ || (K_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      t = ir(), e = $B(), Lm.exports = function(n) {
        i(s, n);
        function s(o, a, A) {
          if (s.__super__.constructor.call(this, o), a == null)
            throw new Error("Missing instruction target. " + this.debugInfo());
          this.type = t.ProcessingInstruction, this.target = this.stringify.insTarget(a), this.name = this.target, A && (this.value = this.stringify.insValue(A));
        }
        return s.prototype.clone = function() {
          return Object.create(this);
        }, s.prototype.toString = function(o) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(o));
        }, s.prototype.isEqualNode = function(o) {
          return !(!s.__super__.isEqualNode.apply(this, arguments).isEqualNode(o) || o.target !== this.target);
        }, s;
      }(e);
    }).call(lBe)), Lm.exports;
  }
  var zm = { exports: {} }, cBe = zm.exports, X_;
  function N4() {
    return X_ || (X_ = 1, (function() {
      var t, e, i = function(n, s) {
        for (var o in s)
          r.call(s, o) && (n[o] = s[o]);
        function a() {
          this.constructor = n;
        }
        return a.prototype = s.prototype, n.prototype = new a(), n.__super__ = s.prototype, n;
      }, r = {}.hasOwnProperty;
      e = ws(), t = ir(), zm.exports = function(n) {
        i(s, n);
        function s(o) {
          s.__super__.constructor.call(this, o), this.type = t.Dummy;
        }
        return s.prototype.clone = function() {
          return Object.create(this);
        }, s.prototype.toString = function(o) {
          return "";
        }, s;
      }(e);
    }).call(cBe)), zm.exports;
  }
  var Pm = { exports: {} }, uBe = Pm.exports, Z_;
  function dBe() {
    return Z_ || (Z_ = 1, (function() {
      Pm.exports = function() {
        function t(e) {
          this.nodes = e;
        }
        return Object.defineProperty(t.prototype, "length", {
          get: function() {
            return this.nodes.length || 0;
          }
        }), t.prototype.clone = function() {
          return this.nodes = null;
        }, t.prototype.item = function(e) {
          return this.nodes[e] || null;
        }, t;
      }();
    }).call(uBe)), Pm.exports;
  }
  var Om = { exports: {} }, hBe = Om.exports, q_;
  function gBe() {
    return q_ || (q_ = 1, (function() {
      Om.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(hBe)), Om.exports;
  }
  var fBe = bm.exports, $_;
  function ws() {
    return $_ || ($_ = 1, (function() {
      var t, e, i, r, n, s, o, a, A, l, c, u, d, h, g, f, p, m = {}.hasOwnProperty;
      p = Ha(), f = p.isObject, g = p.isFunction, h = p.isEmpty, d = p.getValue, a = null, i = null, r = null, n = null, s = null, c = null, u = null, l = null, o = null, e = null, A = null, t = null, bm.exports = function() {
        function E(y) {
          this.parent = y, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), this.value = null, this.children = [], this.baseURI = null, a || (a = N1(), i = U1(), r = L1(), n = z1(), s = H1(), c = J1(), u = V1(), l = W1(), o = N4(), e = ir(), A = dBe(), Y1(), t = gBe());
        }
        return Object.defineProperty(E.prototype, "nodeName", {
          get: function() {
            return this.name;
          }
        }), Object.defineProperty(E.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        }), Object.defineProperty(E.prototype, "nodeValue", {
          get: function() {
            return this.value;
          }
        }), Object.defineProperty(E.prototype, "parentNode", {
          get: function() {
            return this.parent;
          }
        }), Object.defineProperty(E.prototype, "childNodes", {
          get: function() {
            return (!this.childNodeList || !this.childNodeList.nodes) && (this.childNodeList = new A(this.children)), this.childNodeList;
          }
        }), Object.defineProperty(E.prototype, "firstChild", {
          get: function() {
            return this.children[0] || null;
          }
        }), Object.defineProperty(E.prototype, "lastChild", {
          get: function() {
            return this.children[this.children.length - 1] || null;
          }
        }), Object.defineProperty(E.prototype, "previousSibling", {
          get: function() {
            var y;
            return y = this.parent.children.indexOf(this), this.parent.children[y - 1] || null;
          }
        }), Object.defineProperty(E.prototype, "nextSibling", {
          get: function() {
            var y;
            return y = this.parent.children.indexOf(this), this.parent.children[y + 1] || null;
          }
        }), Object.defineProperty(E.prototype, "ownerDocument", {
          get: function() {
            return this.document() || null;
          }
        }), Object.defineProperty(E.prototype, "textContent", {
          get: function() {
            var y, C, w, M, I;
            if (this.nodeType === e.Element || this.nodeType === e.DocumentFragment) {
              for (I = "", M = this.children, C = 0, w = M.length; C < w; C++)
                y = M[C], y.textContent && (I += y.textContent);
              return I;
            } else
              return null;
          },
          set: function(y) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        }), E.prototype.setParent = function(y) {
          var C, w, M, I, b;
          for (this.parent = y, y && (this.options = y.options, this.stringify = y.stringify), I = this.children, b = [], w = 0, M = I.length; w < M; w++)
            C = I[w], b.push(C.setParent(this));
          return b;
        }, E.prototype.element = function(y, C, w) {
          var M, I, b, B, x, Q, v, T, S, D, F;
          if (Q = null, C === null && w == null && (S = [{}, null], C = S[0], w = S[1]), C == null && (C = {}), C = d(C), f(C) || (D = [C, w], w = D[0], C = D[1]), y != null && (y = d(y)), Array.isArray(y))
            for (b = 0, v = y.length; b < v; b++)
              I = y[b], Q = this.element(I);
          else if (g(y))
            Q = this.element(y.apply());
          else if (f(y)) {
            for (x in y)
              if (m.call(y, x))
                if (F = y[x], g(F) && (F = F.apply()), !this.options.ignoreDecorators && this.stringify.convertAttKey && x.indexOf(this.stringify.convertAttKey) === 0)
                  Q = this.attribute(x.substr(this.stringify.convertAttKey.length), F);
                else if (!this.options.separateArrayItems && Array.isArray(F) && h(F))
                  Q = this.dummy();
                else if (f(F) && h(F))
                  Q = this.element(x);
                else if (!this.options.keepNullNodes && F == null)
                  Q = this.dummy();
                else if (!this.options.separateArrayItems && Array.isArray(F))
                  for (B = 0, T = F.length; B < T; B++)
                    I = F[B], M = {}, M[x] = I, Q = this.element(M);
                else f(F) ? !this.options.ignoreDecorators && this.stringify.convertTextKey && x.indexOf(this.stringify.convertTextKey) === 0 ? Q = this.element(F) : (Q = this.element(x), Q.element(F)) : Q = this.element(x, F);
          } else !this.options.keepNullNodes && w === null ? Q = this.dummy() : !this.options.ignoreDecorators && this.stringify.convertTextKey && y.indexOf(this.stringify.convertTextKey) === 0 ? Q = this.text(w) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && y.indexOf(this.stringify.convertCDataKey) === 0 ? Q = this.cdata(w) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && y.indexOf(this.stringify.convertCommentKey) === 0 ? Q = this.comment(w) : !this.options.ignoreDecorators && this.stringify.convertRawKey && y.indexOf(this.stringify.convertRawKey) === 0 ? Q = this.raw(w) : !this.options.ignoreDecorators && this.stringify.convertPIKey && y.indexOf(this.stringify.convertPIKey) === 0 ? Q = this.instruction(y.substr(this.stringify.convertPIKey.length), w) : Q = this.node(y, C, w);
          if (Q == null)
            throw new Error("Could not create any elements with: " + y + ". " + this.debugInfo());
          return Q;
        }, E.prototype.insertBefore = function(y, C, w) {
          var M, I, b, B, x;
          if (y != null && y.type)
            return b = y, B = C, b.setParent(this), B ? (I = children.indexOf(B), x = children.splice(I), children.push(b), Array.prototype.push.apply(children, x)) : children.push(b), b;
          if (this.isRoot)
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(y));
          return I = this.parent.children.indexOf(this), x = this.parent.children.splice(I), M = this.parent.element(y, C, w), Array.prototype.push.apply(this.parent.children, x), M;
        }, E.prototype.insertAfter = function(y, C, w) {
          var M, I, b;
          if (this.isRoot)
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(y));
          return I = this.parent.children.indexOf(this), b = this.parent.children.splice(I + 1), M = this.parent.element(y, C, w), Array.prototype.push.apply(this.parent.children, b), M;
        }, E.prototype.remove = function() {
          var y;
          if (this.isRoot)
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          return y = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [y, y - y + 1].concat([])), this.parent;
        }, E.prototype.node = function(y, C, w) {
          var M, I;
          return y != null && (y = d(y)), C || (C = {}), C = d(C), f(C) || (I = [C, w], w = I[0], C = I[1]), M = new a(this, y, C), w != null && M.text(w), this.children.push(M), M;
        }, E.prototype.text = function(y) {
          var C;
          return f(y) && this.element(y), C = new u(this, y), this.children.push(C), this;
        }, E.prototype.cdata = function(y) {
          var C;
          return C = new i(this, y), this.children.push(C), this;
        }, E.prototype.comment = function(y) {
          var C;
          return C = new r(this, y), this.children.push(C), this;
        }, E.prototype.commentBefore = function(y) {
          var C, w;
          return C = this.parent.children.indexOf(this), w = this.parent.children.splice(C), this.parent.comment(y), Array.prototype.push.apply(this.parent.children, w), this;
        }, E.prototype.commentAfter = function(y) {
          var C, w;
          return C = this.parent.children.indexOf(this), w = this.parent.children.splice(C + 1), this.parent.comment(y), Array.prototype.push.apply(this.parent.children, w), this;
        }, E.prototype.raw = function(y) {
          var C;
          return C = new c(this, y), this.children.push(C), this;
        }, E.prototype.dummy = function() {
          var y;
          return y = new o(this), y;
        }, E.prototype.instruction = function(y, C) {
          var w, M, I, b, B;
          if (y != null && (y = d(y)), C != null && (C = d(C)), Array.isArray(y))
            for (b = 0, B = y.length; b < B; b++)
              w = y[b], this.instruction(w);
          else if (f(y))
            for (w in y)
              m.call(y, w) && (M = y[w], this.instruction(w, M));
          else
            g(C) && (C = C.apply()), I = new l(this, y, C), this.children.push(I);
          return this;
        }, E.prototype.instructionBefore = function(y, C) {
          var w, M;
          return w = this.parent.children.indexOf(this), M = this.parent.children.splice(w), this.parent.instruction(y, C), Array.prototype.push.apply(this.parent.children, M), this;
        }, E.prototype.instructionAfter = function(y, C) {
          var w, M;
          return w = this.parent.children.indexOf(this), M = this.parent.children.splice(w + 1), this.parent.instruction(y, C), Array.prototype.push.apply(this.parent.children, M), this;
        }, E.prototype.declaration = function(y, C, w) {
          var M, I;
          return M = this.document(), I = new n(M, y, C, w), M.children.length === 0 ? M.children.unshift(I) : M.children[0].type === e.Declaration ? M.children[0] = I : M.children.unshift(I), M.root() || M;
        }, E.prototype.dtd = function(y, C) {
          var w, M, I, b, B, x, Q, v, T, S;
          for (M = this.document(), I = new s(M, y, C), T = M.children, b = B = 0, Q = T.length; B < Q; b = ++B)
            if (w = T[b], w.type === e.DocType)
              return M.children[b] = I, I;
          for (S = M.children, b = x = 0, v = S.length; x < v; b = ++x)
            if (w = S[b], w.isRoot)
              return M.children.splice(b, 0, I), I;
          return M.children.push(I), I;
        }, E.prototype.up = function() {
          if (this.isRoot)
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          return this.parent;
        }, E.prototype.root = function() {
          var y;
          for (y = this; y; ) {
            if (y.type === e.Document)
              return y.rootObject;
            if (y.isRoot)
              return y;
            y = y.parent;
          }
        }, E.prototype.document = function() {
          var y;
          for (y = this; y; ) {
            if (y.type === e.Document)
              return y;
            y = y.parent;
          }
        }, E.prototype.end = function(y) {
          return this.document().end(y);
        }, E.prototype.prev = function() {
          var y;
          if (y = this.parent.children.indexOf(this), y < 1)
            throw new Error("Already at the first node. " + this.debugInfo());
          return this.parent.children[y - 1];
        }, E.prototype.next = function() {
          var y;
          if (y = this.parent.children.indexOf(this), y === -1 || y === this.parent.children.length - 1)
            throw new Error("Already at the last node. " + this.debugInfo());
          return this.parent.children[y + 1];
        }, E.prototype.importDocument = function(y) {
          var C;
          return C = y.root().clone(), C.parent = this, C.isRoot = !1, this.children.push(C), this;
        }, E.prototype.debugInfo = function(y) {
          var C, w;
          return y = y || this.name, y == null && !((C = this.parent) != null && C.name) ? "" : y == null ? "parent: <" + this.parent.name + ">" : (w = this.parent) != null && w.name ? "node: <" + y + ">, parent: <" + this.parent.name + ">" : "node: <" + y + ">";
        }, E.prototype.ele = function(y, C, w) {
          return this.element(y, C, w);
        }, E.prototype.nod = function(y, C, w) {
          return this.node(y, C, w);
        }, E.prototype.txt = function(y) {
          return this.text(y);
        }, E.prototype.dat = function(y) {
          return this.cdata(y);
        }, E.prototype.com = function(y) {
          return this.comment(y);
        }, E.prototype.ins = function(y, C) {
          return this.instruction(y, C);
        }, E.prototype.doc = function() {
          return this.document();
        }, E.prototype.dec = function(y, C, w) {
          return this.declaration(y, C, w);
        }, E.prototype.e = function(y, C, w) {
          return this.element(y, C, w);
        }, E.prototype.n = function(y, C, w) {
          return this.node(y, C, w);
        }, E.prototype.t = function(y) {
          return this.text(y);
        }, E.prototype.d = function(y) {
          return this.cdata(y);
        }, E.prototype.c = function(y) {
          return this.comment(y);
        }, E.prototype.r = function(y) {
          return this.raw(y);
        }, E.prototype.i = function(y, C) {
          return this.instruction(y, C);
        }, E.prototype.u = function() {
          return this.up();
        }, E.prototype.importXMLBuilder = function(y) {
          return this.importDocument(y);
        }, E.prototype.replaceChild = function(y, C) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.removeChild = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.appendChild = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.hasChildNodes = function() {
          return this.children.length !== 0;
        }, E.prototype.cloneNode = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.normalize = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.isSupported = function(y, C) {
          return !0;
        }, E.prototype.hasAttributes = function() {
          return this.attribs.length !== 0;
        }, E.prototype.compareDocumentPosition = function(y) {
          var C, w;
          return C = this, C === y ? 0 : this.document() !== y.document() ? (w = t.Disconnected | t.ImplementationSpecific, Math.random() < 0.5 ? w |= t.Preceding : w |= t.Following, w) : C.isAncestor(y) ? t.Contains | t.Preceding : C.isDescendant(y) ? t.Contains | t.Following : C.isPreceding(y) ? t.Preceding : t.Following;
        }, E.prototype.isSameNode = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.lookupPrefix = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.isDefaultNamespace = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.lookupNamespaceURI = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.isEqualNode = function(y) {
          var C, w, M;
          if (y.nodeType !== this.nodeType || y.children.length !== this.children.length)
            return !1;
          for (C = w = 0, M = this.children.length - 1; 0 <= M ? w <= M : w >= M; C = 0 <= M ? ++w : --w)
            if (!this.children[C].isEqualNode(y.children[C]))
              return !1;
          return !0;
        }, E.prototype.getFeature = function(y, C) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.setUserData = function(y, C, w) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.getUserData = function(y) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, E.prototype.contains = function(y) {
          return y ? y === this || this.isDescendant(y) : !1;
        }, E.prototype.isDescendant = function(y) {
          var C, w, M, I, b;
          for (b = this.children, M = 0, I = b.length; M < I; M++)
            if (C = b[M], y === C || (w = C.isDescendant(y), w))
              return !0;
          return !1;
        }, E.prototype.isAncestor = function(y) {
          return y.isDescendant(this);
        }, E.prototype.isPreceding = function(y) {
          var C, w;
          return C = this.treePosition(y), w = this.treePosition(this), C === -1 || w === -1 ? !1 : C < w;
        }, E.prototype.isFollowing = function(y) {
          var C, w;
          return C = this.treePosition(y), w = this.treePosition(this), C === -1 || w === -1 ? !1 : C > w;
        }, E.prototype.treePosition = function(y) {
          var C, w;
          return w = 0, C = !1, this.foreachTreeNode(this.document(), function(M) {
            if (w++, !C && M === y)
              return C = !0;
          }), C ? w : -1;
        }, E.prototype.foreachTreeNode = function(y, C) {
          var w, M, I, b, B;
          for (y || (y = this.document()), b = y.children, M = 0, I = b.length; M < I; M++) {
            if (w = b[M], B = C(w))
              return B;
            if (B = this.foreachTreeNode(w, C), B)
              return B;
          }
        }, E;
      }();
    }).call(fBe)), bm.exports;
  }
  var Gm = { exports: {} }, pBe = Gm.exports, e2;
  function U4() {
    return e2 || (e2 = 1, (function() {
      var t = function(i, r) {
        return function() {
          return i.apply(r, arguments);
        };
      }, e = {}.hasOwnProperty;
      Gm.exports = function() {
        function i(r) {
          this.assertLegalName = t(this.assertLegalName, this), this.assertLegalChar = t(this.assertLegalChar, this);
          var n, s, o;
          r || (r = {}), this.options = r, this.options.version || (this.options.version = "1.0"), s = r.stringify || {};
          for (n in s)
            e.call(s, n) && (o = s[n], this[n] = o);
        }
        return i.prototype.name = function(r) {
          return this.options.noValidation ? r : this.assertLegalName("" + r || "");
        }, i.prototype.text = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar(this.textEscape("" + r || ""));
        }, i.prototype.cdata = function(r) {
          return this.options.noValidation ? r : (r = "" + r || "", r = r.replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(r));
        }, i.prototype.comment = function(r) {
          if (this.options.noValidation)
            return r;
          if (r = "" + r || "", r.match(/--/))
            throw new Error("Comment text cannot contain double-hypen: " + r);
          return this.assertLegalChar(r);
        }, i.prototype.raw = function(r) {
          return this.options.noValidation ? r : "" + r || "";
        }, i.prototype.attValue = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar(this.attEscape(r = "" + r || ""));
        }, i.prototype.insTarget = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.insValue = function(r) {
          if (this.options.noValidation)
            return r;
          if (r = "" + r || "", r.match(/\?>/))
            throw new Error("Invalid processing instruction value: " + r);
          return this.assertLegalChar(r);
        }, i.prototype.xmlVersion = function(r) {
          if (this.options.noValidation)
            return r;
          if (r = "" + r || "", !r.match(/1\.[0-9]+/))
            throw new Error("Invalid version number: " + r);
          return r;
        }, i.prototype.xmlEncoding = function(r) {
          if (this.options.noValidation)
            return r;
          if (r = "" + r || "", !r.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/))
            throw new Error("Invalid encoding: " + r);
          return this.assertLegalChar(r);
        }, i.prototype.xmlStandalone = function(r) {
          return this.options.noValidation ? r : r ? "yes" : "no";
        }, i.prototype.dtdPubID = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.dtdSysID = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.dtdElementValue = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.dtdAttType = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.dtdAttDefault = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.dtdEntityValue = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.dtdNData = function(r) {
          return this.options.noValidation ? r : this.assertLegalChar("" + r || "");
        }, i.prototype.convertAttKey = "@", i.prototype.convertPIKey = "?", i.prototype.convertTextKey = "#text", i.prototype.convertCDataKey = "#cdata", i.prototype.convertCommentKey = "#comment", i.prototype.convertRawKey = "#raw", i.prototype.assertLegalChar = function(r) {
          var n, s;
          if (this.options.noValidation)
            return r;
          if (n = "", this.options.version === "1.0") {
            if (n = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, s = r.match(n))
              throw new Error("Invalid character in string: " + r + " at index " + s.index);
          } else if (this.options.version === "1.1" && (n = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, s = r.match(n)))
            throw new Error("Invalid character in string: " + r + " at index " + s.index);
          return r;
        }, i.prototype.assertLegalName = function(r) {
          var n;
          if (this.options.noValidation)
            return r;
          if (this.assertLegalChar(r), n = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/, !r.match(n))
            throw new Error("Invalid character in name");
          return r;
        }, i.prototype.textEscape = function(r) {
          var n;
          return this.options.noValidation ? r : (n = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, r.replace(n, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;"));
        }, i.prototype.attEscape = function(r) {
          var n;
          return this.options.noValidation ? r : (n = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, r.replace(n, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;"));
        }, i;
      }();
    }).call(pBe)), Gm.exports;
  }
  var jm = { exports: {} }, Hm = { exports: {} }, Jm = { exports: {} }, mBe = Jm.exports, t2;
  function ew() {
    return t2 || (t2 = 1, (function() {
      Jm.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(mBe)), Jm.exports;
  }
  var EBe = Hm.exports, i2;
  function L4() {
    return i2 || (i2 = 1, (function() {
      var t, e, i, r = {}.hasOwnProperty;
      i = Ha().assign, t = ir(), z1(), H1(), U1(), L1(), N1(), J1(), V1(), W1(), N4(), P1(), G1(), O1(), j1(), e = ew(), Hm.exports = function() {
        function n(s) {
          var o, a, A;
          s || (s = {}), this.options = s, a = s.writer || {};
          for (o in a)
            r.call(a, o) && (A = a[o], this["_" + o] = this[o], this[o] = A);
        }
        return n.prototype.filterOptions = function(s) {
          var o, a, A, l, c, u, d, h;
          return s || (s = {}), s = i({}, this.options, s), o = {
            writer: this
          }, o.pretty = s.pretty || !1, o.allowEmpty = s.allowEmpty || !1, o.indent = (a = s.indent) != null ? a : "  ", o.newline = (A = s.newline) != null ? A : `
`, o.offset = (l = s.offset) != null ? l : 0, o.dontPrettyTextNodes = (c = (u = s.dontPrettyTextNodes) != null ? u : s.dontprettytextnodes) != null ? c : 0, o.spaceBeforeSlash = (d = (h = s.spaceBeforeSlash) != null ? h : s.spacebeforeslash) != null ? d : "", o.spaceBeforeSlash === !0 && (o.spaceBeforeSlash = " "), o.suppressPrettyCount = 0, o.user = {}, o.state = e.None, o;
        }, n.prototype.indent = function(s, o, a) {
          var A;
          return !o.pretty || o.suppressPrettyCount ? "" : o.pretty && (A = (a || 0) + o.offset + 1, A > 0) ? new Array(A).join(o.indent) : "";
        }, n.prototype.endline = function(s, o, a) {
          return !o.pretty || o.suppressPrettyCount ? "" : o.newline;
        }, n.prototype.attribute = function(s, o, a) {
          var A;
          return this.openAttribute(s, o, a), A = " " + s.name + '="' + s.value + '"', this.closeAttribute(s, o, a), A;
        }, n.prototype.cdata = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<![CDATA[", o.state = e.InsideTag, A += s.value, o.state = e.CloseTag, A += "]]>" + this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.comment = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<!-- ", o.state = e.InsideTag, A += s.value, o.state = e.CloseTag, A += " -->" + this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.declaration = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<?xml", o.state = e.InsideTag, A += ' version="' + s.version + '"', s.encoding != null && (A += ' encoding="' + s.encoding + '"'), s.standalone != null && (A += ' standalone="' + s.standalone + '"'), o.state = e.CloseTag, A += o.spaceBeforeSlash + "?>", A += this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.docType = function(s, o, a) {
          var A, l, c, u, d;
          if (a || (a = 0), this.openNode(s, o, a), o.state = e.OpenTag, u = this.indent(s, o, a), u += "<!DOCTYPE " + s.root().name, s.pubID && s.sysID ? u += ' PUBLIC "' + s.pubID + '" "' + s.sysID + '"' : s.sysID && (u += ' SYSTEM "' + s.sysID + '"'), s.children.length > 0) {
            for (u += " [", u += this.endline(s, o, a), o.state = e.InsideTag, d = s.children, l = 0, c = d.length; l < c; l++)
              A = d[l], u += this.writeChildNode(A, o, a + 1);
            o.state = e.CloseTag, u += "]";
          }
          return o.state = e.CloseTag, u += o.spaceBeforeSlash + ">", u += this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), u;
        }, n.prototype.element = function(s, o, a) {
          var A, l, c, u, d, h, g, f, p, m, E, y, C, w;
          a || (a = 0), m = !1, E = "", this.openNode(s, o, a), o.state = e.OpenTag, E += this.indent(s, o, a) + "<" + s.name, y = s.attribs;
          for (p in y)
            r.call(y, p) && (A = y[p], E += this.attribute(A, o, a));
          if (c = s.children.length, u = c === 0 ? null : s.children[0], c === 0 || s.children.every(function(M) {
            return (M.type === t.Text || M.type === t.Raw) && M.value === "";
          }))
            o.allowEmpty ? (E += ">", o.state = e.CloseTag, E += "</" + s.name + ">" + this.endline(s, o, a)) : (o.state = e.CloseTag, E += o.spaceBeforeSlash + "/>" + this.endline(s, o, a));
          else if (o.pretty && c === 1 && (u.type === t.Text || u.type === t.Raw) && u.value != null)
            E += ">", o.state = e.InsideTag, o.suppressPrettyCount++, m = !0, E += this.writeChildNode(u, o, a + 1), o.suppressPrettyCount--, m = !1, o.state = e.CloseTag, E += "</" + s.name + ">" + this.endline(s, o, a);
          else {
            if (o.dontPrettyTextNodes) {
              for (C = s.children, d = 0, g = C.length; d < g; d++)
                if (l = C[d], (l.type === t.Text || l.type === t.Raw) && l.value != null) {
                  o.suppressPrettyCount++, m = !0;
                  break;
                }
            }
            for (E += ">" + this.endline(s, o, a), o.state = e.InsideTag, w = s.children, h = 0, f = w.length; h < f; h++)
              l = w[h], E += this.writeChildNode(l, o, a + 1);
            o.state = e.CloseTag, E += this.indent(s, o, a) + "</" + s.name + ">", m && o.suppressPrettyCount--, E += this.endline(s, o, a), o.state = e.None;
          }
          return this.closeNode(s, o, a), E;
        }, n.prototype.writeChildNode = function(s, o, a) {
          switch (s.type) {
            case t.CData:
              return this.cdata(s, o, a);
            case t.Comment:
              return this.comment(s, o, a);
            case t.Element:
              return this.element(s, o, a);
            case t.Raw:
              return this.raw(s, o, a);
            case t.Text:
              return this.text(s, o, a);
            case t.ProcessingInstruction:
              return this.processingInstruction(s, o, a);
            case t.Dummy:
              return "";
            case t.Declaration:
              return this.declaration(s, o, a);
            case t.DocType:
              return this.docType(s, o, a);
            case t.AttributeDeclaration:
              return this.dtdAttList(s, o, a);
            case t.ElementDeclaration:
              return this.dtdElement(s, o, a);
            case t.EntityDeclaration:
              return this.dtdEntity(s, o, a);
            case t.NotationDeclaration:
              return this.dtdNotation(s, o, a);
            default:
              throw new Error("Unknown XML node type: " + s.constructor.name);
          }
        }, n.prototype.processingInstruction = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<?", o.state = e.InsideTag, A += s.target, s.value && (A += " " + s.value), o.state = e.CloseTag, A += o.spaceBeforeSlash + "?>", A += this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.raw = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a), o.state = e.InsideTag, A += s.value, o.state = e.CloseTag, A += this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.text = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a), o.state = e.InsideTag, A += s.value, o.state = e.CloseTag, A += this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.dtdAttList = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<!ATTLIST", o.state = e.InsideTag, A += " " + s.elementName + " " + s.attributeName + " " + s.attributeType, s.defaultValueType !== "#DEFAULT" && (A += " " + s.defaultValueType), s.defaultValue && (A += ' "' + s.defaultValue + '"'), o.state = e.CloseTag, A += o.spaceBeforeSlash + ">" + this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.dtdElement = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<!ELEMENT", o.state = e.InsideTag, A += " " + s.name + " " + s.value, o.state = e.CloseTag, A += o.spaceBeforeSlash + ">" + this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.dtdEntity = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<!ENTITY", o.state = e.InsideTag, s.pe && (A += " %"), A += " " + s.name, s.value ? A += ' "' + s.value + '"' : (s.pubID && s.sysID ? A += ' PUBLIC "' + s.pubID + '" "' + s.sysID + '"' : s.sysID && (A += ' SYSTEM "' + s.sysID + '"'), s.nData && (A += " NDATA " + s.nData)), o.state = e.CloseTag, A += o.spaceBeforeSlash + ">" + this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.dtdNotation = function(s, o, a) {
          var A;
          return this.openNode(s, o, a), o.state = e.OpenTag, A = this.indent(s, o, a) + "<!NOTATION", o.state = e.InsideTag, A += " " + s.name, s.pubID && s.sysID ? A += ' PUBLIC "' + s.pubID + '" "' + s.sysID + '"' : s.pubID ? A += ' PUBLIC "' + s.pubID + '"' : s.sysID && (A += ' SYSTEM "' + s.sysID + '"'), o.state = e.CloseTag, A += o.spaceBeforeSlash + ">" + this.endline(s, o, a), o.state = e.None, this.closeNode(s, o, a), A;
        }, n.prototype.openNode = function(s, o, a) {
        }, n.prototype.closeNode = function(s, o, a) {
        }, n.prototype.openAttribute = function(s, o, a) {
        }, n.prototype.closeAttribute = function(s, o, a) {
        }, n;
      }();
    }).call(EBe)), Hm.exports;
  }
  var yBe = jm.exports, r2;
  function K1() {
    return r2 || (r2 = 1, (function() {
      var t, e = function(r, n) {
        for (var s in n)
          i.call(n, s) && (r[s] = n[s]);
        function o() {
          this.constructor = r;
        }
        return o.prototype = n.prototype, r.prototype = new o(), r.__super__ = n.prototype, r;
      }, i = {}.hasOwnProperty;
      t = L4(), jm.exports = function(r) {
        e(n, r);
        function n(s) {
          n.__super__.constructor.call(this, s);
        }
        return n.prototype.document = function(s, o) {
          var a, A, l, c, u;
          for (o = this.filterOptions(o), c = "", u = s.children, A = 0, l = u.length; A < l; A++)
            a = u[A], c += this.writeChildNode(a, o, 0);
          return o.pretty && c.slice(-o.newline.length) === o.newline && (c = c.slice(0, -o.newline.length)), c;
        }, n;
      }(t);
    }).call(yBe)), jm.exports;
  }
  var BBe = ym.exports, n2;
  function z4() {
    return n2 || (n2 = 1, (function() {
      var t, e, i, r, n, s, o, a = function(l, c) {
        for (var u in c)
          A.call(c, u) && (l[u] = c[u]);
        function d() {
          this.constructor = l;
        }
        return d.prototype = c.prototype, l.prototype = new d(), l.__super__ = c.prototype, l;
      }, A = {}.hasOwnProperty;
      o = Ha().isPlainObject, i = k4(), e = Vye(), r = ws(), t = ir(), s = U4(), n = K1(), ym.exports = function(l) {
        a(c, l);
        function c(u) {
          c.__super__.constructor.call(this, null), this.name = "#document", this.type = t.Document, this.documentURI = null, this.domConfig = new e(), u || (u = {}), u.writer || (u.writer = new n()), this.options = u, this.stringify = new s(u);
        }
        return Object.defineProperty(c.prototype, "implementation", {
          value: new i()
        }), Object.defineProperty(c.prototype, "doctype", {
          get: function() {
            var u, d, h, g;
            for (g = this.children, d = 0, h = g.length; d < h; d++)
              if (u = g[d], u.type === t.DocType)
                return u;
            return null;
          }
        }), Object.defineProperty(c.prototype, "documentElement", {
          get: function() {
            return this.rootObject || null;
          }
        }), Object.defineProperty(c.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        }), Object.defineProperty(c.prototype, "strictErrorChecking", {
          get: function() {
            return !1;
          }
        }), Object.defineProperty(c.prototype, "xmlEncoding", {
          get: function() {
            return this.children.length !== 0 && this.children[0].type === t.Declaration ? this.children[0].encoding : null;
          }
        }), Object.defineProperty(c.prototype, "xmlStandalone", {
          get: function() {
            return this.children.length !== 0 && this.children[0].type === t.Declaration ? this.children[0].standalone === "yes" : !1;
          }
        }), Object.defineProperty(c.prototype, "xmlVersion", {
          get: function() {
            return this.children.length !== 0 && this.children[0].type === t.Declaration ? this.children[0].version : "1.0";
          }
        }), Object.defineProperty(c.prototype, "URL", {
          get: function() {
            return this.documentURI;
          }
        }), Object.defineProperty(c.prototype, "origin", {
          get: function() {
            return null;
          }
        }), Object.defineProperty(c.prototype, "compatMode", {
          get: function() {
            return null;
          }
        }), Object.defineProperty(c.prototype, "characterSet", {
          get: function() {
            return null;
          }
        }), Object.defineProperty(c.prototype, "contentType", {
          get: function() {
            return null;
          }
        }), c.prototype.end = function(u) {
          var d;
          return d = {}, u ? o(u) && (d = u, u = this.options.writer) : u = this.options.writer, u.document(this, u.filterOptions(d));
        }, c.prototype.toString = function(u) {
          return this.options.writer.document(this, this.options.writer.filterOptions(u));
        }, c.prototype.createElement = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createDocumentFragment = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createTextNode = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createComment = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createCDATASection = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createProcessingInstruction = function(u, d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createAttribute = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createEntityReference = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.getElementsByTagName = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.importNode = function(u, d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createElementNS = function(u, d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createAttributeNS = function(u, d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.getElementsByTagNameNS = function(u, d) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.getElementById = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.adoptNode = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.normalizeDocument = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.renameNode = function(u, d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.getElementsByClassName = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createEvent = function(u) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createRange = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createNodeIterator = function(u, d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c.prototype.createTreeWalker = function(u, d, h) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        }, c;
      }(r);
    }).call(BBe)), ym.exports;
  }
  var Vm = { exports: {} }, wBe = Vm.exports, s2;
  function CBe() {
    return s2 || (s2 = 1, (function() {
      var t, e, i, r, n, s, o, a, A, l, c, u, d, h, g, f, p, m, E, y, C, w, M, I = {}.hasOwnProperty;
      M = Ha(), C = M.isObject, y = M.isFunction, w = M.isPlainObject, E = M.getValue, t = ir(), u = z4(), d = N1(), r = U1(), n = L1(), g = J1(), m = V1(), h = W1(), l = z1(), c = H1(), s = P1(), a = O1(), o = G1(), A = j1(), i = Y4(), p = U4(), f = K1(), e = ew(), Vm.exports = function() {
        function b(B, x, Q) {
          var v;
          this.name = "?xml", this.type = t.Document, B || (B = {}), v = {}, B.writer ? w(B.writer) && (v = B.writer, B.writer = new f()) : B.writer = new f(), this.options = B, this.writer = B.writer, this.writerOptions = this.writer.filterOptions(v), this.stringify = new p(B), this.onDataCallback = x || function() {
          }, this.onEndCallback = Q || function() {
          }, this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, this.documentCompleted = !1, this.root = null;
        }
        return b.prototype.createChildNode = function(B) {
          var x, Q, v, T, S, D, F, R;
          switch (B.type) {
            case t.CData:
              this.cdata(B.value);
              break;
            case t.Comment:
              this.comment(B.value);
              break;
            case t.Element:
              v = {}, F = B.attribs;
              for (Q in F)
                I.call(F, Q) && (x = F[Q], v[Q] = x.value);
              this.node(B.name, v);
              break;
            case t.Dummy:
              this.dummy();
              break;
            case t.Raw:
              this.raw(B.value);
              break;
            case t.Text:
              this.text(B.value);
              break;
            case t.ProcessingInstruction:
              this.instruction(B.target, B.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + B.constructor.name);
          }
          for (R = B.children, S = 0, D = R.length; S < D; S++)
            T = R[S], this.createChildNode(T), T.type === t.Element && this.up();
          return this;
        }, b.prototype.dummy = function() {
          return this;
        }, b.prototype.node = function(B, x, Q) {
          var v;
          if (B == null)
            throw new Error("Missing node name.");
          if (this.root && this.currentLevel === -1)
            throw new Error("Document can only have one root node. " + this.debugInfo(B));
          return this.openCurrent(), B = E(B), x == null && (x = {}), x = E(x), C(x) || (v = [x, Q], Q = v[0], x = v[1]), this.currentNode = new d(this, B, x), this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, Q != null && this.text(Q), this;
        }, b.prototype.element = function(B, x, Q) {
          var v, T, S, D, F, R;
          if (this.currentNode && this.currentNode.type === t.DocType)
            this.dtdElement.apply(this, arguments);
          else if (Array.isArray(B) || C(B) || y(B))
            for (D = this.options.noValidation, this.options.noValidation = !0, R = new u(this.options).element("TEMP_ROOT"), R.element(B), this.options.noValidation = D, F = R.children, T = 0, S = F.length; T < S; T++)
              v = F[T], this.createChildNode(v), v.type === t.Element && this.up();
          else
            this.node(B, x, Q);
          return this;
        }, b.prototype.attribute = function(B, x) {
          var Q, v;
          if (!this.currentNode || this.currentNode.children)
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(B));
          if (B != null && (B = E(B)), C(B))
            for (Q in B)
              I.call(B, Q) && (v = B[Q], this.attribute(Q, v));
          else
            y(x) && (x = x.apply()), this.options.keepNullAttributes && x == null ? this.currentNode.attribs[B] = new i(this, B, "") : x != null && (this.currentNode.attribs[B] = new i(this, B, x));
          return this;
        }, b.prototype.text = function(B) {
          var x;
          return this.openCurrent(), x = new m(this, B), this.onData(this.writer.text(x, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.cdata = function(B) {
          var x;
          return this.openCurrent(), x = new r(this, B), this.onData(this.writer.cdata(x, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.comment = function(B) {
          var x;
          return this.openCurrent(), x = new n(this, B), this.onData(this.writer.comment(x, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.raw = function(B) {
          var x;
          return this.openCurrent(), x = new g(this, B), this.onData(this.writer.raw(x, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.instruction = function(B, x) {
          var Q, v, T, S, D;
          if (this.openCurrent(), B != null && (B = E(B)), x != null && (x = E(x)), Array.isArray(B))
            for (Q = 0, S = B.length; Q < S; Q++)
              v = B[Q], this.instruction(v);
          else if (C(B))
            for (v in B)
              I.call(B, v) && (T = B[v], this.instruction(v, T));
          else
            y(x) && (x = x.apply()), D = new h(this, B, x), this.onData(this.writer.processingInstruction(D, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        }, b.prototype.declaration = function(B, x, Q) {
          var v;
          if (this.openCurrent(), this.documentStarted)
            throw new Error("declaration() must be the first node.");
          return v = new l(this, B, x, Q), this.onData(this.writer.declaration(v, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.doctype = function(B, x, Q) {
          if (this.openCurrent(), B == null)
            throw new Error("Missing root node name.");
          if (this.root)
            throw new Error("dtd() must come before the root node.");
          return this.currentNode = new c(this, x, Q), this.currentNode.rootNodeName = B, this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, this;
        }, b.prototype.dtdElement = function(B, x) {
          var Q;
          return this.openCurrent(), Q = new o(this, B, x), this.onData(this.writer.dtdElement(Q, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.attList = function(B, x, Q, v, T) {
          var S;
          return this.openCurrent(), S = new s(this, B, x, Q, v, T), this.onData(this.writer.dtdAttList(S, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.entity = function(B, x) {
          var Q;
          return this.openCurrent(), Q = new a(this, !1, B, x), this.onData(this.writer.dtdEntity(Q, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.pEntity = function(B, x) {
          var Q;
          return this.openCurrent(), Q = new a(this, !0, B, x), this.onData(this.writer.dtdEntity(Q, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.notation = function(B, x) {
          var Q;
          return this.openCurrent(), Q = new A(this, B, x), this.onData(this.writer.dtdNotation(Q, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1), this;
        }, b.prototype.up = function() {
          if (this.currentLevel < 0)
            throw new Error("The document node has no parent.");
          return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], this.currentLevel--, this;
        }, b.prototype.end = function() {
          for (; this.currentLevel >= 0; )
            this.up();
          return this.onEnd();
        }, b.prototype.openCurrent = function() {
          if (this.currentNode)
            return this.currentNode.children = !0, this.openNode(this.currentNode);
        }, b.prototype.openNode = function(B) {
          var x, Q, v, T;
          if (!B.isOpen) {
            if (!this.root && this.currentLevel === 0 && B.type === t.Element && (this.root = B), Q = "", B.type === t.Element) {
              this.writerOptions.state = e.OpenTag, Q = this.writer.indent(B, this.writerOptions, this.currentLevel) + "<" + B.name, T = B.attribs;
              for (v in T)
                I.call(T, v) && (x = T[v], Q += this.writer.attribute(x, this.writerOptions, this.currentLevel));
              Q += (B.children ? ">" : "/>") + this.writer.endline(B, this.writerOptions, this.currentLevel), this.writerOptions.state = e.InsideTag;
            } else
              this.writerOptions.state = e.OpenTag, Q = this.writer.indent(B, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + B.rootNodeName, B.pubID && B.sysID ? Q += ' PUBLIC "' + B.pubID + '" "' + B.sysID + '"' : B.sysID && (Q += ' SYSTEM "' + B.sysID + '"'), B.children ? (Q += " [", this.writerOptions.state = e.InsideTag) : (this.writerOptions.state = e.CloseTag, Q += ">"), Q += this.writer.endline(B, this.writerOptions, this.currentLevel);
            return this.onData(Q, this.currentLevel), B.isOpen = !0;
          }
        }, b.prototype.closeNode = function(B) {
          var x;
          if (!B.isClosed)
            return x = "", this.writerOptions.state = e.CloseTag, B.type === t.Element ? x = this.writer.indent(B, this.writerOptions, this.currentLevel) + "</" + B.name + ">" + this.writer.endline(B, this.writerOptions, this.currentLevel) : x = this.writer.indent(B, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(B, this.writerOptions, this.currentLevel), this.writerOptions.state = e.None, this.onData(x, this.currentLevel), B.isClosed = !0;
        }, b.prototype.onData = function(B, x) {
          return this.documentStarted = !0, this.onDataCallback(B, x + 1);
        }, b.prototype.onEnd = function() {
          return this.documentCompleted = !0, this.onEndCallback();
        }, b.prototype.debugInfo = function(B) {
          return B == null ? "" : "node: <" + B + ">";
        }, b.prototype.ele = function() {
          return this.element.apply(this, arguments);
        }, b.prototype.nod = function(B, x, Q) {
          return this.node(B, x, Q);
        }, b.prototype.txt = function(B) {
          return this.text(B);
        }, b.prototype.dat = function(B) {
          return this.cdata(B);
        }, b.prototype.com = function(B) {
          return this.comment(B);
        }, b.prototype.ins = function(B, x) {
          return this.instruction(B, x);
        }, b.prototype.dec = function(B, x, Q) {
          return this.declaration(B, x, Q);
        }, b.prototype.dtd = function(B, x, Q) {
          return this.doctype(B, x, Q);
        }, b.prototype.e = function(B, x, Q) {
          return this.element(B, x, Q);
        }, b.prototype.n = function(B, x, Q) {
          return this.node(B, x, Q);
        }, b.prototype.t = function(B) {
          return this.text(B);
        }, b.prototype.d = function(B) {
          return this.cdata(B);
        }, b.prototype.c = function(B) {
          return this.comment(B);
        }, b.prototype.r = function(B) {
          return this.raw(B);
        }, b.prototype.i = function(B, x) {
          return this.instruction(B, x);
        }, b.prototype.att = function() {
          return this.currentNode && this.currentNode.type === t.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
        }, b.prototype.a = function() {
          return this.currentNode && this.currentNode.type === t.DocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
        }, b.prototype.ent = function(B, x) {
          return this.entity(B, x);
        }, b.prototype.pent = function(B, x) {
          return this.pEntity(B, x);
        }, b.prototype.not = function(B, x) {
          return this.notation(B, x);
        }, b;
      }();
    }).call(wBe)), Vm.exports;
  }
  var Wm = { exports: {} }, bBe = Wm.exports, o2;
  function MBe() {
    return o2 || (o2 = 1, (function() {
      var t, e, i, r = function(s, o) {
        for (var a in o)
          n.call(o, a) && (s[a] = o[a]);
        function A() {
          this.constructor = s;
        }
        return A.prototype = o.prototype, s.prototype = new A(), s.__super__ = o.prototype, s;
      }, n = {}.hasOwnProperty;
      t = ir(), i = L4(), e = ew(), Wm.exports = function(s) {
        r(o, s);
        function o(a, A) {
          this.stream = a, o.__super__.constructor.call(this, A);
        }
        return o.prototype.endline = function(a, A, l) {
          return a.isLastRootNode && A.state === e.CloseTag ? "" : o.__super__.endline.call(this, a, A, l);
        }, o.prototype.document = function(a, A) {
          var l, c, u, d, h, g, f, p, m;
          for (f = a.children, c = u = 0, h = f.length; u < h; c = ++u)
            l = f[c], l.isLastRootNode = c === a.children.length - 1;
          for (A = this.filterOptions(A), p = a.children, m = [], d = 0, g = p.length; d < g; d++)
            l = p[d], m.push(this.writeChildNode(l, A, 0));
          return m;
        }, o.prototype.attribute = function(a, A, l) {
          return this.stream.write(o.__super__.attribute.call(this, a, A, l));
        }, o.prototype.cdata = function(a, A, l) {
          return this.stream.write(o.__super__.cdata.call(this, a, A, l));
        }, o.prototype.comment = function(a, A, l) {
          return this.stream.write(o.__super__.comment.call(this, a, A, l));
        }, o.prototype.declaration = function(a, A, l) {
          return this.stream.write(o.__super__.declaration.call(this, a, A, l));
        }, o.prototype.docType = function(a, A, l) {
          var c, u, d, h;
          if (l || (l = 0), this.openNode(a, A, l), A.state = e.OpenTag, this.stream.write(this.indent(a, A, l)), this.stream.write("<!DOCTYPE " + a.root().name), a.pubID && a.sysID ? this.stream.write(' PUBLIC "' + a.pubID + '" "' + a.sysID + '"') : a.sysID && this.stream.write(' SYSTEM "' + a.sysID + '"'), a.children.length > 0) {
            for (this.stream.write(" ["), this.stream.write(this.endline(a, A, l)), A.state = e.InsideTag, h = a.children, u = 0, d = h.length; u < d; u++)
              c = h[u], this.writeChildNode(c, A, l + 1);
            A.state = e.CloseTag, this.stream.write("]");
          }
          return A.state = e.CloseTag, this.stream.write(A.spaceBeforeSlash + ">"), this.stream.write(this.endline(a, A, l)), A.state = e.None, this.closeNode(a, A, l);
        }, o.prototype.element = function(a, A, l) {
          var c, u, d, h, g, f, p, m, E;
          l || (l = 0), this.openNode(a, A, l), A.state = e.OpenTag, this.stream.write(this.indent(a, A, l) + "<" + a.name), m = a.attribs;
          for (p in m)
            n.call(m, p) && (c = m[p], this.attribute(c, A, l));
          if (d = a.children.length, h = d === 0 ? null : a.children[0], d === 0 || a.children.every(function(y) {
            return (y.type === t.Text || y.type === t.Raw) && y.value === "";
          }))
            A.allowEmpty ? (this.stream.write(">"), A.state = e.CloseTag, this.stream.write("</" + a.name + ">")) : (A.state = e.CloseTag, this.stream.write(A.spaceBeforeSlash + "/>"));
          else if (A.pretty && d === 1 && (h.type === t.Text || h.type === t.Raw) && h.value != null)
            this.stream.write(">"), A.state = e.InsideTag, A.suppressPrettyCount++, this.writeChildNode(h, A, l + 1), A.suppressPrettyCount--, A.state = e.CloseTag, this.stream.write("</" + a.name + ">");
          else {
            for (this.stream.write(">" + this.endline(a, A, l)), A.state = e.InsideTag, E = a.children, g = 0, f = E.length; g < f; g++)
              u = E[g], this.writeChildNode(u, A, l + 1);
            A.state = e.CloseTag, this.stream.write(this.indent(a, A, l) + "</" + a.name + ">");
          }
          return this.stream.write(this.endline(a, A, l)), A.state = e.None, this.closeNode(a, A, l);
        }, o.prototype.processingInstruction = function(a, A, l) {
          return this.stream.write(o.__super__.processingInstruction.call(this, a, A, l));
        }, o.prototype.raw = function(a, A, l) {
          return this.stream.write(o.__super__.raw.call(this, a, A, l));
        }, o.prototype.text = function(a, A, l) {
          return this.stream.write(o.__super__.text.call(this, a, A, l));
        }, o.prototype.dtdAttList = function(a, A, l) {
          return this.stream.write(o.__super__.dtdAttList.call(this, a, A, l));
        }, o.prototype.dtdElement = function(a, A, l) {
          return this.stream.write(o.__super__.dtdElement.call(this, a, A, l));
        }, o.prototype.dtdEntity = function(a, A, l) {
          return this.stream.write(o.__super__.dtdEntity.call(this, a, A, l));
        }, o.prototype.dtdNotation = function(a, A, l) {
          return this.stream.write(o.__super__.dtdNotation.call(this, a, A, l));
        }, o;
      }(i);
    }).call(bBe)), Wm.exports;
  }
  var a2;
  function IBe() {
    return a2 || (a2 = 1, (function() {
      var t, e, i, r, n, s, o, a, A, l;
      l = Ha(), a = l.assign, A = l.isFunction, i = k4(), r = z4(), n = CBe(), o = K1(), s = MBe(), t = ir(), e = ew(), go.create = function(c, u, d, h) {
        var g, f;
        if (c == null)
          throw new Error("Root element needs a name.");
        return h = a({}, u, d, h), g = new r(h), f = g.element(c), h.headless || (g.declaration(h), (h.pubID != null || h.sysID != null) && g.dtd(h)), f;
      }, go.begin = function(c, u, d) {
        var h;
        return A(c) && (h = [c, u], u = h[0], d = h[1], c = {}), u ? new n(c, u, d) : new r(c);
      }, go.stringWriter = function(c) {
        return new o(c);
      }, go.streamWriter = function(c, u) {
        return new s(c, u);
      }, go.implementation = new i(), go.nodeType = t, go.writerState = e;
    }).call(go)), go;
  }
  var A2;
  function vBe() {
    return A2 || (A2 = 1, (function() {
      var t, e, i, r, n, s = {}.hasOwnProperty;
      t = IBe(), e = k1().defaults, r = function(o) {
        return typeof o == "string" && (o.indexOf("&") >= 0 || o.indexOf(">") >= 0 || o.indexOf("<") >= 0);
      }, n = function(o) {
        return "<![CDATA[" + i(o) + "]]>";
      }, i = function(o) {
        return o.replace("]]>", "]]]]><![CDATA[>");
      }, Pp.Builder = function() {
        function o(a) {
          var A, l, c;
          this.options = {}, l = e["0.2"];
          for (A in l)
            s.call(l, A) && (c = l[A], this.options[A] = c);
          for (A in a)
            s.call(a, A) && (c = a[A], this.options[A] = c);
        }
        return o.prototype.buildObject = function(a) {
          var A, l, c, u, d;
          return A = this.options.attrkey, l = this.options.charkey, Object.keys(a).length === 1 && this.options.rootName === e["0.2"].rootName ? (d = Object.keys(a)[0], a = a[d]) : d = this.options.rootName, c = /* @__PURE__ */ function(h) {
            return function(g, f) {
              var p, m, E, y, C, w;
              if (typeof f != "object")
                h.options.cdata && r(f) ? g.raw(n(f)) : g.txt(f);
              else if (Array.isArray(f)) {
                for (y in f)
                  if (s.call(f, y)) {
                    m = f[y];
                    for (C in m)
                      E = m[C], g = c(g.ele(C), E).up();
                  }
              } else
                for (C in f)
                  if (s.call(f, C))
                    if (m = f[C], C === A) {
                      if (typeof m == "object")
                        for (p in m)
                          w = m[p], g = g.att(p, w);
                    } else if (C === l)
                      h.options.cdata && r(m) ? g = g.raw(n(m)) : g = g.txt(m);
                    else if (Array.isArray(m))
                      for (y in m)
                        s.call(m, y) && (E = m[y], typeof E == "string" ? h.options.cdata && r(E) ? g = g.ele(C).raw(n(E)).up() : g = g.ele(C, E).up() : g = c(g.ele(C), E).up());
                    else typeof m == "object" ? g = c(g.ele(C), m).up() : typeof m == "string" && h.options.cdata && r(m) ? g = g.ele(C).raw(n(m)).up() : (m == null && (m = ""), g = g.ele(C, m.toString()).up());
              return g;
            };
          }(this), u = t.create(d, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          }), c(u, a).end(this.options.renderOpts);
        }, o;
      }();
    }).call(Pp)), Pp;
  }
  var Op = {}, MC = {};
  const xBe = {}, QBe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: xBe
  }, Symbol.toStringTag, { value: "Module" })), hy = /* @__PURE__ */ hre(QBe);
  var l2;
  function FBe() {
    return l2 || (l2 = 1, function(t) {
      (function(e) {
        e.parser = function(k, _) {
          return new r(k, _);
        }, e.SAXParser = r, e.SAXStream = c, e.createStream = l, e.MAX_BUFFER_LENGTH = 64 * 1024;
        var i = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script"
        ];
        e.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace"
        ];
        function r(k, _) {
          if (!(this instanceof r))
            return new r(k, _);
          var q = this;
          s(q), q.q = q.c = "", q.bufferCheckPosition = e.MAX_BUFFER_LENGTH, q.opt = _ || {}, q.opt.lowercase = q.opt.lowercase || q.opt.lowercasetags, q.looseCase = q.opt.lowercase ? "toLowerCase" : "toUpperCase", q.tags = [], q.closed = q.closedRoot = q.sawRoot = !1, q.tag = q.error = null, q.strict = !!k, q.noscript = !!(k || q.opt.noscript), q.state = B.BEGIN, q.strictEntities = q.opt.strictEntities, q.ENTITIES = q.strictEntities ? Object.create(e.XML_ENTITIES) : Object.create(e.ENTITIES), q.attribList = [], q.opt.xmlns && (q.ns = Object.create(f)), q.opt.unquotedAttributeValues === void 0 && (q.opt.unquotedAttributeValues = !k), q.trackPosition = q.opt.position !== !1, q.trackPosition && (q.position = q.line = q.column = 0), Q(q, "onready");
        }
        Object.create || (Object.create = function(k) {
          function _() {
          }
          _.prototype = k;
          var q = new _();
          return q;
        }), Object.keys || (Object.keys = function(k) {
          var _ = [];
          for (var q in k) k.hasOwnProperty(q) && _.push(q);
          return _;
        });
        function n(k) {
          for (var _ = Math.max(e.MAX_BUFFER_LENGTH, 10), q = 0, U = 0, J = i.length; U < J; U++) {
            var ae = k[i[U]].length;
            if (ae > _)
              switch (i[U]) {
                case "textNode":
                  T(k);
                  break;
                case "cdata":
                  v(k, "oncdata", k.cdata), k.cdata = "";
                  break;
                case "script":
                  v(k, "onscript", k.script), k.script = "";
                  break;
                default:
                  D(k, "Max buffer length exceeded: " + i[U]);
              }
            q = Math.max(q, ae);
          }
          var $ = e.MAX_BUFFER_LENGTH - q;
          k.bufferCheckPosition = $ + k.position;
        }
        function s(k) {
          for (var _ = 0, q = i.length; _ < q; _++)
            k[i[_]] = "";
        }
        function o(k) {
          T(k), k.cdata !== "" && (v(k, "oncdata", k.cdata), k.cdata = ""), k.script !== "" && (v(k, "onscript", k.script), k.script = "");
        }
        r.prototype = {
          end: function() {
            F(this);
          },
          write: se,
          resume: function() {
            return this.error = null, this;
          },
          close: function() {
            return this.write(null);
          },
          flush: function() {
            o(this);
          }
        };
        var a;
        try {
          a = hy.Stream;
        } catch {
          a = function() {
          };
        }
        a || (a = function() {
        });
        var A = e.EVENTS.filter(function(k) {
          return k !== "error" && k !== "end";
        });
        function l(k, _) {
          return new c(k, _);
        }
        function c(k, _) {
          if (!(this instanceof c))
            return new c(k, _);
          a.apply(this), this._parser = new r(k, _), this.writable = !0, this.readable = !0;
          var q = this;
          this._parser.onend = function() {
            q.emit("end");
          }, this._parser.onerror = function(U) {
            q.emit("error", U), q._parser.error = null;
          }, this._decoder = null, A.forEach(function(U) {
            Object.defineProperty(q, "on" + U, {
              get: function() {
                return q._parser["on" + U];
              },
              set: function(J) {
                if (!J)
                  return q.removeAllListeners(U), q._parser["on" + U] = J, J;
                q.on(U, J);
              },
              enumerable: !0,
              configurable: !1
            });
          });
        }
        c.prototype = Object.create(a.prototype, {
          constructor: {
            value: c
          }
        }), c.prototype.write = function(k) {
          if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(k)) {
            if (!this._decoder) {
              var _ = hy.StringDecoder;
              this._decoder = new _("utf8");
            }
            k = this._decoder.write(k);
          }
          return this._parser.write(k.toString()), this.emit("data", k), !0;
        }, c.prototype.end = function(k) {
          return k && k.length && this.write(k), this._parser.end(), !0;
        }, c.prototype.on = function(k, _) {
          var q = this;
          return !q._parser["on" + k] && A.indexOf(k) !== -1 && (q._parser["on" + k] = function() {
            var U = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            U.splice(0, 0, k), q.emit.apply(q, U);
          }), a.prototype.on.call(q, k, _);
        };
        var u = "[CDATA[", d = "DOCTYPE", h = "http://www.w3.org/XML/1998/namespace", g = "http://www.w3.org/2000/xmlns/", f = { xml: h, xmlns: g }, p = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, m = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, E = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        function C(k) {
          return k === " " || k === `
` || k === "\r" || k === "	";
        }
        function w(k) {
          return k === '"' || k === "'";
        }
        function M(k) {
          return k === ">" || C(k);
        }
        function I(k, _) {
          return k.test(_);
        }
        function b(k, _) {
          return !I(k, _);
        }
        var B = 0;
        e.STATE = {
          BEGIN: B++,
          // leading byte order mark or whitespace
          BEGIN_WHITESPACE: B++,
          // leading whitespace
          TEXT: B++,
          // general stuff
          TEXT_ENTITY: B++,
          // &amp and such.
          OPEN_WAKA: B++,
          // <
          SGML_DECL: B++,
          // <!BLARG
          SGML_DECL_QUOTED: B++,
          // <!BLARG foo "bar
          DOCTYPE: B++,
          // <!DOCTYPE
          DOCTYPE_QUOTED: B++,
          // <!DOCTYPE "//blah
          DOCTYPE_DTD: B++,
          // <!DOCTYPE "//blah" [ ...
          DOCTYPE_DTD_QUOTED: B++,
          // <!DOCTYPE "//blah" [ "foo
          COMMENT_STARTING: B++,
          // <!-
          COMMENT: B++,
          // <!--
          COMMENT_ENDING: B++,
          // <!-- blah -
          COMMENT_ENDED: B++,
          // <!-- blah --
          CDATA: B++,
          // <![CDATA[ something
          CDATA_ENDING: B++,
          // ]
          CDATA_ENDING_2: B++,
          // ]]
          PROC_INST: B++,
          // <?hi
          PROC_INST_BODY: B++,
          // <?hi there
          PROC_INST_ENDING: B++,
          // <?hi "there" ?
          OPEN_TAG: B++,
          // <strong
          OPEN_TAG_SLASH: B++,
          // <strong /
          ATTRIB: B++,
          // <a
          ATTRIB_NAME: B++,
          // <a foo
          ATTRIB_NAME_SAW_WHITE: B++,
          // <a foo _
          ATTRIB_VALUE: B++,
          // <a foo=
          ATTRIB_VALUE_QUOTED: B++,
          // <a foo="bar
          ATTRIB_VALUE_CLOSED: B++,
          // <a foo="bar"
          ATTRIB_VALUE_UNQUOTED: B++,
          // <a foo=bar
          ATTRIB_VALUE_ENTITY_Q: B++,
          // <foo bar="&quot;"
          ATTRIB_VALUE_ENTITY_U: B++,
          // <foo bar=&quot
          CLOSE_TAG: B++,
          // </a
          CLOSE_TAG_SAW_WHITE: B++,
          // </a   >
          SCRIPT: B++,
          // <script> ...
          SCRIPT_ENDING: B++
          // <script> ... <
        }, e.XML_ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'"
        }, e.ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'",
          AElig: 198,
          Aacute: 193,
          Acirc: 194,
          Agrave: 192,
          Aring: 197,
          Atilde: 195,
          Auml: 196,
          Ccedil: 199,
          ETH: 208,
          Eacute: 201,
          Ecirc: 202,
          Egrave: 200,
          Euml: 203,
          Iacute: 205,
          Icirc: 206,
          Igrave: 204,
          Iuml: 207,
          Ntilde: 209,
          Oacute: 211,
          Ocirc: 212,
          Ograve: 210,
          Oslash: 216,
          Otilde: 213,
          Ouml: 214,
          THORN: 222,
          Uacute: 218,
          Ucirc: 219,
          Ugrave: 217,
          Uuml: 220,
          Yacute: 221,
          aacute: 225,
          acirc: 226,
          aelig: 230,
          agrave: 224,
          aring: 229,
          atilde: 227,
          auml: 228,
          ccedil: 231,
          eacute: 233,
          ecirc: 234,
          egrave: 232,
          eth: 240,
          euml: 235,
          iacute: 237,
          icirc: 238,
          igrave: 236,
          iuml: 239,
          ntilde: 241,
          oacute: 243,
          ocirc: 244,
          ograve: 242,
          oslash: 248,
          otilde: 245,
          ouml: 246,
          szlig: 223,
          thorn: 254,
          uacute: 250,
          ucirc: 251,
          ugrave: 249,
          uuml: 252,
          yacute: 253,
          yuml: 255,
          copy: 169,
          reg: 174,
          nbsp: 160,
          iexcl: 161,
          cent: 162,
          pound: 163,
          curren: 164,
          yen: 165,
          brvbar: 166,
          sect: 167,
          uml: 168,
          ordf: 170,
          laquo: 171,
          not: 172,
          shy: 173,
          macr: 175,
          deg: 176,
          plusmn: 177,
          sup1: 185,
          sup2: 178,
          sup3: 179,
          acute: 180,
          micro: 181,
          para: 182,
          middot: 183,
          cedil: 184,
          ordm: 186,
          raquo: 187,
          frac14: 188,
          frac12: 189,
          frac34: 190,
          iquest: 191,
          times: 215,
          divide: 247,
          OElig: 338,
          oelig: 339,
          Scaron: 352,
          scaron: 353,
          Yuml: 376,
          fnof: 402,
          circ: 710,
          tilde: 732,
          Alpha: 913,
          Beta: 914,
          Gamma: 915,
          Delta: 916,
          Epsilon: 917,
          Zeta: 918,
          Eta: 919,
          Theta: 920,
          Iota: 921,
          Kappa: 922,
          Lambda: 923,
          Mu: 924,
          Nu: 925,
          Xi: 926,
          Omicron: 927,
          Pi: 928,
          Rho: 929,
          Sigma: 931,
          Tau: 932,
          Upsilon: 933,
          Phi: 934,
          Chi: 935,
          Psi: 936,
          Omega: 937,
          alpha: 945,
          beta: 946,
          gamma: 947,
          delta: 948,
          epsilon: 949,
          zeta: 950,
          eta: 951,
          theta: 952,
          iota: 953,
          kappa: 954,
          lambda: 955,
          mu: 956,
          nu: 957,
          xi: 958,
          omicron: 959,
          pi: 960,
          rho: 961,
          sigmaf: 962,
          sigma: 963,
          tau: 964,
          upsilon: 965,
          phi: 966,
          chi: 967,
          psi: 968,
          omega: 969,
          thetasym: 977,
          upsih: 978,
          piv: 982,
          ensp: 8194,
          emsp: 8195,
          thinsp: 8201,
          zwnj: 8204,
          zwj: 8205,
          lrm: 8206,
          rlm: 8207,
          ndash: 8211,
          mdash: 8212,
          lsquo: 8216,
          rsquo: 8217,
          sbquo: 8218,
          ldquo: 8220,
          rdquo: 8221,
          bdquo: 8222,
          dagger: 8224,
          Dagger: 8225,
          bull: 8226,
          hellip: 8230,
          permil: 8240,
          prime: 8242,
          Prime: 8243,
          lsaquo: 8249,
          rsaquo: 8250,
          oline: 8254,
          frasl: 8260,
          euro: 8364,
          image: 8465,
          weierp: 8472,
          real: 8476,
          trade: 8482,
          alefsym: 8501,
          larr: 8592,
          uarr: 8593,
          rarr: 8594,
          darr: 8595,
          harr: 8596,
          crarr: 8629,
          lArr: 8656,
          uArr: 8657,
          rArr: 8658,
          dArr: 8659,
          hArr: 8660,
          forall: 8704,
          part: 8706,
          exist: 8707,
          empty: 8709,
          nabla: 8711,
          isin: 8712,
          notin: 8713,
          ni: 8715,
          prod: 8719,
          sum: 8721,
          minus: 8722,
          lowast: 8727,
          radic: 8730,
          prop: 8733,
          infin: 8734,
          ang: 8736,
          and: 8743,
          or: 8744,
          cap: 8745,
          cup: 8746,
          int: 8747,
          there4: 8756,
          sim: 8764,
          cong: 8773,
          asymp: 8776,
          ne: 8800,
          equiv: 8801,
          le: 8804,
          ge: 8805,
          sub: 8834,
          sup: 8835,
          nsub: 8836,
          sube: 8838,
          supe: 8839,
          oplus: 8853,
          otimes: 8855,
          perp: 8869,
          sdot: 8901,
          lceil: 8968,
          rceil: 8969,
          lfloor: 8970,
          rfloor: 8971,
          lang: 9001,
          rang: 9002,
          loz: 9674,
          spades: 9824,
          clubs: 9827,
          hearts: 9829,
          diams: 9830
        }, Object.keys(e.ENTITIES).forEach(function(k) {
          var _ = e.ENTITIES[k], q = typeof _ == "number" ? String.fromCharCode(_) : _;
          e.ENTITIES[k] = q;
        });
        for (var x in e.STATE)
          e.STATE[e.STATE[x]] = x;
        B = e.STATE;
        function Q(k, _, q) {
          k[_] && k[_](q);
        }
        function v(k, _, q) {
          k.textNode && T(k), Q(k, _, q);
        }
        function T(k) {
          k.textNode = S(k.opt, k.textNode), k.textNode && Q(k, "ontext", k.textNode), k.textNode = "";
        }
        function S(k, _) {
          return k.trim && (_ = _.trim()), k.normalize && (_ = _.replace(/\s+/g, " ")), _;
        }
        function D(k, _) {
          return T(k), k.trackPosition && (_ += `
Line: ` + k.line + `
Column: ` + k.column + `
Char: ` + k.c), _ = new Error(_), k.error = _, Q(k, "onerror", _), k;
        }
        function F(k) {
          return k.sawRoot && !k.closedRoot && R(k, "Unclosed root tag"), k.state !== B.BEGIN && k.state !== B.BEGIN_WHITESPACE && k.state !== B.TEXT && D(k, "Unexpected end"), T(k), k.c = "", k.closed = !0, Q(k, "onend"), r.call(k, k.strict, k.opt), k;
        }
        function R(k, _) {
          if (typeof k != "object" || !(k instanceof r))
            throw new Error("bad call to strictFail");
          k.strict && D(k, _);
        }
        function Y(k) {
          k.strict || (k.tagName = k.tagName[k.looseCase]());
          var _ = k.tags[k.tags.length - 1] || k, q = k.tag = { name: k.tagName, attributes: {} };
          k.opt.xmlns && (q.ns = _.ns), k.attribList.length = 0, v(k, "onopentagstart", q);
        }
        function L(k, _) {
          var q = k.indexOf(":"), U = q < 0 ? ["", k] : k.split(":"), J = U[0], ae = U[1];
          return _ && k === "xmlns" && (J = "xmlns", ae = ""), { prefix: J, local: ae };
        }
        function N(k) {
          if (k.strict || (k.attribName = k.attribName[k.looseCase]()), k.attribList.indexOf(k.attribName) !== -1 || k.tag.attributes.hasOwnProperty(k.attribName)) {
            k.attribName = k.attribValue = "";
            return;
          }
          if (k.opt.xmlns) {
            var _ = L(k.attribName, !0), q = _.prefix, U = _.local;
            if (q === "xmlns")
              if (U === "xml" && k.attribValue !== h)
                R(
                  k,
                  "xml: prefix must be bound to " + h + `
Actual: ` + k.attribValue
                );
              else if (U === "xmlns" && k.attribValue !== g)
                R(
                  k,
                  "xmlns: prefix must be bound to " + g + `
Actual: ` + k.attribValue
                );
              else {
                var J = k.tag, ae = k.tags[k.tags.length - 1] || k;
                J.ns === ae.ns && (J.ns = Object.create(ae.ns)), J.ns[U] = k.attribValue;
              }
            k.attribList.push([k.attribName, k.attribValue]);
          } else
            k.tag.attributes[k.attribName] = k.attribValue, v(k, "onattribute", {
              name: k.attribName,
              value: k.attribValue
            });
          k.attribName = k.attribValue = "";
        }
        function H(k, _) {
          if (k.opt.xmlns) {
            var q = k.tag, U = L(k.tagName);
            q.prefix = U.prefix, q.local = U.local, q.uri = q.ns[U.prefix] || "", q.prefix && !q.uri && (R(k, "Unbound namespace prefix: " + JSON.stringify(k.tagName)), q.uri = U.prefix);
            var J = k.tags[k.tags.length - 1] || k;
            q.ns && J.ns !== q.ns && Object.keys(q.ns).forEach(function(jt) {
              v(k, "onopennamespace", {
                prefix: jt,
                uri: q.ns[jt]
              });
            });
            for (var ae = 0, $ = k.attribList.length; ae < $; ae++) {
              var Ce = k.attribList[ae], Re = Ce[0], Oe = Ce[1], K = L(Re, !0), Ae = K.prefix, ut = K.local, Me = Ae === "" ? "" : q.ns[Ae] || "", Fe = {
                name: Re,
                value: Oe,
                prefix: Ae,
                local: ut,
                uri: Me
              };
              Ae && Ae !== "xmlns" && !Me && (R(k, "Unbound namespace prefix: " + JSON.stringify(Ae)), Fe.uri = Ae), k.tag.attributes[Re] = Fe, v(k, "onattribute", Fe);
            }
            k.attribList.length = 0;
          }
          k.tag.isSelfClosing = !!_, k.sawRoot = !0, k.tags.push(k.tag), v(k, "onopentag", k.tag), _ || (!k.noscript && k.tagName.toLowerCase() === "script" ? k.state = B.SCRIPT : k.state = B.TEXT, k.tag = null, k.tagName = ""), k.attribName = k.attribValue = "", k.attribList.length = 0;
        }
        function P(k) {
          if (!k.tagName) {
            R(k, "Weird empty close tag."), k.textNode += "</>", k.state = B.TEXT;
            return;
          }
          if (k.script) {
            if (k.tagName !== "script") {
              k.script += "</" + k.tagName + ">", k.tagName = "", k.state = B.SCRIPT;
              return;
            }
            v(k, "onscript", k.script), k.script = "";
          }
          var _ = k.tags.length, q = k.tagName;
          k.strict || (q = q[k.looseCase]());
          for (var U = q; _--; ) {
            var J = k.tags[_];
            if (J.name !== U)
              R(k, "Unexpected close tag");
            else
              break;
          }
          if (_ < 0) {
            R(k, "Unmatched closing tag: " + k.tagName), k.textNode += "</" + k.tagName + ">", k.state = B.TEXT;
            return;
          }
          k.tagName = q;
          for (var ae = k.tags.length; ae-- > _; ) {
            var $ = k.tag = k.tags.pop();
            k.tagName = k.tag.name, v(k, "onclosetag", k.tagName);
            var Ce = {};
            for (var Re in $.ns)
              Ce[Re] = $.ns[Re];
            var Oe = k.tags[k.tags.length - 1] || k;
            k.opt.xmlns && $.ns !== Oe.ns && Object.keys($.ns).forEach(function(K) {
              var Ae = $.ns[K];
              v(k, "onclosenamespace", { prefix: K, uri: Ae });
            });
          }
          _ === 0 && (k.closedRoot = !0), k.tagName = k.attribValue = k.attribName = "", k.attribList.length = 0, k.state = B.TEXT;
        }
        function ie(k) {
          var _ = k.entity, q = _.toLowerCase(), U, J = "";
          return k.ENTITIES[_] ? k.ENTITIES[_] : k.ENTITIES[q] ? k.ENTITIES[q] : (_ = q, _.charAt(0) === "#" && (_.charAt(1) === "x" ? (_ = _.slice(2), U = parseInt(_, 16), J = U.toString(16)) : (_ = _.slice(1), U = parseInt(_, 10), J = U.toString(10))), _ = _.replace(/^0+/, ""), isNaN(U) || J.toLowerCase() !== _ ? (R(k, "Invalid character entity"), "&" + k.entity + ";") : String.fromCodePoint(U));
        }
        function V(k, _) {
          _ === "<" ? (k.state = B.OPEN_WAKA, k.startTagPosition = k.position) : C(_) || (R(k, "Non-whitespace before first tag."), k.textNode = _, k.state = B.TEXT);
        }
        function Z(k, _) {
          var q = "";
          return _ < k.length && (q = k.charAt(_)), q;
        }
        function se(k) {
          var _ = this;
          if (this.error)
            throw this.error;
          if (_.closed)
            return D(
              _,
              "Cannot write after close. Assign an onready handler."
            );
          if (k === null)
            return F(_);
          typeof k == "object" && (k = k.toString());
          for (var q = 0, U = ""; U = Z(k, q++), _.c = U, !!U; )
            switch (_.trackPosition && (_.position++, U === `
` ? (_.line++, _.column = 0) : _.column++), _.state) {
              case B.BEGIN:
                if (_.state = B.BEGIN_WHITESPACE, U === "\uFEFF")
                  continue;
                V(_, U);
                continue;
              case B.BEGIN_WHITESPACE:
                V(_, U);
                continue;
              case B.TEXT:
                if (_.sawRoot && !_.closedRoot) {
                  for (var J = q - 1; U && U !== "<" && U !== "&"; )
                    U = Z(k, q++), U && _.trackPosition && (_.position++, U === `
` ? (_.line++, _.column = 0) : _.column++);
                  _.textNode += k.substring(J, q - 1);
                }
                U === "<" && !(_.sawRoot && _.closedRoot && !_.strict) ? (_.state = B.OPEN_WAKA, _.startTagPosition = _.position) : (!C(U) && (!_.sawRoot || _.closedRoot) && R(_, "Text data outside of root node."), U === "&" ? _.state = B.TEXT_ENTITY : _.textNode += U);
                continue;
              case B.SCRIPT:
                U === "<" ? _.state = B.SCRIPT_ENDING : _.script += U;
                continue;
              case B.SCRIPT_ENDING:
                U === "/" ? _.state = B.CLOSE_TAG : (_.script += "<" + U, _.state = B.SCRIPT);
                continue;
              case B.OPEN_WAKA:
                if (U === "!")
                  _.state = B.SGML_DECL, _.sgmlDecl = "";
                else if (!C(U)) if (I(p, U))
                  _.state = B.OPEN_TAG, _.tagName = U;
                else if (U === "/")
                  _.state = B.CLOSE_TAG, _.tagName = "";
                else if (U === "?")
                  _.state = B.PROC_INST, _.procInstName = _.procInstBody = "";
                else {
                  if (R(_, "Unencoded <"), _.startTagPosition + 1 < _.position) {
                    var ae = _.position - _.startTagPosition;
                    U = new Array(ae).join(" ") + U;
                  }
                  _.textNode += "<" + U, _.state = B.TEXT;
                }
                continue;
              case B.SGML_DECL:
                if (_.sgmlDecl + U === "--") {
                  _.state = B.COMMENT, _.comment = "", _.sgmlDecl = "";
                  continue;
                }
                _.doctype && _.doctype !== !0 && _.sgmlDecl ? (_.state = B.DOCTYPE_DTD, _.doctype += "<!" + _.sgmlDecl + U, _.sgmlDecl = "") : (_.sgmlDecl + U).toUpperCase() === u ? (v(_, "onopencdata"), _.state = B.CDATA, _.sgmlDecl = "", _.cdata = "") : (_.sgmlDecl + U).toUpperCase() === d ? (_.state = B.DOCTYPE, (_.doctype || _.sawRoot) && R(
                  _,
                  "Inappropriately located doctype declaration"
                ), _.doctype = "", _.sgmlDecl = "") : U === ">" ? (v(_, "onsgmldeclaration", _.sgmlDecl), _.sgmlDecl = "", _.state = B.TEXT) : (w(U) && (_.state = B.SGML_DECL_QUOTED), _.sgmlDecl += U);
                continue;
              case B.SGML_DECL_QUOTED:
                U === _.q && (_.state = B.SGML_DECL, _.q = ""), _.sgmlDecl += U;
                continue;
              case B.DOCTYPE:
                U === ">" ? (_.state = B.TEXT, v(_, "ondoctype", _.doctype), _.doctype = !0) : (_.doctype += U, U === "[" ? _.state = B.DOCTYPE_DTD : w(U) && (_.state = B.DOCTYPE_QUOTED, _.q = U));
                continue;
              case B.DOCTYPE_QUOTED:
                _.doctype += U, U === _.q && (_.q = "", _.state = B.DOCTYPE);
                continue;
              case B.DOCTYPE_DTD:
                U === "]" ? (_.doctype += U, _.state = B.DOCTYPE) : U === "<" ? (_.state = B.OPEN_WAKA, _.startTagPosition = _.position) : w(U) ? (_.doctype += U, _.state = B.DOCTYPE_DTD_QUOTED, _.q = U) : _.doctype += U;
                continue;
              case B.DOCTYPE_DTD_QUOTED:
                _.doctype += U, U === _.q && (_.state = B.DOCTYPE_DTD, _.q = "");
                continue;
              case B.COMMENT:
                U === "-" ? _.state = B.COMMENT_ENDING : _.comment += U;
                continue;
              case B.COMMENT_ENDING:
                U === "-" ? (_.state = B.COMMENT_ENDED, _.comment = S(_.opt, _.comment), _.comment && v(_, "oncomment", _.comment), _.comment = "") : (_.comment += "-" + U, _.state = B.COMMENT);
                continue;
              case B.COMMENT_ENDED:
                U !== ">" ? (R(_, "Malformed comment"), _.comment += "--" + U, _.state = B.COMMENT) : _.doctype && _.doctype !== !0 ? _.state = B.DOCTYPE_DTD : _.state = B.TEXT;
                continue;
              case B.CDATA:
                U === "]" ? _.state = B.CDATA_ENDING : _.cdata += U;
                continue;
              case B.CDATA_ENDING:
                U === "]" ? _.state = B.CDATA_ENDING_2 : (_.cdata += "]" + U, _.state = B.CDATA);
                continue;
              case B.CDATA_ENDING_2:
                U === ">" ? (_.cdata && v(_, "oncdata", _.cdata), v(_, "onclosecdata"), _.cdata = "", _.state = B.TEXT) : U === "]" ? _.cdata += "]" : (_.cdata += "]]" + U, _.state = B.CDATA);
                continue;
              case B.PROC_INST:
                U === "?" ? _.state = B.PROC_INST_ENDING : C(U) ? _.state = B.PROC_INST_BODY : _.procInstName += U;
                continue;
              case B.PROC_INST_BODY:
                if (!_.procInstBody && C(U))
                  continue;
                U === "?" ? _.state = B.PROC_INST_ENDING : _.procInstBody += U;
                continue;
              case B.PROC_INST_ENDING:
                U === ">" ? (v(_, "onprocessinginstruction", {
                  name: _.procInstName,
                  body: _.procInstBody
                }), _.procInstName = _.procInstBody = "", _.state = B.TEXT) : (_.procInstBody += "?" + U, _.state = B.PROC_INST_BODY);
                continue;
              case B.OPEN_TAG:
                I(m, U) ? _.tagName += U : (Y(_), U === ">" ? H(_) : U === "/" ? _.state = B.OPEN_TAG_SLASH : (C(U) || R(_, "Invalid character in tag name"), _.state = B.ATTRIB));
                continue;
              case B.OPEN_TAG_SLASH:
                U === ">" ? (H(_, !0), P(_)) : (R(_, "Forward-slash in opening tag not followed by >"), _.state = B.ATTRIB);
                continue;
              case B.ATTRIB:
                if (C(U))
                  continue;
                U === ">" ? H(_) : U === "/" ? _.state = B.OPEN_TAG_SLASH : I(p, U) ? (_.attribName = U, _.attribValue = "", _.state = B.ATTRIB_NAME) : R(_, "Invalid attribute name");
                continue;
              case B.ATTRIB_NAME:
                U === "=" ? _.state = B.ATTRIB_VALUE : U === ">" ? (R(_, "Attribute without value"), _.attribValue = _.attribName, N(_), H(_)) : C(U) ? _.state = B.ATTRIB_NAME_SAW_WHITE : I(m, U) ? _.attribName += U : R(_, "Invalid attribute name");
                continue;
              case B.ATTRIB_NAME_SAW_WHITE:
                if (U === "=")
                  _.state = B.ATTRIB_VALUE;
                else {
                  if (C(U))
                    continue;
                  R(_, "Attribute without value"), _.tag.attributes[_.attribName] = "", _.attribValue = "", v(_, "onattribute", {
                    name: _.attribName,
                    value: ""
                  }), _.attribName = "", U === ">" ? H(_) : I(p, U) ? (_.attribName = U, _.state = B.ATTRIB_NAME) : (R(_, "Invalid attribute name"), _.state = B.ATTRIB);
                }
                continue;
              case B.ATTRIB_VALUE:
                if (C(U))
                  continue;
                w(U) ? (_.q = U, _.state = B.ATTRIB_VALUE_QUOTED) : (_.opt.unquotedAttributeValues || D(_, "Unquoted attribute value"), _.state = B.ATTRIB_VALUE_UNQUOTED, _.attribValue = U);
                continue;
              case B.ATTRIB_VALUE_QUOTED:
                if (U !== _.q) {
                  U === "&" ? _.state = B.ATTRIB_VALUE_ENTITY_Q : _.attribValue += U;
                  continue;
                }
                N(_), _.q = "", _.state = B.ATTRIB_VALUE_CLOSED;
                continue;
              case B.ATTRIB_VALUE_CLOSED:
                C(U) ? _.state = B.ATTRIB : U === ">" ? H(_) : U === "/" ? _.state = B.OPEN_TAG_SLASH : I(p, U) ? (R(_, "No whitespace between attributes"), _.attribName = U, _.attribValue = "", _.state = B.ATTRIB_NAME) : R(_, "Invalid attribute name");
                continue;
              case B.ATTRIB_VALUE_UNQUOTED:
                if (!M(U)) {
                  U === "&" ? _.state = B.ATTRIB_VALUE_ENTITY_U : _.attribValue += U;
                  continue;
                }
                N(_), U === ">" ? H(_) : _.state = B.ATTRIB;
                continue;
              case B.CLOSE_TAG:
                if (_.tagName)
                  U === ">" ? P(_) : I(m, U) ? _.tagName += U : _.script ? (_.script += "</" + _.tagName, _.tagName = "", _.state = B.SCRIPT) : (C(U) || R(_, "Invalid tagname in closing tag"), _.state = B.CLOSE_TAG_SAW_WHITE);
                else {
                  if (C(U))
                    continue;
                  b(p, U) ? _.script ? (_.script += "</" + U, _.state = B.SCRIPT) : R(_, "Invalid tagname in closing tag.") : _.tagName = U;
                }
                continue;
              case B.CLOSE_TAG_SAW_WHITE:
                if (C(U))
                  continue;
                U === ">" ? P(_) : R(_, "Invalid characters in closing tag");
                continue;
              case B.TEXT_ENTITY:
              case B.ATTRIB_VALUE_ENTITY_Q:
              case B.ATTRIB_VALUE_ENTITY_U:
                var $, Ce;
                switch (_.state) {
                  case B.TEXT_ENTITY:
                    $ = B.TEXT, Ce = "textNode";
                    break;
                  case B.ATTRIB_VALUE_ENTITY_Q:
                    $ = B.ATTRIB_VALUE_QUOTED, Ce = "attribValue";
                    break;
                  case B.ATTRIB_VALUE_ENTITY_U:
                    $ = B.ATTRIB_VALUE_UNQUOTED, Ce = "attribValue";
                    break;
                }
                if (U === ";") {
                  var Re = ie(_);
                  _.opt.unparsedEntities && !Object.values(e.XML_ENTITIES).includes(Re) ? (_.entity = "", _.state = $, _.write(Re)) : (_[Ce] += Re, _.entity = "", _.state = $);
                } else I(_.entity.length ? y : E, U) ? _.entity += U : (R(_, "Invalid character in entity name"), _[Ce] += "&" + _.entity + U, _.entity = "", _.state = $);
                continue;
              default:
                throw new Error(_, "Unknown state: " + _.state);
            }
          return _.position >= _.bufferCheckPosition && n(_), _;
        }
        /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
        String.fromCodePoint || function() {
          var k = String.fromCharCode, _ = Math.floor, q = function() {
            var U = 16384, J = [], ae, $, Ce = -1, Re = arguments.length;
            if (!Re)
              return "";
            for (var Oe = ""; ++Ce < Re; ) {
              var K = Number(arguments[Ce]);
              if (!isFinite(K) || // `NaN`, `+Infinity`, or `-Infinity`
              K < 0 || // not a valid Unicode code point
              K > 1114111 || // not a valid Unicode code point
              _(K) !== K)
                throw RangeError("Invalid code point: " + K);
              K <= 65535 ? J.push(K) : (K -= 65536, ae = (K >> 10) + 55296, $ = K % 1024 + 56320, J.push(ae, $)), (Ce + 1 === Re || J.length > U) && (Oe += k.apply(null, J), J.length = 0);
            }
            return Oe;
          };
          Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
            value: q,
            configurable: !0,
            writable: !0
          }) : String.fromCodePoint = q;
        }();
      })(t);
    }(MC)), MC;
  }
  var Gp = {}, c2;
  function SBe() {
    return c2 || (c2 = 1, (function() {
      Gp.stripBOM = function(t) {
        return t[0] === "\uFEFF" ? t.substring(1) : t;
      };
    }).call(Gp)), Gp;
  }
  var eA = {}, u2;
  function P4() {
    return u2 || (u2 = 1, (function() {
      var t;
      t = new RegExp(/(?!xmlns)^.*:/), eA.normalize = function(e) {
        return e.toLowerCase();
      }, eA.firstCharLowerCase = function(e) {
        return e.charAt(0).toLowerCase() + e.slice(1);
      }, eA.stripPrefix = function(e) {
        return e.replace(t, "");
      }, eA.parseNumbers = function(e) {
        return isNaN(e) || (e = e % 1 === 0 ? parseInt(e, 10) : parseFloat(e)), e;
      }, eA.parseBooleans = function(e) {
        return /^(?:true|false)$/i.test(e) && (e = e.toLowerCase() === "true"), e;
      };
    }).call(eA)), eA;
  }
  var d2;
  function DBe() {
    return d2 || (d2 = 1, function(t) {
      (function() {
        var e, i, r, n, s, o, a, A, l, c = function(h, g) {
          return function() {
            return h.apply(g, arguments);
          };
        }, u = function(h, g) {
          for (var f in g)
            d.call(g, f) && (h[f] = g[f]);
          function p() {
            this.constructor = h;
          }
          return p.prototype = g.prototype, h.prototype = new p(), h.__super__ = g.prototype, h;
        }, d = {}.hasOwnProperty;
        A = FBe(), n = hy, e = SBe(), a = P4(), l = hy.setImmediate, i = k1().defaults, s = function(h) {
          return typeof h == "object" && h != null && Object.keys(h).length === 0;
        }, o = function(h, g, f) {
          var p, m, E;
          for (p = 0, m = h.length; p < m; p++)
            E = h[p], g = E(g, f);
          return g;
        }, r = function(h, g, f) {
          var p;
          return p = /* @__PURE__ */ Object.create(null), p.value = f, p.writable = !0, p.enumerable = !0, p.configurable = !0, Object.defineProperty(h, g, p);
        }, t.Parser = function(h) {
          u(g, h);
          function g(f) {
            this.parseStringPromise = c(this.parseStringPromise, this), this.parseString = c(this.parseString, this), this.reset = c(this.reset, this), this.assignOrPush = c(this.assignOrPush, this), this.processAsync = c(this.processAsync, this);
            var p, m, E;
            if (!(this instanceof t.Parser))
              return new t.Parser(f);
            this.options = {}, m = i["0.2"];
            for (p in m)
              d.call(m, p) && (E = m[p], this.options[p] = E);
            for (p in f)
              d.call(f, p) && (E = f[p], this.options[p] = E);
            this.options.xmlns && (this.options.xmlnskey = this.options.attrkey + "ns"), this.options.normalizeTags && (this.options.tagNameProcessors || (this.options.tagNameProcessors = []), this.options.tagNameProcessors.unshift(a.normalize)), this.reset();
          }
          return g.prototype.processAsync = function() {
            var f, p;
            try {
              return this.remaining.length <= this.options.chunkSize ? (f = this.remaining, this.remaining = "", this.saxParser = this.saxParser.write(f), this.saxParser.close()) : (f = this.remaining.substr(0, this.options.chunkSize), this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length), this.saxParser = this.saxParser.write(f), l(this.processAsync));
            } catch (m) {
              if (p = m, !this.saxParser.errThrown)
                return this.saxParser.errThrown = !0, this.emit(p);
            }
          }, g.prototype.assignOrPush = function(f, p, m) {
            return p in f ? (f[p] instanceof Array || r(f, p, [f[p]]), f[p].push(m)) : this.options.explicitArray ? r(f, p, [m]) : r(f, p, m);
          }, g.prototype.reset = function() {
            var f, p, m, E;
            return this.removeAllListeners(), this.saxParser = A.parser(this.options.strict, {
              trim: !1,
              normalize: !1,
              xmlns: this.options.xmlns
            }), this.saxParser.errThrown = !1, this.saxParser.onerror = /* @__PURE__ */ function(y) {
              return function(C) {
                if (y.saxParser.resume(), !y.saxParser.errThrown)
                  return y.saxParser.errThrown = !0, y.emit("error", C);
              };
            }(this), this.saxParser.onend = /* @__PURE__ */ function(y) {
              return function() {
                if (!y.saxParser.ended)
                  return y.saxParser.ended = !0, y.emit("end", y.resultObject);
              };
            }(this), this.saxParser.ended = !1, this.EXPLICIT_CHARKEY = this.options.explicitCharkey, this.resultObject = null, E = [], f = this.options.attrkey, p = this.options.charkey, this.saxParser.onopentag = /* @__PURE__ */ function(y) {
              return function(C) {
                var w, M, I, b, B;
                if (I = {}, I[p] = "", !y.options.ignoreAttrs) {
                  B = C.attributes;
                  for (w in B)
                    d.call(B, w) && (!(f in I) && !y.options.mergeAttrs && (I[f] = {}), M = y.options.attrValueProcessors ? o(y.options.attrValueProcessors, C.attributes[w], w) : C.attributes[w], b = y.options.attrNameProcessors ? o(y.options.attrNameProcessors, w) : w, y.options.mergeAttrs ? y.assignOrPush(I, b, M) : r(I[f], b, M));
                }
                return I["#name"] = y.options.tagNameProcessors ? o(y.options.tagNameProcessors, C.name) : C.name, y.options.xmlns && (I[y.options.xmlnskey] = {
                  uri: C.uri,
                  local: C.local
                }), E.push(I);
              };
            }(this), this.saxParser.onclosetag = /* @__PURE__ */ function(y) {
              return function() {
                var C, w, M, I, b, B, x, Q, v, T;
                if (B = E.pop(), b = B["#name"], (!y.options.explicitChildren || !y.options.preserveChildrenOrder) && delete B["#name"], B.cdata === !0 && (C = B.cdata, delete B.cdata), v = E[E.length - 1], B[p].match(/^\s*$/) && !C ? (w = B[p], delete B[p]) : (y.options.trim && (B[p] = B[p].trim()), y.options.normalize && (B[p] = B[p].replace(/\s{2,}/g, " ").trim()), B[p] = y.options.valueProcessors ? o(y.options.valueProcessors, B[p], b) : B[p], Object.keys(B).length === 1 && p in B && !y.EXPLICIT_CHARKEY && (B = B[p])), s(B) && (typeof y.options.emptyTag == "function" ? B = y.options.emptyTag() : B = y.options.emptyTag !== "" ? y.options.emptyTag : w), y.options.validator != null && (T = "/" + function() {
                  var S, D, F;
                  for (F = [], S = 0, D = E.length; S < D; S++)
                    I = E[S], F.push(I["#name"]);
                  return F;
                }().concat(b).join("/"), function() {
                  var S;
                  try {
                    return B = y.options.validator(T, v && v[b], B);
                  } catch (D) {
                    return S = D, y.emit("error", S);
                  }
                }()), y.options.explicitChildren && !y.options.mergeAttrs && typeof B == "object") {
                  if (!y.options.preserveChildrenOrder)
                    I = {}, y.options.attrkey in B && (I[y.options.attrkey] = B[y.options.attrkey], delete B[y.options.attrkey]), !y.options.charsAsChildren && y.options.charkey in B && (I[y.options.charkey] = B[y.options.charkey], delete B[y.options.charkey]), Object.getOwnPropertyNames(B).length > 0 && (I[y.options.childkey] = B), B = I;
                  else if (v) {
                    v[y.options.childkey] = v[y.options.childkey] || [], x = {};
                    for (M in B)
                      d.call(B, M) && r(x, M, B[M]);
                    v[y.options.childkey].push(x), delete B["#name"], Object.keys(B).length === 1 && p in B && !y.EXPLICIT_CHARKEY && (B = B[p]);
                  }
                }
                return E.length > 0 ? y.assignOrPush(v, b, B) : (y.options.explicitRoot && (Q = B, B = {}, r(B, b, Q)), y.resultObject = B, y.saxParser.ended = !0, y.emit("end", y.resultObject));
              };
            }(this), m = /* @__PURE__ */ function(y) {
              return function(C) {
                var w, M;
                if (M = E[E.length - 1], M)
                  return M[p] += C, y.options.explicitChildren && y.options.preserveChildrenOrder && y.options.charsAsChildren && (y.options.includeWhiteChars || C.replace(/\\n/g, "").trim() !== "") && (M[y.options.childkey] = M[y.options.childkey] || [], w = {
                    "#name": "__text__"
                  }, w[p] = C, y.options.normalize && (w[p] = w[p].replace(/\s{2,}/g, " ").trim()), M[y.options.childkey].push(w)), M;
              };
            }(this), this.saxParser.ontext = m, this.saxParser.oncdata = /* @__PURE__ */ function(y) {
              return function(C) {
                var w;
                if (w = m(C), w)
                  return w.cdata = !0;
              };
            }();
          }, g.prototype.parseString = function(f, p) {
            var m;
            p != null && typeof p == "function" && (this.on("end", function(E) {
              return this.reset(), p(null, E);
            }), this.on("error", function(E) {
              return this.reset(), p(E);
            }));
            try {
              return f = f.toString(), f.trim() === "" ? (this.emit("end", null), !0) : (f = e.stripBOM(f), this.options.async ? (this.remaining = f, l(this.processAsync), this.saxParser) : this.saxParser.write(f).close());
            } catch (E) {
              if (m = E, this.saxParser.errThrown || this.saxParser.ended) {
                if (this.saxParser.ended)
                  throw m;
              } else return this.emit("error", m), this.saxParser.errThrown = !0;
            }
          }, g.prototype.parseStringPromise = function(f) {
            return new Promise(/* @__PURE__ */ function(p) {
              return function(m, E) {
                return p.parseString(f, function(y, C) {
                  return y ? E(y) : m(C);
                });
              };
            }(this));
          }, g;
        }(n), t.parseString = function(h, g, f) {
          var p, m, E;
          return f != null ? (typeof f == "function" && (p = f), typeof g == "object" && (m = g)) : (typeof g == "function" && (p = g), m = {}), E = new t.Parser(m), E.parseString(h, p);
        }, t.parseStringPromise = function(h, g) {
          var f, p;
          return typeof g == "object" && (f = g), p = new t.Parser(f), p.parseStringPromise(h);
        };
      }).call(Op);
    }(Op)), Op;
  }
  var h2;
  function TBe() {
    return h2 || (h2 = 1, (function() {
      var t, e, i, r, n = function(o, a) {
        for (var A in a)
          s.call(a, A) && (o[A] = a[A]);
        function l() {
          this.constructor = o;
        }
        return l.prototype = a.prototype, o.prototype = new l(), o.__super__ = a.prototype, o;
      }, s = {}.hasOwnProperty;
      e = k1(), t = vBe(), i = DBe(), r = P4(), ho.defaults = e.defaults, ho.processors = r, ho.ValidationError = function(o) {
        n(a, o);
        function a(A) {
          this.message = A;
        }
        return a;
      }(Error), ho.Builder = t.Builder, ho.Parser = i.Parser, ho.parseString = i.parseString, ho.parseStringPromise = i.parseStringPromise;
    }).call(ho)), ho;
  }
  TBe();
  rn.showGeographicIdentifier;
  rn.gazetteerUrl;
  let RBe = 0;
  const _Be = {
    wms: Uae,
    wmts: HAe,
    wfs: Fue,
    geojson: Rce,
    vectortile: kge,
    oaf: Pge
  }, g2 = Ef.prototype.addLayer;
  function O4(t) {
    return t.getLayers ? t.getLayers().getArray().map((e) => O4(e)).flat(1) : [t];
  }
  function f2(t, e) {
    O4(t).forEach((r) => {
      var s, o, a, A, l;
      const n = (s = r.getSource) == null ? void 0 : s.call(r);
      n ? ((o = n.on) == null || o.call(n, "tileloaderror", e), (a = n.on) == null || a.call(n, "imageloaderror", e), (A = n.on) == null || A.call(n, "featuresloaderror", e), (l = n.on) == null || l.call(n, "error", e)) : console.error("Could not register error callback on layer:", r);
    });
  }
  function kBe(t, e) {
    var A, l;
    const i = (e == null ? void 0 : e.visibility) ?? ((A = e == null ? void 0 : e.layerParams) == null ? void 0 : A.visibility) ?? !0, r = (e == null ? void 0 : e.transparency) ?? ((l = e == null ? void 0 : e.layerParams) == null ? void 0 : l.transparency) ?? 0, n = { ...(e == null ? void 0 : e.layerParams) || {}, visibility: i, transparency: r }, s = typeof (e == null ? void 0 : e.errorCallback) == "function" ? e == null ? void 0 : e.errorCallback : console.error;
    let o, a;
    if (typeof t == "string") {
      const c = Fx.getLayerWhere({ id: t });
      return c ? (a = _Be[c.typ.toLowerCase()], a ? (o = a.createLayer(c, { layerParams: n }, { map: this }), o.setVisible(typeof i == "boolean" ? i : !0), o.setOpacity(typeof r == "number" ? (100 - r) / 100 : 1), f2(o, s), g2.call(this, o), o) : (console.error("Layer with id '" + t + "' has unknown type '" + c.typ + "'. No layer added to map."), null)) : (console.error("Layer with id '" + t + "' not found. No layer added to map."), null);
    }
    return f2(t, s), g2.call(this, t);
  }
  Ef.prototype.addLayer = kBe;
  function YBe(t = rn, { mapParams: e, callback: i, errorCallback: r } = {}) {
    var o, a;
    zye.registerProjections(t.namedProjections), Poe(t), t.gazetteerUrl;
    const n = Object.assign({}, { dragPan: !1, altShiftDragRotate: !1, pinchRotate: !1 }, (o = t.mapInteractions) == null ? void 0 : o.interactionModes), s = new Ef(Object.assign({
      target: t.target || rn.target,
      interactions: gL(n).extend([
        new dL({
          condition: function(A) {
            var l, c, u, d;
            return A.originalEvent.shiftKey ? !1 : !A.originalEvent.pointerType || A.originalEvent.pointerType === "mouse" || ((c = (l = t.mapInteractions) == null ? void 0 : l.interactionModes) == null ? void 0 : c.twoFingerPan) && this.getPointerCount() === 2 || !((d = (u = t.mapInteractions) == null ? void 0 : u.interactionModes) != null && d.twoFingerPan);
          }
        })
      ]),
      controls: [],
      view: Gge(t),
      keyboardEventTarget: (a = t.mapInteractions) != null && a.keyboardEventTarget ? document : !1
    }, e));
    return s.set("mapMode", "2D"), s.set("id", `map2D_${RBe++}`), Fx.initializeLayerList(t.layerConf, (A, l) => (Ooe(t).forEach((c) => {
      s.addLayer(c.id, { layerParams: c, errorCallback: r });
    }), typeof i == "function" ? i(A, l) : null)), s;
  }
  function NBe(t) {
    return $h() ? (KM(t), !0) : !1;
  }
  const G4 = typeof window < "u" && typeof document < "u";
  typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
  const UBe = Object.prototype.toString, LBe = (t) => UBe.call(t) === "[object Object]", oA = () => {
  }, zBe = /* @__PURE__ */ PBe();
  function PBe() {
    var t, e;
    return G4 && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
  }
  function OBe(t, e) {
    function i(...r) {
      return new Promise((n, s) => {
        Promise.resolve(t(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(n).catch(s);
      });
    }
    return i;
  }
  function GBe(t, e = {}) {
    let i, r, n = oA;
    const s = (A) => {
      clearTimeout(A), n(), n = oA;
    };
    let o;
    return (A) => {
      const l = zt(t), c = zt(e.maxWait);
      return i && s(i), l <= 0 || c !== void 0 && c <= 0 ? (r && (s(r), r = null), Promise.resolve(A())) : new Promise((u, d) => {
        n = e.rejectOnCancel ? d : u, o = A, c && !r && (r = setTimeout(() => {
          i && s(i), r = null, u(o());
        }, c)), i = setTimeout(() => {
          r && s(r), r = null, u(A());
        }, l);
      });
    };
  }
  function IC(t) {
    return Array.isArray(t) ? t : [t];
  }
  function jBe(t, e = 200, i = {}) {
    return OBe(
      GBe(e, i),
      t
    );
  }
  function HBe(t, e, i) {
    return ct(
      t,
      e,
      {
        ...i,
        immediate: !0
      }
    );
  }
  const j4 = G4 ? window : void 0;
  function Oi(t) {
    var e;
    const i = zt(t);
    return (e = i == null ? void 0 : i.$el) != null ? e : i;
  }
  function eu(...t) {
    const e = [], i = () => {
      e.forEach((a) => a()), e.length = 0;
    }, r = (a, A, l, c) => (a.addEventListener(A, l, c), () => a.removeEventListener(A, l, c)), n = O(() => {
      const a = IC(zt(t[0])).filter((A) => A != null);
      return a.every((A) => typeof A != "string") ? a : void 0;
    }), s = HBe(
      () => {
        var a, A;
        return [
          (A = (a = n.value) == null ? void 0 : a.map((l) => Oi(l))) != null ? A : [j4].filter((l) => l != null),
          IC(zt(n.value ? t[1] : t[0])),
          IC(j(n.value ? t[2] : t[1])),
          // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
          zt(n.value ? t[3] : t[2])
        ];
      },
      ([a, A, l, c]) => {
        if (i(), !(a != null && a.length) || !(A != null && A.length) || !(l != null && l.length))
          return;
        const u = LBe(c) ? { ...c } : c;
        e.push(
          ...a.flatMap(
            (d) => A.flatMap(
              (h) => l.map((g) => r(d, h, g, u))
            )
          )
        );
      },
      { flush: "post" }
    ), o = () => {
      s(), i();
    };
    return NBe(i), o;
  }
  let p2 = !1;
  function JBe(t, e, i = {}) {
    const { window: r = j4, ignore: n = [], capture: s = !0, detectIframe: o = !1, controls: a = !1 } = i;
    if (!r)
      return a ? { stop: oA, cancel: oA, trigger: oA } : oA;
    if (zBe && !p2) {
      p2 = !0;
      const p = { passive: !0 };
      Array.from(r.document.body.children).forEach((m) => eu(m, "click", oA, p)), eu(r.document.documentElement, "click", oA, p);
    }
    let A = !0;
    const l = (p) => zt(n).some((m) => {
      if (typeof m == "string")
        return Array.from(r.document.querySelectorAll(m)).some((E) => E === p.target || p.composedPath().includes(E));
      {
        const E = Oi(m);
        return E && (p.target === E || p.composedPath().includes(E));
      }
    });
    function c(p) {
      const m = zt(p);
      return m && m.$.subTree.shapeFlag === 16;
    }
    function u(p, m) {
      const E = zt(p), y = E.$.subTree && E.$.subTree.children;
      return y == null || !Array.isArray(y) ? !1 : y.some((C) => C.el === m.target || m.composedPath().includes(C.el));
    }
    const d = (p) => {
      const m = Oi(t);
      if (p.target != null && !(!(m instanceof Element) && c(t) && u(t, p)) && !(!m || m === p.target || p.composedPath().includes(m))) {
        if ("detail" in p && p.detail === 0 && (A = !l(p)), !A) {
          A = !0;
          return;
        }
        e(p);
      }
    };
    let h = !1;
    const g = [
      eu(r, "click", (p) => {
        h || (h = !0, setTimeout(() => {
          h = !1;
        }, 0), d(p));
      }, { passive: !0, capture: s }),
      eu(r, "pointerdown", (p) => {
        const m = Oi(t);
        A = !l(p) && !!(m && !p.composedPath().includes(m));
      }, { passive: !0 }),
      o && eu(r, "blur", (p) => {
        setTimeout(() => {
          var m;
          const E = Oi(t);
          ((m = r.document.activeElement) == null ? void 0 : m.tagName) === "IFRAME" && !(E != null && E.contains(r.document.activeElement)) && e(p);
        }, 0);
      }, { passive: !0 })
    ].filter(Boolean), f = () => g.forEach((p) => p());
    return a ? {
      stop: f,
      cancel: () => {
        A = !1;
      },
      trigger: (p) => {
        A = !0, d(p), A = !1;
      }
    } : f;
  }
  function VBe(t) {
    const e = Object.entries(t.layers).map(
      ([I, b]) => zoe(I, b)
    );
    function i(I) {
      return e.find((b) => b.key === I);
    }
    let r = {};
    function n() {
      r = YBe({
        extent: [264918, 5204271, 905687, 6122003],
        ...t.portalConfig,
        startCenter: t.startCenter,
        target: Oi(t.target),
        layerConf: t.layerConfig
      }), r.addLayer(t.backgroundLayerId), e.forEach((b) => r.addLayer(b.layer)), typeof t.onHover == "function" && r.on("pointermove", (b) => {
        typeof t.onHover == "function" && t.onHover(b.pixel);
      }), typeof t.mapMoveEnd == "function" && r.on("moveend", (b) => {
        typeof t.mapMoveEnd == "function" && t.mapMoveEnd(b.map);
      });
      const I = e.flatMap((b) => Object.values(b.interactions));
      I.forEach((b) => r.addInteraction(b)), m(...I);
    }
    er(() => n()), Fs(() => {
      d(), e.forEach((I) => {
        I.clear();
      });
    });
    function s(I) {
      const b = i(I).getFeatures();
      b.length && o(b);
    }
    function o(I) {
      let b = 0, B = 0, x = 0, Q = 0;
      I.forEach((T) => {
        var D;
        const S = (D = T.getGeometry()) == null ? void 0 : D.getExtent();
        S && (I.indexOf(T) == 0 ? (b = S[0], B = S[1], x = S[2], Q = S[3]) : (b = S[0] < b ? S[0] : b, B = S[1] < B ? S[1] : B, x = S[2] > x ? S[2] : x, Q = S[3] > Q ? S[3] : Q));
      });
      const v = [b, B, x, Q];
      v.includes(1 / 0) || v && r.getView() && r.getView().fit(v, { padding: [50, 50, 50, 50] });
    }
    function a() {
      return typeof r.getLayers != "function" ? [] : r.getLayers().getArray().map((I) => I.getProperties().id).filter((I) => I !== void 0);
    }
    function A(I) {
      if (typeof r.getLayers != "function") return;
      const b = [...r.getLayers().getArray()];
      r.getLayers().getArray().length && r.getLayers().getArray().splice(0, r.getLayers().getArray().length);
      const B = b[0], x = b.filter(
        (Q) => Q instanceof Bs
      );
      r.addLayer(B), I.forEach((Q) => Q.Layer.forEach((v) => r.addLayer(v.id))), x.forEach((Q) => r.addLayer(Q)), r.render();
    }
    function l(I) {
      r.getLayers().getArray().shift(), I.Layer.forEach((B) => r.addLayer(B.id));
      const b = r.getLayers().getArray().pop();
      return b ? (r.getLayers().getArray().splice(0, 0, b), r.render(), I.Titel) : "";
    }
    let c;
    function u(I, b) {
      c && d();
      const B = Oi(I);
      if (!B) throw new Error("Map: No container is given for the map overlay.");
      B.style.visibility = "visible", c = new yie({ element: B, autoPan: { animation: { duration: 250 } } }), c.setPosition(b), r.addOverlay(c);
    }
    function d() {
      c && r.removeOverlay(c), c = void 0;
    }
    function h(I) {
      return r.forEachFeatureAtPixel(I, (b, B) => [
        b,
        Loe(B)
      ]);
    }
    function g(...I) {
      r.getControls().extend(I);
    }
    function f(I, b) {
      const B = i(I);
      if (B)
        return B.interactions[b];
    }
    function p(I) {
      r.getInteractions().forEach((b) => b.setActive(I));
    }
    function m(...I) {
      I.forEach((b) => b.setActive(!1));
    }
    function E(...I) {
      I.forEach((b) => b.setActive(!0));
    }
    function y() {
      return r.getSize();
    }
    function C() {
      return r.getViewport();
    }
    function w() {
      return r.getView().calculateExtent(r.getSize());
    }
    function M() {
      r.render();
    }
    return {
      getLayer: i,
      getLayers: a,
      addControls: g,
      addOverlay: u,
      focusLayerGeometries: s,
      focusGeometries: o,
      getBBox: w,
      getFeatureAtPixel: h,
      getSize: y,
      getViewport: C,
      getInteraction: f,
      enableInteractions: E,
      disableInteractions: m,
      removeOverlay: d,
      render: M,
      setInteractionsTo: p,
      switchBackgroundLayer: l,
      switchDataLayers: A
    };
  }
  function SM(t, e, i) {
    const r = ue(!1), n = ue(e == null ? void 0 : e.default), s = ue(), o = (...a) => (r.value = !0, t(...a).then((A) => n.value = A).catch((A) => s.value = A).finally(() => r.value = !1));
    return e != null && e.immediate && o(), su({
      call: o,
      isLoading: r,
      data: n,
      error: s
    });
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Xh = (t, e) => (t % e + e) % e, Nn = (t) => !!t && typeof t == "object" && !Array.isArray(t), Qr = (t) => t !== null && typeof t < "u", Ss = (t) => Qr(t) && t !== "false" && t !== !1, wu = (t) => Qr(t) ? t : "", X1 = (t, e = "px") => Qr(t) ? isNaN(t) ? String(t) : String(t) + e : void 0;
  function WBe(t, e, i, r = !1, n = !1) {
    return i && typeof i == "function" ? (n ? t : [...t]).sort((s, o) => i(s, o, r)) : (n ? t : [...t]).sort((s, o) => {
      let a = Nn(s) ? Wr(s, e) : s, A = Nn(o) ? Wr(o, e) : o;
      return typeof a == "boolean" && typeof A == "boolean" ? r ? a > A ? 1 : -1 : a > A ? -1 : 1 : !a && a !== 0 ? 1 : !A && A !== 0 ? -1 : a === A ? 0 : (a = typeof a == "string" ? a.toUpperCase() : a, A = typeof A == "string" ? A.toUpperCase() : A, r ? a > A ? 1 : -1 : a > A ? -1 : 1);
    });
  }
  function gy(t, e) {
    if (!t && e || t && !e) return !1;
    if (t === e) return !0;
    if (Nn(t) && Nn(e)) {
      const i = Object.keys(t), r = Object.keys(e);
      if (i.length !== r.length) return !1;
      for (const n of i) {
        const s = t[n], o = e[n], a = Nn(s) && Nn(o);
        if (a && !gy(s, o) || !a && s !== o)
          return !1;
      }
      return !0;
    }
    return Array.isArray(t) && Array.isArray(e) ? !(t.length !== e.length || !t.every((i, r) => i === e[r])) : !1;
  }
  function vC(t, e, i) {
    if (!t) return "";
    const r = e ? Wr(t, e) : t, n = typeof i == "function" ? i(r, t) : r;
    return String(n || "");
  }
  function H4(t, e, i = !1) {
    return !Nn(t) || !Nn(e) ? e : i ? J4(t, e) : Object.assign(t, e);
  }
  function J4(t, e) {
    return !Nn(t) || !Nn(e) ? e : (Object.getOwnPropertyNames(e).forEach((i) => {
      const r = t[i], n = e[i];
      Array.isArray(r) && Array.isArray(n) ? t[i] = r.concat(n) : Nn(r) && Nn(n) ? t[i] = J4(
        Object.assign({}, r),
        n
      ) : t[i] = n;
    }), t);
  }
  function Wr(t, e, i) {
    if (!t || typeof t != "object" || typeof e != "string")
      return i;
    const r = e.split(".").reduce((n, s) => typeof n < "u" ? n[s] : void 0, t);
    return typeof r < "u" ? r : i;
  }
  function KBe(t) {
    return t && t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }
  function m2(t) {
    return t && t.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  }
  function V4(t) {
    return !!(!t || t.type === vG || t.type === xG && !t.children.trim() || t.type === ht && V4(t.children));
  }
  const tu = {
    Android: () => typeof window < "u" && !!window.navigator.userAgent.match(/Android/i),
    BlackBerry: () => typeof window < "u" && !!window.navigator.userAgent.match(/BlackBerry/i),
    iOS: () => typeof window < "u" && !!window.navigator.userAgent.match(/iPhone|iPad|iPod/i),
    Opera: () => typeof window < "u" && !!window.navigator.userAgent.match(/Opera Mini/i),
    Windows: () => typeof window < "u" && !!window.navigator.userAgent.match(/IEMobile/i),
    any: () => tu.Android() || tu.BlackBerry() || tu.iOS() || tu.Opera() || tu.Windows()
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const W4 = ue({});
  function XBe(t, e) {
    W4.value[t] = e;
  }
  function K4() {
    return W4.value;
  }
  let Km;
  const X4 = (t) => {
    Km = t;
  }, Br = (t, e) => {
    t.component(e.name, e);
  }, tw = (t, e, i) => {
    X4(t);
    const r = K4();
    XBe(e, i), t._context.provides && t._context.provides.oruga || t.provide("oruga", r), t.config.globalProperties.$oruga || (t.config.globalProperties.$oruga = r);
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const iw = ue({
    iconPack: "mdi",
    useHtml5Validation: !0,
    statusIcon: !0,
    transformClasses: void 0
  }), ZBe = (t) => {
    iw.value = t;
  }, Z4 = () => Object.assign({}, UC(iw.value)), Vl = (t, e) => Wr(iw.value, t, e), W = (t, e) => Wr(iw.value, t, e), qBe = {
    install(t, e) {
      X4(t), ZBe(H4(Z4(), e, !0));
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Cu = (t) => {
    const e = zt(t);
    return e ? e.flatMap(
      (i) => Object.keys(i).filter((r) => r && i[r]).flatMap((r) => r.split(" "))
    ) : [];
  };
  function ye(...t) {
    const e = Array.isArray(t.at(-1)) ? void 0 : t.at(-1), i = Array.isArray(t.at(-1)) ? t : t.slice(0, -1), r = Uo();
    if (!r)
      throw new Error(
        "defineClasses must be called within a component setup function."
      );
    if (!$h() && !(e != null && e.scope))
      throw new Error(
        "defineClasses must be called within a current active effect scope."
      );
    const n = (e == null ? void 0 : e.scope) || QG();
    $h() && KM(() => {
      n && n.stop();
    });
    const s = ue([]);
    return s.value = i.map((o, a) => {
      const A = o[0], l = o[1], c = o[2], u = o[3];
      function d() {
        const h = $Be(
          r,
          A,
          l,
          zt(c) || void 0
        ), g = !Qr(u) || zt(u);
        return { [h]: g };
      }
      return n.run(() => {
        ct(
          [
            () => {
              var h;
              return (h = r.proxy) == null ? void 0 : h.$props[A];
            },
            () => e != null && e.props ? e == null ? void 0 : e.props[A] : null
          ],
          () => {
            const h = d();
            s.value[a] = h;
          }
        ), Qr(c) && eg(c) && ct(c, (h, g) => {
          if (h === g) return;
          const f = d();
          s.value[a] = f;
        }), Qr(u) && eg(u) && ct(u, (h, g) => {
          if (h === g) return;
          const f = s.value[a];
          Object.keys(f).forEach(
            (p) => f[p] = h
          ), s.value[a] = f;
        });
      }), d();
    }), s;
  }
  function $Be(t, e, i, r = "") {
    var n;
    const s = xC(t), o = (n = t.proxy) == null ? void 0 : n.$options.configField;
    if (!o)
      throw new Error("component must define the 'configField' option.");
    const a = s.override === !0 ? {} : Z4();
    let A = Wr(
      a,
      `${o}.${e}.class`,
      ""
    ) || Wr(
      a,
      `${o}.${e}`,
      ""
    ), l = Wr(
      s,
      e,
      ""
    );
    if (Array.isArray(l) && (l = l.join(" ")), typeof l == "function") {
      const p = xC(t);
      l = l(r, p);
    } else
      l = E2(l, r);
    if (Array.isArray(A) && (A = A.join(" ")), typeof A == "function") {
      const p = xC(t);
      A = A(r, p);
    } else
      A = E2(A, r);
    i.includes("{*}") ? i = i.replace(
      /\{\*\}/g,
      wu(r)
    ) : i = i + wu(r);
    const c = s.override || Wr(a, "override", !1), u = Wr(
      a,
      `${o}.override`,
      c
    );
    let h = `${Wr(
      a,
      `${o}.${e}.override`,
      u
    ) ? "" : i} ${wu(A)} ${wu(l)}`.trim().replace(/\s\s+/g, " ");
    const g = Wr(
      a,
      "transformClasses",
      void 0
    ), f = Wr(
      a,
      `${o}.transformClasses`,
      void 0
    );
    return f ? h = f(h) : g && (h = g(h)), h;
  }
  function E2(t, e) {
    return wu(t).split(" ").filter((i) => i.length > 0).map((i) => i + wu(e)).join(" ");
  }
  const xC = (t) => {
    var e;
    let i = ((e = t.proxy) == null ? void 0 : e.$props) || {};
    return i = Object.keys(i).filter((r) => r.endsWith("Props")).map((r) => i[r]).reduce((r, n) => ({ ...r, ...n }), i), i;
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const ewe = {
    sizes: {
      default: "mdi-24px",
      small: "",
      medium: "mdi-36px",
      large: "mdi-48px"
    },
    iconPrefix: "mdi-"
  }, zc = () => {
    const e = Vl("iconComponent") ? "" : "fa-";
    return {
      sizes: {
        default: "",
        small: "sm",
        medium: "lg",
        large: "xl"
      },
      iconPrefix: e,
      internalIcons: {
        check: "check",
        information: "info-circle",
        alert: "exclamation-triangle",
        "alert-circle": "exclamation-circle",
        "arrow-up": "arrow-up",
        "chevron-right": "angle-right",
        "chevron-left": "angle-left",
        "chevron-down": "angle-down",
        "chevron-up": "angle-up",
        eye: "eye",
        "eye-off": "eye-slash",
        "caret-down": "caret-down",
        "caret-up": "caret-up",
        "close-circle": "times-circle",
        close: "times",
        loading: "circle-notch",
        "emoticon-sad": "frown"
      }
    };
  }, twe = () => {
    let t = {
      mdi: ewe,
      fa: zc(),
      fas: zc(),
      far: zc(),
      fad: zc(),
      fab: zc(),
      fal: zc()
    };
    const e = Vl("customIconPacks");
    return e && (t = H4(t, e, !0)), t;
  }, Fr = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OIcon",
    configField: "icon",
    __name: "Icon",
    props: {
      override: { type: Boolean, default: void 0 },
      icon: { default: void 0 },
      component: { default: () => W("iconComponent") },
      pack: { default: () => W("iconPack", "mdi") },
      variant: { default: () => W("icon.variant") },
      size: { default: () => W("icon.size") },
      customSize: { default: void 0 },
      customClass: { default: void 0 },
      clickable: { type: Boolean, default: !1 },
      spin: { type: Boolean, default: !1 },
      rotation: { default: void 0 },
      both: { type: Boolean, default: !1 },
      rootClass: {},
      sizeClass: {},
      variantClass: {},
      clickableClass: {},
      spinClass: {}
    },
    setup(t) {
      const e = t, i = O(() => {
        const u = {};
        return e.rotation && (u.transform = `rotate(${e.rotation}deg)`), u;
      }), r = O(() => twe()[e.pack]), n = O(
        () => {
          var u;
          return (u = r.value) != null && u.iconPrefix ? r.value.iconPrefix : "";
        }
      ), s = O(() => {
        var u;
        if ((u = r.value) != null && u.sizes) {
          if (e.size && r.value.sizes[e.size] !== void 0)
            return r.value.sizes[e.size];
          if (r.value.sizes.default)
            return r.value.sizes.default;
        }
        return null;
      }), o = O(
        () => `${n.value}${l(e.icon)}`
      ), a = O(() => e.customSize || s.value), A = O(() => {
        if (!e.variant) return;
        let u = "";
        return typeof e.variant == "string" ? u = e.variant : u = Object.keys(e.variant).filter(
          (d) => e.variant[d]
        )[0], u;
      });
      function l(u) {
        var d, h;
        return e.both && (d = r.value) != null && d.internalIcons && (h = r.value) != null && h.internalIcons[u] ? r.value.internalIcons[u] : u;
      }
      const c = ye(
        ["rootClass", "o-icon"],
        [
          "clickableClass",
          "o-icon--clickable",
          null,
          O(() => e.clickable)
        ],
        ["spinClass", "o-icon--spin", null, O(() => e.spin)],
        [
          "sizeClass",
          "o-icon--",
          O(() => e.size),
          O(() => !!e.size)
        ],
        [
          "variantClass",
          "o-icon--",
          A,
          O(() => !!A.value)
        ]
      );
      return (u, d) => (G(), X("span", {
        "data-oruga": "icon",
        class: he(j(c)),
        style: eE(i.value)
      }, [
        u.component ? (G(), De(Nr(u.component), {
          key: 0,
          icon: [u.pack, o.value],
          size: a.value,
          class: he([u.customClass])
        }, null, 8, ["icon", "size", "class"])) : (G(), X("i", {
          key: 1,
          class: he([u.pack, o.value, a.value, u.customClass])
        }, null, 2))
      ], 6));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const q4 = Symbol("FielData");
  function iwe(t) {
    bd(q4, t);
  }
  function hc() {
    const t = bo(
      q4,
      O(() => {
      })
    ), e = O(() => {
      var s;
      if ((s = t == null ? void 0 : t.value) != null && s.message)
        return t == null ? void 0 : t.value.message;
    }), i = O(() => {
      var s;
      if ((s = t == null ? void 0 : t.value) != null && s.variant) {
        if (typeof t.value.variant == "string")
          return t.value.variant;
        if (Array.isArray(t.value.variant)) {
          for (const o in t.value.variant)
            if (t.value.variant[o]) return o;
        }
      }
    }), r = Vl("statusVariantIcon", {
      success: "check",
      danger: "alert-circle",
      info: "information",
      warning: "alert"
    }), n = O(() => !i.value || !r ? "" : r[i.value] || "");
    return {
      parentField: t,
      statusVariant: i,
      statusVariantIcon: n,
      statusMessage: e
    };
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function Kr(t) {
    const e = zt(t);
    return (e == null ? void 0 : e.$el) ?? e;
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const wn = typeof window < "u", $4 = typeof window > "u";
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const rwe = $4 ? [] : [
    HTMLButtonElement,
    HTMLFieldSetElement,
    HTMLInputElement,
    HTMLObjectElement,
    HTMLOutputElement,
    HTMLSelectElement,
    HTMLTextAreaElement
  ];
  function y2(t) {
    return rwe.some((e) => t instanceof e) ? t : null;
  }
  const nwe = [
    "disabled",
    "required",
    "pattern",
    "maxlength",
    "minlength",
    "max",
    "min",
    "step"
  ];
  function rw(t, e, i) {
    const { parentField: r } = hc(), n = O(() => {
      const p = Kr(t);
      if (!p) return;
      if (p.getAttribute("data-oruga-input"))
        return p;
      const m = p.querySelector("[data-oruga-input]");
      if (!m) {
        console.warn(
          "useInputHandler: Underlaying Oruga input component not found"
        );
        return;
      }
      return m;
    }), s = O(() => {
      const p = n.value;
      return p || console.warn("useInputHandler: inputRef contains no element"), p;
    }), o = ue(!1);
    function a() {
      ji(() => {
        s.value && s.value.focus();
      });
    }
    function A() {
      ji(() => {
        s.value && s.value.click();
      });
    }
    function l(p) {
      o.value = !1, r != null && r.value && r.value.setFocus(!1), e("blur", p || new Event("blur")), h();
    }
    function c(p) {
      o.value = !0, r != null && r.value && r.value.setFocus(!0), e("focus", p || new Event("focus"));
    }
    const u = ue(!0);
    function d(p, m) {
      ji(() => {
        r != null && r.value && (r.value.props.variant || r.value.setVariant(p), r.value.props.message || r.value.setMessage(m));
      });
    }
    function h() {
      i.useHtml5Validation && s.value && (s.value.validity.valid ? (d(null, null), u.value = !0) : (g(), u.value = !1));
    }
    function g() {
      var p;
      const m = "danger", E = (p = s.value) == null ? void 0 : p.validationMessage;
      d(m, E);
    }
    function f(p) {
      h();
      const m = y2(p.target);
      if (m && (r != null && r.value) && i.useHtml5Validation) {
        p.preventDefault();
        let E = !1;
        if (m.form != null) {
          const y = m.form.elements;
          for (let C = 0; C < y.length; ++C) {
            const w = y2(
              y.item(C)
            );
            if (w != null && w.willValidate && !w.validity.valid) {
              E = m === w;
              break;
            }
          }
        }
        if (E) {
          const y = r.value.$el, C = Vl("invalidHandler");
          if (!y) return;
          if (C instanceof Function)
            C(m, y);
          else {
            const w = y ? y.scrollIntoView != null : !1;
            m.focus({ preventScroll: w }), w && y.scrollIntoView({ block: "nearest" });
          }
        }
      }
      e("invalid", p);
    }
    if (!$4) {
      const p = ue(null);
      vi(() => {
        if (p.value, !(i.useHtml5Validation ?? !0)) return;
        const y = n.value;
        if (!Qr(y)) return;
        const C = i.customValidity ?? "";
        typeof C == "string" ? y.setCustomValidity(C) : y.setCustomValidity(
          C(i.modelValue, y.validity)
        ), u.value || h();
      }), ct(
        [n, () => i.useHtml5Validation ?? !0],
        (y, C) => {
          const w = y[0], M = y[1], I = C[0], b = C[1];
          w !== I ? I == null || I.setCustomValidity("") : b && !M && (w == null || w.setCustomValidity(""));
        }
      );
      const m = () => {
        ll(p);
      };
      let E = null;
      ct(
        [
          n,
          u,
          () => i.useHtml5Validation ?? !0,
          () => i.customValidity
        ],
        (y, C) => {
          const w = y[0], M = y[1], I = y[2], b = y[3] instanceof Function, B = C[0], x = Qr(w) && I && // For inputs known to be invalid, changes in constraint validation properties
          // may make it so the field is now valid and the message needs to be hidden.
          // For browser-implemented constraint validation (e.g. the `required` attribute),
          // we just care about the message displayed to the user, which is hidden for valid inputs
          // until the next interaction with the control.
          (!M || // For inputs with complex custom validation, any changes to validation-related attributes
          // may affect the results of `props.customValidity`.
          b);
          if ((!x || w !== B) && E != null && (E.takeRecords().length > 0 && m(), E.disconnect()), x && Qr(w) && w !== B) {
            E == null && (E = new MutationObserver(
              m
            )), E.observe(w, {
              attributeFilter: nwe
            });
            let Q = w;
            for (; Q = Q.parentNode; )
              Q instanceof HTMLFieldSetElement && E.observe(Q, {
                attributeFilter: ["disabled"]
              });
          }
        }
      );
    }
    return {
      input: s,
      isFocused: o,
      isValid: u,
      setFocus: a,
      doClick: A,
      onFocus: c,
      onBlur: l,
      onInvalid: f,
      checkHtml5Validity: h
    };
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function Z1(t, e, i) {
    let r;
    return (...n) => {
      const s = () => {
        r = void 0, t.apply(this, n);
      };
      r && clearTimeout(r), r = setTimeout(s, e);
    };
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const swe = ["id", "type", "data-oruga-input", "maxlength", "autocomplete", "placeholder", "disabled"], owe = ["id", "maxlength", "placeholder", "disabled"], q1 = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OInput",
    configField: "input",
    inheritAttrs: !1,
    __name: "Input",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      modelValue: { default: void 0 },
      number: {},
      type: { default: "text" },
      size: { default: () => W("input.size") },
      variant: { default: () => W("input.variant") },
      placeholder: { default: void 0 },
      expanded: { type: Boolean, default: !1 },
      rounded: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      passwordReveal: { type: Boolean, default: !1 },
      maxlength: { default: void 0 },
      counter: { type: Boolean, default: () => W("input.counter", !1) },
      autosize: { type: Boolean, default: !1 },
      iconPack: { default: () => W("input.iconPack") },
      icon: { default: () => W("input.icon") },
      iconClickable: { type: Boolean, default: !1 },
      iconRight: { default: () => W("input.iconRight") },
      iconRightClickable: { type: Boolean, default: !1 },
      iconRightVariant: { default: void 0 },
      clearable: { type: Boolean, default: () => W("input.clearable", !1) },
      clearIcon: { default: () => W("input.clearIcon", "close-circle") },
      statusIcon: { type: Boolean, default: () => W("statusIcon", !0) },
      debounce: { default: () => W("autocomplete.debounce", 400) },
      autocomplete: { default: () => W("input.autocomplete", "off") },
      id: { default: () => Pn() },
      useHtml5Validation: { type: Boolean, default: () => W("useHtml5Validation", !0) },
      customValidity: { type: [String, Function], default: "" },
      rootClass: {},
      sizeClass: {},
      variantClass: {},
      expandedClass: {},
      roundedClass: {},
      disabledClass: {},
      textareaClass: {},
      hasIconRightClass: {},
      inputClass: {},
      iconLeftSpaceClass: {},
      iconRightSpaceClass: {},
      placeholderClass: {},
      iconLeftClass: {},
      iconRightClass: {},
      counterClass: {}
    }, {
      modelValue: {
        // cast incomming value to string
        default: void 0
      },
      modelModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:model-value", "input", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue"]),
    setup(t, { expose: e, emit: i }) {
      var r;
      const n = t, s = i, o = cs("inputElement"), {
        checkHtml5Validity: a,
        onBlur: A,
        onFocus: l,
        onInvalid: c,
        setFocus: u,
        isValid: d,
        isFocused: h
      } = rw(o, s, n), { parentField: g, statusVariant: f, statusVariantIcon: p } = hc(), m = Hi(t, "modelValue", {
        // cast incomming value to string
        get: (Z) => Qr(Z) ? String(Z) : "",
        // cast outgoing value to number if prop number is true
        set: (Z) => Qr(Z) ? Ss(n.number) ? Number(Z) : String(Z) : Z
      });
      n.id && ((r = g == null ? void 0 : g.value) == null || r.setInputId(n.id));
      const E = O(
        () => typeof m.value == "string" || typeof m.value == "number" ? String(m.value).length : 0
      );
      er(() => {
        ct(
          () => m.value,
          (Z) => {
            g != null && g.value && g.value.setFilled(!!Z), n.autosize && C(), d.value || a();
          },
          { immediate: !0, flush: "post" }
        );
      });
      const y = ue("auto");
      function C() {
        y.value = "auto", ji(() => {
          if (n.type !== "textarea" || !o.value) return;
          const Z = o.value.scrollHeight;
          y.value = Z + "px";
        });
      }
      const w = O(
        () => n.type === "textarea" && n.autosize ? {
          resize: "none",
          height: y.value,
          overflow: "hidden"
        } : {}
      );
      let M;
      ct(
        () => n.debounce,
        (Z) => M = Z1(I, Z || 0),
        { immediate: !0 }
      );
      function I(Z) {
        s("input", m.value, Z);
      }
      const b = O(
        () => !Qr(m.value) || m.value === ""
      ), B = O(() => !!(n.passwordReveal || n.statusIcon && p.value || n.clearable && m.value && n.clearIcon || n.iconRight)), x = O(() => n.passwordReveal ? F.value : n.clearable && m.value && n.clearIcon ? n.clearIcon : n.iconRight ? n.iconRight : p.value), Q = O(
        () => n.passwordReveal || n.iconRight ? n.iconRightVariant || n.variant : f.value
      );
      function v(Z) {
        s("icon-click", Z), ji(() => u());
      }
      function T(Z) {
        n.passwordReveal ? R() : n.clearable && (m.value = Ss(n.number) ? 0 : ""), n.iconRightClickable && (s("icon-right-click", Z), ji(() => u()));
      }
      const S = ue(!1), D = O(() => n.passwordReveal ? S.value ? "text" : "password" : n.type), F = O(
        () => S.value ? "eye-off" : "eye"
      );
      function R() {
        S.value = !S.value, ji(() => u());
      }
      const Y = Sy(), L = O(() => {
        var Z;
        return {
          ...(Z = g == null ? void 0 : g.value) == null ? void 0 : Z.inputAttrs,
          ...Y
        };
      }), N = ye(
        ["rootClass", "o-input"],
        [
          "sizeClass",
          "o-input--",
          O(() => n.size),
          O(() => !!n.size)
        ],
        [
          "variantClass",
          "o-input--",
          O(() => f.value || n.variant),
          O(() => !!f.value || !!n.variant)
        ],
        [
          "expandedClass",
          "o-input--expanded",
          null,
          O(() => n.expanded)
        ],
        [
          "disabledClass",
          "o-input--disabled",
          null,
          O(() => n.disabled)
        ],
        ["roundedClass", "o-input--rounded", null, O(() => n.rounded)],
        ["hasIconRightClass", "o-input--icon-right", null, B],
        [
          "textareaClass",
          "o-input--textarea",
          null,
          O(() => n.type === "textarea")
        ]
      ), H = ye(
        ["inputClass", "o-input__input"],
        [
          "iconLeftSpaceClass",
          "o-input__input--iconspace-left",
          null,
          O(() => !!n.icon)
        ],
        [
          "iconRightSpaceClass",
          "o-input__input--iconspace-right",
          null,
          B
        ],
        [
          "placeholderClass",
          "o-input__input--placeholder",
          null,
          b
        ]
      ), P = ye(["iconLeftClass", "o-input__icon-left"]), ie = ye([
        "iconRightClass",
        "o-input__icon-right"
      ]), V = ye(["counterClass", "o-input__counter"]);
      return e({ focus: u, value: m }), (Z, se) => (G(), X("div", {
        "data-oruga": "input",
        class: he(j(N))
      }, [
        Z.icon ? (G(), De(Fr, {
          key: 0,
          class: he(j(P)),
          clickable: Z.iconClickable,
          icon: Z.icon,
          pack: Z.iconPack,
          size: Z.size,
          onClick: v
        }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : de("", !0),
        Z.type !== "textarea" ? $t((G(), X("input", Tt({ key: 1 }, L.value, {
          id: Z.id,
          ref: "inputElement",
          "onUpdate:modelValue": se[0] || (se[0] = (k) => m.value = k),
          type: D.value,
          "data-oruga-input": D.value,
          class: j(H),
          maxlength: Z.maxlength,
          autocomplete: Z.autocomplete,
          placeholder: Z.placeholder,
          disabled: Z.disabled,
          onBlur: se[1] || (se[1] = //@ts-ignore
          (...k) => j(A) && j(A)(...k)),
          onFocus: se[2] || (se[2] = //@ts-ignore
          (...k) => j(l) && j(l)(...k)),
          onInvalid: se[3] || (se[3] = //@ts-ignore
          (...k) => j(c) && j(c)(...k)),
          onInput: se[4] || (se[4] = //@ts-ignore
          (...k) => j(M) && j(M)(...k))
        }), null, 16, swe)), [
          [FG, m.value]
        ]) : $t((G(), X("textarea", Tt({ key: 2 }, L.value, {
          id: Z.id,
          ref: "inputElement",
          "onUpdate:modelValue": se[5] || (se[5] = (k) => m.value = k),
          "data-oruga-input": "textarea",
          class: j(H),
          maxlength: Z.maxlength,
          style: w.value,
          placeholder: Z.placeholder,
          disabled: Z.disabled,
          onBlur: se[6] || (se[6] = //@ts-ignore
          (...k) => j(A) && j(A)(...k)),
          onFocus: se[7] || (se[7] = //@ts-ignore
          (...k) => j(l) && j(l)(...k)),
          onInvalid: se[8] || (se[8] = //@ts-ignore
          (...k) => j(c) && j(c)(...k)),
          onInput: se[9] || (se[9] = //@ts-ignore
          (...k) => j(M) && j(M)(...k))
        }), null, 16, owe)), [
          [SG, m.value]
        ]),
        B.value ? (G(), De(Fr, {
          key: 3,
          class: he(j(ie)),
          clickable: Z.passwordReveal || Z.clearable || Z.iconRightClickable,
          icon: x.value,
          pack: Z.iconPack,
          size: Z.size,
          variant: Q.value,
          both: "",
          onClick: T
        }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : de("", !0),
        Z.maxlength && Z.counter && j(h) && Z.type !== "number" ? (G(), X("small", {
          key: 4,
          class: he(j(V))
        }, Pe(E.value) + " / " + Pe(Z.maxlength), 3)) : de("", !0)
      ], 2));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function Vd(t = 0) {
    let e = t;
    function i() {
      return String(e++);
    }
    return {
      nextSequence: i,
      sequence: e
    };
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function $1(t) {
    var e;
    const i = Uo();
    if (!i)
      throw new Error(
        "useProviderChild must be called within a component setup function."
      );
    const r = (e = i.proxy) == null ? void 0 : e.$options.configField, n = (t == null ? void 0 : t.key) || r, s = ue([]);
    if (t != null && t.rootRef) {
      const l = Z1((c) => {
        const u = Kr(t.rootRef);
        if (!u) return;
        const d = c.map((f) => `[data-id="${n}-${f.identifier}"]`).join(","), h = u.querySelectorAll(d), g = Array.from(h).map(
          (f) => {
            var p;
            return (p = f.getAttribute("data-id")) == null ? void 0 : p.replace(`${n}-`, "");
          }
        );
        c.forEach(
          (f) => f.index = g.indexOf(`${f.identifier}`)
        ), c.sort((f, p) => f.index - p.index);
      }, 500);
      ct(s, l);
    }
    const { nextSequence: o } = Vd(1);
    function a(l) {
      const c = s.value.length, u = o(), d = { index: c, data: l, identifier: u };
      return s.value = [
        ...s.value,
        d
      ], d;
    }
    function A(l) {
      s.value = s.value.filter((c) => c !== l);
    }
    return bd("$o-" + n, {
      registerItem: a,
      unregisterItem: A,
      data: t == null ? void 0 : t.data
    }), {
      childItems: s
    };
  }
  function eQ(t) {
    var e, i;
    t = Object.assign({ needParent: !0, register: !0 }, t);
    const r = Uo();
    if (!r)
      throw new Error(
        "useProviderChild must be called within a component setup function."
      );
    const n = (e = r.proxy) == null ? void 0 : e.$options.configField, s = (t == null ? void 0 : t.key) || n, o = bo("$o-" + s, void 0);
    if (t.needParent && !o)
      throw new Error(
        `You should wrap ${(i = r.proxy) == null ? void 0 : i.$options.name} in a ${s} component`
      );
    const a = ue();
    return o && t.register && (a.value = o.registerItem(
      t == null ? void 0 : t.data
    )), Fs(() => {
      o && a.value && o.unregisterItem(a.value);
    }), { parent: (o == null ? void 0 : o.data) || ue(), item: a };
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function awe(t) {
    if (t.style.position === "fixed" || !t)
      return document.documentElement;
    let e = !1, i = t.parentElement;
    for (; !e && Qr(i) && i !== document.documentElement; ) {
      const { overflow: r, overflowY: n } = getComputedStyle(i), { scrollHeight: s, clientHeight: o } = i;
      if (e = /(auto|scroll)/.test(`${r}${n}`) && s > o, e) break;
      i = i.parentElement;
    }
    return i;
  }
  const eO = /* @__PURE__ */ je({
    inheritAttrs: !1,
    __name: "PositionWrapper",
    props: {
      teleport: {
        type: [Boolean, String, Object],
        required: !0
      },
      trigger: {
        type: Object,
        default: void 0
      },
      /**
       * Position of the component relative to the trigger
       * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
       */
      position: {
        type: String,
        validator: (t) => [
          "auto",
          "top",
          "bottom",
          "left",
          "right",
          "top-right",
          "top-left",
          "bottom-left",
          "bottom-right"
        ].includes(t),
        required: !0
      },
      /** Used for calculation position auto */
      defaultPosition: {
        type: String,
        validator: (t) => ["top", "bottom", "left", "right"].includes(t),
        default: "top"
      },
      /** disable the position calculation */
      disabled: { type: Boolean, default: !1 },
      /** update positioning on teleport */
      disablePositioning: { type: Boolean, default: !0 }
    },
    emits: ["update:position"],
    setup(t, { emit: e }) {
      const i = {
        top: "bottom",
        bottom: "top",
        right: "left",
        left: "right"
      }, r = t, n = e, s = O(
        () => typeof r.teleport == "boolean" ? "body" : r.teleport
      ), o = O(
        () => typeof r.teleport == "boolean" || !r.teleport ? !r.teleport : !1
      ), a = ue();
      function A(E) {
        return a.value = E, ji(() => {
          g(), d();
        }), E;
      }
      const l = r.position, c = ue();
      let u;
      wn && window.ResizeObserver && (u = new window.ResizeObserver(g)), ct(
        () => r.disabled,
        () => {
          r.disabled ? h() : d();
        },
        { immediate: !0, flush: "post" }
      ), ct(
        [
          () => !!r.trigger,
          () => r.disablePositioning,
          () => r.disabled
        ],
        () => g(),
        { immediate: !0, flush: "post" }
      ), XM(() => h());
      function d() {
        wn && !c.value && a.value && (c.value = awe(Kr(a)), c.value && c.value !== document.documentElement ? (c.value.addEventListener(
          "scroll",
          g,
          { passive: !0 }
        ), window.ResizeObserver && u && u.observe(c.value)) : (document.addEventListener("scroll", g, {
          passive: !0
        }), window.addEventListener("resize", g)));
      }
      function h() {
        wn && (window.ResizeObserver && u && u.disconnect(), window.removeEventListener("resize", g), document.removeEventListener("scroll", g), c.value = void 0);
      }
      function g() {
        if (r.disabled) return;
        let E = r.position;
        if (l === "auto" && (E = f(), E != r.position && n("update:position", E)), !r.teleport) return;
        const y = Kr(a), C = Kr(r.trigger);
        if (y && C) {
          const w = C.getBoundingClientRect();
          let M = w.top + window.scrollY, I = w.left + window.scrollX;
          E.includes("bottom") ? M += C.clientHeight : E.includes("top") && (M -= y.clientHeight), E === "left" ? I -= y.clientWidth : E === "right" ? I += C.clientWidth : E.includes("-right") && (I += C.clientWidth - y.clientWidth), (E === "top" || E === "bottom") && (I += C.clientWidth / 2), (E === "left" || E === "right") && (M += C.clientHeight / 2), r.disablePositioning ? (y.style.position = "relative", y.style.top = `${M}px`, y.style.left = `${I}px`) : (y.style.position = "", y.style.top = "", y.style.left = "");
        }
      }
      function f() {
        let E = r.defaultPosition;
        if (!r.trigger || !a.value || !c.value) return E;
        const y = new DOMRect(
          c.value.offsetLeft,
          c.value.offsetTop,
          c.value.clientWidth,
          c.value.clientHeight
        ), C = Kr(a).getBoundingClientRect(), w = Kr(r.trigger).getBoundingClientRect(), M = m(w), I = m(C), b = (S) => {
          const D = M[S], F = I[i[S]];
          return new DOMRect(
            C.x + (D.x - F.x),
            C.y + (D.y - F.y),
            C.width,
            C.height
          );
        }, B = i[r.defaultPosition], x = r.defaultPosition === "top" || r.defaultPosition === "bottom" ? "left" : "top", Q = i[x], v = [
          r.defaultPosition,
          B,
          x,
          Q
        ];
        let T = 0;
        for (const S of v) {
          const D = p(
            y,
            b(S)
          );
          D > T && (T = D, E = S);
        }
        return E;
      }
      function p(E, y) {
        const C = Math.max(E.left, y.left), w = Math.min(E.right, y.right), M = Math.max(E.top, y.top), I = Math.min(E.bottom, y.bottom);
        return Math.max(w - C, 0) * Math.max(I - M, 0);
      }
      const m = (E) => ({
        top: { x: (E.left + E.right) * 0.5, y: E.top },
        bottom: { x: (E.left + E.right) * 0.5, y: E.bottom },
        left: { x: E.left, y: (E.top + E.bottom) * 0.5 },
        right: { x: E.right, y: (E.top + E.bottom) * 0.5 }
      });
      return (E, y) => (G(), De(WM, {
        to: s.value,
        disabled: o.value
      }, [
        o.value ? ge(E.$slots, "default", {
          key: 0,
          setContent: A
        }) : (G(), X("div", Tt({ key: 1 }, E.$attrs, { style: { position: "absolute", left: "0px", top: "0px" } }), [
          ge(E.$slots, "default", { setContent: A })
        ], 16))
      ], 8, ["to", "disabled"]));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function Wd(t, e, i, r) {
    let n;
    const s = () => {
      if (!t) return;
      const A = Kr(t), l = Nn(r) ? { ...r } : r;
      setTimeout(() => {
        A.addEventListener(e, i, l), n = () => {
          A.removeEventListener(e, i, l);
        };
      });
    };
    let o;
    typeof (r == null ? void 0 : r.trigger) < "u" && (o = ct(
      r.trigger,
      (A) => {
        A ? s() : typeof n == "function" && n();
      },
      { flush: "post" }
    )), r != null && r.immediate ? s() : $h() && er(() => {
      (typeof (r == null ? void 0 : r.trigger) > "u" || r.trigger.value) && s();
    });
    const a = () => {
      typeof o == "function" && o(), typeof n == "function" && n();
    };
    return $h() && KM(a), a;
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function _f(t) {
    var e;
    const i = ue(!1), r = ue(), n = Uo();
    if (!n)
      throw new Error(
        "useMatchMedia must be called within a component setup function."
      );
    const s = n.props, o = (e = n.proxy) == null ? void 0 : e.$options.configField;
    if (!o)
      throw new Error("component must define the 'configField' option.");
    let a = s.mobileBreakpoint;
    if (!a) {
      const l = Vl(
        "mobileBreakpoint",
        t || "1023px"
      );
      a = Vl(`${o}.mobileBreakpoint`, l);
    }
    r.value = wn ? window.matchMedia(`(max-width: ${a})`) : void 0, r.value ? (i.value = r.value.matches, Wd(r.value, "change", A)) : i.value = !1;
    function A(l) {
      i.value = l.matches;
    }
    return { isMobile: i };
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function tQ(t, e, i) {
    if (!window) return () => {
    };
    const r = Object.assign({ ignore: [] }, i), n = Array.isArray(t) ? t : [t], s = (A) => n.some((l) => {
      if (typeof l == "string")
        return Array.from(
          window.document.querySelectorAll(l)
        ).some(
          (c) => c === A.target || A.composedPath().includes(c)
        );
      {
        const c = Kr(l);
        return c && (A.target === c || A.composedPath().includes(c));
      }
    });
    function o(A) {
      s(A) || e(A);
    }
    return Wd(window, "click", o, r);
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function kf(t, e) {
    return t ? Array.isArray(t) ? t.map(
      (i) => {
        if (typeof i == "string" || typeof i == "number")
          return {
            label: String(i),
            value: String(i),
            key: e()
          };
        if (typeof i == "object") {
          if ("options" in i) {
            const r = kf(i.options, e);
            return {
              ...i,
              options: r,
              key: e()
            };
          } else if ("value" in i)
            return {
              ...i,
              key: e()
            };
        }
        return i;
      }
    ) : Object.keys(t).map(
      (i) => ({
        // create option from object key/value
        label: t[i],
        value: i,
        key: e()
      })
    ) : [];
  }
  function Yf(t) {
    return t && typeof t == "object" && Array.isArray(t.options);
  }
  function tO(t, e) {
    return Array.isArray(t) ? t.some((r) => Yf(r)) ? [...t] : [{ options: t, key: e }] : [];
  }
  function Awe(t) {
    return Array.isArray(zt(t)) ? zt(t).reduce((e, i) => (e.push(...i.options), e), []) : [];
  }
  function iQ(t, e) {
    zt(t).forEach((i) => {
      Yf(i) ? (iQ(i.options, e), i.hidden = i.options.every((r) => r.hidden)) : i.hidden = e(i);
    });
  }
  function iO(t) {
    return Array.isArray(zt(t)) ? zt(t).every((e) => Yf(e) ? iO(e.options) : !rO(e)) : !0;
  }
  function DM(t, e) {
    if (Array.isArray(zt(t))) {
      for (const i of zt(t))
        if (!(typeof i != "object" && i)) {
          if (Yf(i)) {
            const r = DM(i.options, e);
            if (r !== void 0) return r;
          } else if (gy(zt(e), i.value)) return i;
        }
    }
  }
  function rO(t) {
    var e;
    return !zt(t).hidden && !((e = zt(t).attrs) != null && e.disabled);
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  function rQ(t) {
    const e = ye([
      "scrollClipClass",
      "o-scroll-clip"
    ]), i = ye([
      "scrollKeepClass",
      "o-scroll-keep"
    ]), r = O(
      () => Cu(
        zt(t) ? e.value : i.value
      )
    ), n = ue();
    XM(() => s(!1));
    function s(o) {
      wn && r.value && (n.value = n.value ? n.value : document.documentElement.scrollTop, o ? document.body.classList.add(...r.value) : document.body.classList.remove(...r.value), zt(t) || (o ? document.body.style.top = `-${n.value}px` : (document.documentElement.scrollTop = n.value, document.body.style.top = "", n.value = void 0)));
    }
    return s;
  }
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const AA = /* @__PURE__ */ je({
    isOruga: !0,
    name: "ODropdownItem",
    configField: "dropdown",
    __name: "DropdownItem",
    props: {
      override: { type: Boolean, default: void 0 },
      value: { default: void 0 },
      label: { default: void 0 },
      disabled: { type: Boolean, default: !1 },
      clickable: { type: Boolean, default: !0 },
      hidden: { type: Boolean, default: !1 },
      tag: { default: () => W("dropdown.itemTag", "div") },
      itemClass: {},
      itemSelectedClass: {},
      itemFocusedClass: {},
      itemClickableClass: {},
      itemDisabledClass: {}
    },
    emits: ["click"],
    setup(t, { emit: e }) {
      const i = t, r = e, n = i.value ?? Pn(), s = cs("rootElement"), o = O(() => ({
        ...i,
        $el: s.value,
        value: n,
        selectItem: d
      })), { parent: a, item: A } = eQ({ data: o }), l = O(
        () => !a.value.disabled && !i.disabled && i.clickable
      ), c = O(() => Qr(a.value.selected) ? a.value.multiple && Array.isArray(a.value.selected) ? a.value.selected.some(
        (f) => gy(n, f)
      ) : gy(n, a.value.selected) : !1), u = O(
        () => A.value.identifier === a.value.focsuedIdentifier
      );
      function d(f) {
        l.value && (a.value.selectItem(A.value, f), r("click", n, f));
      }
      function h() {
        a.value.focusItem(A.value);
      }
      const g = ye(
        ["itemClass", "o-dropdown__item"],
        [
          "itemDisabledClass",
          "o-dropdown__item--disabled",
          null,
          O(() => a.value.disabled || i.disabled)
        ],
        ["itemSelectedClass", "o-dropdown__item--active", null, c],
        ["itemClickableClass", "o-dropdown__item--clickable", null, l],
        ["itemFocusedClass", "o-dropdown__item--focused", null, u]
      );
      return (f, p) => (G(), De(Nr(f.tag), {
        id: `${j(a).menuId}-${j(A).identifier}`,
        ref: "rootElement",
        "data-oruga": "dropdown-item",
        "data-id": `dropdown-${j(A).identifier}`,
        class: he(j(g)),
        role: j(a).selectable ? "option" : "menuitem",
        "aria-selected": j(a).selectable ? c.value : void 0,
        "aria-disabled": f.disabled,
        onClick: d,
        onMouseenter: h,
        onKeydown: [
          At(d, ["enter"]),
          At(d, ["space"])
        ]
      }, {
        default: Ye(() => [
          ge(f.$slots, "default", {}, () => [
            Ct(Pe(f.label), 1)
          ])
        ]),
        _: 3
      }, 40, ["id", "data-id", "class", "role", "aria-selected", "aria-disabled"]));
    }
  });
  function lwe(t, e) {
    const i = Kr(e), r = Kr(t), { offsetHeight: n, offsetTop: s } = r, { offsetHeight: o, scrollTop: a } = i, A = s < a, l = s + n > a + o;
    A ? i.scrollTo(0, s) : l && i.scrollTo(0, s - o + n);
  }
  function cwe(t, e, i) {
    wn && Wd(t, "scroll", r);
    function r() {
      const n = Kr(t);
      if (!n) return;
      const s = n.offsetTop;
      n.clientHeight !== n.scrollHeight && (Math.ceil(
        n.scrollTop + n.clientHeight + s
      ) >= n.scrollHeight ? e() : n.scrollTop <= s && i());
    }
    return { checkScroll: r };
  }
  const uwe = { key: 1 }, nO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "ODropdown",
    configField: "dropdown",
    __name: "Dropdown",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      modelValue: { default: void 0 },
      multiple: {},
      options: { default: void 0 },
      active: { type: Boolean, default: !1 },
      label: { default: void 0 },
      disabled: { type: Boolean, default: !1 },
      inline: { type: Boolean, default: !1 },
      selectable: { type: Boolean, default: !1 },
      scrollable: { type: Boolean, default: !1 },
      checkScroll: { type: Boolean, default: () => W("dropdown.checkScroll", !1) },
      maxHeight: { default: () => W("dropdown.maxHeight", 200) },
      position: { default: () => W("dropdown.position", "bottom-left") },
      animation: { default: () => W("dropdown.animation", "fade") },
      expanded: { type: Boolean, default: !1 },
      menuId: { default: () => Pn() },
      menuTag: { default: () => W("dropdown.menuTag", "div") },
      triggerTag: { default: () => W("dropdown.triggerTag", "div") },
      triggers: { default: () => W("dropdown.triggers", ["click"]) },
      delay: { default: void 0 },
      keepOpen: { type: Boolean, default: () => W("dropdown.keepOpen", !1) },
      keepFirst: { type: Boolean, default: () => W("dropdown.keepFirst", !1) },
      closeOnOutside: { type: Boolean, default: () => W("dropdown.closeOnOutside", !0) },
      closeOnScroll: { type: Boolean, default: () => W("dropdown.closeOnScroll", !1) },
      selectOnFocus: { type: Boolean, default: () => W("dropdown.selectOnFocus", !1) },
      selectOnClose: { type: Boolean, default: () => W("dropdown.selectOnClose", !1) },
      mobileModal: { type: Boolean, default: () => W("dropdown.mobileModal", !0) },
      desktopModal: { type: Boolean, default: () => W("dropdown.desktopModal", !1) },
      mobileBreakpoint: { default: () => W("dropdown.mobileBreakpoint") },
      teleport: { type: [Boolean, String, Object], default: () => W("dropdown.teleport", !1) },
      clipScroll: { type: Boolean, default: () => W("dropdown.clipScroll", !1) },
      labelledby: {},
      ariaLabel: {},
      rootClass: {},
      mobileClass: {},
      modalClass: {},
      teleportClass: {},
      inlineClass: {},
      disabledClass: {},
      expandedClass: {},
      positionClass: {},
      activeClass: {},
      hoverableClass: {},
      triggerClass: {},
      menuClass: {},
      menuPositionClass: {},
      menuActiveClass: {},
      overlayClass: {},
      scrollClipClass: {},
      scrollKeepClass: {}
    }, {
      modelValue: { default: void 0 },
      modelModifiers: {},
      active: { type: Boolean, default: !1 },
      activeModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:model-value", "update:active", "select", "change", "open", "close", "scroll-start", "scroll-end"], ["update:modelValue", "update:active"]),
    setup(t, { expose: e, emit: i }) {
      var r;
      const n = t, s = i, o = ue(), a = ue(), A = O(() => {
        var K;
        return {
          disabled: n.disabled,
          multiple: Ss(n.multiple),
          selectable: n.selectable,
          menuId: n.menuId,
          selected: g.value,
          focsuedIdentifier: (K = N.value) == null ? void 0 : K.identifier,
          selectItem: L,
          focusItem: H
        };
      }), { childItems: l } = $1({
        rootRef: a,
        data: A
      }), { nextSequence: c } = Vd(), u = O(() => {
        const K = kf(n.options, c);
        return tO(K, c());
      }), d = O(() => l.value.some(J)), { parentField: h } = hc(), g = Hi(t, "modelValue"), f = Hi(t, "active"), p = n.labelledby ?? ((r = h.value) == null ? void 0 : r.labelId), m = ue(n.position);
      ct(
        () => n.position,
        (K) => m.value = K
      );
      const { isMobile: E } = _f(n.mobileBreakpoint), y = wn && tu.any(), C = O(
        () => !n.inline && (E.value && n.mobileModal || !E.value && n.desktopModal)
      ), w = O(() => ({
        maxHeight: n.scrollable ? X1(n.maxHeight) : null,
        overflow: n.scrollable ? "auto" : null
      })), M = O(() => n.triggers.includes("hover")), I = rQ(n.clipScroll);
      wn && n.scrollable && n.checkScroll && cwe(
        a,
        () => s("scroll-end"),
        () => s("scroll-start")
      ), wn && n.closeOnOutside && tQ([a, o], b, {
        trigger: f,
        passive: !0
      }), wn && n.closeOnScroll && Wd(window, "scroll", B, { passive: !0 }), ct(
        f,
        (K) => {
          K && !n.inline && n.keepFirst && !N.value && P(1), C.value && I(K);
        },
        { flush: "post" }
      );
      function b(K) {
        !f.value || n.inline || n.closeOnOutside && Y("outside", K);
      }
      function B(K) {
        !f.value || n.inline || n.closeOnScroll && Y("scroll", K);
      }
      function x(K) {
        y && M.value && D("click", K), n.triggers.includes("click") && D("click", K);
      }
      function Q(K) {
        n.triggers.includes("contextmenu") && (K.preventDefault(), R("contextmenu", K));
      }
      function v(K) {
        n.triggers.includes("focus") && R("focus", K);
      }
      function T(K) {
        y || n.triggers.includes("hover") && R("hover", K);
      }
      function S(K) {
        y || n.triggers.includes("hover") && Y("outside", K);
      }
      function D(K, Ae) {
        n.disabled || (f.value ? Y(K, Ae) : R(K, Ae));
      }
      let F;
      function R(K, Ae) {
        n.disabled || f.value || (n.delay ? F = setTimeout(() => {
          f.value = !0, s("open", K, Ae), F = void 0;
        }, n.delay) : (ji(() => f.value = !0), s("open", K, Ae)));
      }
      function Y(K, Ae) {
        var ut, Me;
        f.value && (s("close", K, Ae), n.selectOnClose && ((Me = (ut = N.value) == null ? void 0 : ut.data) != null && Me.value) && L(N.value), f.value = !1, N.value = void 0, F && clearTimeout(F));
      }
      function L(K, Ae) {
        var ut;
        const Me = K.data.value;
        s("select", Me), n.selectable && (Ss(n.multiple) ? (g.value && Array.isArray(g.value) ? g.value.includes(Me) ? g.value = g.value.filter(
          (Fe) => Fe !== Me
        ) : g.value = [...g.value, Me] : g.value = [Me], ji(() => s("change", g.value))) : g.value !== Me && (g.value = Me, ji(() => s("change", g.value)))), (ut = o.value) == null || ut.focus(), !(n.keepOpen || !f.value || !Ae) && Y("content", Ae);
      }
      const N = ue();
      function H(K) {
        N.value = K;
      }
      function P(K) {
        var Ae;
        if (!d.value) return;
        const ut = U(((Ae = N.value) == null ? void 0 : Ae.index) || 0, K);
        ie(ut);
      }
      function ie(K) {
        var Ae, ut;
        n.selectOnFocus && ((Ae = K.data) != null && Ae.value) && L(K, new Event("focus"));
        const Me = Kr(a), Fe = Kr((ut = K.data) == null ? void 0 : ut.$el);
        !Me || !Fe || (N.value = K, lwe(Fe, Me));
      }
      function V(K) {
        if (!f.value) return R("keydown", K);
        P(-1);
      }
      function Z(K) {
        if (!f.value) return R("keydown", K);
        P(1);
      }
      function se(K) {
        var Ae;
        f.value && N.value && (ie(N.value), (Ae = N.value.data) == null || Ae.selectItem(K));
      }
      function k(K) {
        if (R("keydown", K), !d.value) return;
        const Ae = U(0, 1);
        ie(Ae);
      }
      function _(K) {
        if (R("keydown", K), !d.value) return;
        const Ae = U(l.value.length - 1, -1);
        ie(Ae);
      }
      function q(K) {
        Y("escape", K);
      }
      function U(K, Ae) {
        var ut, Me;
        let Fe = Xh(
          ((ut = N.value) == null ? void 0 : ut.index) == K ? K + Ae : K,
          l.value.length
        );
        for (; Fe !== ((Me = N.value) == null ? void 0 : Me.index) && !J(l.value[Fe]); Fe = Xh(Fe + Ae, l.value.length))
          ;
        return l.value[Fe];
      }
      function J(K) {
        var Ae, ut, Me;
        return !((Ae = K.data) != null && Ae.disabled) && !((ut = K.data) != null && ut.hidden) && !!((Me = K.data) != null && Me.clickable);
      }
      const ae = ye(
        ["rootClass", "o-dropdown"],
        [
          "disabledClass",
          "o-dropdown--disabled",
          null,
          O(() => n.disabled)
        ],
        [
          "expandedClass",
          "o-dropdown--expanded",
          null,
          O(() => n.expanded)
        ],
        ["inlineClass", "o-dropdown--inline", null, O(() => n.inline)],
        ["mobileClass", "o-dropdown--mobile", null, E],
        ["modalClass", "o-dropdown--modal", null, C],
        ["hoverableClass", "o-dropdown--hoverable", null, M],
        [
          "positionClass",
          "o-dropdown--position-",
          m,
          O(() => !!m.value)
        ],
        [
          "activeClass",
          "o-dropdown--active",
          null,
          O(() => f.value || n.inline)
        ]
      ), $ = ye(["triggerClass", "o-dropdown__trigger"]), Ce = ye([
        "teleportClass",
        "o-dropdown--teleport",
        null,
        O(() => !!n.teleport)
      ]), Re = ye(["overlayClass", "o-dropdown__overlay"]), Oe = ye(
        ["menuClass", "o-dropdown__menu"],
        [
          "menuPositionClass",
          "o-dropdown__menu--",
          m,
          O(() => !!m.value)
        ],
        [
          "menuActiveClass",
          "o-dropdown__menu--active",
          null,
          O(() => f.value || n.inline)
        ]
      );
      return e({ $trigger: o, $content: a, value: g }), (K, Ae) => (G(), X("div", {
        "data-oruga": "dropdown",
        class: he(j(ae)),
        onMouseleave: S,
        onFocusout: S
      }, [
        K.inline ? de("", !0) : (G(), De(Nr(K.triggerTag), {
          key: 0,
          ref_key: "triggerRef",
          ref: o,
          class: he(j($)),
          role: K.selectable ? "combobox" : void 0,
          tabindex: K.disabled ? -1 : null,
          "aria-haspopup": K.selectable ? "listbox" : "menu",
          "aria-expanded": K.selectable ? f.value : void 0,
          "aria-activedescendant": N.value ? `${K.menuId}-${N.value.identifier}` : void 0,
          "aria-disabled": K.disabled,
          "aria-controls": K.menuId,
          "aria-labelledby": K.selectable ? j(p) : void 0,
          "aria-label": K.selectable ? K.ariaLabel : void 0,
          onClick: x,
          onContextmenu: Q,
          onMouseenter: T,
          onFocusCapture: v,
          onKeydown: [
            At(q, ["tab"]),
            At(q, ["escape"]),
            At(se, ["enter"]),
            At(se, ["space"]),
            At(at(V, ["prevent"]), ["up"]),
            At(at(Z, ["prevent"]), ["down"]),
            At(at(k, ["prevent"]), ["home"]),
            At(at(_, ["prevent"]), ["end"])
          ]
        }, {
          default: Ye(() => [
            ge(K.$slots, "trigger", {
              active: f.value,
              value: t.modelValue,
              toggle: x
            }, () => [
              Ct(Pe(K.label), 1)
            ])
          ]),
          _: 3
        }, 40, ["class", "role", "tabindex", "aria-haspopup", "aria-expanded", "aria-activedescendant", "aria-disabled", "aria-controls", "aria-labelledby", "aria-label", "onKeydown"])),
        ee(eO, {
          position: m.value,
          "onUpdate:position": Ae[6] || (Ae[6] = (ut) => m.value = ut),
          teleport: K.teleport,
          class: he([...j(ae), ...j(Ce)]),
          trigger: o.value,
          disabled: !f.value,
          "default-position": "bottom",
          "disable-positioning": !C.value
        }, {
          default: Ye(({ setContent: ut }) => [
            C.value ? (G(), De(Ws, {
              key: 0,
              name: K.animation
            }, {
              default: Ye(() => [
                $t(be("div", {
                  class: he(j(Re)),
                  tabindex: "-1",
                  onClick: b
                }, null, 2), [
                  [gi, f.value]
                ])
              ]),
              _: 1
            }, 8, ["name"])) : de("", !0),
            ee(Ws, { name: K.animation }, {
              default: Ye(() => [
                $t((G(), De(Nr(K.menuTag), {
                  id: K.menuId,
                  ref: (Me) => a.value = ut(Me),
                  tabindex: K.inline ? 0 : -1,
                  class: he(j(Oe)),
                  style: eE(w.value),
                  role: K.selectable ? "listbox" : "menu",
                  "aria-labelledby": j(p),
                  "aria-label": K.ariaLabel,
                  "aria-hidden": !K.inline && (K.disabled || !f.value),
                  "aria-multiselectable": K.selectable ? j(Ss)(K.multiple) : void 0,
                  onKeydown: [
                    Ae[0] || (Ae[0] = At(at((Me) => K.inline && se(Me), ["prevent"]), ["enter"])),
                    Ae[1] || (Ae[1] = At(at((Me) => K.inline && se(Me), ["prevent"]), ["space"])),
                    Ae[2] || (Ae[2] = At(at((Me) => K.inline && V(Me), ["prevent"]), ["up"])),
                    Ae[3] || (Ae[3] = At(at((Me) => K.inline && Z(Me), ["prevent"]), ["down"])),
                    Ae[4] || (Ae[4] = At(at((Me) => K.inline && k(Me), ["prevent"]), ["home"])),
                    Ae[5] || (Ae[5] = At(at((Me) => K.inline && _(Me), ["prevent"]), ["end"]))
                  ]
                }, {
                  default: Ye(() => {
                    var Me;
                    return [
                      ge(K.$slots, "default", {
                        active: f.value,
                        focusedIndex: (Me = N.value) == null ? void 0 : Me.index,
                        toggle: D
                      }, () => [
                        ge(K.$slots, "before"),
                        (G(!0), X(ht, null, xi(u.value, (Fe, jt) => (G(), X(ht, null, [
                          Fe.label ? $t((G(), De(AA, Tt({
                            key: 0,
                            ref_for: !0
                          }, Fe.attrs, {
                            key: Fe.key,
                            value: Fe.value,
                            hidden: Fe.hidden,
                            role: "presentation",
                            clickable: !1
                          }), {
                            default: Ye(() => [
                              K.$slots.group ? ge(K.$slots, "group", {
                                key: 0,
                                group: Fe.label,
                                index: jt
                              }) : (G(), X("span", uwe, Pe(Fe.label), 1))
                            ]),
                            _: 2
                          }, 1040, ["value", "hidden"])), [
                            [gi, !Fe.hidden]
                          ]) : de("", !0),
                          (G(!0), X(ht, null, xi(Fe.options, (Rt) => $t((G(), De(AA, Tt({ ref_for: !0 }, Rt.attrs, {
                            key: Rt.key,
                            value: Rt.value,
                            hidden: Rt.hidden
                          }), {
                            default: Ye(() => [
                              Ct(Pe(Rt.label), 1)
                            ]),
                            _: 2
                          }, 1040, ["value", "hidden"])), [
                            [gi, !Rt.hidden]
                          ])), 128))
                        ], 64))), 256)),
                        ge(K.$slots, "after")
                      ])
                    ];
                  }),
                  _: 2
                }, 1064, ["id", "tabindex", "class", "style", "role", "aria-labelledby", "aria-label", "aria-hidden", "aria-multiselectable"])), [
                  [gi, !K.disabled && f.value || K.inline]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled", "disable-positioning"])
      ], 34));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const dwe = { key: 1 }, hwe = { key: 1 }, gwe = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OAutocomplete",
    configField: "autocomplete",
    inheritAttrs: !1,
    __name: "Autocomplete",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      modelValue: { default: void 0 },
      input: { default: "" },
      active: { type: Boolean, default: !1 },
      options: { default: void 0 },
      filter: { type: Function, default: void 0 },
      type: { default: "text" },
      menuTag: { default: () => W("autocomplete.menuTag", "div") },
      itemTag: { default: () => W("autocomplete.itemTag", "div") },
      size: { default: () => W("autocomplete.size") },
      position: { default: () => W("autocomplete.position", "auto") },
      placeholder: { default: void 0 },
      expanded: { type: Boolean, default: !1 },
      rounded: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      maxlength: { default: void 0 },
      debounce: { default: () => W("autocomplete.debounce", 400) },
      keepFirst: { type: Boolean, default: () => W("autocomplete.keepFirst", !1) },
      keepOpen: { type: Boolean, default: () => W("autocomplete.keepOpen", !1) },
      clearOnSelect: { type: Boolean, default: () => W("autocomplete.clearOnSelect", !1) },
      openOnFocus: { type: Boolean, default: () => W("autocomplete.openOnFocus", !1) },
      selectOnClose: { type: Boolean, default: !1 },
      selectableHeader: { type: Boolean, default: !1 },
      selectableFooter: { type: Boolean, default: !1 },
      maxHeight: { default: () => W("autocomplete.maxHeight") },
      checkScroll: { type: Boolean, default: () => W("autocomplete.checkScroll", !1) },
      iconPack: { default: () => W("autocomplete.iconPack") },
      icon: { default: () => W("autocomplete.icon") },
      iconClickable: { type: Boolean, default: !1 },
      iconRight: { default: () => W("autocomplete.iconRight") },
      iconRightClickable: { type: Boolean, default: !1 },
      iconRightVariant: { default: void 0 },
      clearable: { type: Boolean, default: () => W("autocomplete.clearable", !1) },
      clearIcon: { default: () => W("autocomplete.clearIcon", "close-circle") },
      statusIcon: { type: Boolean, default: () => W("statusIcon", !0) },
      mobileModal: { type: Boolean, default: () => W("autocomplete.mobileModal", !1) },
      desktopModal: { type: Boolean, default: () => W("dropdown.desktopModal", !1) },
      animation: { default: () => W("autocomplete.animation", "fade") },
      autocomplete: { default: () => W("autocomplete.autocomplete", "off") },
      useHtml5Validation: { type: Boolean, default: () => W("useHtml5Validation", !0) },
      customValidity: { type: [String, Function], default: void 0 },
      teleport: { type: [Boolean, String, Object], default: () => W("autocomplete.teleport", !1) },
      rootClass: {},
      itemClass: {},
      itemGroupTitleClass: {},
      itemEmptyClass: {},
      itemHeaderClass: {},
      itemFooterClass: {},
      inputClasses: { default: () => W("autocomplete.inputClasses", {}) }
    }, {
      active: { type: Boolean, default: !1 },
      activeModifiers: {},
      modelValue: { default: void 0 },
      modelModifiers: {},
      input: { default: "" },
      inputModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:model-value", "update:input", "update:active", "input", "select", "select-header", "select-footer", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"], ["update:active", "update:modelValue", "update:input"]),
    setup(t, { expose: e, emit: i }) {
      const r = t, n = i, s = Ng(), o = cs("inputComponent"), { checkHtml5Validity: a, onInvalid: A, onFocus: l, onBlur: c, isFocused: u, setFocus: d } = rw(o, n, r), { parentField: h } = hc(), g = Hi(t, "active"), f = Hi(t, "modelValue"), p = Hi(t, "input"), m = Pn(), { nextSequence: E } = Vd(), y = O(() => {
        const P = kf(r.options, E);
        return tO(P, E());
      });
      vi(() => {
        iQ(y, (P) => C(P, p)), ll(y);
      });
      function C(P, ie) {
        var V;
        return typeof r.filter == "function" ? r.filter(P.value, zt(ie)) : !String(P.label).toLowerCase().includes((V = zt(ie)) == null ? void 0 : V.toLowerCase());
      }
      if (f.value) {
        const P = DM(y, f);
        P && (p.value = P.label);
      }
      const w = O(() => iO(y));
      ct(w, (P) => {
        u.value && (g.value = !P || !!s.empty);
      });
      const M = ue();
      ct(
        p,
        (P) => {
          const ie = DM(y, f);
          ie && ie.label !== P && (f.value = void 0, M.value = void 0), w.value && !s.empty && (g.value = !1);
        },
        { flush: "post" }
      );
      function I(P) {
        let ie;
        P === 0 ? n("select-header") : P === 1 ? n("select-footer") : P && (ie = Awe(y).find((Z) => Z.value === P)), M.value = ie, f.value = ie == null ? void 0 : ie.value, n("select", ie == null ? void 0 : ie.value), p.value = r.clearOnSelect ? "" : (ie == null ? void 0 : ie.label) || "", a(), r.keepOpen ? d() : g.value = !1;
      }
      function b(P, ie) {
        u.value && (!g.value && P && (!w.value || s.empty) ? g.value = !0 : g.value && !P && !r.keepOpen && (g.value = !1)), n("input", P, ie), a();
      }
      function B(P) {
        var ie;
        r.openOnFocus && ((ie = r.options) != null && ie.length || s.header || s.footer) && (g.value = !0), l(P);
      }
      function x(P) {
        c(P);
      }
      const Q = O(
        () => r.clearable && p.value && r.clearIcon ? r.clearIcon : r.iconRight
      ), v = O(
        () => r.clearable ? !0 : r.iconRightClickable
      );
      function T(P) {
        r.clearable ? p.value = "" : n("icon-right-click", P);
      }
      const S = Sy(), D = O(() => {
        var P;
        return {
          ...(P = h == null ? void 0 : h.value) == null ? void 0 : P.inputAttrs,
          ...S,
          ...r.inputClasses
        };
      }), F = ye(["rootClass", "o-autocomplete"]), R = ye(["itemClass", "o-autocomplete__item"]), Y = ye([
        "itemEmptyClass",
        "o-autocomplete__item--empty"
      ]), L = ye([
        "itemGroupTitleClass",
        "o-autocomplete__item-group-title"
      ]), N = ye([
        "itemHeaderClass",
        "o-autocomplete__item-header"
      ]), H = ye([
        "itemFooterClass",
        "o-autocomplete__item-footer"
      ]);
      return e({ focus: d, value: p }), (P, ie) => (G(), De(nO, {
        modelValue: M.value,
        "onUpdate:modelValue": ie[2] || (ie[2] = (V) => M.value = V),
        active: g.value,
        "onUpdate:active": ie[3] || (ie[3] = (V) => g.value = V),
        "data-oruga": "autocomplete",
        class: he(j(F)),
        "menu-id": j(m),
        "menu-tag": P.menuTag,
        triggers: [],
        scrollable: "",
        selectable: "",
        "keep-open": P.keepOpen,
        "keep-first": P.keepFirst,
        "check-scroll": P.checkScroll,
        "select-on-close": P.selectOnClose,
        disabled: P.disabled,
        "desktop-modal": P.desktopModal,
        "mobile-modal": P.mobileModal,
        "max-height": P.maxHeight,
        animation: P.animation,
        position: P.position,
        teleport: P.teleport,
        expanded: P.expanded,
        onSelect: I,
        onScrollStart: ie[4] || (ie[4] = (V) => n("scroll-start")),
        onScrollEnd: ie[5] || (ie[5] = (V) => n("scroll-end"))
      }, {
        trigger: Ye(() => [
          ee(q1, Tt({ ref: "inputComponent" }, D.value, {
            modelValue: p.value,
            "onUpdate:modelValue": ie[0] || (ie[0] = (V) => p.value = V),
            type: P.type,
            size: P.size,
            rounded: P.rounded,
            icon: P.icon,
            "icon-right": Q.value,
            "icon-right-clickable": v.value,
            "icon-pack": P.iconPack,
            placeholder: P.placeholder,
            maxlength: P.maxlength,
            autocomplete: P.autocomplete,
            expanded: P.expanded,
            disabled: P.disabled,
            "status-icon": P.statusIcon,
            debounce: P.debounce,
            "aria-autocomplete": P.keepFirst ? "both" : "list",
            "aria-controls": j(m),
            enterkeyhint: "enter",
            "use-html5-validation": !1,
            onInput: b,
            onFocus: B,
            onBlur: x,
            onInvalid: j(A),
            onIconClick: ie[1] || (ie[1] = (V) => n("icon-click", V)),
            onIconRightClick: T
          }), null, 16, ["modelValue", "type", "size", "rounded", "icon", "icon-right", "icon-right-clickable", "icon-pack", "placeholder", "maxlength", "autocomplete", "expanded", "disabled", "status-icon", "debounce", "aria-autocomplete", "aria-controls", "onInvalid"])
        ]),
        default: Ye(() => [
          P.$slots.header ? (G(), De(AA, {
            key: 0,
            tag: P.itemTag,
            value: 0,
            clickable: P.selectableHeader,
            class: he([...j(R), ...j(N)])
          }, {
            default: Ye(() => [
              ge(P.$slots, "header")
            ]),
            _: 3
          }, 8, ["tag", "value", "clickable", "class"])) : de("", !0),
          (G(!0), X(ht, null, xi(y.value, (V, Z) => (G(), X(ht, null, [
            V.label ? $t((G(), De(AA, Tt({
              key: V.key,
              ref_for: !0
            }, V.attrs, {
              hidden: V.hidden,
              value: V.value,
              tag: P.itemTag,
              role: "presentation",
              clickable: !1,
              class: [...j(R), ...j(L)]
            }), {
              default: Ye(() => [
                P.$slots.group ? ge(P.$slots, "group", {
                  key: 0,
                  group: V.label,
                  index: Z
                }) : (G(), X("span", dwe, Pe(V.label), 1))
              ]),
              _: 2
            }, 1040, ["hidden", "value", "tag", "class"])), [
              [gi, !V.hidden]
            ]) : de("", !0),
            (G(!0), X(ht, null, xi(V.options, (se, k) => $t((G(), De(AA, Tt({
              key: se.key,
              ref_for: !0
            }, se.attrs, {
              value: se.value,
              hidden: se.hidden,
              tag: P.itemTag,
              class: j(R)
            }), {
              default: Ye(() => [
                P.$slots.default ? ge(P.$slots, "default", {
                  key: 0,
                  option: se,
                  value: se.value,
                  index: k
                }) : (G(), X("span", hwe, Pe(se.label), 1))
              ]),
              _: 2
            }, 1040, ["value", "hidden", "tag", "class"])), [
              [gi, !se.hidden]
            ])), 128))
          ], 64))), 256)),
          w.value && P.$slots.empty ? (G(), De(AA, {
            key: 1,
            tag: P.itemTag,
            class: he([...j(R), ...j(Y)])
          }, {
            default: Ye(() => [
              ge(P.$slots, "empty")
            ]),
            _: 3
          }, 8, ["tag", "class"])) : de("", !0),
          P.$slots.footer ? (G(), De(AA, {
            key: 2,
            tag: P.itemTag,
            value: 1,
            clickable: P.selectableFooter,
            class: he([...j(R), ...j(H)])
          }, {
            default: Ye(() => [
              ge(P.$slots, "footer")
            ]),
            _: 3
          }, 8, ["tag", "value", "clickable", "class"])) : de("", !0)
        ]),
        _: 3
      }, 8, ["modelValue", "active", "class", "menu-id", "menu-tag", "keep-open", "keep-first", "check-scroll", "select-on-close", "disabled", "desktop-modal", "mobile-modal", "max-height", "animation", "position", "teleport", "expanded"]));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const fwe = {
    install(t) {
      Br(t, gwe);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const sO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OButton",
    configField: "button",
    __name: "Button",
    props: {
      override: { type: Boolean, default: void 0 },
      tag: { default: () => W("button.tag", "button") },
      variant: { default: () => W("button.variant") },
      size: { default: () => W("button.size") },
      label: { default: void 0 },
      iconPack: { default: () => W("button.iconPack") },
      iconLeft: { default: void 0 },
      iconRight: { default: void 0 },
      rounded: { type: Boolean, default: () => W("button.rounded", !1) },
      expanded: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      outlined: { type: Boolean, default: !1 },
      loading: { type: Boolean, default: !1 },
      inverted: { type: Boolean, default: !1 },
      type: { default: "button" },
      iconBoth: { type: Boolean, default: !1 },
      rootClass: {},
      sizeClass: {},
      variantClass: {},
      outlinedClass: {},
      invertedClass: {},
      loadingClass: {},
      expandedClass: {},
      roundedClass: {},
      disabledClass: {},
      wrapperClass: {},
      iconClass: {},
      iconLeftClass: {},
      iconRightClass: {},
      labelClass: {}
    },
    emits: ["click"],
    setup(t) {
      const e = t, i = O(
        () => typeof e.disabled < "u" && e.disabled !== !1 ? "button" : e.tag
      ), r = O(
        () => e.tag === "button" || e.tag === "input" ? e.type : null
      ), n = ye(
        ["rootClass", "o-button"],
        [
          "sizeClass",
          "o-button--",
          O(() => e.size),
          O(() => !!e.size)
        ],
        [
          "variantClass",
          "o-button--",
          O(() => e.variant),
          O(() => !!e.variant && !e.outlined && !e.inverted)
        ],
        [
          "outlinedClass",
          "o-button--outlined",
          null,
          O(() => e.outlined && !e.variant)
        ],
        [
          "invertedClass",
          "o-button--inverted",
          null,
          O(() => e.inverted && !e.variant)
        ],
        [
          "outlinedClass",
          "o-button--outlined-",
          O(() => e.variant),
          O(() => e.outlined && !!e.variant)
        ],
        [
          "invertedClass",
          "o-button--inverted-",
          O(() => e.variant),
          O(() => e.inverted && !!e.variant)
        ],
        [
          "expandedClass",
          "o-button--expanded",
          null,
          O(() => e.expanded)
        ],
        ["loadingClass", "o-button--loading", null, O(() => e.loading)],
        ["roundedClass", "o-button--rounded", null, O(() => e.rounded)],
        [
          "disabledClass",
          "o-button--disabled",
          null,
          O(() => e.disabled)
        ]
      ), s = ye(["wrapperClass", "o-button__wrapper"]), o = ye(["labelClass", "o-button__label"]), a = ye(["iconClass", "o-button__icon"]), A = ye(["iconLeftClass", "o-button__icon-left"]), l = ye([
        "iconRightClass",
        "o-button__icon-right"
      ]);
      return (c, u) => (G(), De(Nr(i.value), {
        "data-oruga": "button",
        type: r.value,
        role: "button",
        tabindex: "0",
        class: he(j(n)),
        disabled: c.disabled ? !0 : null,
        onClick: u[0] || (u[0] = (d) => c.$emit("click", d)),
        onKeydown: [
          u[1] || (u[1] = At((d) => c.$emit("click", d), ["enter"])),
          u[2] || (u[2] = At((d) => c.$emit("click", d), ["space"]))
        ]
      }, {
        default: Ye(() => [
          be("span", {
            class: he(j(s))
          }, [
            c.iconLeft ? (G(), De(Fr, {
              key: 0,
              pack: c.iconPack,
              icon: c.iconLeft,
              size: c.size,
              both: c.iconBoth,
              class: he([...j(a), ...j(A)])
            }, null, 8, ["pack", "icon", "size", "both", "class"])) : de("", !0),
            c.label || c.$slots.default ? (G(), X("span", {
              key: 1,
              class: he(j(o))
            }, [
              ge(c.$slots, "default", {}, () => [
                Ct(Pe(c.label), 1)
              ])
            ], 2)) : de("", !0),
            c.iconRight ? (G(), De(Fr, {
              key: 2,
              pack: c.iconPack,
              icon: c.iconRight,
              size: c.size,
              both: c.iconBoth,
              class: he([...j(a), ...j(l)])
            }, null, 8, ["pack", "icon", "size", "both", "class"])) : de("", !0)
          ], 2)
        ]),
        _: 3
      }, 40, ["type", "class", "disabled"]));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const pwe = {
    install(t) {
      Br(t, sO);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const mwe = ["id", "name", "value", "true-value", "false-value", "required", "indeterminate", "disabled", "autocomplete", "aria-checked", "aria-labelledby"], Ewe = ["id", "for"], xh = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OCheckbox",
    configField: "checkbox",
    inheritAttrs: !1,
    __name: "Checkbox",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      modelValue: { default: void 0 },
      variant: { default: () => W("checkbox.variant") },
      size: { default: () => W("checkbox.size") },
      label: { default: void 0 },
      indeterminate: { type: Boolean, default: !1 },
      nativeValue: { default: void 0 },
      disabled: { type: Boolean, default: !1 },
      required: { type: Boolean, default: !1 },
      name: { default: void 0 },
      trueValue: { default: void 0 },
      falseValue: { default: void 0 },
      autocomplete: { default: () => W("checkbox.autocomplete", "off") },
      id: { default: () => Pn() },
      useHtml5Validation: { type: Boolean, default: () => W("useHtml5Validation", !0) },
      customValidity: { type: [String, Function], default: "" },
      rootClass: {},
      sizeClass: {},
      variantClass: {},
      disabledClass: {},
      checkedClass: {},
      indeterminateClass: {},
      inputClass: {},
      labelClass: {}
    }, {
      modelValue: { default: void 0 },
      modelModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:model-value", "input", "focus", "blur", "invalid"], ["update:modelValue"]),
    setup(t, { expose: e, emit: i }) {
      var r, n;
      const s = t, o = i, a = cs("inputElement"), { onBlur: A, onFocus: l, onInvalid: c, setFocus: u } = rw(
        a,
        o,
        s
      ), { parentField: d } = hc(), h = d.value || s.label || Ng().default ? ((r = d.value) == null ? void 0 : r.labelId) || Pn() : void 0;
      !s.label && s.id && ((n = d.value) == null || n.setInputId(s.id));
      const g = Hi(t, "modelValue"), f = O(
        () => g.value === (s.trueValue ?? !0) || Array.isArray(g.value) && g.value.includes(s.nativeValue)
      );
      function p(M) {
        o("input", g.value, M);
      }
      const m = Sy(), E = O(() => {
        var M;
        return {
          ...(M = d.value) == null ? void 0 : M.inputAttrs,
          ...m
        };
      }), y = ye(
        ["rootClass", "o-checkbox"],
        [
          "sizeClass",
          "o-checkbox--",
          O(() => s.size),
          O(() => !!s.size)
        ],
        [
          "variantClass",
          "o-checkbox--",
          O(() => s.variant),
          O(() => !!s.variant)
        ],
        [
          "disabledClass",
          "o-checkbox--disabled",
          null,
          O(() => s.disabled)
        ],
        ["checkedClass", "o-checkbox--checked", null, f],
        [
          "indeterminateClass",
          "o-checkbox--indeterminate",
          null,
          O(() => s.indeterminate)
        ]
      ), C = ye(["inputClass", "o-checkbox__input"]), w = ye(["labelClass", "o-checkbox__label"]);
      return e({ focus: u, value: g }), (M, I) => (G(), X("div", {
        "data-oruga": "checkbox",
        class: he(j(y))
      }, [
        $t(be("input", Tt(E.value, {
          id: M.id,
          ref: "inputElement",
          "onUpdate:modelValue": I[0] || (I[0] = (b) => g.value = b),
          type: "checkbox",
          "data-oruga-input": "checkbox",
          class: j(C),
          name: M.name,
          value: M.nativeValue,
          "true-value": M.trueValue ?? !0,
          "false-value": M.falseValue ?? !1,
          required: M.required,
          indeterminate: M.indeterminate,
          disabled: M.disabled,
          autocomplete: M.autocomplete,
          "aria-checked": M.indeterminate ? "mixed" : f.value,
          "aria-labelledby": j(h),
          onBlur: I[1] || (I[1] = //@ts-ignore
          (...b) => j(A) && j(A)(...b)),
          onFocus: I[2] || (I[2] = //@ts-ignore
          (...b) => j(l) && j(l)(...b)),
          onInvalid: I[3] || (I[3] = //@ts-ignore
          (...b) => j(c) && j(c)(...b)),
          onChange: p
        }), null, 16, mwe), [
          [DG, g.value]
        ]),
        M.label || M.$slots.default ? (G(), X("label", {
          key: 0,
          id: j(h),
          for: M.id,
          class: he(j(w))
        }, [
          ge(M.$slots, "default", {}, () => [
            Ct(Pe(M.label), 1)
          ])
        ], 10, Ewe)) : de("", !0)
      ], 2));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const ywe = {
    install(t) {
      Br(t, xh);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Bwe = ["id", "aria-controls", "aria-expanded"], wwe = ["id", "aria-labelledby"], Cwe = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OCollapse",
    configField: "collapse",
    __name: "Collapse",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      open: { type: Boolean, default: !0 },
      animation: { default: () => W("collapse.animation", "fade") },
      position: { default: () => W("collapse.position", "top") },
      expanded: { type: Boolean, default: !1 },
      contentId: { default: () => Pn() },
      triggerId: { default: () => Pn() },
      rootClass: {},
      expandedClass: {},
      positionClass: {},
      triggerClass: {},
      contentClass: {}
    }, {
      open: { type: Boolean, default: !0 },
      openModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:open", "open", "close"], ["update:open"]),
    setup(t, { emit: e }) {
      const i = t, r = e, n = Hi(t, "open");
      function s() {
        n.value = !n.value, n.value ? r("open") : r("close");
      }
      const o = ye(
        ["rootClass", "o-collapse"],
        [
          "positionClass",
          "o-collapse--",
          O(() => i.position),
          O(() => !!i.position)
        ]
      ), a = ye(
        ["triggerClass", "o-collapse__trigger"],
        [
          "expandedClass",
          "o-collapse__trigger--expanded",
          null,
          O(() => i.expanded)
        ]
      ), A = ye(["contentClass", "o-collapse__content"]);
      return (l, c) => (G(), X("div", {
        "data-oruga": "collapse",
        class: he(j(o))
      }, [
        be("div", {
          id: l.triggerId,
          class: he(j(a)),
          role: "button",
          tabindex: "0",
          "aria-controls": l.contentId,
          "aria-expanded": n.value,
          onClick: s,
          onKeydown: [
            At(s, ["enter"]),
            At(s, ["space"])
          ]
        }, [
          ge(l.$slots, "trigger", { open: n.value })
        ], 42, Bwe),
        ee(Ws, { name: l.animation }, {
          default: Ye(() => [
            $t(be("div", {
              id: l.contentId,
              class: he(j(A)),
              "aria-labelledby": l.triggerId
            }, [
              ge(l.$slots, "default")
            ], 10, wwe), [
              [gi, n.value]
            ])
          ]),
          _: 3
        }, 8, ["name"])
      ], 2));
    }
  }), bwe = {
    install(t) {
      Br(t, Cwe);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Mwe = ["id", "autocomplete", "multiple", "size", "disabled", "required"], Iwe = {
    key: 0,
    value: "",
    disabled: "",
    hidden: ""
  }, vwe = ["label", "value"], xwe = ["value", "selected"], Qwe = ["value", "selected"], oO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OSelect",
    configField: "select",
    inheritAttrs: !1,
    __name: "Select",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      modelValue: { default: void 0 },
      multiple: {},
      options: { default: void 0 },
      size: { default: () => W("select.size") },
      variant: { default: () => W("select.variant") },
      placeholder: { default: void 0 },
      disabled: { type: Boolean, default: !1 },
      required: { type: Boolean, default: !1 },
      expanded: { type: Boolean, default: !1 },
      rounded: { type: Boolean, default: !1 },
      nativeSize: { default: void 0 },
      iconPack: { default: () => W("select.iconPack") },
      icon: { default: () => W("select.icon") },
      iconClickable: { type: Boolean, default: !1 },
      iconRight: { default: () => W("select.iconRight") },
      iconRightClickable: { type: Boolean, default: !1 },
      iconRightVariant: { default: void 0 },
      id: { default: () => Pn() },
      autocomplete: { default: () => W("select.autocomplete", "off") },
      statusIcon: { type: Boolean, default: () => W("statusIcon", !0) },
      useHtml5Validation: { type: Boolean, default: () => W("useHtml5Validation", !0) },
      customValidity: {},
      rootClass: {},
      sizeClass: {},
      variantClass: {},
      expandedClass: {},
      disabledClass: {},
      roundedClass: {},
      hasIconRightClass: {},
      multipleClass: {},
      selectClass: {},
      placeholderClass: {},
      arrowedClass: {},
      iconLeftSpaceClass: {},
      iconRightSpaceClass: {},
      iconLeftClass: {},
      iconRightClass: {}
    }, {
      modelValue: {
        default: void 0
      },
      modelModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:model-value", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue"]),
    setup(t, { expose: e, emit: i }) {
      var r;
      const n = t, s = i, o = cs("selectElement"), { checkHtml5Validity: a, onBlur: A, onFocus: l, onInvalid: c, setFocus: u, isValid: d } = rw(o, s, n), { parentField: h, statusVariant: g, statusVariantIcon: f } = hc();
      n.id && ((r = h == null ? void 0 : h.value) == null || r.setInputId(n.id));
      const p = Hi(t, "modelValue", {
        get: (F) => typeof F < "u" ? F : n.multiple ? [] : "",
        set: (F) => typeof F < "u" ? F : n.multiple ? [] : void 0
      });
      ct(
        p,
        (F) => {
          h != null && h.value && h.value.setFilled(!!F), d.value || a();
        },
        { immediate: !0, flush: "post" }
      );
      const { nextSequence: m } = Vd(), E = O(
        () => kf(n.options, m)
      ), y = O(
        () => !Ss(n.multiple) && (!Qr(p.value) || p.value === "")
      ), C = O(
        () => !!n.iconRight && !Ss(n.multiple) || n.statusIcon && !!f.value
      ), w = O(
        () => n.iconRight ? n.iconRight : f.value
      ), M = O(
        () => n.iconRight ? n.iconRightVariant || n.variant : g.value
      );
      function I(F, R) {
        s(F, R), ji(() => u());
      }
      function b(F) {
        n.iconClickable && I("icon-click", F);
      }
      function B(F) {
        n.iconRightClickable && I("icon-right-click", F);
      }
      const x = Sy(), Q = O(() => {
        var F;
        return {
          ...(F = h == null ? void 0 : h.value) == null ? void 0 : F.inputAttrs,
          ...x
        };
      }), v = ye(
        ["rootClass", "o-select"],
        [
          "sizeClass",
          "o-select--",
          O(() => n.size),
          O(() => !!n.size)
        ],
        [
          "variantClass",
          "o-select--",
          O(() => g.value || n.variant),
          O(() => !!g.value || !!n.variant)
        ],
        [
          "expandedClass",
          "o-select--expanded",
          null,
          O(() => n.expanded)
        ],
        [
          "disabledClass",
          "o-select--disabled",
          null,
          O(() => Ss(n.disabled))
        ],
        [
          "roundedClass",
          "o-select--rounded",
          null,
          O(() => Ss(n.rounded))
        ],
        ["hasIconRightClass", "o-select--icon-right", null, C],
        [
          "multipleClass",
          "o-select--multiple",
          null,
          O(() => Ss(n.multiple))
        ]
      ), T = ye(
        ["selectClass", "o-select__input"],
        [
          "iconLeftSpaceClass",
          "o-select__input--iconspace-left",
          null,
          O(() => !!n.icon)
        ],
        [
          "iconRightSpaceClass",
          "o-select__input--iconspace-right",
          null,
          C
        ],
        [
          "placeholderClass",
          "o-select__input--placeholder",
          null,
          y
        ],
        [
          "arrowedClass",
          "o-select__input--arrowed",
          null,
          O(() => !C.value && !Ss(n.multiple))
        ]
      ), S = ye(["iconLeftClass", "o-select__icon-left"]), D = ye([
        "iconRightClass",
        "o-select__icon-right"
      ]);
      return e({ focus: u, value: p }), (F, R) => (G(), X("div", {
        "data-oruga": "select",
        class: he(j(v))
      }, [
        F.icon ? (G(), De(Fr, {
          key: 0,
          class: he(j(S)),
          clickable: F.iconClickable,
          icon: F.icon,
          pack: F.iconPack,
          size: F.size,
          onClick: R[0] || (R[0] = (Y) => b(Y))
        }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : de("", !0),
        $t(be("select", Tt(Q.value, {
          id: F.id,
          ref: "selectElement",
          "onUpdate:modelValue": R[1] || (R[1] = (Y) => p.value = Y),
          "data-oruga-input": "select",
          class: j(T),
          autocomplete: F.autocomplete,
          multiple: n.multiple,
          size: F.nativeSize,
          disabled: F.disabled,
          required: F.required,
          onBlur: R[2] || (R[2] = //@ts-ignore
          (...Y) => j(A) && j(A)(...Y)),
          onFocus: R[3] || (R[3] = //@ts-ignore
          (...Y) => j(l) && j(l)(...Y)),
          onInvalid: R[4] || (R[4] = //@ts-ignore
          (...Y) => j(c) && j(c)(...Y))
        }), [
          F.placeholder || F.$slots.placeholder ? (G(), X(ht, { key: 0 }, [
            y.value ? (G(), X("option", Iwe, [
              ge(F.$slots, "placeholder", {}, () => [
                Ct(Pe(F.placeholder), 1)
              ])
            ])) : de("", !0)
          ], 64)) : de("", !0),
          ge(F.$slots, "default", {}, () => [
            (G(!0), X(ht, null, xi(E.value, (Y) => (G(), X(ht, {
              key: Y.key
            }, [
              j(Yf)(Y) ? $t((G(), X("optgroup", Tt({
                key: 0,
                ref_for: !0
              }, Y.attrs, {
                label: Y.label,
                value: Y.value
              }), [
                (G(!0), X(ht, null, xi(Y.options, (L) => $t((G(), X("option", Tt({ ref_for: !0 }, L.attrs, {
                  key: L.key,
                  value: L.value,
                  selected: Y.value === p.value
                }), Pe(L.label), 17, xwe)), [
                  [gi, !L.hidden]
                ])), 128))
              ], 16, vwe)), [
                [gi, !Y.hidden]
              ]) : $t((G(), X("option", Tt({
                key: 1,
                ref_for: !0
              }, Y.attrs, {
                value: Y.value,
                selected: Y.value === p.value
              }), Pe(Y.label), 17, Qwe)), [
                [gi, !Y.hidden]
              ])
            ], 64))), 128))
          ])
        ], 16, Mwe), [
          [TG, p.value]
        ]),
        C.value ? (G(), De(Fr, {
          key: 1,
          class: he(j(D)),
          clickable: F.iconRightClickable,
          icon: w.value,
          pack: F.iconPack,
          size: F.size,
          variant: M.value,
          both: "",
          onClick: B
        }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : de("", !0)
      ], 2));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Fwe = {
    install(t) {
      Br(t, nO), Br(t, AA);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Swe = ["id", "for"], Dwe = ["id", "for"], aO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OField",
    configField: "field",
    __name: "Field",
    props: {
      override: { type: Boolean, default: void 0 },
      variant: { default: void 0 },
      label: { default: void 0 },
      labelSize: { default: () => W("field.labelsize") },
      labelFor: { default: void 0 },
      labelId: { default: () => Pn() },
      message: { default: void 0 },
      messageTag: { default: () => W("field.messageTag", "p") },
      messageId: { default: () => Pn() },
      grouped: { type: Boolean, default: !1 },
      addons: { type: Boolean, default: !1 },
      multiline: { type: Boolean, default: !1 },
      horizontal: { type: Boolean, default: !1 },
      mobileBreakpoint: { default: () => W("field.mobileBreakpoint") },
      rootClass: {},
      mobileClass: {},
      focusedClass: {},
      filledClass: {},
      bodyClass: {},
      groupedClass: {},
      addonsClass: {},
      multilineClass: {},
      horizontalClass: {},
      horizontalLabelClass: {},
      horizontalBodyClass: {},
      labelClass: {},
      labelSizeClass: {},
      labelVariantClass: {},
      messageClass: {},
      messageVariantClass: {}
    },
    setup(t) {
      const e = t, { isMobile: i } = _f(e.mobileBreakpoint), r = ue(e.labelFor);
      ct(
        () => e.labelFor,
        (F) => r.value = F
      );
      const n = ue(e.variant);
      ct(
        () => e.variant,
        (F) => n.value = F
      );
      const s = ue(e.message);
      ct(
        () => e.message,
        (F) => s.value = F
      ), ct(s, (F) => {
        l.value && l.value.hasInnerField && (l.value.variant || l.value.setVariant(n.value), l.value.message || l.value.setMessage(F));
      });
      const o = ue(!1), a = ue(!1), A = ue(!1), { parentField: l } = hc();
      l.value && l.value.addInnerField();
      const c = Ng(), u = O(() => e.label || !!c.label), d = O(() => !!s.value || !!c.message), h = O(
        () => e.grouped || e.multiline || A.value || g.value
      ), g = O(
        () => e.addons && !e.horizontal && !!c.default
      );
      function f(F) {
        const R = F();
        return R.length === 1 && Array.isArray(R[0].children) ? R[0].children : R;
      }
      const p = cs("rootElement");
      function m() {
        A.value = !0;
      }
      function E(F) {
        o.value = F;
      }
      function y(F) {
        a.value = F;
      }
      function C(F) {
        n.value = F;
      }
      function w(F) {
        s.value = F;
      }
      function M(F) {
        r.value = F;
      }
      const I = O(() => ({
        "aria-labelledby": e.labelId,
        ...n.value === "error" ? { "aria-errormessage": e.messageId } : { "aria-describedby": e.messageId }
      })), b = O(() => ({
        $el: p.value,
        props: e,
        hasInnerField: A.value,
        variant: n.value,
        message: s.value,
        labelId: e.labelId,
        inputAttrs: I.value,
        addInnerField: m,
        setInputId: M,
        setFocus: E,
        setFilled: y,
        setVariant: C,
        setMessage: w
      }));
      iwe(b);
      const B = ye(
        ["rootClass", "o-field"],
        [
          "horizontalClass",
          "o-field--horizontal",
          null,
          O(() => !!e.horizontal)
        ],
        ["mobileClass", "o-field--mobile", null, i],
        ["focusedClass", "o-field--focused", null, o],
        ["filledClass", "o-field--filled", null, a]
      ), x = ye(
        ["labelClass", "o-field__label"],
        [
          "labelSizeClass",
          "o-field__label-",
          O(() => e.labelSize),
          O(() => !!e.labelSize)
        ],
        [
          "labelVariantClass",
          "o-field__label-",
          n,
          O(() => !!n.value)
        ]
      ), Q = ye([
        "horizontalLabelClass",
        "o-field__horizontal-label"
      ]), v = ye([
        "horizontalBodyClass",
        "o-field__horizontal-body"
      ]), T = ye(["bodyClass", "o-field__body"]), S = ye(
        ["rootClass", "o-field"],
        ["groupedClass", "o-field--grouped", null, O(() => e.grouped)],
        [
          "addonsClass",
          "o-field--addons",
          null,
          O(() => !e.grouped && g.value)
        ],
        [
          "multilineClass",
          "o-field--multiline",
          null,
          O(() => e.multiline)
        ]
      ), D = ye(
        ["messageClass", "o-field__message"],
        [
          "messageVariantClass",
          "o-field__message-",
          n,
          O(() => !!n.value)
        ]
      );
      return (F, R) => {
        const Y = Os("OField");
        return G(), X("div", {
          ref: "rootElement",
          "data-oruga": "field",
          class: he(j(B))
        }, [
          F.horizontal ? (G(), X("div", {
            key: 0,
            class: he(j(Q))
          }, [
            u.value ? (G(), X("label", {
              key: 0,
              id: F.labelId,
              for: r.value,
              class: he(j(x))
            }, [
              ge(F.$slots, "label", { label: F.label }, () => [
                Ct(Pe(F.label), 1)
              ])
            ], 10, Swe)) : de("", !0)
          ], 2)) : (G(), X(ht, { key: 1 }, [
            u.value ? (G(), X("label", {
              key: 0,
              id: F.labelId,
              for: r.value,
              class: he(j(x))
            }, [
              ge(F.$slots, "label", { label: F.label }, () => [
                Ct(Pe(F.label), 1)
              ])
            ], 10, Dwe)) : de("", !0)
          ], 64)),
          F.horizontal ? (G(), X("div", {
            key: 2,
            class: he(j(v))
          }, [
            (G(!0), X(ht, null, xi(f(F.$slots.default), (L, N) => (G(), X(ht, { key: N }, [
              j(V4)(L) ? (G(), De(Nr(L), { key: 0 })) : (G(), De(Y, {
                key: 1,
                variant: n.value,
                addons: !1,
                "label-id": F.labelId,
                "message-id": F.messageId,
                "message-tag": F.messageTag,
                "message-class": F.messageClass
              }, ok({
                default: Ye(() => [
                  (G(), De(Nr(L)))
                ]),
                _: 2
              }, [
                N === 0 ? {
                  name: "message",
                  fn: Ye(() => [
                    ge(F.$slots, "message", { message: s.value }, () => [
                      Ct(Pe(s.value), 1)
                    ])
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["variant", "label-id", "message-id", "message-tag", "message-class"]))
            ], 64))), 128))
          ], 2)) : h.value ? (G(), X("div", {
            key: 3,
            class: he(j(T))
          }, [
            be("div", {
              class: he(j(S))
            }, [
              ge(F.$slots, "default")
            ], 2)
          ], 2)) : ge(F.$slots, "default", { key: 4 }),
          d.value && !F.horizontal ? (G(), De(Nr(F.messageTag), {
            key: 5,
            id: F.messageId,
            class: he(j(D))
          }, {
            default: Ye(() => [
              ge(F.$slots, "message", { message: s.value }, () => [
                Ct(Pe(s.value), 1)
              ])
            ]),
            _: 3
          }, 8, ["id", "class"])) : de("", !0)
        ], 2);
      };
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Twe = {
    install(t) {
      Br(t, aO);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Rwe = {
    install(t) {
      Br(t, Fr);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const _we = {
    install(t) {
      Br(t, q1);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const nQ = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OLoading",
    configField: "loading",
    inheritAttrs: !1,
    __name: "Loading",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      active: { type: Boolean, default: !1 },
      fullPage: { type: Boolean, default: !0 },
      label: { default: void 0 },
      animation: { default: () => W("loading.animation", "fade") },
      cancelable: { type: Boolean, default: !1 },
      icon: { default: () => W("loading.icon", "loading") },
      iconSpin: { type: Boolean, default: () => W("loading.iconSpin", !0) },
      iconSize: { default: () => W("loading.iconSize", "medium") },
      clipScroll: { type: Boolean, default: () => W("loading.clipScroll", !1) },
      container: {},
      rootClass: {},
      fullPageClass: {},
      overlayClass: {},
      iconClass: {},
      labelClass: {},
      scrollClipClass: {},
      scrollKeepClass: {}
    }, {
      fullPage: { type: Boolean, default: !0 },
      fullPageModifiers: {},
      active: { type: Boolean, default: !1 },
      activeModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:active", "update:fullPage", "close"], ["update:fullPage", "update:active"]),
    setup(t, { expose: e, emit: i }) {
      const r = t, n = i, s = cs("rootElement"), o = Hi(t, "fullPage"), a = Hi(t, "active"), A = rQ(r.clipScroll);
      ct(a, (p) => {
        o.value && A(p);
      }), wn && Wd(s, "keyup", l, { trigger: a });
      function l(p) {
        a.value && (p.key === "Escape" || p.key === "Esc") && c("escape");
      }
      function c(p) {
        !r.cancelable || Array.isArray(r.cancelable) && !r.cancelable.includes(p) || u({ action: "cancel", method: p });
      }
      function u(...p) {
        a.value = !1, n("close", p);
      }
      const d = ye(
        ["rootClass", "o-loading"],
        ["fullPageClass", "o-loading--fullpage", null, o]
      ), h = ye(["overlayClass", "o-loading__overlay"]), g = ye(["iconClass", "o-loading__icon"]), f = ye(["labelClass", "o-loading__label"]);
      return e({ close: u }), (p, m) => (G(), De(Ws, { name: p.animation }, {
        default: Ye(() => [
          a.value ? (G(), X("div", {
            key: 0,
            ref: "rootElement",
            "data-oruga": "loading",
            class: he(j(d)),
            role: "status",
            "aria-live": "polite"
          }, [
            be("div", {
              class: he(j(h)),
              tabindex: -1,
              onClick: m[0] || (m[0] = (E) => c("outside"))
            }, null, 2),
            ge(p.$slots, "default", { close: u }, () => [
              ee(Fr, {
                icon: p.icon,
                spin: p.iconSpin,
                size: p.iconSize,
                class: he(j(g)),
                both: ""
              }, null, 8, ["icon", "spin", "size", "class"]),
              p.label ? (G(), X("span", {
                key: 0,
                class: he(j(f))
              }, Pe(p.label), 3)) : de("", !0)
            ])
          ], 2)) : de("", !0)
        ]),
        _: 3
      }, 8, ["name"]));
    }
  });
  var kwe = Object.defineProperty, Ywe = (t, e, i) => e in t ? kwe(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i, Nwe = (t, e, i) => Ywe(t, e + "", i);
  class nw {
    constructor() {
      Nwe(this, "entries"), this.entries = [];
    }
    /** Returns the number of registered active instances. */
    count() {
      return this.entries.length;
    }
    /** Returns the first registered active instance. */
    fist() {
      return this.entries.at(0);
    }
    /** Returns the last registered active instance. */
    last() {
      return this.entries.at(-1);
    }
    /** Adds a new instance to the instance stack. */
    add(e) {
      this.entries.push(e);
    }
    /** Removes an instance from the instance stack. */
    remove(e) {
      const i = this.entries.indexOf(e);
      this.entries.splice(i, 1);
    }
    /** Call a function for every registered active instance. */
    walk(e) {
      this.entries = [...this.entries].filter((i) => e(i) !== !0);
    }
  }
  const Uwe = je(
    (t, { expose: e, emit: i, slots: r }) => {
      const n = Uo();
      if (!n)
        throw new Error("ProgrammaticComponent initialisation failed.");
      let s;
      const o = new Promise((A) => s = A);
      er(() => {
        var A;
        return (A = t.registry) == null ? void 0 : A.add(n);
      }), Fs(() => {
        var A;
        return (A = t.registry) == null ? void 0 : A.remove(n);
      });
      function a(...A) {
        i("close", ...A), s(...A), setTimeout(() => {
          wn ? window.requestAnimationFrame(() => i("destroy")) : i("destroy");
        });
      }
      return e({ close: a, promise: o }), () => ee(
        t.component,
        { ...t.props, onClose: a },
        r.default
      );
    },
    {
      name: "ProgrammaticApp",
      // manual runtime props declaration is currently still needed.
      props: ["component", "props", "registry"],
      // manual runtime emits declaration
      emits: ["close", "destroy"],
      // manual runtime slot declaration
      slots: ["default"]
    }
  ), jp = new nw(), sw = {
    /** Returns the number of registered active instances. */
    count: jp.count,
    /**
     * Create a new programmatic component instance.
     * @param component component to render
     * @param options render options
     */
    open(t, e) {
      var i;
      e = { registry: jp, ...e };
      const r = zt(e.target);
      let n = (typeof r == "string" ? (
        // query element if target is a string
        document.querySelector(r)
      ) : (
        // else unwrap element
        Kr(r)
      )) || // else use default
      document.body;
      (i = Km) == null || i.runWithContext(() => {
        const l = bo("$PROGRAMMATIC-TARGET", void 0);
        l && (n = zt(l));
      });
      let s = document.createElement("div");
      s.id = e.appId || "programmatic-app", n.appendChild(s);
      function o() {
        a && (a.unmount(), a = void 0), s && (n.removeChild(s), s = void 0);
      }
      let a = RG(Uwe, {
        registry: e.registry,
        // programmatic registry instance - can be overriden by given in options
        component: t,
        // the component which should be rendered
        props: { ...e.props, container: n },
        // component props including the target as `container`
        onClose: e.onClose,
        // custom onClose handler
        onDestroy: o
        // node destory cleanup handler
      });
      return Km && (a._context = Object.assign(a._context, Km._context)), a.mount(s);
    },
    /** close the last registred instance in the global programmatic instance registry */
    close(...t) {
      var e, i;
      (i = (e = jp.last()) == null ? void 0 : e.exposed) == null || i.close(...t);
    },
    /** close all instances in the global programmatic instance registry */
    closeAll(...t) {
      jp.walk((e) => {
        var i;
        return (i = e.exposed) == null ? void 0 : i.close(...t);
      });
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Hp = new nw(), Lwe = {
    /** Returns the number of registered active instances. */
    count: Hp.count,
    /**
     * Create a new programmatic loading component instance.
     * @param options loading label string or loading component props object
     * @param target specify a target the component get rendered into
     * @returns ProgrammaticExpose
     */
    open(t, e) {
      const i = typeof t == "string" ? { label: t } : t, r = {
        active: !0,
        // set the active default state to true
        fullPage: !1,
        // set the full page default state to false
        ...i
      };
      return sw.open(nQ, {
        registry: Hp,
        // custom programmatic instance registry
        target: e,
        // target the component get rendered into
        props: r,
        // component specific props
        onClose: i.onClose
        // on close event handler
      });
    },
    /** Close the last registred instance in the loading programmatic instance registry. */
    close(...t) {
      var e, i;
      (i = (e = Hp.last()) == null ? void 0 : e.exposed) == null || i.close(...t);
    },
    /** Close all instances in the programmatic loading instance registry. */
    closeAll(...t) {
      Hp.walk((e) => {
        var i;
        return (i = e.exposed) == null ? void 0 : i.close(...t);
      });
    }
  }, zwe = {
    install(t) {
      Br(t, nQ), tw(t, "loading", Lwe);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Pwe = ["aria-label"], Owe = { key: 0 }, AO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "ONotification",
    configField: "notification",
    inheritAttrs: !1,
    __name: "Notification",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      message: { default: void 0 },
      active: { type: Boolean, default: !0 },
      type: { default: void 0 },
      variant: { default: () => W("notification.variant") },
      position: { default: () => W("notification.position", "top") },
      animation: { default: () => W("notification.animation", "fade") },
      icon: { default: void 0 },
      iconPack: { default: () => W("notification.iconPack") },
      iconSize: { default: () => W("notification.iconSize", "large") },
      closable: { type: Boolean, default: !1 },
      closeIcon: { default: () => W("notification.closeIcon", "close") },
      closeIconSize: { default: () => W("notification.closeIconSize") },
      ariaCloseLabel: { default: () => W("notification.ariaCloseLabel", "Close") },
      rootClass: {},
      positionClass: {},
      variantClass: {},
      closeClass: {},
      contentClass: {},
      iconClass: {},
      wrapperClass: {}
    }, {
      active: { type: Boolean, default: !0 },
      activeModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:active", "close"], ["update:active"]),
    setup(t, { emit: e }) {
      const i = t, r = e, n = Hi(t, "active"), s = O(() => {
        if (i.icon) return i.icon;
        switch (i.type) {
          case "info":
            return "information";
          case "success":
            return "check-circle";
          case "warning":
            return "alert";
          case "danger":
            return "alert-circle";
          default:
            return null;
        }
      });
      function o(...d) {
        n.value = !1, r("close", ...d);
      }
      const a = ye(
        ["rootClass", "o-notification"],
        [
          "variantClass",
          "o-notification--",
          O(() => i.variant),
          O(() => !!i.variant)
        ],
        [
          "positionClass",
          "o-notification--",
          O(() => i.position),
          O(() => !!i.position)
        ]
      ), A = ye([
        "wrapperClass",
        "o-notification__wrapper"
      ]), l = ye(["iconClass", "o-notification__icon"]), c = ye([
        "contentClass",
        "o-notification__content"
      ]), u = ye(["closeClass", "o-notification__close"]);
      return (d, h) => (G(), De(Ws, { name: d.animation }, {
        default: Ye(() => [
          $t(be("article", Tt(d.$attrs, {
            "data-oruga": "notification",
            class: j(a)
          }), [
            d.closable ? (G(), X("button", {
              key: 0,
              class: he(j(u)),
              type: "button",
              "aria-label": d.ariaCloseLabel,
              onClick: h[0] || (h[0] = (g) => o({ action: "close", method: "x" }))
            }, [
              ee(Fr, {
                clickable: "",
                pack: d.iconPack,
                icon: d.closeIcon,
                size: d.closeIconSize,
                both: ""
              }, null, 8, ["pack", "icon", "size"])
            ], 10, Pwe)) : de("", !0),
            ge(d.$slots, "inner", { close: o }),
            d.$slots.default || d.message ? (G(), X("div", {
              key: 1,
              class: he(j(A))
            }, [
              s.value ? (G(), De(Fr, {
                key: 0,
                icon: s.value,
                pack: d.iconPack,
                class: he(j(l)),
                size: d.iconSize,
                both: "",
                "aria-hidden": ""
              }, null, 8, ["icon", "pack", "class", "size"])) : de("", !0),
              be("div", {
                class: he(j(c))
              }, [
                ge(d.$slots, "default", { close: o }, () => [
                  d.message ? (G(), X("span", Owe, Pe(d.message), 1)) : de("", !0)
                ])
              ], 2)
            ], 2)) : de("", !0)
          ], 16), [
            [gi, n.value]
          ])
        ]),
        _: 3
      }, 8, ["name"]));
    }
  }), Gwe = /* @__PURE__ */ je({
    isOruga: !0,
    name: "ONotificationNotice",
    configField: "notification",
    inheritAttrs: !1,
    __name: "NotificationNotice",
    props: {
      override: { type: Boolean, default: void 0 },
      container: { default: void 0 },
      position: { default: () => W("notification.position", "top") },
      variant: { default: () => W("notification.variant") },
      duration: { default: () => W("notification.duration", 2e3) },
      infinite: { type: Boolean, default: !1 },
      queue: { type: Boolean, default: () => W("notification.queue") },
      component: { default: void 0 },
      props: { default: void 0 },
      events: { default: void 0 },
      noticeClass: {},
      noticePositionClass: {},
      noticeContainerClass: {}
    },
    emits: ["close"],
    setup(t, { expose: e, emit: i }) {
      const r = t, n = i, s = cs("notificationComponent"), o = ue(!0), a = ue(null), A = ue(null), l = ue();
      _G(() => {
        if (p.value && E.value && m.value) {
          const C = Cu(p.value), w = Cu(m.value), M = Cu(E.value);
          if (a.value = r.container.querySelector(
            `.${C.join(".")}.${w.join(".")}`
          ), A.value = r.container.querySelector(
            `.${C.join(".")}.${M.join(".")}`
          ), a.value && A.value) return;
          if (a.value || (a.value = document.createElement("div"), a.value.className = `${C.join(
            " "
          )} ${w.join(" ")}`, a.value.role = "region", a.value.ariaLive = "polite"), A.value || (A.value = document.createElement("div"), A.value.className = `${C.join(
            " "
          )} ${M.join(" ")}`, A.value.role = "region", A.value.ariaLive = "polite"), r.container.appendChild(a.value), r.container.appendChild(A.value), r.container.tagName !== "BODY") {
            const I = Cu(y.value);
            I != null && I.length && I.filter((b) => !!b).forEach((b) => {
              var B, x;
              (B = a.value) == null || B.classList.add(b), (x = A.value) == null || x.classList.add(b);
            });
          }
        }
      }), er(() => {
        h(), g();
      });
      const c = O(() => {
        switch (r.position) {
          case "top-right":
          case "top":
          case "top-left":
            return a.value;
          case "bottom-right":
          case "bottom":
          case "bottom-left":
            return A.value;
          default:
            return null;
        }
      }), u = O(
        () => r.queue && a.value && A.value ? a.value.childElementCount > 0 || A.value.childElementCount > 0 : !1
      ), d = O(
        () => r.variant === "warning" || r.variant === "danger"
      );
      function h() {
        var C;
        c.value && (u.value && (c.value.innerHTML = ""), c.value.insertAdjacentElement(
          "afterbegin",
          (C = s.value) == null ? void 0 : C.$el
        ));
      }
      function g() {
        r.infinite || (l.value && clearTimeout(l.value), l.value = setTimeout(() => {
          o.value && f({ action: "close", method: "timeout" });
        }, r.duration));
      }
      function f(...C) {
        o.value = !1, l.value && clearTimeout(l.value), n("close", C);
      }
      const p = ye(["noticeClass", "o-notices"]), m = ye([
        "noticePositionClass",
        "o-notices--",
        "top"
      ]), E = ye([
        "noticePositionClass",
        "o-notices--",
        "bottom"
      ]), y = ye([
        "noticeContainerClass",
        "o-notices__container"
      ]);
      return e({ close: f }), (C, w) => (G(), De(AO, Tt({ ref: "notificationComponent" }, C.$attrs, {
        active: o.value,
        "onUpdate:active": w[0] || (w[0] = (M) => o.value = M),
        override: C.override,
        position: C.position,
        role: d.value ? "alert" : "status",
        "aria-atomic": !0,
        onClose: f
      }), {
        inner: Ye(({ close: M }) => [
          C.component ? (G(), De(Nr(C.component), Tt({ key: 0 }, C.$props.props, ZM(C.$props.events || {}), { onClose: M }), null, 16, ["onClose"])) : de("", !0)
        ]),
        default: Ye(() => [
          ge(C.$slots, "default")
        ]),
        _: 3
      }, 16, ["active", "override", "position", "role"]));
    }
  }), Jp = new nw(), jwe = {
    /** Returns the number of registered active instances. */
    count: Jp.count,
    /**
     * Create a new programmatic notification component instance.
     * @param options notification message string or notification component props object
     * @param target specify a target the component get rendered into - default is `document.body`
     * @returns ProgrammaticExpose
     */
    open(t, e) {
      const i = typeof t == "string" ? { message: t } : t, r = {
        position: Vl("notification.position", "top-right"),
        container: document.body,
        ...i
        // pass all props to the internal notification component
      };
      return sw.open(Gwe, {
        registry: Jp,
        // custom programmatic instance registry
        target: e,
        // target the component get rendered into
        props: r,
        // component specific props
        onClose: i.onClose
        // on close event handler
      });
    },
    /** Close the last registred instance in the notification programmatic instance registry. */
    close(...t) {
      var e, i;
      (i = (e = Jp.last()) == null ? void 0 : e.exposed) == null || i.close(...t);
    },
    /** Close all instances in the programmatic notification instance registry. */
    closeAll(...t) {
      Jp.walk((e) => {
        var i;
        return (i = e.exposed) == null ? void 0 : i.close(...t);
      });
    }
  }, Hwe = {
    install(t) {
      Br(t, AO), tw(
        t,
        "notification",
        jwe
      );
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const dh = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OPaginationButton",
    configField: "pagination",
    __name: "PaginationButton",
    props: {
      number: { type: Number, default: void 0 },
      isCurrent: { type: Boolean, default: !1 },
      ariaLabel: { type: String, default: void 0 },
      disabled: { type: Boolean, default: !1 },
      tag: {
        type: [String, Object, Function],
        default: "button"
      },
      rootClass: { type: Array, default: () => [] },
      buttonClass: {
        type: Array,
        required: !0
      },
      buttonCurrentClass: {
        type: Array,
        required: !0
      }
    },
    emits: ["click"],
    setup(t) {
      const e = t, i = O(() => [
        ...e.rootClass,
        ...e.buttonClass,
        ...e.isCurrent ? e.buttonCurrentClass : []
      ]);
      return (r, n) => (G(), De(Nr(t.tag), {
        role: "button",
        tabindex: t.disabled ? void 0 : 0,
        disabled: t.disabled,
        class: he(i.value),
        "aria-label": t.ariaLabel,
        "aria-current": t.isCurrent,
        onClick: n[0] || (n[0] = at((s) => r.$emit("click", s), ["prevent"])),
        onKeydown: n[1] || (n[1] = At(at((s) => r.$emit("click", s), ["prevent"]), ["enter"]))
      }, {
        default: Ye(() => [
          ge(r.$slots, "default", {}, () => [
            Ct(Pe(t.number), 1)
          ])
        ]),
        _: 3
      }, 40, ["tabindex", "disabled", "class", "aria-label", "aria-current"]));
    }
  }), Jwe = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OPagination",
    configField: "pagination",
    inheritAttrs: !1,
    __name: "Pagination",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      total: { default: void 0 },
      perPage: { default: () => W("pagination.perPage", 20) },
      current: { default: 1 },
      rangeBefore: { default: 1 },
      rangeAfter: { default: 1 },
      size: { default: () => W("pagination.size") },
      simple: { type: Boolean, default: () => W("pagination.simple", !1) },
      rounded: { type: Boolean, default: () => W("pagination.rounded", !1) },
      order: { default: () => W("pagination.order", "right") },
      buttonTag: { default: () => W("pagination.buttonTag", "button") },
      iconPack: { default: () => W("pagination.iconPack") },
      iconPrev: { default: () => W("pagination.iconPrev", "chevron-left") },
      iconNext: { default: () => W("pagination.iconNext", "chevron-right") },
      mobileBreakpoint: { default: () => W("pagination.mobileBreakpoint") },
      ariaNextLabel: { default: () => W("pagination.ariaNextLabel", "Next page") },
      ariaPreviousLabel: { default: () => W("pagination.ariaPreviousLabel", "Previous page") },
      ariaPageLabel: { default: () => W("pagination.ariaPageLabel", "Page") },
      ariaCurrentLabel: { default: () => W("pagination.ariaCurrentLabel", "Current page") },
      rootClass: {},
      mobileClass: {},
      orderClass: {},
      sizeClass: {},
      simpleClass: {},
      infoClass: {},
      listClass: {},
      listItemClass: {},
      ellipsisClass: {},
      buttonClass: {},
      roundedClass: {},
      buttonCurrentClass: {},
      buttonPrevClass: {},
      buttonNextClass: {},
      buttonDisabledClass: {}
    }, {
      current: { default: 1 },
      currentModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:current", "change"], ["update:current"]),
    setup(t, { expose: e, emit: i }) {
      const r = t, n = i, { isMobile: s } = _f(r.mobileBreakpoint), o = Hi(t, "current"), a = O(
        () => Math.ceil((r.total || 0) / Number(r.perPage))
      );
      ct(
        () => a.value,
        (F) => {
          r.current > F && w(new Event("change"));
        }
      );
      const A = O(() => {
        const F = Number(r.perPage), R = r.current * F - F + 1;
        return R >= 0 ? R : 0;
      }), l = O(() => r.current <= 1), c = O(() => r.current >= r.rangeBefore + 2), u = O(() => r.current >= r.rangeBefore + 4), d = O(() => r.current >= a.value), h = O(
        () => r.current <= a.value - (1 + r.rangeAfter)
      ), g = O(
        () => r.current < a.value - (2 + r.rangeAfter)
      ), f = O(() => {
        if (r.simple) return [];
        let F = Math.max(1, r.current - r.rangeBefore);
        F - 1 === 2 && F--;
        let R = Math.min(r.current + r.rangeAfter, a.value);
        a.value - R === 2 && R++;
        const Y = [];
        for (let L = F; L <= R; L++)
          Y.push(p(L));
        return Y;
      });
      function p(F, R) {
        return {
          number: F,
          isCurrent: r.current === F,
          onClick: (Y) => M(F, Y),
          ariaLabel: R || m(F, r.current === F),
          tag: r.buttonTag
        };
      }
      function m(F, R) {
        return r.ariaPageLabel && (!R || !r.ariaCurrentLabel) ? r.ariaPageLabel + " " + F + "." : r.ariaPageLabel && R && r.ariaCurrentLabel ? r.ariaCurrentLabel + ", " + r.ariaPageLabel + " " + F + "." : "";
      }
      function E(F) {
        M(r.current - 1, F);
      }
      function y(F) {
        M(r.current + 1, F);
      }
      function C(F) {
        M(1, F);
      }
      function w(F) {
        M(a.value, F);
      }
      function M(F, R) {
        r.current === F || F < 1 || F > a.value || (n("change", F), o.value = F, R && R.target && ji(() => R.target.focus()));
      }
      const I = ye(
        ["rootClass", "o-pagination"],
        [
          "orderClass",
          "o-pagination--",
          O(() => r.order),
          O(() => !!r.order)
        ],
        [
          "sizeClass",
          "o-pagination--",
          O(() => r.size),
          O(() => !!r.size)
        ],
        ["simpleClass", "o-pagination--simple", null, O(() => r.simple)],
        ["mobileClass", "o-pagination--mobile", null, s]
      ), b = ye(["infoClass", "o-pagination__info"]), B = ye([
        "ellipsisClass",
        "o-pagination__ellipsis"
      ]), x = ye(["listClass", "o-pagination__list"]), Q = ye(["listItemClass", "o-pagination__item"]), v = ye(
        ["buttonClass", "o-pagination__button"],
        [
          "roundedClass",
          "o-pagination__button--rounded",
          null,
          O(() => r.rounded)
        ]
      ), T = ye([
        "buttonCurrentClass",
        "o-pagination__button--current"
      ]), S = ye(
        ["buttonPrevClass", "o-pagination__button-previous"],
        ["buttonDisabledClass", "o-pagination__button--disabled", null, l]
      ), D = ye(
        ["buttonNextClass", "o-pagination__button-next"],
        ["buttonDisabledClass", "o-pagination__button--disabled", null, d]
      );
      return e({ last: w, first: C, prev: E, next: y }), (F, R) => (G(), X("nav", {
        "data-oruga": "pagination",
        class: he(j(I))
      }, [
        ge(F.$slots, "previous", ia(ra(p(o.value - 1, F.ariaPreviousLabel))), () => [
          ee(dh, Tt(p(o.value - 1, F.ariaPreviousLabel), {
            disabled: l.value,
            "root-class": j(S),
            "button-class": j(v),
            "button-current-class": j(T)
          }), {
            default: Ye(() => [
              ee(Fr, {
                icon: F.iconPrev,
                pack: F.iconPack,
                both: "",
                "aria-hidden": "true"
              }, null, 8, ["icon", "pack"])
            ]),
            _: 1
          }, 16, ["disabled", "root-class", "button-class", "button-current-class"])
        ]),
        ge(F.$slots, "next", ia(ra(p(o.value + 1, F.ariaNextLabel))), () => [
          ee(dh, Tt(p(o.value + 1, F.ariaNextLabel), {
            disabled: d.value,
            "root-class": j(D),
            "button-class": j(v),
            "button-current-class": j(T)
          }), {
            default: Ye(() => [
              ee(Fr, {
                icon: F.iconNext,
                pack: F.iconPack,
                both: "",
                "aria-hidden": "true"
              }, null, 8, ["icon", "pack"])
            ]),
            _: 1
          }, 16, ["disabled", "root-class", "button-class", "button-current-class"])
        ]),
        F.simple ? (G(), X("small", {
          key: 0,
          class: he(j(b))
        }, [
          F.perPage == 1 ? (G(), X(ht, { key: 0 }, [
            Ct(Pe(A.value) + " / " + Pe(F.total), 1)
          ], 64)) : (G(), X(ht, { key: 1 }, [
            Ct(Pe(A.value) + "-" + Pe(Math.min(o.value * Number(F.perPage), F.total)) + " / " + Pe(F.total), 1)
          ], 64))
        ], 2)) : (G(), X("ul", {
          key: 1,
          class: he(j(x))
        }, [
          c.value ? (G(), X("li", {
            key: 0,
            class: he(j(Q))
          }, [
            ge(F.$slots, "default", ia(ra(p(1))), () => [
              ee(dh, Tt(p(1), {
                "button-class": j(v),
                "button-current-class": j(T)
              }), null, 16, ["button-class", "button-current-class"])
            ])
          ], 2)) : de("", !0),
          u.value ? (G(), X("li", {
            key: 1,
            class: he(j(Q))
          }, [
            be("span", {
              class: he(j(B))
            }, "…", 2)
          ], 2)) : de("", !0),
          (G(!0), X(ht, null, xi(f.value, (Y) => (G(), X("li", {
            key: Y.number,
            class: he(j(Q))
          }, [
            ge(F.$slots, "default", Tt({ ref_for: !0 }, Y), () => [
              ee(dh, Tt({ ref_for: !0 }, Y, {
                "button-class": j(v),
                "button-current-class": j(T)
              }), null, 16, ["button-class", "button-current-class"])
            ])
          ], 2))), 128)),
          g.value ? (G(), X("li", {
            key: 2,
            class: he(j(Q))
          }, [
            be("span", {
              class: he(j(B))
            }, "…", 2)
          ], 2)) : de("", !0),
          h.value ? (G(), X("li", {
            key: 3,
            class: he(j(Q))
          }, [
            ge(F.$slots, "default", ia(ra(p(a.value))), () => [
              ee(dh, Tt(p(a.value), {
                "button-class": j(v),
                "button-current-class": j(T)
              }), null, 16, ["button-class", "button-current-class"])
            ])
          ], 2)) : de("", !0)
        ], 2))
      ], 2));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Vwe = {
    install(t) {
      tw(
        t,
        "programmatic",
        sw
      );
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Wwe = {
    install(t) {
      Br(t, oO);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const lO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OSidebar",
    configField: "sidebar",
    inheritAttrs: !1,
    __name: "Sidebar",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      active: { type: Boolean, default: !1 },
      overlay: { type: Boolean, default: () => W("sidebar.overlay", !1) },
      inline: { type: Boolean, default: !1 },
      position: { default: () => W("sidebar.position", "left") },
      fullheight: { type: Boolean, default: () => W("sidebar.fullheight", !1) },
      fullwidth: { type: Boolean, default: () => W("sidebar.fullwidth", !1) },
      reduce: { type: Boolean, default: () => W("sidebar.reduce", !1) },
      mobile: { default: () => W("sidebar.mobile") },
      expandOnHover: { type: Boolean, default: () => W("sidebar.expandOnHover", !1) },
      animation: { default: () => W("sidebar.animation") },
      cancelable: { type: [Array, Boolean], default: () => W("sidebar.cancelable", ["escape", "outside"]) },
      clipScroll: { type: Boolean, default: () => W("sidebar.clipScroll", !1) },
      mobileBreakpoint: { default: () => W("sidebar.mobileBreakpoint") },
      teleport: { type: [Boolean, String, Object], default: () => W("sidebar.teleport", !1) },
      container: {},
      component: { default: void 0 },
      props: { default: void 0 },
      events: { default: void 0 },
      rootClass: {},
      mobileClass: {},
      activeClass: {},
      teleportClass: {},
      inlineClass: {},
      overlayClass: {},
      contentClass: {},
      hiddenClass: {},
      visibleClass: {},
      positionClass: {},
      fullheightClass: {},
      fullwidthClass: {},
      reduceClass: {},
      expandOnHoverClass: {},
      scrollClipClass: {},
      scrollKeepClass: {}
    }, {
      active: { type: Boolean, default: !1 },
      activeModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:active", "close"], ["update:active"]),
    setup(t, { expose: e, emit: i }) {
      const r = t, n = i, s = cs("rootElement"), o = cs("contentElement"), a = Hi(t, "active"), { isMobile: A } = _f(r.mobileBreakpoint), l = O(
        () => typeof r.teleport == "boolean" ? { to: "body", disabled: !r.teleport } : { to: r.teleport, disabled: !1 }
      ), c = O(() => {
        if (r.animation) return r.animation;
        const I = r.position === "top" || r.position === "bottom";
        return (r.position === "right" ? !a.value : a.value) ? I ? "slide-down" : "slide-next" : I ? "slide-up" : "slide-prev";
      }), u = O(
        () => r.mobile === "hidden" && A.value
      ), d = rQ(r.clipScroll);
      ct(
        a,
        (I) => {
          r.overlay && d(I);
        },
        { flush: "post" }
      ), er(() => {
        a.value && r.overlay && d(!0);
      }), wn && (Wd(s, "keyup", h, { trigger: a }), r.overlay || tQ(o, g, { trigger: a }));
      function h(I) {
        a.value && (I.key === "Escape" || I.key === "Esc") && f("escape");
      }
      function g(I) {
        r.inline || !a.value || m.value || ((r.overlay || o.value && !I.composedPath().includes(o.value)) && I.preventDefault(), f("outside"));
      }
      function f(I) {
        typeof r.cancelable == "boolean" && !r.cancelable || !r.cancelable || Array.isArray(r.cancelable) && !r.cancelable.includes(I) || p({ action: "cancel", method: I });
      }
      function p(...I) {
        a.value = !1, n("close", I);
      }
      const m = ue(!r.active);
      function E() {
        m.value = !1;
      }
      function y() {
        m.value = !0;
      }
      const C = ye(
        ["rootClass", "o-sidebar"],
        ["mobileClass", "o-sidebar--mobile", null, A],
        ["activeClass", "o-sidebar--active", null, a],
        [
          "teleportClass",
          "o-sidebar--teleport",
          null,
          O(() => !!r.teleport)
        ],
        ["inlineClass", "o-sidebar--inline", null, O(() => r.inline)]
      ), w = ye(["overlayClass", "o-sidebar__overlay"]), M = ye(
        ["contentClass", "o-sidebar__content"],
        [
          "positionClass",
          "o-sidebar__content--",
          O(() => r.position),
          O(() => !!r.position)
        ],
        [
          "fullheightClass",
          "o-sidebar__content--fullheight",
          null,
          O(() => r.fullheight)
        ],
        [
          "fullwidthClass",
          "o-sidebar__content--fullwidth",
          null,
          O(
            () => r.fullwidth || A.value && r.mobile === "expanded"
          )
        ],
        [
          "reduceClass",
          "o-sidebar__content--reduced",
          null,
          O(
            () => r.reduce || A.value && r.mobile === "reduced"
          )
        ],
        [
          "expandOnHoverClass",
          "o-sidebar__content--hover-expand",
          null,
          O(
            () => r.expandOnHover && (!A.value || r.mobile !== "expanded")
          )
        ],
        ["visibleClass", "o-sidebar__content--visible", null, a],
        [
          "hiddenClass",
          "o-sidebar__content--hidden",
          null,
          O(() => !a.value)
        ]
      );
      return e({ close: p }), (I, b) => (G(), De(WM, {
        to: l.value.to,
        disabled: l.value.disabled
      }, [
        $t(be("div", Tt({ ref: "rootElement" }, I.$attrs, {
          "data-oruga": "sidebar",
          class: j(C)
        }), [
          I.overlay && a.value ? (G(), X("div", {
            key: 0,
            class: he(j(w)),
            tabindex: -1,
            onClick: g
          }, null, 2)) : de("", !0),
          ee(Ws, {
            name: c.value,
            onAfterEnter: E,
            onBeforeLeave: y
          }, {
            default: Ye(() => [
              $t(be("div", {
                ref: "contentElement",
                class: he(j(M))
              }, [
                ge(I.$slots, "default", { close: p }, () => [
                  I.component ? (G(), De(Nr(I.component), Tt({ key: 0 }, I.$props.props, ZM(I.$props.events || {}), { onClose: p }), null, 16)) : de("", !0)
                ])
              ], 2), [
                [gi, a.value]
              ])
            ]),
            _: 3
          }, 8, ["name"])
        ], 16), [
          [gi, !u.value]
        ])
      ], 8, ["to", "disabled"]));
    }
  }), Vp = new nw(), Kwe = {
    /** Returns the number of registered active instances. */
    count: Vp.count,
    /**
     * Create a new programmatic sidebar component instance.
     * @param options sidebar component props object
     * @param target specify a target the component get rendered into - default is `document.body`
     * @returns ProgrammaticExpose
     */
    open(t, e) {
      const i = {
        active: !0,
        // set the active default state to true
        ...t
      };
      return sw.open(lO, {
        registry: Vp,
        // custom programmatic instance registry
        target: e,
        // target the component get rendered into
        props: i,
        // component specific props
        onClose: t.onClose
        // on close event handler
      });
    },
    /** Close the last registred instance in the sidebar programmatic instance registry. */
    close(...t) {
      var e, i;
      (i = (e = Vp.last()) == null ? void 0 : e.exposed) == null || i.close(...t);
    },
    /** Close all instances in the programmatic sidebar instance registry. */
    closeAll(...t) {
      Vp.walk((e) => {
        var i;
        return (i = e.exposed) == null ? void 0 : i.close(...t);
      });
    }
  }, Xwe = {
    install(t) {
      Br(t, lO), tw(t, "sidebar", Kwe);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Zwe = ["id"], cO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OTooltip",
    configField: "tooltip",
    __name: "Tooltip",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      active: { type: Boolean, default: !1 },
      label: { default: void 0 },
      variant: { default: () => W("tooltip.variant") },
      position: { default: () => W("tooltip.position", "auto") },
      always: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
      animation: { default: () => W("tooltip.animation", "fade") },
      multiline: { type: Boolean, default: !1 },
      triggerTag: { default: () => W("tooltip.triggerTag", "div") },
      triggers: { default: () => W("tooltip.triggers", ["hover", "focus"]) },
      delay: { default: void 0 },
      closeable: { type: [Array, Boolean], default: () => W("tooltip.closeable", ["escape", "outside", "content"]) },
      teleport: { type: [Boolean, String, Object], default: () => W("dropdown.teleport", !1) },
      rootClass: {},
      teleportClass: {},
      triggerClass: {},
      contentClass: {},
      positionClass: {},
      variantClass: {},
      multilineClass: {},
      alwaysClass: {},
      arrowClass: {},
      arrowPositionClass: {},
      arrowVariantClass: {}
    }, {
      active: { type: Boolean, default: !1 },
      activeModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:active", "close", "open"], ["update:active"]),
    setup(t, { emit: e }) {
      const i = t, r = e, n = Hi(t, "active");
      ct(n, (I) => {
        r(I ? "open" : "close");
      });
      const s = Pn(), o = ue(), a = ue(i.position);
      ct(
        () => i.position,
        (I) => a.value = I
      );
      const A = ue(), l = ue(), c = O(
        () => typeof i.closeable == "boolean" ? i.closeable ? ["escape", "outside", "content"] : [] : i.closeable
      );
      wn && c.value.includes("outside") && tQ([A, l], u, {
        trigger: n,
        passive: !0
      });
      function u() {
        !n.value || i.always || c.value.includes("outside") && (n.value = !1);
      }
      function d() {
        n.value && c.value.includes("escape") && (n.value = !1);
      }
      function h() {
        i.triggers.includes("click") && ji(() => setTimeout(() => m()));
      }
      function g(I) {
        i.triggers.includes("contextmenu") && (I.preventDefault(), m());
      }
      function f() {
        i.triggers.includes("focus") && m();
      }
      function p() {
        i.triggers.includes("hover") && m();
      }
      function m() {
        i.disabled || (i.delay ? o.value = setTimeout(() => {
          n.value = !0, o.value = null;
        }, i.delay) : n.value = !0);
      }
      function E() {
        c.value.includes("content") && (n.value = !i.closeable, o.value && i.closeable && clearTimeout(o.value));
      }
      const y = ye(
        ["rootClass", "o-tooltip"],
        [
          "teleportClass",
          "o-tooltip--teleport",
          null,
          O(() => !!i.teleport)
        ]
      ), C = ye(["triggerClass", "o-tooltip__trigger"]), w = ye(
        ["contentClass", "o-tooltip__content"],
        [
          "positionClass",
          "o-tooltip__content--",
          a,
          O(() => !!a.value)
        ],
        [
          "variantClass",
          "o-tooltip__content--",
          O(() => i.variant),
          O(() => !!i.variant)
        ],
        [
          "multilineClass",
          "o-tooltip__content--multiline",
          null,
          O(() => i.multiline)
        ],
        [
          "alwaysClass",
          "o-tooltip__content--always",
          null,
          O(() => i.always)
        ]
      ), M = ye(
        ["arrowClass", "o-tooltip__arrow"],
        [
          "arrowPositionClass",
          "o-tooltip__arrow--",
          a,
          O(() => !!a.value)
        ],
        [
          "arrowVariantClass",
          "o-tooltip__arrow--",
          O(() => i.variant),
          O(() => !!i.variant)
        ]
      );
      return (I, b) => (G(), X("div", {
        "data-oruga": "tooltip",
        class: he(j(y))
      }, [
        (G(), De(Nr(I.triggerTag), {
          ref_key: "triggerRef",
          ref: l,
          class: he(j(C)),
          "aria-haspopup": "true",
          "aria-describedby": j(s),
          onKeydown: At(d, ["escape"]),
          onClick: h,
          onContextmenu: g,
          onMouseenter: p,
          onFocusCapture: f,
          onBlurCapture: E,
          onMouseleave: E
        }, {
          default: Ye(() => [
            ge(I.$slots, "default", { active: n.value })
          ]),
          _: 3
        }, 40, ["class", "aria-describedby"])),
        ee(eO, {
          position: a.value,
          "onUpdate:position": b[0] || (b[0] = (B) => a.value = B),
          teleport: I.teleport,
          class: he(j(y)),
          trigger: l.value,
          "default-position": "top",
          disabled: !n.value
        }, {
          default: Ye(({ setContent: B }) => [
            ee(Ws, { name: I.animation }, {
              default: Ye(() => [
                $t(be("div", {
                  id: j(s),
                  ref: (x) => A.value = B(x),
                  class: he(j(w)),
                  role: "tooltip"
                }, [
                  be("span", {
                    class: he(j(M))
                  }, null, 2),
                  ge(I.$slots, "content", {}, () => [
                    Ct(Pe(I.label), 1)
                  ])
                ], 10, Zwe), [
                  [gi, n.value || I.always && !I.disabled]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled"])
      ], 2));
    }
  });
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Qh = je(
    (t, { slots: e }) => {
      const i = { tag: "div", name: "default", ...t };
      return () => {
        const r = t.component.$slots[i.name] ? t.component.$slots[i.name](t.props) : e.default ? e.default() : {};
        return ee(i.tag, {}, r);
      };
    },
    {
      name: "OSlotComponent",
      // manual runtime props declaration is currently still needed.
      props: ["component", "props", "name", "tag"]
    }
  );
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const qwe = ["value"], $we = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OTableMobileSort",
    configField: "table",
    __name: "TableMobileSort",
    props: {
      currentSortColumn: {
        type: Object,
        default: void 0
      },
      columns: {
        type: Array,
        default: void 0
      },
      placeholder: { type: String, default: void 0 },
      iconPack: { type: String, default: void 0 },
      sortIcon: { type: String, default: "arrow-up" },
      sortIconSize: { type: String, default: "small" },
      isAsc: { type: Boolean, default: !1 },
      mobileSortClasses: { type: Array, required: !0 }
    },
    emits: ["sort"],
    setup(t, { emit: e }) {
      var i;
      const r = t, n = e, s = ue((i = r.currentSortColumn) == null ? void 0 : i.identifier), o = O(
        () => !r.columns || r.columns.every((c) => c.identifier !== s.value)
      ), a = O(
        () => r.columns ? r.columns.filter((c) => c.sortable) : []
      ), A = O(
        () => {
          var c;
          return ((c = r.currentSortColumn) == null ? void 0 : c.identifier) === s.value;
        }
      );
      ct(s, (c) => {
        var u;
        ((u = r.currentSortColumn) == null ? void 0 : u.identifier) !== c && l(new Event("sort"));
      }), ct(
        () => r.currentSortColumn,
        (c) => {
          s.value = c == null ? void 0 : c.identifier;
        }
      );
      function l(c) {
        const u = a.value.find(
          (d) => d.identifier === s.value
        );
        u && n("sort", u, c);
      }
      return (c, u) => (G(), X("div", {
        class: he(t.mobileSortClasses)
      }, [
        ee(aO, { addons: "" }, {
          default: Ye(() => [
            ee(oO, {
              modelValue: s.value,
              "onUpdate:modelValue": u[0] || (u[0] = (d) => s.value = d),
              expanded: ""
            }, {
              default: Ye(() => [
                t.placeholder ? $t((G(), X("option", {
                  key: 0,
                  value: {},
                  selected: "",
                  disabled: "",
                  hidden: ""
                }, Pe(t.placeholder), 513)), [
                  [gi, o.value]
                ]) : de("", !0),
                (G(!0), X(ht, null, xi(a.value, (d, h) => (G(), X("option", {
                  key: d.field || h,
                  value: d.identifier
                }, Pe(d.label), 9, qwe))), 128))
              ]),
              _: 1
            }, 8, ["modelValue"]),
            ee(sO, {
              onClick: u[1] || (u[1] = (d) => l(d))
            }, {
              default: Ye(() => [
                $t(ee(Fr, {
                  icon: t.sortIcon,
                  pack: t.iconPack,
                  size: t.sortIconSize,
                  both: "",
                  rotation: t.isAsc ? 0 : 180
                }, null, 8, ["icon", "pack", "size", "rotation"]), [
                  [gi, A.value]
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ], 2));
    }
  }), e0e = ["data-id"], uO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OTableColumn",
    configField: "table",
    __name: "TableColumn",
    props: {
      label: { default: void 0 },
      field: { default: void 0 },
      formatter: { type: Function, default: void 0 },
      subheading: { default: void 0 },
      width: { default: void 0 },
      numeric: { type: Boolean, default: !1 },
      position: { default: void 0 },
      searchable: { type: Boolean, default: !1 },
      sortable: { type: Boolean, default: !1 },
      hidden: { type: Boolean, default: !1 },
      sticky: { type: Boolean, default: !1 },
      headerSelectable: { type: Boolean, default: !1 },
      customSort: { type: Function, default: void 0 },
      customSearch: { type: Function, default: void 0 },
      thAttrs: { default: void 0 },
      tdAttrs: { default: void 0 }
    },
    setup(t) {
      const e = t, i = O(() => ({
        width: X1(e.width)
      })), r = O(
        () => !e.headerSelectable && e.sortable
      ), n = Uo(), s = O(() => ({
        ...e,
        $el: n.proxy,
        $slots: n.slots,
        style: i.value,
        thClasses: A.value,
        tdClasses: l.value
      })), { parent: o, item: a } = eQ({ data: s }), A = ye(
        [
          "thCurrentSortClass",
          "o-table__th-current-sort",
          null,
          O(() => {
            var c;
            return (c = o.value) == null ? void 0 : c.isColumnSorted(a.value);
          })
        ],
        [
          "thSortableClass",
          "o-table__th--sortable",
          null,
          O(() => e.sortable)
        ],
        [
          "thUnselectableClass",
          "o-table__th--unselectable",
          null,
          r
        ],
        [
          "thPositionClass",
          "o-table__th--",
          O(() => e.position),
          O(() => !!e.position)
        ],
        [
          "thStickyClass",
          "o-table__th--sticky",
          null,
          O(() => e.sticky)
        ]
      ), l = ye(
        [
          "tdPositionClass",
          "o-table__td--",
          O(() => e.position),
          O(() => !!e.position)
        ],
        [
          "tdStickyClass",
          "o-table__td--sticky",
          null,
          O(() => e.sticky)
        ]
      );
      return (c, u) => (G(), X("span", {
        "data-oruga": "table-column",
        "data-id": `table-${j(a).identifier}`
      }, [
        Ct(Pe(c.label) + " ", 1),
        de("", !0)
      ], 8, e0e));
    }
  }), B2 = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OTablePagination",
    configField: "table",
    inheritAttrs: !1,
    __name: "TablePagination",
    props: /* @__PURE__ */ li({
      current: { type: Number, default: void 0 },
      paginated: { type: Boolean, default: !1 },
      rootClass: {
        type: [String, Array, Object],
        default: void 0
      }
    }, {
      current: {},
      currentModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:current", "change"], ["update:current"]),
    setup(t, { emit: e }) {
      const i = e, r = Hi(t, "current");
      function n(s) {
        const o = s > 0 ? s : 1;
        r.value = o, i("change", o);
      }
      return (s, o) => (G(), X("div", {
        class: he(t.rootClass)
      }, [
        be("div", null, [
          ge(s.$slots, "default")
        ]),
        be("div", null, [
          t.paginated ? (G(), De(Jwe, Tt({ key: 0 }, s.$attrs, {
            current: r.value,
            onChange: n
          }), null, 16, ["current"])) : de("", !0)
        ])
      ], 2));
    }
  }), t0e = {
    ref: "slotsWrapper",
    style: { display: "none" }
  }, i0e = ["tabindex", "aria-rowcount", "aria-colcount"], r0e = { key: 0 }, n0e = { key: 1 }, s0e = { "aria-rowindex": 1 }, o0e = ["aria-colindex"], a0e = ["draggable", "aria-sort", "aria-colindex", "onClick", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"], A0e = { key: 1 }, l0e = ["aria-hidden"], c0e = ["aria-colindex"], u0e = {
    key: 0,
    "aria-rowindex": 2
  }, d0e = { key: 1 }, h0e = { key: 2 }, g0e = ["aria-rowindex"], f0e = { key: 1 }, p0e = { key: 1 }, m0e = { key: 2 }, E0e = ["draggable", "aria-rowindex", "onClick", "onDblclick", "onMouseenter", "onMouseleave", "onContextmenu", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"], y0e = ["colspan"], B0e = ["colspan"], w0e = { key: 2 }, C0e = ["colspan"], b0e = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OTable",
    configField: "table",
    inheritAttrs: !1,
    __name: "Table",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      data: { default: void 0 },
      columns: { default: void 0 },
      rowKey: { default: () => W("table.rowKey") },
      rowClass: { type: Function, default: W("table.rowClass", () => "") },
      thAttrs: { type: Function, default: void 0 },
      tdAttrs: { type: Function, default: void 0 },
      customCompare: { type: Function, default: void 0 },
      bordered: { type: Boolean, default: () => W("table.bordered", !1) },
      striped: { type: Boolean, default: () => W("table.striped", !1) },
      narrowed: { type: Boolean, default: () => W("table.narrowed", !1) },
      hoverable: { type: Boolean, default: () => W("table.hoverable", !1) },
      selected: { default: void 0 },
      selectable: { type: Boolean, default: () => W("table.selectable", !1) },
      isRowSelectable: { type: Function, default: () => !0 },
      showHeader: { type: Boolean, default: () => W("table.showHeader", !0) },
      draggable: { type: Boolean, default: !1 },
      draggableColumn: { type: Boolean, default: !1 },
      scrollable: { type: Boolean, default: void 0 },
      stickyHeader: { type: Boolean, default: !1 },
      height: { default: void 0 },
      checkable: { type: Boolean, default: !1 },
      checkableHeader: { type: Boolean, default: !0 },
      stickyCheckbox: { type: Boolean, default: !1 },
      checkedRows: { default: () => [] },
      checkboxPosition: { default: () => W("table.checkboxPosition", "left") },
      checkboxVariant: { default: () => W("table.checkboxVariant") },
      isRowChecked: { type: Function, default: void 0 },
      isRowCheckable: { type: Function, default: W("table.isRowCheckable", () => !0) },
      backendSorting: { type: Boolean, default: () => W("table.backendSorting", !1) },
      defaultSort: { default: () => W("table.defaultSort") },
      defaultSortDirection: { default: () => W("table.defaultSortDirection", "asc") },
      sortIcon: { default: () => W("table.sortIcon", "arrow-up") },
      sortIconSize: { default: () => W("table.sortIconSize", "small") },
      iconPack: { default: () => W("table.iconPack") },
      detailed: { type: Boolean, default: !1 },
      detailedRows: { default: () => [] },
      isDetailedVisible: { type: Function, default: W("table.isDetailedVisible", () => !0) },
      showDetailIcon: { type: Boolean, default: () => W("table.showDetailIcon", !0) },
      detailIcon: { default: () => W("table.detailIcon", "chevron-right") },
      customDetailRow: { type: Boolean, default: !1 },
      detailTransition: { default: () => W("table.detailTransition", "slide") },
      paginated: { type: Boolean, default: () => W("table.paginated", !1) },
      backendPagination: { type: Boolean, default: !1 },
      total: { default: 0 },
      currentPage: { default: 1 },
      perPage: { default: () => W("table.perPage", 20) },
      paginationPosition: { default: () => W("table.paginationPosition", "bottom") },
      paginationSize: { default: () => W("table.paginationSize", "small") },
      paginationRounded: { type: Boolean, default: () => W("table.paginationRounded", !1) },
      paginationSimple: { type: Boolean, default: () => W("table.paginationSimple", !1) },
      paginationOrder: { default: () => W("table.paginationOrder") },
      backendFiltering: { type: Boolean, default: () => W("table.backendFiltering", !1) },
      filtersIcon: { default: () => W("table.filterIcon") },
      filtersPlaceholder: { default: () => W("table.filterPlaceholder") },
      filtersEvent: { default: "" },
      filterDebounce: { default: () => W("table.filterDebounce", 300) },
      emptyLabel: { default: () => W("table.emptyLabel") },
      emptyIcon: { default: () => W("table.emptyIcon") },
      emptyIconSize: { default: () => W("table.emptyIconSize") },
      loading: { type: Boolean, default: !1 },
      loadingIcon: { default: () => W("table.loadingIcon", "loading") },
      loadingLabel: { default: () => W("table.loadingLabel") },
      mobileBreakpoint: { default: () => W("table.mobileBreakpoint") },
      mobileCards: { type: Boolean, default: () => W("table.mobileCards", !0) },
      mobileSortPlaceholder: { default: () => W("table.mobileSortPlaceholder") },
      ariaNextLabel: { default: () => W("table.ariaNextLabel") },
      ariaPreviousLabel: { default: () => W("table.ariaPreviousLabel") },
      ariaPageLabel: { default: () => W("table.ariaPageLabel") },
      ariaCurrentLabel: { default: () => W("table.ariaCurrentLabel") },
      rootClass: {},
      mobileClass: {},
      mobileSortClass: {},
      wrapperClass: {},
      stickyHeaderClass: {},
      scrollableClass: {},
      tableClass: {},
      borderedClass: {},
      stripedClass: {},
      narrowedClass: {},
      hoverableClass: {},
      emptyClass: {},
      thClass: {},
      thPositionClass: {},
      thCheckboxClass: {},
      thStickyClass: {},
      thDetailedClass: {},
      thSortableClass: {},
      thSortIconClass: {},
      thCurrentSortClass: {},
      thUnselectableClass: {},
      thSubheadingClass: {},
      trSelectedClass: {},
      trCheckedClass: {},
      trDetailedClass: {},
      trEmptyClass: {},
      tdClass: {},
      tdPositionClass: {},
      tdStickyClass: {},
      tdCheckboxClass: {},
      tdDetailedChevronClass: {},
      paginationWrapperClass: {},
      footerClass: {},
      loadingClasses: {}
    }, {
      currentPage: { default: 1 },
      currentPageModifiers: {},
      selected: { default: void 0 },
      selectedModifiers: {},
      checkedRows: {
        default: []
      },
      checkedRowsModifiers: {},
      detailedRows: {
        default: []
      },
      detailedRowsModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:currentPage", "page-change", "update:selected", "select", "check", "check-all", "update:checkedRows", "sort", "filters-change", "filters-event", "update:detailedRows", "details-open", "details-close", "click", "dblclick", "contextmenu", "mouseenter", "mouseleave", "cell-click", "dragstart", "dragend", "drop", "dragleave", "dragover", "columndragstart", "columndragend", "columndrop", "columndragleave", "columndragover"], ["update:currentPage", "update:selected", "update:checkedRows", "update:detailedRows"]),
    setup(t, { expose: e, emit: i }) {
      const r = t, n = i, s = Ng(), { isMobile: o } = _f(r.mobileBreakpoint), a = O(() => r.mobileCards && o.value), A = cs("slotsWrapper"), l = O(() => ({
        isColumnSorted: ie
      })), { childItems: c } = $1({
        rootRef: A,
        data: l
      }), u = O(() => c.value.length ? c.value.map((z) => {
        const fe = zt(z.data);
        let re = typeof r.thAttrs == "function" ? r.thAttrs(fe) : {};
        re = Object.assign(re, fe.thAttrs);
        const kt = (r.data ?? []).map((Qe) => {
          const Xi = typeof r.tdAttrs == "function" ? r.tdAttrs(Qe, fe) : {};
          return Object.assign(Xi, fe.tdAttrs);
        });
        return {
          ...fe,
          value: fe,
          index: z.index,
          identifier: z.identifier,
          thAttrsData: re,
          tdAttrsData: kt
        };
      }) : []), d = O(() => {
        let z = u.value.length;
        return K.value && z++, r.checkable && z++, z;
      }), h = O(() => {
        let z = 1;
        return K.value && z++, r.checkable && r.checkboxPosition === "left" && z++, z;
      }), g = O(() => s.subheading ? !0 : u.value.some((z) => !!z.subheading)), f = O(() => r.scrollable ? !0 : u.value.some((z) => z.sticky)), p = Hi(t, "currentPage");
      ct(
        [p, () => r.perPage, () => r.data],
        () => C()
      );
      const { nextSequence: m } = Vd(), E = O(() => r.data ? r.data.map((z, fe) => ({
        label: "row " + fe,
        // row display label
        value: zt(z),
        // normalizes wrapped ref values
        index: fe,
        // row index
        key: (
          // if no key is given and data is object, create unique row id for each row
          String(
            Wr(
              z,
              r.rowKey,
              m()
            )
          )
        )
      })) : []), y = O(
        () => E.value.filter(rO)
      );
      function C() {
        const z = p.value, fe = Number(r.perPage), re = (z - 1) * fe, kt = re + fe;
        iQ(E, (Qe) => (r.paginated || !r.backendPagination) && E.value.length > fe && (Qe.index < re || Qe.index >= kt) ? !0 : r.backendFiltering ? !1 : !L(Qe.value));
      }
      const w = O(
        () => r.backendPagination ? r.total : E.value.length
      ), M = O(() => w.value + I.value), I = O(() => {
        let z = 1;
        return D.value && z++, g.value && z++, z;
      });
      function b() {
        if (!s.footer) return !1;
        const z = s.footer({
          columnCount: d.value,
          rowCount: M.value
        });
        if (z.length > 1) return !0;
        const fe = z[0].type;
        return fe === "th" || fe === "td";
      }
      function B(z, fe) {
        return vC(z, fe.field, fe.formatter);
      }
      function x(z, fe) {
        const re = UC(zt(z)), kt = UC(zt(fe));
        return Qr(fe) ? typeof r.customCompare == "function" ? r.customCompare(re, kt) : r.rowKey ? vC(re, r.rowKey) == vC(kt, r.rowKey) : re == kt : !1;
      }
      const Q = Hi(t, "selected");
      function v(z, fe) {
        if (!y.value.length) return;
        let re = y.value.findIndex(
          (Qe) => x(Qe.value, Q.value)
        ) + z;
        re = re > y.value.length - 1 ? y.value.length - 1 : re, re = re < 0 ? 0 : re;
        const kt = y.value[re];
        if (r.isRowSelectable(kt.value))
          T(kt, fe);
        else {
          let Qe;
          if (z > 0)
            for (let Xi = re; Xi < y.value.length && Qe === void 0; Xi++)
              r.isRowSelectable(y.value[Xi].value) && (Qe = Xi);
          else
            for (let Xi = re; Xi >= 0 && Qe === void 0; Xi--)
              r.isRowSelectable(y.value[Xi].value) && (Qe = Xi);
          Qe != null && Qe >= 0 && T(y.value[Qe], fe);
        }
      }
      function T(z, fe) {
        n("click", z.value, z.index, fe), r.selectable && (x(Q, z.value) || r.isRowSelectable(z.value) && (Q.value = z.value, n("select", z.value, Q.value)));
      }
      const S = ue({}), D = O(
        () => u.value.some((z) => z.searchable)
      );
      let F;
      ct(
        () => r.filterDebounce,
        (z) => F = Z1(R, z || 0),
        { immediate: !0 }
      ), ct(S, (z) => F(z), { deep: !0 });
      function R(z) {
        n("filters-change", z), r.backendFiltering || (C(), ll(E));
      }
      function Y(z) {
        n("filters-event", r.filtersEvent, S.value, z);
      }
      function L(z) {
        return Object.values(S.value).filter(Boolean).length ? Object.entries(S.value).some(([fe, re]) => {
          if (!re) return !1;
          const kt = u.value.find((Pf) => Pf.field === fe);
          if (typeof (kt == null ? void 0 : kt.customSearch) == "function")
            return kt.customSearch(z, re);
          const Qe = typeof z == "object" && z ? Wr(z, fe) : z;
          if (Qe == null) return !1;
          if (Number.isInteger(Qe)) return Qe === Number(re);
          const Xi = new RegExp(KBe(re), "i");
          return Array.isArray(Qe) ? Qe.some(
            (Pf) => Xi.test(m2(Pf)) || Xi.test(Pf)
          ) : typeof Qe != "string" ? !!Qe : Xi.test(m2(Qe)) || Xi.test(Qe);
        }) : !0;
      }
      const N = ue(), H = ue(!0), P = O(
        () => u.value.some((z) => z.sortable)
      );
      function ie(z) {
        var fe;
        return ((fe = N.value) == null ? void 0 : fe.identifier) === z.identifier;
      }
      er(() => ji(() => V()));
      function V() {
        if (!u.value.length || N.value || !r.defaultSort) return;
        let z = "", fe = r.defaultSortDirection;
        Array.isArray(r.defaultSort) ? (z = r.defaultSort[0], r.defaultSort[1] && (fe = r.defaultSort[1])) : z = r.defaultSort, se(z, fe);
      }
      function Z(z, fe = !1, re) {
        z != null && z.sortable && (fe && (H.value = ie(z) ? !H.value : r.defaultSortDirection.toLowerCase() === "asc"), N.value && n(
          "sort",
          z,
          H.value ? "asc" : "desc",
          re || new Event("sort")
        ), N.value = z, r.backendSorting || k(E.value));
      }
      function se(z, fe) {
        const re = u.value.find(
          (kt) => kt.field === z
        );
        re && (H.value = fe.toLowerCase() === "asc", Z(re));
      }
      function k(z) {
        const fe = N.value;
        return fe ? WBe(
          z,
          fe != null && fe.field ? "value." + fe.field : "",
          fe != null && fe.customSort ? (re, kt, Qe) => fe.customSort(re.value, kt.value, Qe) : void 0,
          H.value,
          !0
        ) : z;
      }
      const _ = Hi(t, "checkedRows"), q = O(() => {
        const z = y.value.filter(
          (fe) => r.isRowCheckable(fe.value)
        );
        return z.length === 0 ? !1 : z.every(
          (fe) => J(fe)
        );
      }), U = O(
        () => !y.value.some((z) => r.isRowCheckable(z.value))
      );
      function J(z) {
        return typeof r.isRowChecked == "function" ? r.isRowChecked(z.value) : _.value.some((fe) => x(fe, z.value));
      }
      function ae(z) {
        _.value = [..._.value, z.value];
      }
      function $(z) {
        const fe = _.value.findIndex(
          (re) => x(re, z.value)
        );
        fe >= 0 && (_.value = _.value.toSpliced(fe, 1));
      }
      function Ce() {
        q.value ? _.value = [] : _.value = y.value.filter((z) => r.isRowCheckable(z.value)).map((z) => z.value), ji(() => n("check-all", _.value));
      }
      function Re(z) {
        r.isRowCheckable(z.value) && (J(z) ? $(z) : ae(z), ji(() => n("check", _.value, z.value)));
      }
      const Oe = Hi(t, "detailedRows"), K = O(
        () => r.detailed && r.showDetailIcon
      );
      function Ae(z) {
        Fe(z) ? (Me(z), n("details-close", z.value)) : (ut(z), n("details-open", z.value));
      }
      function ut(z) {
        Oe.value = [...Oe.value, z.value];
      }
      function Me(z) {
        const fe = Oe.value.findIndex(
          (re) => x(re, z.value)
        );
        fe >= 0 && (Oe.value = Oe.value.toSpliced(fe, 1));
      }
      function Fe(z) {
        return r.detailed && Oe.value.some((fe) => x(fe, z.value));
      }
      const jt = ue(!1), Rt = ue(!1), rt = O(() => r.draggable && !Rt.value), Ke = O(
        () => r.draggableColumn && !jt.value
      );
      function Qt(z, fe) {
        r.draggable && n("dragstart", z.value, z.index, fe);
      }
      function Ht(z, fe) {
        r.draggable && n("dragend", z.value, z.index, fe);
      }
      function lt(z, fe) {
        r.draggable && n("drop", z.value, z.index, fe);
      }
      function Ft(z, fe) {
        r.draggable && n("dragover", z.value, z.index, fe);
      }
      function si(z, fe) {
        r.draggable && n("dragleave", z.value, z.index, fe);
      }
      function pi(z, fe) {
        Ke.value && (Rt.value = !0, n("columndragstart", z.value, z.index, fe));
      }
      function Ti(z, fe) {
        Ke.value && (Rt.value = !1, n("columndragend", z.value, z.index, fe));
      }
      function Li(z, fe) {
        Ke.value && n("columndrop", z.value, z.index, fe);
      }
      function zi(z, fe) {
        Ke.value && n("columndragover", z.value, z.index, fe);
      }
      function Ri(z, fe) {
        Ke.value && n("columndragleave", z.value, z.index, fe);
      }
      const ei = ye(
        ["rootClass", "o-table__root"],
        ["mobileClass", "o-table__root--mobile", null, a]
      ), oi = ye(
        ["wrapperClass", "o-table__wrapper"],
        [
          "stickyHeaderClass",
          "o-table__wrapper--sticky-header",
          null,
          O(() => r.stickyHeader)
        ],
        ["scrollableClass", "o-table__wrapper--scrollable", null, f],
        ["mobileClass", "o-table__wrapper--mobile", null, a]
      ), Wi = O(() => ({
        height: X1(r.height)
      })), Ki = ye(
        ["tableClass", "o-table"],
        [
          "borderedClass",
          "o-table--bordered",
          null,
          O(() => r.bordered)
        ],
        ["stripedClass", "o-table--striped", null, O(() => r.striped)],
        [
          "narrowedClass",
          "o-table--narrowed",
          null,
          O(() => r.narrowed)
        ],
        [
          "hoverableClass",
          "o-table--hoverable",
          null,
          O(
            () => (r.hoverable || r.selectable) && !!y.value.length
          )
        ],
        [
          "emptyClass",
          "o-table--empty",
          null,
          O(() => !y.value.length)
        ]
      ), Ut = ye(["thClass", "o-table__th"]), zr = ye(
        ["thCheckboxClass", "o-table__th-checkbox"],
        [
          "thStickyClass",
          "o-table__th--sticky",
          null,
          O(() => r.stickyCheckbox)
        ]
      ), an = ye([
        "thDetailedClass",
        "o-table__th-detailed"
      ]), An = ye([
        "thSubheadingClass",
        "o-table__th-subheading"
      ]), Wn = ye([
        "thSortIconClass",
        "o-table__th__sort-icon"
      ]), oe = ye([
        "trSelectedClass",
        "o-table__tr--selected"
      ]), le = ye([
        "trCheckedClass",
        "o-table__tr--checked"
      ]), we = ye(["trEmptyClass", "o-table__tr-empty"]), St = ye([
        "trDetailedClass",
        "o-table__tr-detail"
      ]), Xt = ye(["tdClass", "o-table__td"]), wr = ye(
        ["tdCheckboxClass", "o-table__td-checkbox"],
        [
          "thStickyClass",
          "o-table__th--sticky",
          null,
          O(() => r.stickyCheckbox)
        ]
      ), Ar = ye([
        "tdDetailedChevronClass",
        "o-table__td-chevron"
      ]), Cs = ye(["footerClass", "o-table__footer"]), bs = ye([
        "mobileSortClass",
        "o-table__mobile-sort"
      ]), bi = ye([
        "paginationWrapperClass",
        "o-table__pagination"
      ]), lr = O(
        () => Cu(bi)
      );
      function Ms(z) {
        const fe = x(z.value, Q.value) ? oe.value : [], re = J(z) ? le.value : [], kt = typeof r.rowClass == "function" && r.rowClass(z.value, z.index) || "";
        return [...fe, ...re, { [kt]: !0 }];
      }
      return C(), e({ rows: E, sort: se }), (z, fe) => (G(), X("div", {
        "data-oruga": "table",
        class: he(j(ei))
      }, [
        be("div", t0e, [
          ge(z.$slots, "default", {}, () => {
            var re;
            return [
              ge(z.$slots, "before"),
              (re = z.columns) != null && re.length ? (G(!0), X(ht, { key: 0 }, xi(z.columns, (kt, Qe) => (G(), De(uO, Tt({
                key: kt.field || Qe,
                ref_for: !0
              }, kt), {
                default: Ye(({ row: Xi }) => [
                  Ct(Pe(B(Xi, kt)), 1)
                ]),
                _: 2
              }, 1040))), 128)) : de("", !0),
              ge(z.$slots, "after")
            ];
          })
        ], 512),
        a.value && P.value ? (G(), De($we, {
          key: 0,
          "current-sort-column": N.value,
          columns: u.value,
          placeholder: z.mobileSortPlaceholder,
          "icon-pack": z.iconPack,
          "sort-icon": z.sortIcon,
          "sort-icon-size": z.sortIconSize,
          "is-asc": H.value,
          "mobile-sort-classes": j(bs),
          onSort: fe[0] || (fe[0] = (re, kt) => Z(re, !0, kt))
        }, null, 8, ["current-sort-column", "columns", "placeholder", "icon-pack", "sort-icon", "sort-icon-size", "is-asc", "mobile-sort-classes"])) : de("", !0),
        z.paginated && (z.paginationPosition === "top" || z.paginationPosition === "both") ? ge(z.$slots, "pagination", {
          key: 1,
          current: p.value,
          perPage: z.perPage,
          total: w.value,
          change: (re) => p.value = re
        }, () => [
          ee(B2, {
            current: p.value,
            "onUpdate:current": fe[1] || (fe[1] = (re) => p.value = re),
            paginated: z.paginated,
            "per-page": z.perPage,
            total: w.value,
            rounded: z.paginationRounded,
            size: z.paginationSize,
            order: z.paginationOrder,
            simple: z.paginationSimple,
            "icon-pack": z.iconPack,
            "aria-next-label": z.ariaNextLabel,
            "aria-previous-label": z.ariaPreviousLabel,
            "aria-page-label": z.ariaPageLabel,
            "aria-current-label": z.ariaCurrentLabel,
            "root-class": lr.value,
            onChange: fe[2] || (fe[2] = (re) => z.$emit("page-change", re))
          }, {
            default: Ye(() => [
              ge(z.$slots, "top-left")
            ]),
            _: 3
          }, 8, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
        ]) : de("", !0),
        be("div", {
          class: he(j(oi)),
          style: eE(Wi.value)
        }, [
          u.value.length ? (G(), X("table", Tt({ key: 0 }, z.$attrs, {
            class: j(Ki),
            tabindex: z.selectable || f.value ? 0 : void 0,
            "aria-rowcount": M.value,
            "aria-colcount": d.value,
            onKeydown: [
              fe[3] || (fe[3] = At(at((re) => v(-1, re), ["prevent"]), ["up"])),
              fe[4] || (fe[4] = At(at((re) => v(1, re), ["prevent"]), ["down"])),
              fe[5] || (fe[5] = At(at((re) => T(y.value[0], re), ["prevent"]), ["home"])),
              fe[6] || (fe[6] = At(at((re) => T(y.value[y.value.length - 1], re), ["prevent"]), ["end"]))
            ]
          }), [
            z.$slots.caption ? (G(), X("caption", r0e, [
              ge(z.$slots, "caption")
            ])) : de("", !0),
            z.showHeader ? (G(), X("thead", n0e, [
              ge(z.$slots, "preheader"),
              be("tr", s0e, [
                K.value ? (G(), X("th", {
                  key: 0,
                  class: he([...j(Ut), ...j(an)]),
                  "aria-colindex": 1,
                  "aria-hidden": "true"
                }, null, 2)) : de("", !0),
                z.checkable && z.checkboxPosition === "left" ? (G(), X("th", {
                  key: 1,
                  class: he([...j(Ut), ...j(zr)]),
                  "aria-colindex": K.value ? 2 : 1
                }, [
                  z.checkableHeader ? ge(z.$slots, "check-all", {
                    key: 0,
                    isAllChecked: q.value,
                    isAllUncheckable: U.value,
                    checkAll: Ce
                  }, () => [
                    ee(xh, {
                      "model-value": q.value,
                      autocomplete: "off",
                      name: "row_check_all",
                      variant: z.checkboxVariant,
                      disabled: U.value,
                      "aria-label": "Check all",
                      "onUpdate:modelValue": Ce
                    }, null, 8, ["model-value", "variant", "disabled"])
                  ]) : de("", !0)
                ], 10, o0e)) : de("", !0),
                (G(!0), X(ht, null, xi(u.value, (re) => {
                  var kt;
                  return G(), X(ht, {
                    key: re.identifier
                  }, [
                    re.hidden ? de("", !0) : (G(), X("th", Tt({
                      key: 0,
                      ref_for: !0
                    }, re.thAttrsData, {
                      class: [...j(Ut), ...re.thClasses],
                      style: a.value ? {} : re.style,
                      draggable: Ke.value,
                      "aria-sort": ie(re) ? H.value ? "ascending" : "descending" : void 0,
                      "aria-colindex": h.value + re.index,
                      onClick: at((Qe) => Z(re, !0, Qe), ["stop"]),
                      onDragstart: (Qe) => pi(re, Qe),
                      onDragend: (Qe) => Ti(re, Qe),
                      onDrop: (Qe) => Li(re, Qe),
                      onDragover: (Qe) => zi(re, Qe),
                      onDragleave: (Qe) => Ri(re, Qe)
                    }), [
                      (kt = re.$slots) != null && kt.header ? (G(), De(j(Qh), {
                        key: 0,
                        component: re.$el,
                        name: "header",
                        tag: "span",
                        props: {
                          column: re.value,
                          index: re.index
                        }
                      }, null, 8, ["component", "props"])) : (G(), X("span", A0e, [
                        Ct(Pe(re.label) + " ", 1),
                        re.sortable ? $t((G(), X("span", {
                          key: 0,
                          class: he(j(Wn)),
                          "aria-hidden": !ie(re)
                        }, [
                          ee(Fr, {
                            icon: z.sortIcon,
                            pack: z.iconPack,
                            both: "",
                            size: z.sortIconSize,
                            rotation: H.value ? 0 : 180
                          }, null, 8, ["icon", "pack", "size", "rotation"])
                        ], 10, l0e)), [
                          [gi, ie(re)]
                        ]) : de("", !0)
                      ]))
                    ], 16, a0e))
                  ], 64);
                }), 128)),
                z.checkable && z.checkboxPosition === "right" ? (G(), X("th", {
                  key: 2,
                  class: he([...j(Ut), ...j(zr)]),
                  "aria-colindex": h.value + u.value.length
                }, [
                  z.checkableHeader ? ge(z.$slots, "check-all", {
                    key: 0,
                    isAllChecked: q.value,
                    isAllUncheckable: U.value,
                    checkAll: Ce
                  }, () => [
                    ee(xh, {
                      "model-value": q.value,
                      autocomplete: "off",
                      name: "row_check_all",
                      variant: z.checkboxVariant,
                      disabled: U.value,
                      "aria-label": "Check all",
                      "onUpdate:modelValue": Ce
                    }, null, 8, ["model-value", "variant", "disabled"])
                  ]) : de("", !0)
                ], 10, c0e)) : de("", !0)
              ]),
              D.value ? (G(), X("tr", u0e, [
                K.value ? (G(), X("th", {
                  key: 0,
                  class: he([...j(Ut), ...j(an)]),
                  "aria-hidden": "true"
                }, null, 2)) : de("", !0),
                z.checkable && z.checkboxPosition === "left" ? (G(), X("th", d0e)) : de("", !0),
                (G(!0), X(ht, null, xi(u.value, (re) => {
                  var kt;
                  return G(), X(ht, {
                    key: re.identifier
                  }, [
                    re.hidden ? de("", !0) : (G(), X("th", Tt({
                      key: 0,
                      ref_for: !0
                    }, re.thAttrsData, {
                      class: [...j(Ut), ...re.thClasses],
                      style: a.value ? {} : re.style
                    }), [
                      re.searchable ? (G(), X(ht, { key: 0 }, [
                        (kt = re.$slots) != null && kt.searchable ? (G(), De(j(Qh), {
                          key: 0,
                          component: re.$el,
                          name: "searchable",
                          tag: "span",
                          props: {
                            column: re.value,
                            index: re.index,
                            filters: S.value
                          }
                        }, null, 8, ["component", "props"])) : re.field ? (G(), De(q1, Tt({
                          key: 1,
                          modelValue: S.value[re.field],
                          "onUpdate:modelValue": (Qe) => S.value[re.field] = Qe,
                          name: `column_${re.field}_filter`,
                          type: re.numeric ? "number" : "search",
                          placeholder: z.filtersPlaceholder,
                          icon: z.filtersIcon,
                          pack: z.iconPack,
                          size: "small",
                          "aria-label": `${re.label} search`
                        }, { [kG(z.filtersEvent)]: Y }), null, 16, ["modelValue", "onUpdate:modelValue", "name", "type", "placeholder", "icon", "pack", "aria-label"])) : de("", !0)
                      ], 64)) : de("", !0)
                    ], 16))
                  ], 64);
                }), 128)),
                z.checkable && z.checkboxPosition === "right" ? (G(), X("th", h0e)) : de("", !0)
              ])) : de("", !0),
              g.value ? (G(), X("tr", {
                key: 1,
                "aria-rowindex": D.value ? 3 : 2
              }, [
                K.value ? (G(), X("th", {
                  key: 0,
                  class: he([...j(Ut), ...j(an)])
                }, null, 2)) : de("", !0),
                z.checkable && z.checkboxPosition === "left" ? (G(), X("th", f0e)) : de("", !0),
                (G(!0), X(ht, null, xi(u.value, (re) => {
                  var kt;
                  return G(), X(ht, {
                    key: re.identifier
                  }, [
                    re.hidden ? de("", !0) : (G(), X("th", {
                      key: 0,
                      style: eE(a.value ? {} : re.style),
                      class: he([
                        ...j(Ut),
                        ...j(An)
                      ])
                    }, [
                      (kt = re.$slots) != null && kt.subheading ? (G(), De(j(Qh), {
                        key: 0,
                        component: re.$el,
                        name: "subheading",
                        tag: "span",
                        props: {
                          column: re.value,
                          index: re.index
                        }
                      }, null, 8, ["component", "props"])) : (G(), X("span", p0e, [
                        ge(z.$slots, "subheading", {}, () => [
                          Ct(Pe(re.subheading), 1)
                        ])
                      ]))
                    ], 6))
                  ], 64);
                }), 128)),
                z.checkable && z.checkboxPosition === "right" ? (G(), X("th", m0e)) : de("", !0)
              ], 8, g0e)) : de("", !0)
            ])) : de("", !0),
            be("tbody", null, [
              (G(!0), X(ht, null, xi(E.value, (re, kt) => (G(), X(ht, {
                key: re.key
              }, [
                re.hidden ? de("", !0) : (G(), X("tr", {
                  key: 0,
                  class: he(Ms(re)),
                  draggable: rt.value,
                  "aria-rowindex": I.value + kt + 1,
                  onClick: (Qe) => T(re, Qe),
                  onDblclick: (Qe) => z.$emit("dblclick", re.value, re.index, Qe),
                  onMouseenter: (Qe) => z.$emit(
                    "mouseenter",
                    re.value,
                    re.index,
                    Qe
                  ),
                  onMouseleave: (Qe) => z.$emit(
                    "mouseleave",
                    re.value,
                    re.index,
                    Qe
                  ),
                  onContextmenu: (Qe) => z.$emit(
                    "contextmenu",
                    re.value,
                    re.index,
                    Qe
                  ),
                  onDragstart: (Qe) => Qt(re, Qe),
                  onDragend: (Qe) => Ht(re, Qe),
                  onDrop: (Qe) => lt(re, Qe),
                  onDragover: (Qe) => Ft(re, Qe),
                  onDragleave: (Qe) => si(re, Qe)
                }, [
                  K.value ? (G(), X("td", {
                    key: 0,
                    class: he([
                      ...j(Xt),
                      ...j(Ar)
                    ])
                  }, [
                    z.isDetailedVisible(re.value) ? (G(), De(Fr, {
                      key: 0,
                      icon: z.detailIcon,
                      pack: z.iconPack,
                      rotation: Fe(re) ? 90 : 0,
                      role: "button",
                      tabindex: "0",
                      clickable: "",
                      both: "",
                      "aria-label": `Open ${re.label} details`,
                      onClick: at((Qe) => Ae(re), ["prevent"]),
                      onKeydown: [
                        At(at((Qe) => Ae(re), ["prevent"]), ["enter"]),
                        At(at((Qe) => Ae(re), ["prevent"]), ["space"])
                      ]
                    }, null, 8, ["icon", "pack", "rotation", "aria-label", "onClick", "onKeydown"])) : de("", !0)
                  ], 2)) : de("", !0),
                  z.checkable && z.checkboxPosition === "left" ? (G(), X("td", {
                    key: 1,
                    class: he([
                      ...j(Ut),
                      ...j(wr)
                    ])
                  }, [
                    ee(xh, {
                      "model-value": J(re),
                      autocomplete: "off",
                      name: `row_${re.index}_check`,
                      variant: z.checkboxVariant,
                      disabled: !z.isRowCheckable(re.value),
                      "aria-label": `Check ${re.label}`,
                      "onUpdate:modelValue": (Qe) => Re(re)
                    }, null, 8, ["model-value", "name", "variant", "disabled", "aria-label", "onUpdate:modelValue"])
                  ], 2)) : de("", !0),
                  (G(!0), X(ht, null, xi(u.value, (Qe) => (G(), X(ht, {
                    key: Qe.identifier
                  }, [
                    Qe.hidden ? de("", !0) : (G(), De(j(Qh), Tt({
                      key: 0,
                      ref_for: !0
                    }, Qe.tdAttrsData[re.index], {
                      component: Qe.$el,
                      name: "default",
                      tag: "td",
                      class: [
                        ...j(Xt),
                        ...Qe.tdClasses
                      ],
                      style: a.value ? {} : Qe.style,
                      props: {
                        row: re.value,
                        index: re.index,
                        column: Qe.value,
                        colindex: Qe.index,
                        toggleDetails: () => Ae(re)
                      },
                      onClick: (Xi) => z.$emit(
                        "cell-click",
                        re.value,
                        Qe.value,
                        re.index,
                        Qe.index,
                        Xi
                      )
                    }), {
                      default: Ye(() => [
                        Ct(Pe(B(re.value, Qe)), 1)
                      ]),
                      _: 2
                    }, 1040, ["component", "class", "style", "props", "onClick"]))
                  ], 64))), 128)),
                  z.checkable && z.checkboxPosition === "right" ? (G(), X("td", {
                    key: 2,
                    class: he([
                      ...j(Ut),
                      ...j(wr)
                    ])
                  }, [
                    ee(xh, {
                      "model-value": J(re),
                      autocomplete: "off",
                      variant: z.checkboxVariant,
                      disabled: !z.isRowCheckable(re.value),
                      "aria-label": `Check ${re.label}`,
                      "onUpdate:modelValue": (Qe) => Re(re)
                    }, null, 8, ["model-value", "variant", "disabled", "aria-label", "onUpdate:modelValue"])
                  ], 2)) : de("", !0)
                ], 42, E0e)),
                r.detailed ? (G(), De(YG, {
                  key: 1,
                  name: z.detailTransition
                }, {
                  default: Ye(() => [
                    Fe(re) ? (G(), X(ht, { key: 0 }, [
                      z.customDetailRow ? ge(z.$slots, "detail", {
                        key: 0,
                        row: re.value,
                        index: re.index
                      }) : (G(), X("tr", {
                        key: `${re.key}_detail`,
                        class: he(j(St))
                      }, [
                        be("td", { colspan: d.value }, [
                          ge(z.$slots, "detail", {
                            row: re.value,
                            index: re.index
                          })
                        ], 8, y0e)
                      ], 2))
                    ], 64)) : de("", !0)
                  ]),
                  _: 2
                }, 1032, ["name"])) : de("", !0)
              ], 64))), 128)),
              y.value.length ? de("", !0) : (G(), X("tr", {
                key: 0,
                class: he(j(we))
              }, [
                be("td", { colspan: d.value }, [
                  ge(z.$slots, "empty", {}, () => [
                    z.emptyIcon ? (G(), De(Fr, {
                      key: 0,
                      icon: z.emptyIcon,
                      size: z.emptyIconSize,
                      pack: z.iconPack,
                      both: ""
                    }, null, 8, ["icon", "size", "pack"])) : de("", !0),
                    Ct(" " + Pe(z.emptyLabel), 1)
                  ])
                ], 8, B0e)
              ], 2))
            ]),
            z.$slots.footer ? (G(), X("tfoot", w0e, [
              be("tr", {
                class: he(j(Cs))
              }, [
                b() ? ge(z.$slots, "footer", {
                  key: 0,
                  columnCount: d.value,
                  rowCount: M.value
                }) : (G(), X("th", {
                  key: 1,
                  colspan: d.value
                }, [
                  ge(z.$slots, "footer", {
                    columnCount: d.value,
                    rowCount: M.value
                  })
                ], 8, C0e))
              ], 2)
            ])) : de("", !0)
          ], 16, i0e)) : de("", !0),
          ge(z.$slots, "loading", { loading: z.loading }, () => [
            ee(nQ, Tt(z.loadingClasses, {
              "full-page": !1,
              active: z.loading,
              icon: z.loadingIcon,
              label: z.loadingLabel
            }), null, 16, ["active", "icon", "label"])
          ])
        ], 6),
        z.checkable && z.$slots["bottom-left"] || z.paginated && (z.paginationPosition === "bottom" || z.paginationPosition === "both") ? ge(z.$slots, "pagination", {
          key: 2,
          current: p.value,
          perPage: z.perPage,
          total: w.value,
          change: (re) => p.value = re
        }, () => [
          ee(B2, {
            current: p.value,
            "onUpdate:current": fe[7] || (fe[7] = (re) => p.value = re),
            paginated: z.paginated,
            "per-page": z.perPage,
            total: w.value,
            rounded: z.paginationRounded,
            size: z.paginationSize,
            order: z.paginationOrder,
            simple: z.paginationSimple,
            "icon-pack": z.iconPack,
            "aria-next-label": z.ariaNextLabel,
            "aria-previous-label": z.ariaPreviousLabel,
            "aria-page-label": z.ariaPageLabel,
            "aria-current-label": z.ariaCurrentLabel,
            "root-class": lr.value,
            onChange: fe[8] || (fe[8] = (re) => z.$emit("page-change", re))
          }, {
            default: Ye(() => [
              ge(z.$slots, "bottom-left")
            ]),
            _: 3
          }, 8, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
        ]) : de("", !0)
      ], 2));
    }
  }), M0e = {
    install(t) {
      Br(t, b0e), Br(t, uO);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const I0e = ["id", "data-id", "hidden", "aria-labelledby"], dO = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OTabItem",
    configField: "tabs",
    inheritAttrs: !1,
    __name: "TabItem",
    props: {
      override: { type: Boolean, default: void 0 },
      value: { default: void 0 },
      label: { default: void 0 },
      disabled: { type: Boolean, default: !1 },
      visible: { type: Boolean, default: !0 },
      icon: { default: () => W("tabs.icon") },
      iconPack: { default: () => W("tabs.iconPack") },
      tag: { default: () => W("tabs.itemTag", "button") },
      content: { default: void 0 },
      component: { default: void 0 },
      props: { default: void 0 },
      events: { default: void 0 },
      tabClass: {},
      tabActiveClass: {},
      tabPreviousClass: {},
      tabNextClass: {},
      tabDisabledClass: {},
      tabIconClass: {},
      tabLabelClass: {},
      tabPanelClass: {}
    },
    emits: ["activate", "deactivate"],
    setup(t, { emit: e }) {
      const i = t, r = e, n = i.value ?? Pn(), s = Ng(), o = O(() => ({
        ...i,
        value: n,
        $slots: s,
        tabClasses: E.value,
        iconClasses: y.value,
        labelClasses: C.value,
        isTransitioning: u.value,
        activate: g,
        deactivate: f
      })), { parent: a, item: A } = eQ({
        data: o
      }), l = ue(), c = O(() => A.value.index === a.value.activeIndex), u = ue(!1), d = O(() => {
        const M = a.value.vertical && a.value.animation.length === 4 ? 2 : 0;
        return a.value.animation[M];
      }), h = O(() => {
        const M = a.value.vertical && a.value.animation.length === 4 ? 3 : 1;
        return a.value.animation[M];
      });
      function g(M) {
        l.value = A.value.index < M ? d.value : h.value, r("activate");
      }
      function f(M) {
        l.value = M < A.value.index ? d.value : h.value, r("deactivate");
      }
      function p() {
        u.value = !0;
      }
      function m() {
        u.value = !0;
      }
      const E = ye(
        ["tabClass", "o-tabs__tab"],
        ["tabActiveClass", "o-tabs__tab--active", null, c],
        [
          "tabDisabledClass",
          "o-tabs__tab--disabled",
          null,
          O(() => i.disabled)
        ],
        [
          "tabPreviousClass",
          "o-tabs__tab--previous",
          null,
          O(() => {
            var M;
            return A.value.index < ((M = a.value) == null ? void 0 : M.activeIndex);
          })
        ],
        [
          "tabNextClass",
          "o-tabs__tab--next",
          null,
          O(() => {
            var M;
            return A.value.index > ((M = a.value) == null ? void 0 : M.activeIndex);
          })
        ]
      ), y = ye(["tabIconClass", "o-tabs__tab-icon"]), C = ye(["tabLabelClass", "o-tabs__tab-label"]), w = ye(["tabPanelClass", "o-tabs__panel"]);
      return (M, I) => j(a) ? (G(), De(Ws, {
        key: 0,
        css: j(a).animated,
        name: l.value,
        appear: j(a).animateInitially,
        onAfterEnter: p,
        onBeforeLeave: m
      }, {
        default: Ye(() => [
          $t(be("div", Tt(M.$attrs, {
            id: `tabpanel-${j(A).identifier}`,
            "data-oruga": "tabs-item",
            "data-id": `tabs-${j(A).identifier}`,
            class: j(w),
            role: "tabpanel",
            hidden: !c.value,
            "aria-labelledby": `tab-${j(A).identifier}`,
            "aria-roledescription": "item"
          }), [
            ge(M.$slots, "default", {
              active: c.value && M.visible
            }, () => [
              M.component ? (G(), De(Nr(M.component), Tt({ key: 0 }, M.$props.props, ZM(M.$props.events || {})), null, 16)) : (G(), X(ht, { key: 1 }, [
                Ct(Pe(M.content), 1)
              ], 64))
            ]),
            de("", !0)
          ], 16, I0e), [
            [gi, c.value && M.visible]
          ])
        ]),
        _: 3
      }, 8, ["css", "name", "appear"])) : de("", !0);
    }
  }), v0e = /* @__PURE__ */ je({
    isOruga: !0,
    name: "OTabs",
    configField: "tabs",
    __name: "Tabs",
    props: /* @__PURE__ */ li({
      override: { type: Boolean, default: void 0 },
      modelValue: { default: void 0 },
      options: { default: void 0 },
      variant: { default: () => W("tabs.variant") },
      size: { default: () => W("tabs.size") },
      vertical: { type: Boolean, default: () => W("tabs.vertical", !1) },
      position: { default: void 0 },
      type: { default: () => W("tabs.type", "default") },
      expanded: { type: Boolean, default: !1 },
      tag: { default: () => W("tabs.tag", "div") },
      activateOnFocus: { type: Boolean, default: !1 },
      animated: { type: Boolean, default: () => W("tabs.animated", !0) },
      animation: { default: () => W("tabs.animation", [
        "slide-next",
        "slide-prev",
        "slide-down",
        "slide-up"
      ]) },
      animateInitially: { type: Boolean, default: () => W("tabs.animateInitially", !1) },
      multiline: { type: Boolean, default: !1 },
      ariaLabel: { default: () => W("tabs.ariaLabel") },
      rootClass: {},
      positionClass: {},
      sizeClass: {},
      typeClass: {},
      expandedClass: {},
      verticalClass: {},
      multilineClass: {},
      listClass: {},
      contentClass: {},
      transitioningClass: {}
    }, {
      modelValue: { default: void 0 },
      modelModifiers: {}
    }),
    emits: /* @__PURE__ */ li(["update:model-value", "change"], ["update:modelValue"]),
    setup(t, { emit: e }) {
      const i = t, r = e, n = cs("rootElement"), s = O(() => {
        var b;
        return {
          activeIndex: ((b = u.value) == null ? void 0 : b.index) ?? 0,
          type: i.type,
          vertical: i.vertical,
          animated: i.animated,
          animation: i.animation,
          animateInitially: i.animateInitially
        };
      }), { childItems: o } = $1({
        rootRef: n,
        data: s
      }), a = O(() => o.value ? o.value.map((b) => ({
        index: b.index,
        identifier: b.identifier,
        ...zt(b.data)
      })) : []), { nextSequence: A } = Vd(), l = O(
        () => kf(i.options, A)
      ), c = Hi(t, "modelValue");
      ct(
        () => i.modelValue,
        (b) => {
          c.value !== b && C(b);
        }
      );
      const u = ue();
      vi(() => {
        u.value = Qr(c.value) && a.value.find((b) => b.value === c.value) || a.value[0];
      });
      const d = O(
        () => a.value.some((b) => b.isTransitioning)
      );
      er(() => {
        var b;
        c.value || (c.value = (b = a.value[0]) == null ? void 0 : b.value);
      });
      function h(b) {
        c.value !== b.value && C(b.value);
      }
      function g(b, B) {
        if (i.vertical && b.key == "ArrowDown" || !i.vertical && b.key == "ArrowRight") {
          const x = Xh(B + 1, a.value.length), Q = y(x, !0);
          E(Q);
        }
      }
      function f(b, B) {
        if (i.vertical && b.key == "ArrowUp" || !i.vertical && b.key == "ArrowLeft") {
          const x = Xh(B - 1, a.value.length), Q = y(x, !1);
          E(Q);
        }
      }
      function p() {
        if (a.value.length < 1) return;
        const b = y(0, !0);
        E(b);
      }
      function m() {
        if (a.value.length < 1) return;
        const b = y(a.value.length - 1, !1);
        E(b);
      }
      function E(b) {
        var B;
        if (i.activateOnFocus)
          h(b);
        else {
          const x = (B = n.value) == null ? void 0 : B.querySelector(
            `#tab-${b.identifier}`
          );
          x == null || x.focus();
        }
      }
      function y(b, B) {
        var x;
        const Q = B ? 1 : -1;
        let v = b;
        for (; v !== ((x = u.value) == null ? void 0 : x.index) && !(a.value[v].visible && !a.value[v].disabled); v = Xh(v + Q, a.value.length))
          ;
        return a.value[v];
      }
      function C(b) {
        const B = c.value, x = u.value, Q = a.value.find((v) => v.value === b) || a.value[0];
        x && Q && (x.deactivate(Q.index), Q.activate(x.index)), ji(() => {
          c.value = b, r("change", b, B);
        });
      }
      const w = ye(
        ["rootClass", "o-tabs"],
        [
          "positionClass",
          "o-tabs--",
          O(() => i.position),
          O(() => !!i.position)
        ],
        [
          "sizeClass",
          "o-tabs--",
          O(() => i.size),
          O(() => !!i.size)
        ],
        [
          "typeClass",
          "o-tabs--",
          O(() => i.type),
          O(() => !!i.type)
        ],
        ["expandedClass", "o-tabs--expanded", null, O(() => i.expanded)],
        ["verticalClass", "o-tabs--vertical", null, O(() => i.vertical)],
        [
          "multilineClass",
          "o-tabs--multiline",
          null,
          O(() => i.multiline)
        ]
      ), M = ye(["listClass", "o-tabs__list"]), I = ye(
        ["contentClass", "o-tabs__content"],
        [
          "transitioningClass",
          "o-tabs__content--transitioning",
          null,
          d
        ]
      );
      return (b, B) => (G(), X("div", {
        ref: "rootElement",
        "data-oruga": "tabs",
        class: he(j(w))
      }, [
        (G(), De(Nr(i.tag), {
          class: he(j(M)),
          role: "tablist",
          "aria-label": b.ariaLabel,
          "aria-orientation": b.vertical ? "vertical" : "horizontal"
        }, {
          default: Ye(() => [
            ge(b.$slots, "before"),
            (G(!0), X(ht, null, xi(a.value, (x) => {
              var Q, v, T;
              return $t((G(), De(j(Qh), {
                id: `tab-${x.identifier}`,
                key: x.identifier,
                component: x,
                tag: x.tag,
                name: "header",
                class: he(x.tabClasses),
                role: "tab",
                tabindex: x.value === ((Q = u.value) == null ? void 0 : Q.value) ? 0 : -1,
                "aria-current": x.value === ((v = u.value) == null ? void 0 : v.value) ? "true" : void 0,
                "aria-controls": `tabpanel-${x.identifier}`,
                "aria-selected": x.value === ((T = u.value) == null ? void 0 : T.value),
                onClick: (S) => h(x),
                onKeydown: [
                  At(at((S) => h(x), ["prevent"]), ["enter"]),
                  At(at((S) => h(x), ["prevent"]), ["space"]),
                  At(at((S) => f(S, x.index), ["prevent"]), ["left"]),
                  At(at((S) => g(S, x.index), ["prevent"]), ["right"]),
                  At(at((S) => f(S, x.index), ["prevent"]), ["up"]),
                  At(at((S) => g(S, x.index), ["prevent"]), ["down"]),
                  At(at(p, ["prevent"]), ["home"]),
                  At(at(m, ["prevent"]), ["end"])
                ]
              }, {
                default: Ye(() => [
                  x.icon ? (G(), De(Fr, {
                    key: 0,
                    class: he(x.iconClasses),
                    icon: x.icon,
                    pack: x.iconPack,
                    size: b.size
                  }, null, 8, ["class", "icon", "pack", "size"])) : de("", !0),
                  be("span", {
                    class: he(x.labelClasses)
                  }, Pe(x.label), 3)
                ]),
                _: 2
              }, 1032, ["id", "component", "tag", "class", "tabindex", "aria-current", "aria-controls", "aria-selected", "onClick", "onKeydown"])), [
                [gi, x.visible]
              ]);
            }), 128)),
            ge(b.$slots, "after")
          ]),
          _: 3
        }, 8, ["class", "aria-label", "aria-orientation"])),
        be("section", {
          class: he(j(I))
        }, [
          ge(b.$slots, "default", {}, () => [
            (G(!0), X(ht, null, xi(l.value, (x) => $t((G(), De(dO, Tt({ ref_for: !0 }, x.attrs, {
              key: x.key,
              value: x.value,
              label: x.label
            }), null, 16, ["value", "label"])), [
              [gi, !x.hidden]
            ])), 128))
          ])
        ], 2)
      ], 2));
    }
  }), x0e = {
    install(t) {
      Br(t, v0e), Br(t, dO);
    }
  };
  /*! Oruga v0.10.2 | MIT License | github.com/oruga-ui/oruga */
  const Q0e = {
    install(t) {
      Br(t, cO);
    }
  }, ow = K4(), F0e = (t) => {
    ow.notification.open({
      message: t,
      position: "bottom-left",
      variant: "danger",
      duration: 8e3,
      // 8sec
      closable: !0,
      role: "alert",
      ariaLive: "assertive",
      ariaAtomic: !0,
      ariaCloseLabel: "Close",
      rootClass: "alert-dismissible"
    });
  }, S0e = (t) => {
    ow.notification.open({
      message: t,
      position: "bottom-left",
      variant: "success",
      icon: "success",
      duration: 3e3,
      // 3sec
      closable: !0,
      queue: !1,
      role: "alert",
      ariaLive: "assertive",
      ariaAtomic: !0,
      ariaCloseLabel: "Close",
      rootClass: "alert-dismissible",
      iconClass: "text-success"
    });
  }, D0e = (t) => {
    ow.notification.open({
      message: t,
      position: "bottom-left",
      variant: "primary",
      icon: "info",
      duration: 3e3,
      // 3sec
      closable: !0,
      queue: !0,
      role: "alert",
      ariaLive: "assertive",
      ariaAtomic: !0,
      ariaCloseLabel: "Close",
      rootClass: "alert-dismissible",
      iconClass: "text-primary"
    });
  }, T0e = (t) => {
    ow.notification.open({
      message: t,
      position: "bottom-left",
      variant: "warning",
      icon: "warning",
      duration: 4e3,
      // 4sec
      queue: !1,
      ariaRole: "alert",
      ariaLive: "assertive",
      ariaAtomic: !0,
      ariaCloseLabel: "Close",
      rootClass: "alert-dismissible",
      iconClass: "text-warning"
    });
  }, R0e = {
    showInfo: D0e,
    showWarning: T0e,
    showSuccess: S0e,
    showError: F0e
  }, _0e = () => R0e, k0e = "353cdae2-2c78-1654-c1f0-85192cfa13d6", Y0e = "EPSG:25832", N0e = 3, U0e = /* @__PURE__ */ je({
    __name: "SearchGazetteer",
    emits: ["select", "search:input"],
    setup(t, { emit: e }) {
      const i = e, r = ue(), n = `https://sg.geodatenzentrum.de/gdz_ortssuche__${k0e}/geosearch?count=${N0e}&srsname=${Y0e}&query=`;
      async function s(c) {
        const u = `${n}${encodeURIComponent(c)}`;
        try {
          const d = await fetch(u);
          if (!d.ok)
            throw new Error(`Request failed with status ${d.status}`);
          return await d.json();
        } catch (d) {
          throw new Error(`Gazetteer search failed: ${d}`);
        }
      }
      const o = [
        { label: "Suchbegriff eingeben", value: void 0, attrs: { disabled: !0 } }
      ], a = SM(
        async (c) => {
          if (!c || c.length < 4)
            return o;
          try {
            const u = await s(c);
            return u.features.length < 1 ? [
              { label: "Kein Ergebnis vorhanden", value: void 0, attrs: { disabled: !0 } }
            ] : [
              ...u.features.map((d) => {
                var h;
                return {
                  label: ((h = d.properties) == null ? void 0 : h.text) ?? "",
                  value: d
                };
              }),
              { label: "Alle anzeigen", value: void 0, attrs: { "data-h2-show-all": !0 } }
            ];
          } catch (u) {
            return console.error("Search error:", u), o;
          }
        },
        {
          default: o
        }
      );
      function A(c) {
        c && i("select", c);
      }
      const l = (c) => {
        c || (a.call(""), r.value = void 0);
      };
      return (c, u) => {
        const d = Os("o-autocomplete");
        return G(), De(d, {
          modelValue: r.value,
          "onUpdate:modelValue": u[0] || (u[0] = (h) => r.value = h),
          options: j(a).data,
          inputClass: "h2-autocomplete-input",
          placeholder: "Adresse...",
          clearable: "",
          clearOnSelect: "",
          icon: "search",
          openOnFocus: "",
          mobileModal: !1,
          debounce: 500,
          loading: j(a).isLoading,
          filter: () => !1,
          onInput: j(a).call,
          onSelect: A,
          onFocus: u[1] || (u[1] = (h) => i("search:input", !0)),
          onBlur: u[2] || (u[2] = (h) => i("search:input", !1)),
          "onUpdate:input": l
        }, null, 8, ["modelValue", "options", "loading", "onInput"]);
      };
    }
  }), L0e = "[data-v-b6262211] .h2-autocomplete-input{width:320px;height:40px;padding-right:35px;margin-left:0!important;border-radius:20px}[data-v-b6262211] .dropdown-trigger[aria-expanded=true] .h2-autocomplete-input{border-radius:20px 20px 0 0}[data-v-b6262211] .dropdown-menu{border-radius:0 0 20px 20px!important;border-color:1px solid red}[data-v-b6262211] .dropdown-menu.position-bottom{top:calc(100% + var(--diplan-dropdown-spacer) - 3px)!important;background-color:#fff;padding:8px;transform:translate(0)!important}[data-v-b6262211] .dropdown-item[data-h2-show-all=true]{color:#3375d4;font-weight:600}", z0e = /* @__PURE__ */ Zl(U0e, [["styles", [L0e]], ["__scopeId", "data-v-b6262211"]]), P0e = { class: "ol-popup" }, O0e = { key: 1 }, G0e = /* @__PURE__ */ je({
    __name: "GeometryOverlay",
    props: {
      geometries: { type: Array, required: !0 },
      names: { type: Array, required: !0 }
    },
    emits: ["add", "subtract", "update"],
    setup(t, { emit: e }) {
      const i = e;
      return (r, n) => (G(), X("div", P0e, [
        (G(!0), X(ht, null, xi(t.geometries, (s, o) => {
          var a;
          return G(), X(ht, {
            key: j(ve)(s.feature)
          }, [
            s.variant === j(eI).CADASTRAL ? (G(), X("div", {
              key: 0,
              class: he(s.variant)
            }, [
              n[2] || (n[2] = be("b", null, "Flurstücksinformationen:", -1)),
              n[3] || (n[3] = be("b", null, "Name:", -1)),
              be("span", null, Pe(s.feature.getProperties().lagebeztxt), 1),
              n[4] || (n[4] = be("b", null, "Gemarkung:", -1)),
              be("span", null, Pe(s.feature.getProperties().gemarkung), 1),
              n[5] || (n[5] = be("b", null, "Flurstücksnummer:", -1)),
              be("span", null, Pe(s.feature.getProperties().flstnrzae), 1),
              ee(j(vl), {
                class: "mt-3",
                variant: "secondary",
                icon: "group",
                onClick: (A) => i("add", s.feature)
              }, {
                default: Ye(() => n[0] || (n[0] = [
                  Ct(" Als Umring verwenden ")
                ])),
                _: 2
              }, 1032, ["onClick"]),
              (a = s.attrs) != null && a.isSubtractAllowed ? (G(), De(j(vl), {
                key: 0,
                class: "mt-3",
                variant: "secondary",
                icon: "minus",
                onClick: (A) => i("subtract", s.feature)
              }, {
                default: Ye(() => n[1] || (n[1] = [
                  Ct(" Aus Umring entfernen ")
                ])),
                _: 2
              }, 1032, ["onClick"])) : de("", !0)
            ], 2)) : de("", !0),
            t.geometries.length > 1 && o < t.geometries.length - 1 ? (G(), X("hr", O0e)) : de("", !0)
          ], 64);
        }), 128))
      ]));
    }
  }), j0e = '.ol-popup[data-v-9e0e009c]{position:absolute;bottom:12px;left:-50px;padding:15px;box-shadow:0 .125rem .25rem #04071a13;background-color:var(--diplan-white);border:1px solid var(--diplan-gray)}.ol-popup[data-v-9e0e009c]:before{content:" ";position:absolute;top:100%;left:48px;border:solid transparent;border-top-color:var(--diplan-white);border-width:11px;margin-left:-11px;pointer-events:none}.ol-popup>div[data-v-9e0e009c]{display:grid}.ol-popup>div[data-v-9e0e009c]>*:first-child{padding-bottom:1em}.ol-popup .cadastral[data-v-9e0e009c],.ol-popup .status[data-v-9e0e009c]{min-width:280px}.ol-popup[data-v-9e0e009c] .formkit-outer:not([data-type=hidden]){margin-bottom:1em}', H0e = /* @__PURE__ */ Zl(G0e, [["styles", [j0e]], ["__scopeId", "data-v-9e0e009c"]]);
  function TM() {
    return Xm.instance || (Xm.instance = new Xm());
  }
  function w2(t) {
    if (!t)
      throw new Error("There was no api set!");
    return {
      headers: {
        Authorization: `Bearer ${t}`
      }
    };
  }
  class Xm {
    constructor() {
      Ne(this, "api", "http://localhost:8080/api/");
    }
    getLayerConfig(e) {
      const i = w2(e);
      return Bi.get(this.api + "config/layer", i).then((r) => r.data).catch((r) => {
        throw new Error("Was not able to get Layer config", r);
      });
    }
    getPortalConfig(e) {
      const i = w2(e);
      return Bi.get(this.api + "config/portal", i).then((r) => r.data).catch((r) => {
        throw new Error("Was not able to get Portal config", r);
      });
    }
    // TODO Make type more explicit than any
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validateGeometry(e) {
      return console.log("validateGeometry", e), !0;
    }
    /**
     * Requests the public API of the city of Hamburg to fetch all cadestral features that lie inside the viewport of the map.
     * @param bbox boundingBox of the viewport
     * @returns an array of features that touch the boundingbox in the CRS EPSG:25832
     */
    fetchCadastralFeatures(e) {
      return Bi.get("https://api.hamburg.de/datasets/v1/alkis_vereinfacht/collections/Flurstueck/items?bbox=" + e.join(",") + "&bbox-crs=http%3A%2F%2Fwww.opengis.net%2Fdef%2Fcrs%2FEPSG%2F0%2F25832&crs=http%3A%2F%2Fwww.opengis.net%2Fdef%2Fcrs%2FEPSG%2F0%2F25832&filter-crs=http%3A%2F%2Fwww.opengis.net%2Fdef%2Fcrs%2FOGC%2F1.3%2FCRS84&filter-lang=cql2-text&offset=0&limit=500&skipGeometry=false").then((n) => n.data);
    }
    fetchXPlanInfo(e) {
      return Bi.get("https://hh.xplanungsplattform.de/xplan-wms/services/wms?REQUEST=GetFeatureInfo&QUERY_LAYERS=BP_Planvektor&SERVICE=WMS&VERSION=1.3.0&FORMAT=image/png&STYLES=&TRANSPARENT=true&CACHEID=6098142&LAYERS=BP_Planvektor&SINGLETILE=false&WIDTH=512&HEIGHT=512&INFO_FORMAT=text/xml&FEATURE_COUNT=20&I=346&J=466&CRS=EPSG:25832&BBOX=" + e.join(",")).then((r) => r.data);
    }
  }
  Ne(Xm, "instance");
  const J0e = { class: "xplan-box" }, V0e = { class: "xplan-padding" }, W0e = { class: "header" }, K0e = { class: "dpk-row" }, X0e = { key: 0 }, Z0e = { class: "table" }, q0e = { class: "table-body" }, $0e = { class: "table-body-cell" }, eCe = { class: "table-body-cell" }, tCe = /* @__PURE__ */ je({
    __name: "GFIOverlay",
    props: {
      geometry: { type: Object, default: void 0 }
    },
    emits: ["close:gfi"],
    setup(t, { emit: e }) {
      const i = t, r = new jx(), n = new ld(), s = e;
      ct(
        () => i.geometry,
        () => c()
      );
      const o = ue(), a = ue(), A = ue("object"), l = ue();
      function c() {
        var p, m;
        const f = (m = (p = i.geometry) == null ? void 0 : p.getGeometry()) == null ? void 0 : m.getExtent();
        f && TM().fetchXPlanInfo(f).then((E) => {
          var w, M;
          const y = r.readFeatures(E), C = n.writeFeatures(y);
          o.value = JSON.parse(C), (w = o.value) != null && w.features.length && (a.value = (M = o.value) == null ? void 0 : M.features[0]);
        });
      }
      function u() {
        return o.value ? o.value.features.map((f) => ({ label: f.properties.xpPlanName, value: f })) : [];
      }
      function d(f) {
        if (!o.value) return;
        let m = o.value.features.map((E) => E.id).indexOf(a.value.id) + f;
        m > o.value.features.length ? m = 0 : m < 0 && (m = o.value.features.length - 1), a.value = o.value.features[m];
      }
      ct(a, () => {
        a.value && (l.value = a.value.properties, h());
      });
      function h() {
        a.value.properties && (l.value = Object.fromEntries(
          Object.entries(a.value.properties).filter(
            ([f]) => !f.includes("position") && !f.includes("text") && !f.includes("xp")
          )
        ));
      }
      function g(f) {
        a.value.properties && (l.value = Object.fromEntries(
          Object.entries(a.value.properties).filter(([p]) => p.includes(f))
        ));
      }
      return ct(A, () => {
        switch (A.value) {
          case "plan":
            g("xp");
            break;
          case "text":
            g("text");
            break;
          case "references":
            g("position");
            break;
          case "object":
            h();
            break;
        }
      }), (f, p) => {
        var C, w;
        const m = Os("FormKit"), E = Os("o-tab-item"), y = Os("o-tabs");
        return G(), X("div", J0e, [
          be("div", V0e, [
            be("div", W0e, [
              p[5] || (p[5] = be("h3", null, "BPlan Vektor", -1)),
              ee(j(vl), {
                class: "close-button",
                icon: "close",
                variant: "link",
                onClick: p[0] || (p[0] = () => s("close:gfi", !0))
              })
            ]),
            p[7] || (p[7] = be("p", null, "1 Layer", -1)),
            be("div", K0e, [
              be("div", null, Pe((C = o.value) == null ? void 0 : C.features.length) + " WMS Features", 1),
              be("div", null, [
                o.value ? (G(), De(m, {
                  key: 0,
                  modelValue: a.value,
                  "onUpdate:modelValue": p[1] || (p[1] = (M) => a.value = M),
                  value: (w = o.value) == null ? void 0 : w.features[0],
                  type: "select",
                  name: "xplanselect",
                  options: u()
                }, null, 8, ["modelValue", "value", "options"])) : de("", !0)
              ])
            ]),
            be("div", null, [
              ee(y, {
                modelValue: A.value,
                "onUpdate:modelValue": p[2] || (p[2] = (M) => A.value = M),
                class: "tabs"
              }, {
                default: Ye(() => [
                  ee(E, {
                    value: "object",
                    label: "OBJEKTATTRIBUTE"
                  }),
                  ee(E, {
                    value: "text",
                    label: "TEXTINHALTE"
                  }),
                  ee(E, {
                    value: "references",
                    label: "REFERENZEN"
                  }),
                  ee(E, {
                    value: "plan",
                    label: "PLANATTRIBUTE"
                  })
                ]),
                _: 1
              }, 8, ["modelValue"]),
              a.value ? (G(), X("div", X0e, [
                be("table", Z0e, [
                  p[6] || (p[6] = be("thead", { class: "table-header" }, [
                    be("tr", null, [
                      be("th", { class: "table-header-cell" }, "Attribut"),
                      be("th", null, "Wert")
                    ])
                  ], -1)),
                  be("tbody", q0e, [
                    (G(!0), X(ht, null, xi(l.value, (M, I) => (G(), X("tr", {
                      key: I,
                      class: "table-body-row"
                    }, [
                      be("td", $0e, [
                        be("b", null, Pe(I), 1)
                      ]),
                      be("td", eCe, Pe(M), 1)
                    ]))), 128))
                  ])
                ])
              ])) : de("", !0)
            ])
          ]),
          ee(j(vl), {
            variant: "secondary",
            squared: "",
            class: "flat-button backwards",
            onClick: p[3] || (p[3] = (M) => d(-1))
          }, {
            default: Ye(() => p[8] || (p[8] = [
              Ct(" < ")
            ])),
            _: 1
          }),
          ee(j(vl), {
            variant: "secondary",
            squared: "",
            class: "flat-button forwards",
            onClick: p[4] || (p[4] = (M) => d(1))
          }, {
            default: Ye(() => p[9] || (p[9] = [
              Ct(" > ")
            ])),
            _: 1
          })
        ]);
      };
    }
  }), iCe = ".header[data-v-57173262]{display:flex;flex-direction:row;vertical-align:middle;justify-content:space-between}.table[data-v-57173262]{width:100%}.table-header[data-v-57173262]{border-bottom:1px solid black;display:block}.table-header-cell[data-v-57173262]{width:84%}.table-body[data-v-57173262]{display:block;height:300px;overflow-y:scroll}.table-body-row[data-v-57173262]{border-bottom:1px solid black}.table-body-cell[data-v-57173262]{word-break:break-word;overflow-wrap:break-word;text-align:start;width:50%}.tabs[data-v-57173262]{font-size:small;font-weight:bolder}.close-button[data-v-57173262]{color:#000}.flat-button[data-v-57173262]{margin-top:1rem;width:50%;border:1px solid lightgray}.dpk-row[data-v-57173262]{display:flex;flex-direction:row;align-items:center;justify-content:space-between}.xplan-box[data-v-57173262]{background-color:#fff;height:600px;width:500px;position:absolute;right:0;padding:1rem}", rCe = /* @__PURE__ */ Zl(tCe, [["styles", [iCe]], ["__scopeId", "data-v-57173262"]]), QC = "units", nCe = [1, 2, 5], hh = 25.4 / 0.28;
  class sCe extends mf {
    /**
     * @param {Options} [options] Scale line options.
     */
    constructor(e) {
      e = e || {};
      const i = document.createElement("div");
      i.style.pointerEvents = "none", super({
        element: i,
        render: e.render,
        target: e.target
      }), this.on, this.once, this.un;
      const r = e.className !== void 0 ? e.className : e.bar ? "ol-scale-bar" : "ol-scale-line";
      this.innerElement_ = document.createElement("div"), this.innerElement_.className = r + "-inner", this.element.className = r + " " + df, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = e.minWidth !== void 0 ? e.minWidth : 64, this.maxWidth_ = e.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(QC, this.handleUnitsChanged_), this.setUnits(e.units || "metric"), this.scaleBar_ = e.bar || !1, this.scaleBarSteps_ = e.steps || 4, this.scaleBarText_ = e.text || !1, this.dpi_ = e.dpi || void 0;
    }
    /**
     * Return the units to use in the scale line.
     * @return {Units} The units
     * to use in the scale line.
     * @observable
     * @api
     */
    getUnits() {
      return this.get(QC);
    }
    /**
     * @private
     */
    handleUnitsChanged_() {
      this.updateElement_();
    }
    /**
     * Set the units to use in the scale line.
     * @param {Units} units The units to use in the scale line.
     * @observable
     * @api
     */
    setUnits(e) {
      this.set(QC, e);
    }
    /**
     * Specify the dpi of output device such as printer.
     * @param {number|undefined} dpi The dpi of output device.
     * @api
     */
    setDpi(e) {
      this.dpi_ = e;
    }
    /**
     * @private
     */
    updateElement_() {
      const e = this.viewState_;
      if (!e) {
        this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
        return;
      }
      const i = e.center, r = e.projection, n = this.getUnits(), s = n == "degrees" ? "degrees" : "m";
      let o = lg(
        r,
        e.resolution,
        i,
        s
      );
      const a = this.minWidth_ * (this.dpi_ || hh) / hh, A = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || hh) / hh : void 0;
      let l = a * o, c = "";
      if (n == "degrees") {
        const y = Fa.degrees;
        l *= y, l < y / 60 ? (c = "″", o *= 3600) : l < y ? (c = "′", o *= 60) : c = "°";
      } else if (n == "imperial")
        l < 0.9144 ? (c = "in", o /= 0.0254) : l < 1609.344 ? (c = "ft", o /= 0.3048) : (c = "mi", o /= 1609.344);
      else if (n == "nautical")
        o /= 1852, c = "NM";
      else if (n == "metric")
        l < 1e-6 ? (c = "nm", o *= 1e9) : l < 1e-3 ? (c = "μm", o *= 1e6) : l < 1 ? (c = "mm", o *= 1e3) : l < 1e3 ? c = "m" : (c = "km", o /= 1e3);
      else if (n == "us")
        l < 0.9144 ? (c = "in", o *= 39.37) : l < 1609.344 ? (c = "ft", o /= 0.30480061) : (c = "mi", o /= 1609.3472);
      else
        throw new Error("Invalid units");
      let u = 3 * Math.floor(Math.log(a * o) / Math.log(10)), d, h, g, f, p, m;
      for (; ; ) {
        g = Math.floor(u / 3);
        const y = Math.pow(10, g);
        if (d = nCe[(u % 3 + 3) % 3] * y, h = Math.round(d / o), isNaN(h)) {
          this.element.style.display = "none", this.renderedVisible_ = !1;
          return;
        }
        if (A !== void 0 && h >= A) {
          d = f, h = p, g = m;
          break;
        } else if (h >= a)
          break;
        f = d, p = h, m = g, ++u;
      }
      const E = this.scaleBar_ ? this.createScaleBar(h, d, c) : d.toFixed(g < 0 ? -g : 0) + " " + c;
      this.renderedHTML_ != E && (this.innerElement_.innerHTML = E, this.renderedHTML_ = E), this.renderedWidth_ != h && (this.innerElement_.style.width = h + "px", this.renderedWidth_ = h), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
    }
    /**
     * @private
     * @param {number} width The current width of the scalebar.
     * @param {number} scale The current scale.
     * @param {string} suffix The suffix to append to the scale text.
     * @return {string} The stringified HTML of the scalebar.
     */
    createScaleBar(e, i, r) {
      const n = this.getScaleForResolution(), s = n < 1 ? Math.round(1 / n).toLocaleString() + " : 1" : "1 : " + Math.round(n).toLocaleString(), o = this.scaleBarSteps_, a = e / o, A = [this.createMarker("absolute")];
      for (let c = 0; c < o; ++c) {
        const u = c % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
        A.push(
          `<div><div class="ol-scale-singlebar ${u}" style="width: ${a}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
          (c % 2 === 0 || o === 2 ? this.createStepText(c, e, !1, i, r) : "") + "</div>"
        );
      }
      return A.push(this.createStepText(o, e, !0, i, r)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${e}px;">` + s + "</div>" : "") + A.join("");
    }
    /**
     * Creates a marker at given position
     * @param {'absolute'|'relative'} position The position, absolute or relative
     * @return {string} The stringified div containing the marker
     */
    createMarker(e) {
      return `<div class="ol-scale-step-marker" style="position: ${e}; top: ${e === "absolute" ? 3 : -10}px;"></div>`;
    }
    /**
     * Creates the label for a marker marker at given position
     * @param {number} i The iterator
     * @param {number} width The width the scalebar will currently use
     * @param {boolean} isLast Flag indicating if we add the last step text
     * @param {number} scale The current scale for the whole scalebar
     * @param {string} suffix The suffix for the scale
     * @return {string} The stringified div containing the step text
     */
    createStepText(e, i, r, n, s) {
      const a = (e === 0 ? 0 : Math.round(n / this.scaleBarSteps_ * e * 100) / 100) + (e === 0 ? "" : " " + s), A = e === 0 ? -3 : i / this.scaleBarSteps_ * -1, l = e === 0 ? 0 : i / this.scaleBarSteps_ * 2;
      return `<div class="ol-scale-step-text" style="margin-left: ${A}px;text-align: ${e === 0 ? "left" : "center"};min-width: ${l}px;left: ${r ? i + "px" : "unset"};">` + a + "</div>";
    }
    /**
     * Returns the appropriate scale for the given resolution and units.
     * @return {number} The appropriate scale.
     */
    getScaleForResolution() {
      const e = lg(
        this.viewState_.projection,
        this.viewState_.resolution,
        this.viewState_.center,
        "m"
      ), i = this.dpi_ || hh, r = 1e3 / 25.4;
      return e * r * i;
    }
    /**
     * Update the scale line element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(e) {
      const i = e.frameState;
      i ? this.viewState_ = i.viewState : this.viewState_ = null, this.updateElement_();
    }
  }
  function sQ(t) {
    return class extends t {
      constructor(i) {
        const r = i || {}, n = Uo();
        if (!n) throw new Error("Control initialization must be called inside script setup.");
        super(r), [...this.element.childNodes].forEach((o, a) => {
          const A = document.createElement("div"), l = "masterportal-tooltip", c = (Array.isArray(r.tooltip) ? r.tooltip[a] : r.tooltip) || {}, u = ju(cO, {
            ...c,
            triggerClass: l
          });
          u.appContext = n.appContext, NG(u, A), o.ariaLabel = c.label || null;
          const d = A.getElementsByClassName(l);
          if (!(d != null && d.length))
            throw new Error("Could not find masterportal tooltip element.");
          d[0].appendChild(o), this.element.append(...A.childNodes);
        });
      }
    };
  }
  class hO extends mf {
    constructor(i) {
      i = Object.assign({}, i);
      super({
        element: document.createElement("div"),
        target: i.target
      });
      Ne(this, "button_");
      Ne(this, "className_");
      Ne(this, "handler_");
      this.handler_ = i.onClick, this.className_ = i.className !== void 0 ? i.className : "ol-draw";
      const r = document.createElement("span");
      r.className = `dps-icon dps-icon--${i.icon} is-medium`, this.button_ = document.createElement("button"), this.button_.setAttribute("type", "button"), this.button_.appendChild(r), this.button_.addEventListener(Ge.CLICK, this.handleClick_.bind(this), !1), this.button_.className = "draw-control", this.element.className = `${this.className_} ol-unselectable ol-control`, typeof i.visible == "boolean" && !i.visible && (this.element.style.display = "none"), this.element.appendChild(this.button_);
    }
    handleClick_() {
      typeof this.handler_ == "function" && this.handler_();
    }
  }
  class oCe extends hO {
    constructor(i) {
      i = i || {};
      super({ ...i, onClick: void 0 });
      Ne(this, "toggleTarget_");
      Ne(this, "toggleHandler_");
      Ne(this, "removeOutsideHandler_");
      Ne(this, "isActive_", !1);
      Ne(this, "toggleClasses_");
      this.toggleTarget_ = i.toggleElement, this.toggleHandler_ = i.onClick, this.toggleClasses_ = i.toggleClasses || [], this.handler_ = this.handleToggleClick_;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleToggleClick_() {
      this.switchOffButtons(), this.isActive_ = !this.isActive_, this.isActive_ ? this.button_.classList.add("draw-control-enabled") : this.button_.classList.remove("draw-control-enabled"), this.toggleElement(), typeof this.toggleHandler_ == "function" && this.toggleHandler_();
    }
    /** toggle the visability of an target element if given */
    toggleElement() {
      const i = Oi(this.toggleTarget_);
      i && (i.style.visibility = this.isActive_ ? "visible" : "hidden", i.style.display = this.isActive_ ? "block" : "none", this.toggleClickOutside());
    }
    /** adds an outside click handler to the target element */
    toggleClickOutside() {
      if (typeof this.removeOutsideHandler_ == "function") this.removeOutsideHandler_();
      else if (this.toggleTarget_) {
        const { stop: i } = JBe(
          Oi(this.toggleTarget_),
          () => {
            this.isActive_ && this.button_.click();
          },
          { ignore: [this.element] }
        );
        this.removeOutsideHandler_ = i;
      }
    }
    /** disable all toggle control buttons with the toggle classes */
    switchOffButtons() {
      this.toggleClasses_.forEach((i) => {
        const r = document.querySelector(`.${i} .draw-control`);
        r != null && r.classList.contains("draw-control-enabled") && r.click();
      });
    }
  }
  var rA = /* @__PURE__ */ ((t) => (t.NEUTRAL = "NEUTRAL", t.SELECTED = "SELECTED", t.DRAWING = "DRAWING", t.EDITING = "EDITING", t))(rA || {}), dt = /* @__PURE__ */ ((t) => (t.DRAW = "action-shape", t.LINE = "action-line", t.LASSO = "action-lasso", t.CIRCLE = "action-circle", t.MERGE = "action-merge", t.CUT = "action-cut", t.MODIFY = "action-modify", t.UNDO = "action-undo", t.DELETE = "action-delete", t.POINTS = "action-points", t.CADASTRAL = "action-cadastral", t.NEIGHBOURS = "action-neighbours", t.SUPERIORAREAS = "action-superiorareas", t.SELECT = "action-select", t.LAYERS = "action-layers", t.FULLSCREEN = "action-fullscreen", t.INFO = "action-info", t))(dt || {});
  const nA = [
    "action-shape",
    "action-line",
    "action-circle",
    "action-merge",
    "action-cut",
    "action-modify",
    "action-lasso"
    /* LASSO */
  ], C2 = {
    NEUTRAL: nA,
    SELECTED: [
      "action-delete"
      /* DELETE */
    ],
    DRAWING: [
      "action-undo"
      /* UNDO */
    ],
    EDITING: []
  }, aCe = {
    "action-cadastral": "NEUTRAL",
    "action-neighbours": "NEUTRAL",
    "action-superiorareas": "NEUTRAL",
    "action-select": "NEUTRAL",
    "action-layers": "NEUTRAL",
    "action-info": "NEUTRAL",
    "action-points": "NEUTRAL",
    "action-delete": "NEUTRAL",
    "action-undo": "NEUTRAL",
    "action-shape": "DRAWING",
    "action-line": "DRAWING",
    "action-lasso": "DRAWING",
    "action-circle": "DRAWING",
    "action-merge": "DRAWING",
    "action-cut": "DRAWING",
    "action-modify": "EDITING",
    "action-fullscreen": "NEUTRAL"
    /* NEUTRAL */
  };
  var gO = /* @__PURE__ */ ((t) => (t.TOGGLE = "toggle", t.ACTION = "action", t))(gO || {});
  const ACe = [
    {
      className: "action-cadastral",
      icon: "flurstuecke-anzeigen",
      label: "Flurstücke anzeigen (Z)",
      type: "toggle",
      profiles: [qi.COCKPIT, qi.VORHABEN]
    },
    {
      className: "action-points",
      icon: "stuetzpunkte-anzeigen",
      label: "Stützpunkte anzeigen (P)",
      type: "toggle",
      profiles: [qi.COCKPIT, qi.VORHABEN]
    },
    {
      className: "action-shape",
      toggleClasses: nA.filter(
        (t) => t != "action-shape"
        /* DRAW */
      ),
      icon: "group",
      label: "Fläche einzeichen (U)",
      type: "toggle",
      profiles: [qi.COCKPIT]
    },
    {
      className: "action-line",
      toggleClasses: nA.filter(
        (t) => t != "action-line"
        /* LINE */
      ),
      icon: "group",
      label: "Trasse einzeichen",
      type: "toggle",
      profiles: [qi.VORHABEN]
    },
    {
      className: "action-merge",
      toggleClasses: nA.filter(
        (t) => t != "action-merge"
        /* MERGE */
      ),
      icon: "kombinieren",
      label: "Flächen kombinieren (M)",
      type: "toggle",
      profiles: [qi.COCKPIT]
    },
    {
      className: "action-circle",
      toggleClasses: nA.filter(
        (t) => t != "action-circle"
        /* CIRCLE */
      ),
      icon: "kreis-einzeichnen",
      label: "Kreis einzeichen (R)",
      type: "toggle",
      profiles: [qi.COCKPIT]
    },
    {
      className: "action-cut",
      toggleClasses: nA.filter(
        (t) => t != "action-cut"
        /* CUT */
      ),
      icon: "durchschneiden",
      label: "Umring schneiden (C)",
      type: "toggle",
      profiles: [qi.COCKPIT]
    },
    {
      className: "action-lasso",
      toggleClasses: nA.filter(
        (t) => t != "action-lasso"
        /* LASSO */
      ),
      icon: "lasso",
      label: "Lasso einzeichnen (L)",
      type: "toggle",
      profiles: [qi.COCKPIT, qi.VORHABEN]
    },
    {
      className: "action-modify",
      toggleClasses: nA.filter(
        (t) => t != "action-modify"
        /* MODIFY */
      ),
      icon: "create",
      label: "Bearbeitungsmodus (E)",
      type: "toggle",
      profiles: [qi.COCKPIT, qi.VORHABEN]
    },
    {
      className: "action-undo",
      icon: "rueckgaengig",
      label: "Rückgängig (Strg + Z)",
      type: "action",
      profiles: [qi.COCKPIT, qi.VORHABEN]
    },
    {
      className: "action-delete",
      icon: "delete",
      label: "Geometrie löschen (D)",
      type: "action",
      profiles: [qi.COCKPIT, qi.VORHABEN]
    }
  ];
  class lCe extends sQ(sL) {
    constructor(e) {
      super(e);
    }
  }
  class b2 extends sQ(hO) {
    constructor(e) {
      super(e);
    }
  }
  class FC extends sQ(oCe) {
    constructor(e) {
      super(e);
    }
  }
  function cCe(t, e) {
    if (!t.length) return [e];
    if (!e) return t;
    const i = Kne(t, "MultiPolygon"), r = [], n = [], s = Hs(e), o = js(s.geometry.coordinates);
    if (i.forEach((a) => {
      const A = Hs(a), l = js(A.geometry.coordinates), c = ps([o, l]);
      hne(c) ? n.push(a) : r.push(a);
    }), n.length) {
      n.push(e);
      const a = n.map((c) => {
        const u = Hs(c);
        return js(u.geometry.coordinates);
      }), A = zL(ps(a));
      if (!A) return r;
      const l = Js(wg(A));
      HL(l, n[0]), r.push(l);
    } else
      r.push(e);
    return r;
  }
  function uCe(t, e) {
    const r = Hs(e).geometry.coordinates;
    return t.map((n) => {
      const o = bB(n).map((A) => {
        const l = lx(A), c = l.filter(
          (u) => r[0] != u[0] || r[1] != u[1]
        );
        return c.length && l.length - c.length > 1 && c.push(c[0]), [c];
      }), a = Js(js(o));
      return HL(a, n), a;
    });
  }
  function SC(t, e, i) {
    const r = to(e), n = to(i), s = [], o = Bf(t);
    let a = -1, A = -1;
    for (let u = 0; u < o.features.length; u++) {
      const d = o.features[u], h = Ed(d, r), g = Ed(d, n);
      if (h && (a = u), g && (A = u), // is first line segment
      (!s.length && (h || g) || // is inner line segment
      s.length && !h && !g || // is last line segment
      s.length && (h || g)) && s.push(d), a >= 0 && A >= 0) break;
    }
    if (a === A)
      return SA([r.coordinates, n.coordinates]);
    const l = A < a, c = [];
    (!s.length || (l ? n.coordinates : r.coordinates) !== s[0].geometry.coordinates[1]) && c.push(l ? n.coordinates : r.coordinates);
    for (let u = 0; u < s.length - 1; u++)
      c.push(s[u].geometry.coordinates[1]);
    return (!s.length || (l ? n.coordinates : r.coordinates) !== s[s.length - 1].geometry.coordinates[1]) && c.push(l ? r.coordinates : n.coordinates), SA(c);
  }
  function dCe(t, e) {
    const i = Bf(t).features.flatMap(
      (r) => (
        // check each point if its on the line segment
        e.features.filter((n) => Ed(r, n)).map((n) => ({
          point: n,
          // calc the distance between the starting point of the segment and the point on this line segment
          distance: Zh(r.geometry.coordinates[0], n.geometry.coordinates)
        })).sort((n, s) => n.distance - s.distance).map((n) => n.point)
      )
    ).filter((r, n, s) => s.indexOf(r) == n);
    return ps(i);
  }
  function Zh(t, e) {
    return Math.sqrt((t[0] - e[0]) ** 2 + (t[1] - e[1]) ** 2);
  }
  function Ed(t, e, i = 1e-9) {
    const r = to(t), n = yg(e), s = Zh(r.coordinates[0], r.coordinates[1]), o = Zh(r.coordinates[0], n), a = Zh(r.coordinates[1], n);
    return Math.abs(o + a - s) < i;
  }
  function hCe(t, e) {
    const i = Array.isArray(e) ? e : e.features, r = Bf(t);
    for (let n = 0; n < r.features.length; n++) {
      const s = r.features[n], o = i.filter((a) => Ed(s, a));
      if (o.length == 1) return o[0];
      if (o.length > 1) {
        const a = o.map(
          (l) => Zh(s.geometry.coordinates[0], l.geometry.coordinates)
        ), A = o.map((l, c) => c).sort((l, c) => a[l] - a[c]);
        return o[A[0]];
      }
    }
  }
  function gCe(t, e) {
    const i = to(e), r = yg(t);
    return !!(qie(r, i) || Bf(e).features.some((a) => Ed(a, t)));
  }
  function fCe(t, e) {
    const i = to(t), r = to(e);
    pCe(i.coordinates.at(0), i.coordinates.at(-1));
    const n = Bf(t), s = n.features.findIndex((A) => Ed(A, e));
    if (s < 0) return SA(i.coordinates);
    const o = [];
    o.push(r.coordinates);
    const a = n.features[s].geometry.coordinates[1];
    r.coordinates[0] !== a[0] && r.coordinates[1] !== a[1] && o.push(a);
    for (let A = s + 1; A < n.features.length; A++)
      o.push(n.features[A].geometry.coordinates[1]);
    for (let A = 0; A < s; A++)
      o.push(n.features[A].geometry.coordinates[1]);
    return o.push(r.coordinates), SA(o);
  }
  function fy(t, e) {
    const i = ps([t, e]), r = dne(i);
    return r ? r.geometry.type === "MultiPolygon" ? r.geometry.coordinates.map((n) => Ts(n)) : [r] : [t];
  }
  function oQ(t, e) {
    const i = to(t);
    return to(e).coordinates[0].every((n) => gCe(n, i));
  }
  function pCe(t, e) {
    return !0;
  }
  function mCe(t, e, i = !0) {
    if (!t.length)
      return i ? [e] : [];
    let r = Hs(e);
    const n = t.flatMap((s) => {
      let o = bB(s);
      return o = o.flatMap((a) => (oQ(r, a) && (r = fy(r, a)[0]), fy(a, r))), qne(o, s);
    });
    return i ? [...n, e] : n;
  }
  function ECe(t, e) {
    if (!t.length) return;
    const i = Hs(e), n = t.flatMap(bB).filter(
      (a) => oQ(i, a)
    );
    if (!n.length) return;
    if (n.length === 1)
      return Js(wg(n[0]));
    const s = ps(n);
    let o = zL(s);
    if (o) {
      if (o.geometry.type === "MultiPolygon") {
        const a = ps(lx(s).map((A) => Ad(A)));
        o = jre(a);
      }
      if (o)
        return Js(wg(o));
    }
  }
  function yCe(t, e) {
    if (!t.length) return [];
    const i = Hs(e);
    return t.flatMap((r) => {
      let n = bB(r);
      return n = n.flatMap((s) => RM(s, i)), $ne(n, r);
    });
  }
  function RM(t, e) {
    const i = to(t), r = to(e);
    if (gne(r).features.length) return [Ts(i.coordinates)];
    const s = SA(i.coordinates[0]), o = Ts([i.coordinates[0]]), a = Are(o, r), A = dCe(r, a);
    if (A.features.length < 2) return [Ts(i.coordinates)];
    const l = A.features[0], c = A.features[1], u = SC(r, l, c), d = fCe(s, l), h = A.features.filter((I) => I !== l), g = hCe(d, h);
    g && !_b(g.geometry, c.geometry) && d.geometry.coordinates.reverse();
    const f = SC(d, l, c);
    _b(f.geometry.coordinates[0], u.geometry.coordinates[0]) && f.geometry.coordinates.reverse(), u.geometry.coordinates.pop();
    const p = [...u.geometry.coordinates, ...f.geometry.coordinates], m = Ts([p]);
    let E, y;
    const C = oQ(o, m);
    C ? (E = fy(o, m)[0], y = m) : (E = o, y = null);
    let w = [];
    const M = r.coordinates.at(-1);
    if (M && c != A.features.at(-1)) {
      const I = C ? c : Ad(u.geometry.coordinates.at(-1)), b = SC(
        r,
        I,
        Ad(M)
      ), B = RM(E, b);
      if (w.push(...B), y !== null) {
        const x = RM(y, b);
        w.push(...x);
      }
    } else
      w.push(E), y !== null && w.push(y);
    if (i.coordinates.length > 1) {
      const I = i.coordinates.slice(1);
      w = w.map(
        (b) => (
          // cut every origin inner ring on the polygon
          I.reduce((B, x) => {
            const Q = Ts([x]);
            return fy(B, Q)[0];
          }, b)
        )
      );
    }
    return w;
  }
  const BCe = {
    class: "ol-control control-layer-info d-print-none",
    style: { visibility: "hidden" }
  }, wCe = /* @__PURE__ */ je({
    __name: "LayerInfoControl",
    props: {
      activeLayerIds: { type: Array, required: !0 },
      themenConfig: { type: Object, required: !0 }
    },
    setup(t) {
      const e = t, i = (s, o) => {
        const a = [];
        return o == null || o.forEach((A) => {
          A.Layer.some((c) => s == null ? void 0 : s.includes(c.id)) && a.push(A.Titel);
        }), a;
      }, r = (s, o) => {
        const a = [];
        return o.Xplandaten && a.push(...i(s, o.Xplandaten.Ordner)), a.push(...i(s, o.Fachdaten.Ordner)), a.push(...i(s, o.Hintergrundkarten.Layer)), a;
      }, n = O(() => r(e.activeLayerIds, e.themenConfig));
      return (s, o) => (G(), X("div", BCe, [
        o[3] || (o[3] = be("p", null, [
          be("strong", null, "Datenquellen der verwendeten Karten:")
        ], -1)),
        be("ul", null, [
          (G(!0), X(ht, null, xi(n.value, (a) => (G(), X("li", { key: a }, [
            Ct(Pe(a) + ": © GeoBasis-DE / ", 1),
            o[0] || (o[0] = be("a", {
              href: "https://www.bkg.bund.de",
              target: "_blank"
            }, "BKG", -1)),
            o[1] || (o[1] = Ct(" (2025) ")),
            o[2] || (o[2] = be("a", {
              href: "https://creativecommons.org/licenses/by/4.0/",
              target: "_blank"
            }, "CC BY 4.0", -1))
          ]))), 128))
        ])
      ]));
    }
  }), CCe = ".control-layer-info[data-v-9b17e899]{background-color:#fff;padding:.5rem;visibility:hidden;display:none;overflow-y:scroll;overflow-x:hidden;margin-left:.5rem}", bCe = /* @__PURE__ */ Zl(wCe, [["styles", [CCe]], ["__scopeId", "data-v-9b17e899"]]), MCe = /* @__PURE__ */ je({
    __name: "MapFrame.ce",
    props: {
      enableDraw: { type: Boolean, default: !0 },
      disableZoom: { type: Boolean, default: !1 },
      // use just the extracted slices from the area down to the featurecollection array
      baseData: { type: Array, default: () => [] },
      // type limited to Multipolygon in geojson notation
      geojson: { type: Array, default: void 0 },
      xplanWms: { type: String, default: void 0 },
      isReduced: { type: Boolean, default: !1 },
      profile: { type: String, default: qi.COCKPIT },
      baseLayer: {
        type: Number,
        default: pk.STREETMAP
      },
      /** the name is necessary for a named download. Without a given name, the download option will default to the name "Belegenheit" */
      name: { type: String, default: void 0 },
      portalConfig: {
        type: Object,
        default: () => {
        }
      },
      layerConfig: {
        type: Object,
        default: () => {
        }
      }
    },
    emits: ["diplan-karte:background-layer-update", "diplan-karte:data-layer-update", "diplan-karte:fullscreen-update", "diplan-karte:geojson-update"],
    setup(t, { emit: e }) {
      var zr, an, An, Wn;
      const i = t, r = e, n = ue(), s = {
        Portalconfig: {
          portalTitle: {
            title: "DiPlanPotentiale",
            logo: "https://geoportal-hamburg.de/lgv-config/img/hh-logo.png",
            link: "https://geoportal.bayern.de/",
            toolTip: "Landesamt für Digitalisierung, Breitband und Vermessung"
          },
          quickHelp: {
            configs: {
              search: !1,
              tree: !1
            }
          },
          tree: {
            highlightedFeatures: {
              active: !0
            },
            showScaleTooltip: !0
          },
          searchBar: {
            gazetteer: {
              minChars: 3,
              serviceId: "8",
              searchAddress: !0,
              searchStreets: !0,
              searchHouseNumbers: !0,
              searchDistricts: !0,
              searchParcels: !0,
              searchStreetKey: !0
            },
            elasticSearch: {
              minChars: 3,
              serviceId: "elastic_test",
              type: "GET",
              payload: {
                id: "query",
                params: {
                  query_string: ""
                }
              },
              searchStringAttribute: "query_string",
              responseEntryPath: "hits.hits",
              triggerEvent: {
                channel: "Parser",
                event: "addGdiLayer"
              },
              hitMap: {
                name: "_source.name",
                id: "_source.id",
                source: "_source"
              },
              hitType: "Fachthema",
              hitIcon: "bi-list-ul"
            },
            placeholder: "Suche nach Adresse/Thema"
          },
          mapView: {
            backgroundImage: "https://geoportal-hamburg.de/lgv-config/img/backgroundCanvas.jpeg",
            startCenter: [684150, 5436382],
            options: [
              {
                resolution: 26.4583333333333,
                scale: 1e5,
                zoomLevel: 5
              },
              {
                resolution: 13.2291666666667,
                scale: 5e4,
                zoomLevel: 6
              },
              {
                resolution: 6.61458333333333,
                scale: 25e3,
                zoomLevel: 7
              },
              {
                resolution: 2.64583333333334,
                scale: 1e4,
                zoomLevel: 8
              },
              {
                resolution: 1.32291666666667,
                scale: 5e3,
                zoomLevel: 9
              },
              {
                resolution: 0.661458333333333,
                scale: 2500,
                zoomLevel: 10
              },
              {
                resolution: 0.264583333333333,
                scale: 1e3,
                zoomLevel: 11
              },
              {
                resolution: 0.132291666666667,
                scale: 500,
                zoomLevel: 12
              },
              {
                resolution: 0.0661458333333333,
                scale: 250,
                zoomLevel: 13
              },
              {
                resolution: 0.0264583333333334,
                scale: 100,
                zoomLevel: 14
              }
            ]
          },
          menu: {
            tree: {
              name: "Themen",
              icon: "bi-stack",
              isInitOpen: !1
            },
            tools: {
              name: "Werkzeuge",
              icon: "bi-tools",
              children: {
                gfi: {
                  name: "translate#common:menu.tools.getInfos",
                  icon: "bi-info-circle-fill",
                  active: !0,
                  desktopType: "detached"
                },
                draw: {
                  name: "Zeichnen / Schreiben",
                  icon: "bi-pencil-fill",
                  isVisibleInMenu: !1
                },
                measure: {
                  name: "Strecke / Fläche messen",
                  icon: "bi-rulers"
                },
                print: {
                  name: "Karte drucken",
                  icon: "bi-printer-fill",
                  printServiceId: "mapfish_qs",
                  printAppId: "mrh",
                  filename: "Ausdruck",
                  title: "Mein Titel",
                  dpiForPdf: 120
                },
                saveSelection: {
                  name: "translate#common:menu.tools.saveSelection",
                  icon: "bi-bookmark-check",
                  simpleMap: !1,
                  isVisibleInMenu: !1
                },
                scaleSwitcher: {
                  name: "translate#common:menu.tools.scaleSwitcher",
                  icon: "bi-arrows-angle-contract",
                  isDisplayInFooter: !0
                }
              }
            },
            legend: {
              name: "Legende",
              icon: "bi-lightbulb",
              showCollapseAllButton: !0
            }
          },
          controls: {
            fullScreen: !0,
            orientation3d: !1,
            zoom: !0,
            orientation: {
              zoomMode: "once",
              poiDistances: [500, 1e3, 2e3]
            },
            totalView: !0,
            attributions: !1,
            overviewMap: {
              layerId: "452",
              isInitOpen: !0
            },
            mousePosition: !0,
            button3d: !1,
            freeze: !1,
            backForward: !0
          },
          treeType: "custom"
        },
        Themenconfig: {
          Hintergrundkarten: {
            Layer: [
              {
                Titel: "Basiskarte Deutschland",
                Layer: [
                  {
                    id: "1"
                  }
                ]
              }
            ]
          },
          Fachdaten: {
            Ordner: [
              {
                Titel: "Topographische Karten Bayern",
                Ordinal: 1,
                Layer: [
                  {
                    id: "2"
                  }
                ]
              },
              {
                Titel: "Landesgrenze Bayern",
                Ordinal: 2,
                Layer: [
                  {
                    id: "3"
                  }
                ]
              }
            ]
          }
        }
      }, o = [
        {
          id: "1",
          name: "Basiskarte Deutschland",
          url: "https://sgx.geodatenzentrum.de/wms_basemapde",
          typ: "WMS",
          layers: "de_basemapde_web_raster_grau",
          format: "image/png",
          version: "1.3.0",
          singleTile: !1,
          transparent: !0,
          transparency: 0,
          urlIsVisible: !0,
          tilesize: 512,
          gutter: 0,
          minScale: "0",
          maxScale: "2500000",
          gfiAttributes: "ignore",
          gfiTheme: "default",
          layerAttribution: "nicht vorhanden",
          legendURL: "ignore",
          cache: !1,
          featureCount: 1,
          notSupportedFor3DNeu: !1
        },
        {
          id: "2",
          name: "Hintergrundkarte Bayern",
          url: "https://geoservices.bayern.de/od/wms/dtk/v1/dtk25",
          typ: "WMS",
          layers: "by_amtl_karte",
          format: "image/png",
          version: "1.3.0",
          singleTile: !1,
          transparent: !0,
          transparency: 0,
          urlIsVisible: !0,
          tilesize: 512,
          gutter: 0,
          minScale: "0",
          maxScale: "2500000",
          gfiAttributes: "ignore",
          gfiTheme: "default",
          layerAttribution: "nicht vorhanden",
          legendURL: "ignore",
          cache: !1,
          featureCount: 1,
          notSupportedFor3DNeu: !1
        },
        {
          id: "3",
          name: "Landesgrenze Bayern",
          url: "https://geoservices.bayern.de/od/wms/alkis/v1/verwaltungsgrenzen",
          typ: "WMS",
          layers: "by_alkis_land_grenze",
          format: "image/png",
          version: "1.3.0",
          singleTile: !1,
          transparent: !0,
          transparency: 0,
          urlIsVisible: !0,
          tilesize: 512,
          gutter: 0,
          minScale: "0",
          maxScale: "2500000",
          gfiAttributes: "ignore",
          gfiTheme: "default",
          layerAttribution: "nicht vorhanden",
          legendURL: "ignore",
          cache: !1,
          featureCount: 1,
          notSupportedFor3DNeu: !1
        }
      ], a = UQ(i.portalConfig) ? s : i.portalConfig, A = UQ(i.layerConfig) ? o : i.layerConfig, l = ((an = (zr = a == null ? void 0 : a.Themenconfig) == null ? void 0 : zr.Hintergrundkarten) == null ? void 0 : an.Layer.length) > 1 ? 1 : 0, c = (Wn = (An = a == null ? void 0 : a.Themenconfig) == null ? void 0 : An.Hintergrundkarten) == null ? void 0 : Wn.Layer[l];
      n.value = c == null ? void 0 : c.Titel, ct(
        () => i.xplanWms,
        () => {
          if (i.xplanWms) {
            const oe = Yoe(i.xplanWms);
            oe && (A.push(...oe.layers), a.Themenconfig.Xplandaten = oe.config);
          }
        },
        {
          immediate: !0
        }
      );
      const u = ue(null), d = ue(null), h = ue(null), g = ue(null), f = ue(null), p = ue(null), m = ue(null), E = ue(null), y = ue(null), C = {
        [ai.Base]: { passive: !0, strokeWidth: 3, baseColor: "PRIMARY" },
        [ai.Draw]: {
          strokeWidth: 3,
          baseColor: "skyblue",
          selectOn: Oe,
          selectOff: K,
          onDrawStart: V,
          onLineDrawEnd: ut,
          onPolygonDrawEnd: se,
          onCircleDrawEnd: k,
          onDragBox: Me,
          onModifyEnd: Z
        },
        [ai.Cadastral]: {
          strokeWidth: 3,
          baseColor: "CADASTRAL",
          selectOn: Ht,
          selectOff: zi
        }
      }, w = c == null ? void 0 : c.Layer[0].id, M = VBe({
        target: u,
        portalConfig: a,
        layerConfig: A,
        startCenter: a.Portalconfig.mapView.startCenter,
        backgroundLayerId: w,
        layers: C,
        mapMoveEnd: Fe
      }), I = ue([w]), b = ue(!1);
      function B() {
        [
          E.value,
          g.value,
          m.value,
          d.value
        ].forEach((we) => {
          const St = Oi(we);
          St && (St.style.display = b.value ? "flex" : "none");
        });
        const le = Oi(
          h.value
        ).getElementsByClassName("ol-zoom")[0];
        le && (le.style.display = b.value ? "flex" : "none");
      }
      er(() => {
        S(), Y(), ji(() => {
          i.disableZoom && M.setInteractionsTo(!1), oi(dt.DELETE, !0), oi(dt.UNDO, !0), $(dt.SELECT), B();
        });
      });
      const x = ue();
      ct(
        () => i.geojson,
        () => {
          x.value = i.geojson;
        },
        { immediate: !0 }
      );
      const Q = O(
        () => {
          var oe;
          return ((oe = x.value) == null ? void 0 : oe.map((le) => {
            var we;
            return ((we = le.properties) == null ? void 0 : we.name) || "";
          })) || [];
        }
      );
      eu(document, "keyup", T);
      const v = ue(!1);
      function T(oe) {
        if (v.value || !b.value) return;
        let le;
        switch (oe.key) {
          case "z":
            if (oe.ctrlKey) {
              Ce();
              return;
            }
            le = dt.CADASTRAL;
            break;
          case "u":
            le = dt.DRAW;
            break;
          case "m":
            le = dt.MERGE;
            break;
          case "c":
            le = dt.CUT;
            break;
          case "r":
            le = dt.CIRCLE;
            break;
          case "e":
            le = dt.MODIFY;
            break;
          case "p":
            le = dt.POINTS;
            break;
          case "d":
            le = dt.DELETE;
            break;
          case "l":
            le = dt.LASSO;
            break;
          case "k":
            le = dt.LAYERS;
            break;
          case "i":
            le = dt.INFO;
            break;
          case "t":
            le = dt.LINE;
            break;
          case "+": {
            const we = document.querySelector(".ol-zoom-in");
            we && we.click();
            return;
          }
          case "-": {
            const we = document.querySelector(".ol-zoom-out");
            we && we.click();
            return;
          }
          case "f": {
            const we = document.querySelector(".dps-icon--fullscreen") || document.querySelector(".dps-icon--fullscreen-exit");
            we && we.click();
            return;
          }
          case "s": {
            const we = document.querySelector(".h2-autocomplete-input");
            we && we.focus();
            return;
          }
          default:
            console.info("the pressed button could not be matched to a shortcut.");
            return;
        }
        le && document.getElementsByClassName(le)[0].getElementsByTagName("button")[0].click();
      }
      function S() {
        if (!d.value || !h.value || !g.value || !f.value || !p.value || !m.value || !E.value)
          throw new Error("Control initialization must be called after mount.");
        M.addControls(
          // layer info
          new FC({
            target: Oi(d),
            toggleElement: p,
            className: dt.INFO,
            icon: "info",
            tooltip: { position: "right", label: "Datenquellen der Karten anzeigen (I)" }
          })
        ), M.addControls(
          // zoom buttons
          new lCe({
            target: Oi(h),
            tooltip: [
              { position: "left", label: "Vergrößern (+)" },
              { position: "left", label: "Verkleinern (-)" }
            ]
          }),
          // fullscreen button
          new b2({
            className: dt.FULLSCREEN,
            icon: "fullscreen",
            target: Oi(h),
            tooltip: { position: "left", label: "Vollbild (F)" },
            visible: !0,
            onClick: () => $(dt.FULLSCREEN)
          }),
          // scale number without tooltip wrapper
          // hence not using ScaleControl from "./controls" but ol's ScaleLine directly
          // position hence set via scss below
          new sCe({
            // the scale bar must be enabled (will be hidden via scss below), otherwise scale number text is not printed by OpenLayers:
            bar: !0,
            text: !0
          })
        ), M.addControls(
          // layer toggle button
          new FC({
            target: Oi(E),
            toggleElement: f,
            className: dt.LAYERS,
            icon: "layer-half",
            tooltip: { position: "left", label: "Kartendaten wählen (K)" }
          })
        ), M.addControls(
          ...ACe.filter(
            (oe) => (!i.isReduced || i.isReduced && !q.includes(oe.className)) && oe.profiles.includes(i.profile)
          ).map((oe) => oe.type === gO.TOGGLE ? new FC({
            ...oe,
            target: Oi(g),
            tooltip: { position: "left", label: oe.label },
            visible: i.enableDraw,
            onClick: () => $(oe.className)
          }) : new b2({
            ...oe,
            target: Oi(g),
            tooltip: { position: "left", label: oe.label },
            visible: i.enableDraw,
            onClick: () => $(oe.className)
          }))
        );
      }
      function D(oe) {
        const le = Js(oe);
        M.focusGeometries([le]);
      }
      function F(oe, le) {
        return le === "toLonLat" ? oe.map((we) => I$(we, "EPSG:25832")) : le === "toEPSG" ? oe.map((we) => yE(we, "EPSG:25832")) : [[0, 0]];
      }
      function R(oe, le) {
        if (!oe.length)
          return [];
        const we = oe.map((St) => {
          const Xt = St.coordinates.flat(2), wr = F(Xt, le);
          return js([[wr]]).geometry;
        });
        return we.length ? we : [];
      }
      function Y() {
        if (M.getLayer(ai.Draw).clear(), !i.geojson) return;
        const oe = R(i.geojson, "toEPSG");
        if (!oe)
          return;
        const le = mT(kne(oe));
        M.getLayer(ai.Draw).addFeatures(le), M.focusLayerGeometries(ai.Draw);
      }
      const L = ue(!1);
      ct(L, () => P());
      function N() {
        L.value = !L.value;
      }
      function H(oe) {
        return oe || (oe = M.getLayer(ai.Draw).getFeatures([Tr.MULTIPOLYGON, Tr.POLYGON])), Zne(oe);
      }
      async function P(oe) {
        const le = M.getLayer(ai.Draw);
        if (oe || (oe = le.getFeatures([
          Tr.MULTIPOLYGON,
          Tr.POLYGON,
          Tr.LINESTRING
        ])), le.clear(), L.value) {
          const we = H(oe);
          oe.push(...we);
        }
        le.addFeatures(oe);
      }
      const ie = jBe(() => {
        if (!i.enableDraw) return;
        const oe = M.getLayer(ai.Draw).getFeatures([Tr.MULTIPOLYGON, Tr.POLYGON]), le = OL(oe);
        x.value = le.features;
        const we = R(
          le.features.map((St) => St.geometry),
          "toLonLat"
        );
        r("diplan-karte:geojson-update", we);
      });
      function V() {
      }
      function Z() {
        P(), ie();
      }
      function se(oe) {
        _.call(oe);
      }
      function k(oe) {
        const le = Yne(oe);
        _.call(le);
      }
      const _ = SM(async (oe) => {
        const le = J.value, we = M.getLayer(ai.Draw).getFeatures([Tr.MULTIPOLYGON, Tr.POLYGON]);
        let St = oe;
        if (J.value == dt.LASSO && (St = await jt(St), M.getLayer(ai.Draw).removeFeature(oe), !St))
          return;
        const Xt = le === dt.MERGE || le === dt.LASSO ? cCe(we, St) : mCe(we, St);
        ei(), setTimeout(() => {
          P(Xt), ie();
        });
      }), q = [dt.MERGE, dt.CUT], U = ue(), J = ue();
      function ae(oe) {
        U.value = oe;
      }
      ct(U, (oe, le) => {
        le && C2[le].forEach((we) => {
          we != J.value && oi(we, !0);
        }), oe && C2[oe].forEach((we) => {
          (!i.isReduced || i.isReduced && !q.includes(we)) && oi(we, !1);
        });
      }), ct(J, (oe, le) => {
        le && M.disableInteractions(...Ri(le)), oe && (M.enableInteractions(...Ri(oe)), ae(aCe[oe]));
      });
      const $ = (oe) => {
        switch (oe) {
          case dt.DELETE:
            Ae();
            break;
          case dt.POINTS:
            N();
            break;
          case dt.UNDO:
            Ce();
            break;
          case dt.CADASTRAL:
            rt();
            break;
          case dt.FULLSCREEN:
            b.value = !b.value, B(), r("diplan-karte:fullscreen-update", b.value);
            break;
          default:
            J.value = oe == J.value ? dt.SELECT : oe;
            break;
        }
      };
      function Ce() {
        if (U.value !== rA.DRAWING || !J.value) return;
        Ri(J.value)[0].removeLastPoint();
      }
      const Re = ue([]);
      function Oe(oe, le) {
        if (U.value != rA.DRAWING && (ae(rA.SELECTED), Re.value = le, Ut.value = oe, Ut.value)) {
          const we = Oi(y.value);
          if (!we) throw new Error("Map: No container is given for the map overlay.");
          we.style.visibility = "visible";
        }
      }
      function K(oe, le) {
        U.value != rA.DRAWING && (Re.value = le, ae(rA.NEUTRAL), Ti());
      }
      function Ae() {
        let oe = M.getLayer(ai.Draw).getFeatures([Tr.MULTIPOLYGON, Tr.POLYGON]);
        Re.value.forEach((le) => {
          var we;
          ((we = le.getGeometry()) == null ? void 0 : we.getType()) == Tr.POINT ? oe = uCe(oe, le) : oe = oe.filter((St) => ve(St) !== ve(le));
        }), P(oe), Re.value = [], ae(rA.NEUTRAL), Ti(), setTimeout(ie);
      }
      async function ut(oe) {
        const le = M.getLayer(ai.Draw).getFeatures([Tr.MULTIPOLYGON, Tr.POLYGON]), we = yCe(le, oe);
        P(we), ei(), setTimeout(() => {
          P(we), ie();
        });
      }
      function Me(oe) {
        if (!i.enableDraw) return;
        const le = H();
        if (le.length == 0) return;
        P();
        const we = M.getInteraction(ai.Draw, "select");
        if (!we) throw new Error("Could not find select interaction.");
        const St = oe.getGeometry();
        if (!St) throw new Error("Could not find dragbox!");
        const Xt = le.filter(
          (wr) => {
            var Ar;
            return (Ar = wr.getGeometry()) == null ? void 0 : Ar.intersectsExtent(St.getExtent());
          }
        );
        M.getLayer(ai.Draw).addFeatures(Xt), we.getFeatures().clear(), we.getFeatures().extend(Xt);
      }
      function Fe(oe) {
        var we;
        const le = ((we = oe.getView()) == null ? void 0 : we.getZoom()) || 0;
        !le || le < 5 ? (oi(dt.CADASTRAL, !0), oi(dt.LASSO, !0), Ke()) : (oi(dt.CADASTRAL, !1), oi(dt.LASSO, !1), Rt.value && Qt.call());
      }
      function jt(oe) {
        var le;
        return TM().fetchCadastralFeatures((le = oe.getGeometry()) == null ? void 0 : le.getExtent()).then((we) => we.features).catch((we) => {
          console.error("could not fetch cadastral feature", we);
        }).then((we) => {
          if (!we) throw new Error();
          const St = mT(we), Xt = ECe(St, oe);
          if (!Xt) throw new Error();
          return Xt;
        }).catch(() => {
          _0e().showWarning(
            "Leider konnte kein Umring basierend auf den Flurstücken erzeugt werden."
          );
        });
      }
      const Rt = ue(!1);
      function rt() {
        Rt.value ? Ke() : Qt.call(), Rt.value = !Rt.value;
      }
      function Ke() {
        M.getLayer(ai.Cadastral).clear();
      }
      const Qt = SM(() => {
        const oe = M.getBBox();
        return TM().fetchCadastralFeatures(oe).then((le) => {
          const we = le.features.map((St) => Js(St));
          M.getLayer(ai.Cadastral).clear(), M.getLayer(ai.Cadastral).addFeatures(we), M.enableInteractions(...Ri(dt.CADASTRAL));
        });
      });
      function Ht(oe) {
        U.value != rA.DRAWING && setTimeout(() => {
          pi(oe, eI.CADASTRAL);
        });
      }
      function lt(oe) {
        const le = Hs(oe);
        le.properties = {}, le.id = void 0, oe = Js(le), _.call(oe);
      }
      const Ft = ue(), si = ue([]);
      function pi(oe, le, we) {
        var Xt;
        if (si.value.push({ feature: oe, variant: le, attrs: we }), ((Xt = oe.getGeometry()) == null ? void 0 : Xt.getType()) == Tr.POINT) return;
        const St = Xne(oe);
        M.addOverlay(Ft.value, St);
      }
      function Ti() {
        if (M.removeOverlay(), si.value = [], Ut.value) {
          const oe = Oi(y.value);
          if (!oe) throw new Error("Map: No container is given for the map overlay.");
          oe.style.visibility = "hidden";
        }
      }
      function Li(oe) {
        Ti(), ie();
      }
      function zi() {
        var le;
        Ti();
        const oe = (le = M.getInteraction(ai.Draw, "select")) == null ? void 0 : le.getFeatures().getArray();
        oe != null && oe.length && Oe(oe[0], oe);
      }
      function Ri(oe) {
        switch (oe) {
          case dt.DRAW:
          case dt.LASSO:
          case dt.MERGE: {
            const le = M.getInteraction(ai.Draw, "polygon");
            return le ? [le] : [];
          }
          case dt.LINE: {
            const le = M.getInteraction(ai.Draw, "line");
            return le ? [le] : [];
          }
          case dt.CIRCLE: {
            const le = M.getInteraction(ai.Draw, "circle");
            return le ? [le] : [];
          }
          case dt.MODIFY: {
            const le = M.getInteraction(ai.Draw, "modify");
            return le ? [le] : [];
          }
          case dt.CUT: {
            const le = M.getInteraction(ai.Draw, "line");
            return le ? [le] : [];
          }
          case dt.CADASTRAL: {
            const le = M.getInteraction(ai.Cadastral, "select");
            return le ? [le] : [];
          }
          case dt.SELECT: {
            const le = M.getInteraction(ai.Draw, "select"), we = M.getInteraction(ai.Draw, "dragBox");
            return [...le ? [le] : [], ...we ? [we] : []];
          }
          default:
            return console.warn("Case not implemented", oe), [];
        }
      }
      function ei() {
        const oe = Oi(g);
        if (!oe) return;
        const le = oe.getElementsByClassName("draw-control-enabled");
        Array.from(le).forEach((we) => we.click());
      }
      function oi(oe, le) {
        const we = Oi(u);
        if (!we) return;
        const St = we.querySelector(`.${oe} button`);
        if (!St) return;
        const Xt = St;
        le ? Xt.setAttribute("disabled", "") : Xt.removeAttribute("disabled");
      }
      function Wi(oe) {
        M.switchBackgroundLayer(oe), r("diplan-karte:background-layer-update", oe), I.value = M.getLayers();
      }
      function Ki(oe) {
        M.switchDataLayers(oe), r("diplan-karte:data-layer-update", oe), I.value = M.getLayers();
      }
      const Ut = ue();
      return (oe, le) => (G(), X("div", {
        id: "diplanung-karten-main-container",
        ref_key: "mapRootRef",
        ref: u,
        class: "map-frame-container"
      }, [
        ee(qA, {
          ref: "controlPanelLeftRef",
          position: "left"
        }, null, 512),
        ee(qA, {
          ref_key: "controlPanelTopRightRef",
          ref: E,
          position: "top-right",
          style: { visibility: "visible" },
          class: ""
        }, {
          default: Ye(() => {
            var we;
            return [
              ee(Tq, {
                ref_key: "controlPanelLayerRef",
                ref: f,
                baseLayer: j(l),
                backgroundLayers: j(a).Themenconfig.Hintergrundkarten.Layer,
                dataLayers: j(a).Themenconfig.Fachdaten.Ordner,
                xplanLayers: (we = j(a).Themenconfig.Xplandaten) == null ? void 0 : we.Ordner,
                onBackgroundChange: le[0] || (le[0] = (St) => Wi(St)),
                onDataChange: le[1] || (le[1] = (St) => Ki(St))
              }, null, 8, ["baseLayer", "backgroundLayers", "dataLayers", "xplanLayers"])
            ];
          }),
          _: 1
        }, 512),
        ee(qA, {
          ref: "controlPanelTop",
          position: "top",
          style: { visibility: "visible", position: "relative" }
        }, {
          default: Ye(() => [
            be("div", {
              ref_key: "gfiOverlayRef",
              ref: y,
              style: { visibility: "hidden" }
            }, [
              ee(rCe, {
                geometry: Ut.value,
                "onClose:gfi": le[2] || (le[2] = () => Ti())
              }, null, 8, ["geometry"])
            ], 512)
          ]),
          _: 1
        }, 512),
        ee(qA, {
          ref_key: "controlPanelTopLeftRef",
          ref: m,
          position: "top-left"
        }, {
          default: Ye(() => [
            t.profile != j(qi).VORHABEN ? (G(), De(z0e, {
              key: 0,
              class: "ms-2",
              onSelect: le[3] || (le[3] = (we) => D(we)),
              "onSearch:input": le[4] || (le[4] = (we) => v.value = we)
            })) : de("", !0)
          ]),
          _: 1
        }, 512),
        ee(qA, {
          ref_key: "controlPanelRightRef",
          ref: g,
          position: "right"
        }, null, 512),
        ee(qA, {
          ref_key: "controlPanelBottomLeftRef",
          ref: d,
          position: "bottom-left"
        }, {
          default: Ye(() => [
            ee(bCe, {
              ref_key: "controlPanelLayerInfoRef",
              ref: p,
              activeLayerIds: I.value,
              themenConfig: j(a).Themenconfig
            }, null, 8, ["activeLayerIds", "themenConfig"])
          ]),
          _: 1
        }, 512),
        ee(qA, {
          ref_key: "controlPanelBottomRightRef",
          ref: h,
          position: "bottom-right"
        }, null, 512),
        be("div", {
          ref_key: "mapOverlayRef",
          ref: Ft,
          style: { visibility: "hidden" }
        }, [
          ee(H0e, {
            geometries: si.value,
            names: Q.value,
            onAdd: le[5] || (le[5] = (we) => lt(we)),
            onUpdate: le[6] || (le[6] = (we) => Li())
          }, null, 8, ["geometries", "names"])
        ], 512)
      ], 512));
    }
  }), ICe = ".map-frame-container[data-v-95727b2b]{position:relative;width:100%;height:100%}[data-v-95727b2b] .ol-scale-bar{position:absolute;bottom:0;right:0;background-color:#ffffffa8;color:#04071a}[data-v-95727b2b] .ol-scale-bar .ol-scale-bar-inner{width:auto!important}[data-v-95727b2b] .ol-scale-bar .ol-scale-bar-inner div{display:none}[data-v-95727b2b] .ol-scale-bar .ol-scale-bar-inner div.ol-scale-text{display:block;white-space:nowrap;width:auto!important;padding:8px;font-size:1rem;line-height:1rem}", _M = /* @__PURE__ */ Zl(MCe, [["styles", [ICe]], ["__scopeId", "data-v-95727b2b"]]);
  /*! Oruga Bootstrap Theme v0.8.2 | MIT License | github.com/oruga-ui/theme-bootstrap */
  const vCe = {
    autocomplete: {
      override: !0,
      rootClass: "autocomplete",
      itemEmptyClass: "disabled",
      itemGroupTitleClass: "fw-bold"
    },
    button: {
      override: !0,
      rootClass: "btn",
      wrapperClass: "button-wrapper",
      sizeClass: (t) => t == "small" ? "btn-sm" : t == "medium" ? "btn-md" : t == "large" ? "btn-lg" : `btn-${t}`,
      variantClass: (t, e) => e.outlined ? "" : `btn-${e.variant}`,
      outlinedClass: (t, e) => e.variant ? `btn-outline-${e.variant}` : "btn-outline",
      invertedClass: (t) => t ? `btn-inverted-${t}` : "btn-inverted",
      roundedClass: "rounded-pill",
      expandedClass: "expanded",
      disabledClass: "btn-disabled",
      loadingClass: "loading"
    },
    carousel: {
      override: !0,
      rootClass: "carousel",
      overlayClass: "carousel-overlay",
      wrapperClass: "carousel-scene",
      itemsClass: "carousel-items carousel-inner",
      itemsDraggingClass: "dragging",
      itemClass: "carousel-item",
      itemActiveClass: "active",
      itemClickableClass: "clickable",
      iconClass: "carousel-control",
      iconAutoplayClass: "carousel-control-autoplay",
      iconNextClass: "carousel-control-next carousel-control-next-icon",
      iconPrevClass: "carousel-control-prev carousel-control-prev-icon",
      indicatorPosition: "position-",
      indicatorsClass: "carousel-indicators",
      indicatorClass: "carousel-indicator",
      indicatorsInsideClass: "inside",
      indicatorsPositionClass: "position-",
      indicatorItemClass: "carousel-indicator-item",
      indicatorItemStyleClass: "indicator-",
      indicatorItemActiveClass: "active"
    },
    checkbox: {
      override: !0,
      rootClass: "form-check",
      variantClass: "variant-",
      sizeClass: "size-",
      disabledClass: "disabled",
      inputClass: "form-check-input",
      labelClass: "form-check-label"
    },
    collapse: {
      override: !0,
      rootClass: "collapse",
      triggerClass: "collapse-trigger",
      expandedClass: "w-100",
      contentClass: "collapse-content"
    },
    dropdown: {
      override: !0,
      rootClass: "dropdown",
      modalClass: "dropdown-modal",
      teleportClass: "teleported",
      disabledClass: "disabled",
      expandedClass: "expanded",
      inlineClass: "inline",
      triggerClass: "dropdown-trigger",
      overlayClass: "dropdown-backdrop",
      menuClass: "dropdown-menu",
      menuPositionClass: "position-",
      menuActiveClass: "show",
      itemClass: "dropdown-item",
      itemSelectedClass: "active",
      itemFocusedClass: "focused",
      itemClickableClass: "clickable",
      itemDisabledClass: "disabled",
      scrollClipClass: "scroll-clipped",
      scrollKeepClass: "scroll-hidden"
    },
    datepicker: {
      override: !0,
      rootClass: "datepicker",
      mobileClass: "mobile",
      boxClass: "dropdown-item",
      headerClass: "datepicker-header",
      footerClass: "datepicker-footer",
      listsClass: "pagination-list",
      prevButtonClass: "pagination-previous btn",
      nextButtonClass: "pagination-next btn",
      tableClass: "datepicker-table",
      tableBodyClass: "datepicker-body",
      tableHeadClass: "datepicker-header",
      tableHeadCellClass: "datepicker-cell",
      tableRowClass: "datepicker-row",
      tableCellClass: "datepicker-cell focus-ring",
      tableCellSelectableClass: "selectable",
      tableCellUnselectableClass: "unselectable",
      tableCellTodayClass: "today",
      tableCellSelectedClass: "selected",
      tableCellWithinHoveredClass: "hovered-within",
      tableCellFirstHoveredClass: "hovered-first",
      tableCellLastHoveredClass: "hovered-last",
      tableCellFirstSelectedClass: "selected-first",
      tableCellLastSelectedClass: "selected-last",
      tableCellWithinSelectedClass: "selected-within",
      tableCellInvisibleClass: "",
      tableCellNearbyClass: "nearby",
      tableCellEventsClass: (t, e) => {
        const i = ["has-event"];
        return e.indicators && i.push(`${e.indicators}`), i.join(" ");
      },
      tableEventsClass: "events",
      tableEventClass: "event",
      tableEventVariantClass: "variant-",
      monthClass: "datepicker-month",
      monthTableClass: "datepicker-table",
      monthCellClass: "datepicker-cell",
      monthCellSelectableClass: "selectable",
      monthCellUnselectableClass: "unselectable",
      monthCellTodayClass: "today",
      monthCellSelectedClass: "selected",
      monthCellWithinHoveredClass: "hovered-within",
      monthCellFirstHoveredClass: "hovered-first",
      monthCellLastHoveredClass: "hovered-last",
      monthCellFirstSelectedClass: "selected-first",
      monthCellLastSelectedClass: "selected-last",
      monthCellWithinSelectedClass: "selected-within",
      monthEventsClass: "events",
      monthEventClass: "event",
      monthEventVariantClass: "variant-"
    },
    timepicker: {
      override: !0,
      rootClass: "timepicker",
      boxClass: "dropdown-item",
      selectClasses: {
        rootClass: "select",
        selectClass: "form-select"
      },
      separatorClass: "separator",
      footerClass: "timepicker-footer",
      sizeClass: "size-"
    },
    datetimepicker: {
      override: !0,
      datepickerWrapperClass: "datepicker-wrapper",
      timepickerWrapperClass: "timepicker-wrapper d-flex justify-content-center"
    },
    field: {
      override: !0,
      rootClass: "input-field",
      bodyClass: "field-wrapper",
      labelClass: "form-label",
      messageClass: "help",
      messageVariantClass: "text-",
      addonsClass: "input-group",
      groupedClass: "input-grouped",
      multilineClass: "multiline",
      horizontalClass: "field-horizontal row",
      horizontalLabelClass: "col-form-label",
      horizontalBodyClass: "col-form-field"
    },
    icon: {
      override: !0,
      rootClass: "icon",
      variantClass: "text-",
      sizeClass: "size-",
      clickableClass: "clickable",
      spinClass: "spin"
    },
    input: {
      override: !0,
      rootClass: "input",
      sizeClass: "size-",
      variantClass: "variant-",
      expandedClass: "expanded",
      disabledClass: "disabled",
      roundedClass: "rounded-pill",
      inputClass: (t, e) => {
        const i = ["form-control focus-ring"];
        return e.icon && i.push("icon-left"), e.iconRight && i.push("icon-right"), e.size == "small" ? i.push("form-control-sm") : e.size == "medium" ? i.push("form-control-md") : e.size == "large" && i.push("form-control-lg"), i.join(" ");
      },
      iconLeftClass: "icon-left",
      iconRightClass: "icon-right",
      counterClass: "help counter"
    },
    loading: {
      override: !0,
      rootClass: "loading",
      fullPageClass: "fullpage",
      overlayClass: "loading-overlay",
      labelClass: "loading-label",
      iconClass: "icon",
      scrollClipClass: "scroll-clipped",
      scrollKeepClass: "scroll-hidden"
    },
    menu: {
      override: !0,
      rootClass: "menu",
      listClass: "menu-list",
      labelClass: "menu-label",
      itemClass: "menu-item",
      itemButtonClass: "menu-button",
      itemButtonFocusedClass: "focused",
      itemButtonActiveClass: "active",
      itemButtonDisabledClass: "disabled",
      itemButtonIconClass: "menu-icon",
      itemSubmenuClass: "menu-submenu"
    },
    modal: {
      override: !0,
      rootClass: "modal fade",
      activeClass: "show",
      overlayClass: "modal-backdrop",
      contentClass: (t, e) => {
        const i = ["modal-dialog"];
        return e.fullScreen || i.push("modal-dialog-centered"), i.join(" ");
      },
      closeIcon: "",
      closeClass: "btn-close",
      fullScreenClass: "fullscreen",
      mobileClass: "mobile",
      scrollClipClass: ["scroll-clipped", "modal-open"],
      scrollKeepClass: "scroll-hidden"
    },
    notification: {
      override: !0,
      rootClass: "notifictation alert",
      variantClass: "variant-",
      wrapperClass: "notifictation-wrapper",
      contentClass: "notifictation-content",
      positionClass: "position-",
      iconClass: "media",
      closeClass: "btn-close",
      noticeClass: "notifictations",
      noticePositionClass: "position-"
    },
    pagination: {
      override: !0,
      rootClass: "pagination-wrapper",
      sizeClass: (t, e) => {
        if (e.size == "small") return "pagination-sm";
        if (e.size == "medium") return "pagination-md";
        if (e.size == "large") return "pagination-lg";
      },
      roundedClass: "rounded-pill",
      simpleClass: "simple",
      orderClass: "order-",
      listClass: (t, e) => {
        const i = ["pagination"];
        return e.size == "small" ? i.push("pagination-sm") : e.size == "medium" ? i.push("pagination-md") : e.size == "large" && i.push("pagination-lg"), i.join(" ");
      },
      listItemClass: "page-item",
      buttonClass: "page-link",
      buttonCurrentClass: "active",
      buttonDisabledClass: "disabled",
      ellipsisClass: (t, e) => {
        const i = ["pagination-ellipsis"];
        return e.rounded && i.push("rounded-pill"), i.join(" ");
      },
      buttonNextClass: "pagination-next page-item",
      buttonPrevClass: "pagination-prev page-item",
      infoClass: "pagination-info"
    },
    radio: {
      override: !0,
      rootClass: "form-check",
      disabledClass: "disabled",
      variantClass: "variant-",
      sizeClass: "size-",
      inputClass: "form-check-input",
      labelClass: "form-check-label"
    },
    select: {
      override: !0,
      rootClass: "select",
      sizeClass: "size-",
      variantClass: "variant-",
      expandedClass: "expanded",
      disabledClass: "disabled",
      roundedClass: "rounded-pill",
      multipleClass: "multiple",
      placeholderClass: "empty",
      arrowedClass: "arrowed",
      selectClass: (t, e) => {
        const i = ["form-select focus-ring"];
        return e.icon && i.push("icon-left"), e.iconRight && i.push("icon-right"), e.size == "small" ? i.push("form-select-sm") : e.size == "medium" ? i.push("form-select-md") : e.size == "large" && i.push("form-select-lg"), i.join(" ");
      },
      iconLeftClass: "icon-left",
      iconRightClass: "icon-right"
    },
    sidebar: {
      override: !0,
      rootClass: "sidebar",
      overlayClass: "offcanvas-backdrop",
      activeClass: "show",
      positionClass: (t, e) => e.position === "left" ? "offcanvas-start" : e.position === "right" ? "offcanvas-end" : e.position === "top" ? "offcanvas-top" : e.position === "bottom" ? "offcanvas-bottom" : "offcanvas-start",
      contentClass: "offcanvas",
      reduceClass: "reduced",
      expandOnHoverClass: "hover-expanded",
      fullheightClass: "fullheight",
      fullwidthClass: "fullwidth",
      mobileClass: "mobile",
      inlineClass: "inline",
      teleportClass: "teleported",
      scrollClipClass: "scroll-clipped",
      scrollKeepClass: "scroll-hidden"
    },
    skeleton: {
      override: !0,
      rootClass: "skeleton",
      itemClass: "skeleton-item",
      roundedClass: "rounded-pill",
      animatedClass: "animated",
      sizeClass: "size-",
      positionClass: (t) => {
        if (t == "left") return "align-items-start";
        if (t == "centered") return "align-items-center";
        if (t == "right") return "align-items-end";
      }
    },
    slider: {
      override: !0,
      rootClass: "slider",
      disabledClass: "disabled",
      variantClass: "variant-",
      trackClass: "slider-track",
      fillClass: "slider-fill",
      thumbWrapperClass: "slider-thumb-wrapper",
      sizeClass: "size-",
      thumbClass: (t, e) => {
        const i = ["slider-thumb", "focus-ring"];
        return e.variant && i.push(`variant-${e.variant}`), e.variant && i.push(`focus-ring-${e.variant}`), i.join(" ");
      },
      tickClass: "slider-tick",
      tickLabelClass: "slider-tick-label",
      tickHiddenClass: "slider-tick-hidden",
      thumbRoundedClass: "rounded-pill",
      thumbDraggingClass: "dragging"
    },
    steps: {
      override: !0,
      rootClass: (t, e) => {
        const i = ["steps"];
        return e.variant && i.push(`variant-${e.variant}`), e.disabled && i.push("disabled"), i.join(" ");
      },
      sizeClass: "size-",
      positionClass: "position-",
      verticalClass: "vertical",
      animatedClass: "animated",
      listClass: "steps-list",
      stepClass: "step-item",
      stepActiveClass: "active",
      stepDisabledClass: "disabled",
      stepClickableClass: "clickable",
      stepVariantClass: "variant-",
      stepPositionClass: "label-",
      stepPreviousClass: "previous",
      stepNextClass: "next",
      stepLabelClass: "step-title",
      markerClass: "step-marker",
      markerRoundedClass: "rounded-pill",
      dividerClass: "divider",
      stepPanelClass: "step-item",
      contentClass: "step-content",
      transitioningClass: "transition",
      navigationClass: "step-navigation"
    },
    switch: {
      override: !0,
      rounded: !0,
      rootClass: "form-check form-switch",
      roundedClass: "rounded",
      positionClass: (t) => {
        if (t == "left") return "reversed";
      },
      inputClass: (t, e) => {
        const i = ["form-check-input"];
        return e.rounded && i.push("rounded-pill"), i.join(" ");
      },
      labelClass: "form-check-label",
      disabledClass: "disabled",
      sizeClass: "size-",
      variantClass: "variant-",
      passiveVariantClass: "variant-"
    },
    table: {
      override: !0,
      rootClass: "table-wrapper",
      wrapperClass: "table-inner",
      tableClass: "table",
      stickyHeaderClass: "table-sticky",
      borderedClass: "table-bordered",
      stripedClass: "table-striped",
      narrowedClass: "table-sm",
      hoverableClass: "table-hover",
      emptyClass: "table-empty",
      footerClass: "table-footer",
      paginationWrapperClass: "table-pagination",
      scrollableClass: "scrollable",
      trDetailedClass: "table-detail",
      trEmptyClass: "table-empty",
      trSelectedClass: "table-active",
      trCheckedClass: "table-checked",
      thClass: "table-th",
      thSortableClass: "sortable",
      thCurrentSortClass: "current-sort",
      thSortIconClass: "sort-icon",
      thUnselectableClass: "unselectable",
      thDetailedClass: "chevron",
      thStickyClass: "sticky",
      thCheckboxClass: "checkbox",
      thPositionClass: "text-",
      tdClass: "table-td",
      tdDetailedChevronClass: "chevron",
      tdStickyClass: "sticky",
      tdCheckboxClass: "checkbox",
      tdPositionClass: "text-",
      mobileClass: "mobile-cards",
      mobileSortClass: "table-mobile-sort"
    },
    tabs: {
      override: !0,
      tag: "ul",
      itemTag: "li",
      rootClass: "tabs",
      positionClass: "position-",
      expandedClass: "expanded",
      verticalClass: "vertical",
      multilineClass: "multiline",
      typeClass: "type-",
      sizeClass: "size-",
      listClass: (t, e) => {
        const i = ["nav"];
        return e.type && i.push(`nav-${e.type}`), e.position === "left" ? i.push("justify-content-start") : e.position === "centered" ? i.push("justify-content-center") : e.position === "right" && i.push("justify-content-end"), i.join(" ");
      },
      tabClass: "nav-item nav-link",
      tabActiveClass: "active",
      tabDisabledClass: "disabled",
      contentClass: "tab-content",
      transitioningClass: "transition"
    },
    taginput: {
      override: !0,
      rootClass: (t, e) => {
        const i = ["taginput"];
        return e.disabled && i.push("disabled"), i.join(" ");
      },
      containerClass: (t, e) => {
        const i = ["taginput-wrapper", "focus-ring"];
        return e.variant && i.push(`focus-ring-${e.variant}`), i.join(" ");
      },
      itemClass: "badge",
      closeClass: "btn-close",
      variantClass: "variant-",
      sizeClass: "size-",
      expandedClass: "expanded",
      counterClass: "counter"
    },
    tooltip: {
      override: !0,
      rootClass: "tooltip-wrapper",
      alwaysClass: "always",
      multilineClass: "multiline",
      variantClass: "variant-",
      positionClass: "position-",
      teleportClass: "teleported",
      triggerClass: "tooltip-trigger",
      contentClass: "tooltip-content"
    },
    upload: {
      override: !0,
      rootClass: "upload",
      variantClass: "variant-",
      draggableClass: "upload-draggable",
      expandedClass: "expanded",
      disabledClass: "disabled",
      hoveredClass: "hovered"
    }
  }, xCe = {
    /**
     * Add Oruga to the Vue instance
     * @param app Vue app instance
     * @param options pass external config to oruga via the options property
     */
    // TODO Make type more explicit than any
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    install: (t, e = {}) => {
      let i = {
        iconPack: "dps-icon",
        customIconPacks: {
          "dps-icon": {
            iconPrefix: "dps-icon--"
          }
        },
        table: {
          mobileCards: !1,
          sortIcon: "chevron-up",
          sortIconSize: "large",
          loadingIcon: "refresh",
          emptyIcon: "frown",
          emptyLabel: "Keine Flächen verfügbar"
        },
        dropdown: {
          itemTag: "div"
        }
      };
      i = kM(vCe, i), i = kM(i, e), t.use(qBe, i).use(fwe).use(pwe).use(Fwe).use(Rwe).use(Q0e).use(ywe).use(M0e).use(x0e).use(Hwe).use(bwe).use(zwe).use(Twe).use(_we).use(Wwe).use(Xwe).use(Vwe), console.log("Oruga Plugin is initialized.");
    }
  };
  function kM(t, e) {
    const i = (r) => r && typeof r == "object";
    return !i(t) || !i(e) ? e : (Object.keys(e).forEach((r) => {
      const n = t[r], s = e[r];
      Array.isArray(n) && Array.isArray(s) ? t[r] = n.concat(s) : i(n) && i(s) ? t[r] = kM({ ...n }, s) : t[r] = s;
    }), t);
  }
  function aQ() {
    const t = [];
    let e = 0;
    const i = (n) => t.push(n), r = (n) => {
      const s = t[e];
      return typeof s == "function" ? s(n, (o) => (e++, r(o))) : (e = 0, n);
    };
    return i.dispatch = r, i.unshift = (n) => t.unshift(n), i.remove = (n) => {
      const s = t.indexOf(n);
      s > -1 && t.splice(s, 1);
    }, i;
  }
  function fO() {
    const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map();
    let i;
    const r = (n, s) => {
      if (i) {
        i.set(s.name, [n, s]);
        return;
      }
      t.has(s.name) && t.get(s.name).forEach((o) => {
        (s.origin === n || o.modifiers.includes("deep")) && o.listener(s);
      }), s.bubble && n.bubble(s);
    };
    return r.flush = () => {
      t.clear(), e.clear(), i == null || i.clear();
    }, r.on = (n, s, o = "push") => {
      const [a, ...A] = n.split("."), l = s.receipt || Ld(), c = {
        modifiers: A,
        event: a,
        listener: s,
        receipt: l
      };
      return t.has(a) ? t.get(a)[o](c) : t.set(a, [c]), e.has(l) ? e.get(l)[o](a) : e.set(l, [a]), l;
    }, r.off = (n) => {
      var s;
      e.has(n) && ((s = e.get(n)) == null || s.forEach((o) => {
        const a = t.get(o);
        Array.isArray(a) && t.set(
          o,
          a.filter((A) => A.receipt !== n)
        );
      }), e.delete(n));
    }, r.pause = (n) => {
      i || (i = /* @__PURE__ */ new Map()), n && n.walk((s) => s._e.pause());
    }, r.play = (n) => {
      if (!i)
        return;
      const s = i;
      i = void 0, s.forEach(([o, a]) => r(o, a)), n && n.walk((o) => o._e.play());
    }, r;
  }
  function QCe(t, e, i, r, n = !0, s) {
    return e._e(t, {
      payload: r,
      name: i,
      bubble: n,
      origin: t,
      meta: s
    }), t;
  }
  function FCe(t, e, i) {
    return Uf(t.parent) && t.parent._e(t.parent, i), t;
  }
  function SCe(t, e, i, r, n) {
    return e._e.on(i, r, n);
  }
  function DCe(t, e, i) {
    return e._e.off(i), t;
  }
  var AQ = aQ();
  AQ((t, e) => (t.message || (t.message = `E${t.code}`), e(t)));
  var lQ = aQ();
  lQ((t, e) => {
    t.message || (t.message = `W${t.code}`);
    const i = e(t);
    return console && typeof console.warn == "function" && console.warn(i.message), i;
  });
  function gc(t, e = {}) {
    lQ.dispatch({ code: t, data: e });
  }
  function zn(t, e = {}) {
    throw Error(AQ.dispatch({ code: t, data: e }).message);
  }
  function nn(t, e) {
    return {
      blocking: !1,
      key: Ld(),
      meta: {},
      type: "state",
      visible: !0,
      ...t
    };
  }
  var M2 = {
    apply: NCe,
    set: RCe,
    remove: pO,
    filter: kCe,
    reduce: YCe,
    release: zCe,
    touch: _Ce
  };
  function TCe(t = !1) {
    const e = {};
    let i, r = t, n = [];
    const s = /* @__PURE__ */ new Map();
    let o;
    const a = new Proxy(e, {
      get(...A) {
        const [l, c] = A;
        return c === "buffer" ? r : c === "_b" ? n : c === "_m" ? s : c === "_r" ? o : gt(M2, c) ? M2[c].bind(
          null,
          e,
          a,
          i
        ) : Reflect.get(...A);
      },
      set(A, l, c) {
        return l === "_n" ? (i = c, o === "__n" && mO(i, a), !0) : l === "_b" ? (n = c, !0) : l === "buffer" ? (r = c, !0) : l === "_r" ? (o = c, !0) : (zn(101, i), !1);
      }
    });
    return a;
  }
  function RCe(t, e, i, r) {
    if (e.buffer)
      return e._b.push([[r]]), e;
    if (t[r.key] !== r) {
      if (typeof r.value == "string" && r.meta.localize !== !1) {
        const s = r.value;
        r.value = i.t(r), r.value !== s && (r.meta.locale = i.props.locale);
      }
      const n = `message-${gt(t, r.key) ? "updated" : "added"}`;
      t[r.key] = Object.freeze(
        i.hook.message.dispatch(r)
      ), i.emit(n, r);
    }
    return e;
  }
  function _Ce(t, e) {
    for (const i in t) {
      const r = { ...t[i] };
      e.set(r);
    }
  }
  function pO(t, e, i, r) {
    if (gt(t, r)) {
      const n = t[r];
      delete t[r], i.emit("message-removed", n);
    }
    return e.buffer === !0 && (e._b = e._b.filter((n) => (n[0] = n[0].filter((s) => s.key !== r), n[1] || n[0].length))), e;
  }
  function kCe(t, e, i, r, n) {
    for (const s in t) {
      const o = t[s];
      (!n || o.type === n) && !r(o) && pO(t, e, i, s);
    }
  }
  function YCe(t, e, i, r, n) {
    for (const s in t) {
      const o = t[s];
      n = r(n, o);
    }
    return n;
  }
  function NCe(t, e, i, r, n) {
    if (Array.isArray(r)) {
      if (e.buffer) {
        e._b.push([r, n]);
        return;
      }
      const s = new Set(
        r.map((o) => (e.set(o), o.key))
      );
      typeof n == "string" ? e.filter(
        (o) => o.type !== n || s.has(o.key)
      ) : typeof n == "function" && e.filter((o) => !n(o) || s.has(o.key));
    } else
      for (const s in r) {
        const o = i.at(s);
        o ? o.store.apply(r[s], n) : LCe(i, e, s, r[s], n);
      }
  }
  function UCe(t, ...e) {
    const i = `${t.name}-set`, r = (n) => /* @__PURE__ */ nn({
      key: yx(n),
      type: "error",
      value: n,
      meta: { source: i, autoClear: !0 }
    });
    return e.filter((n) => !!n).map((n) => {
      if (typeof n == "string" && (n = [n]), Array.isArray(n))
        return n.map((s) => r(s));
      {
        const s = {};
        for (const o in n)
          Array.isArray(n[o]) ? s[o] = n[o].map(
            (a) => r(a)
          ) : s[o] = [r(n[o])];
        return s;
      }
    });
  }
  function LCe(t, e, i, r, n) {
    var o;
    const s = e._m;
    s.has(i) || s.set(i, []), e._r || (e._r = mO(t, e)), (o = s.get(i)) == null || o.push([r, n]);
  }
  function mO(t, e) {
    return t.on(
      "child.deep",
      ({ payload: i }) => {
        e._m.forEach((r, n) => {
          t.at(n) === i && (r.forEach(([s, o]) => {
            i.store.apply(s, o);
          }), e._m.delete(n));
        }), e._m.size === 0 && e._r && (t.off(e._r), e._r = void 0);
      }
    );
  }
  function zCe(t, e) {
    e.buffer = !1, e._b.forEach(([i, r]) => e.apply(i, r)), e._b = [];
  }
  function PCe() {
    const t = {};
    let e;
    return {
      count: (...i) => OCe(e, t, ...i),
      init(i) {
        e = i, i.on("message-added.deep", I2(t, 1)), i.on("message-removed.deep", I2(t, -1));
      },
      merge: (i) => v2(e, t, i),
      settled(i) {
        return gt(t, i) ? t[i].promise : Promise.resolve();
      },
      unmerge: (i) => v2(e, t, i, !0),
      value(i) {
        return gt(t, i) ? t[i].count : 0;
      }
    };
  }
  function OCe(t, e, i, r, n = 0) {
    if (r = GCe(r || i), !gt(e, i)) {
      const s = {
        condition: r,
        count: 0,
        name: i,
        node: t,
        promise: Promise.resolve(),
        resolve: () => {
        }
        // eslint-disable-line @typescript-eslint/no-empty-function
      };
      e[i] = s, n = t.store.reduce(
        (o, a) => o + s.condition(a) * 1,
        n
      ), t.each((o) => {
        o.ledger.count(s.name, s.condition), n += o.ledger.value(s.name);
      });
    }
    return EO(e[i], n).promise;
  }
  function GCe(t) {
    return typeof t == "function" ? t : (e) => e.type === t;
  }
  function EO(t, e) {
    const i = t.count, r = t.count + e;
    return t.count = r, i === 0 && r !== 0 ? (t.node.emit(`unsettled:${t.name}`, t.count, !1), t.promise = new Promise((n) => t.resolve = n)) : i !== 0 && r === 0 && (t.node.emit(`settled:${t.name}`, t.count, !1), t.resolve()), t.node.emit(`count:${t.name}`, t.count, !1), t;
  }
  function I2(t, e) {
    return (i) => {
      for (const r in t) {
        const n = t[r];
        n.condition(i.payload) && EO(n, e);
      }
    };
  }
  function v2(t, e, i, r = !1) {
    const n = t;
    for (const s in e) {
      const o = e[s].condition;
      r || i.ledger.count(s, o);
      const a = i.ledger.value(s) * (r ? -1 : 1);
      if (t) {
        do
          t.ledger.count(s, o, a), t = t.parent;
        while (t);
        t = n;
      }
    }
  }
  var cQ = /* @__PURE__ */ new Map(), Zm = /* @__PURE__ */ new Map(), uQ = fO();
  function jCe(t) {
    t.props.id && (cQ.set(t.props.id, t), Zm.set(t, t.props.id), uQ(t, {
      payload: t,
      name: t.props.id,
      bubble: !1,
      origin: t
    }));
  }
  function HCe(t) {
    if (Zm.has(t)) {
      const e = Zm.get(t);
      Zm.delete(t), cQ.delete(e), uQ(t, {
        payload: null,
        name: e,
        bubble: !1,
        origin: t
      });
    }
  }
  function Nf(t) {
    return cQ.get(t);
  }
  function JCe(t, e) {
    return uQ.on(t, e);
  }
  function YM(t, e, i) {
    let r = !0;
    return e in t.config._t ? r = !1 : t.emit(`config:${e}`, i, !1), e in t.props || (t.emit("prop", { prop: e, value: i }), t.emit(`prop:${e}`, i)), r;
  }
  function VCe(t = {}) {
    const e = /* @__PURE__ */ new Set(), i = {
      ...t,
      _add: (n) => e.add(n),
      _rm: (n) => e.delete(n)
    };
    return new Proxy(i, {
      set(n, s, o, a) {
        return typeof s == "string" && e.forEach((A) => YM(A, s, o)), Reflect.set(n, s, o, a);
      }
    });
  }
  function yO(t, e) {
    const i = (e || document).getElementById(t);
    if (i instanceof HTMLFormElement) {
      const r = new Event("submit", { cancelable: !0, bubbles: !0 });
      i.dispatchEvent(r);
      return;
    }
    gc(151, t);
  }
  function WCe(t) {
    const e = (i) => {
      for (const r in i.store) {
        const n = i.store[r];
        n.type === "error" || n.type === "ui" && r === "incomplete" ? i.store.remove(r) : n.type === "state" && i.store.set({ ...n, value: !1 });
      }
    };
    e(t), t.walk(e);
  }
  function BO(t, e) {
    const i = typeof t == "string" ? Nf(t) : t;
    if (i) {
      const r = (o) => {
        const a = Us(o.props.initial);
        return a !== void 0 ? a : o.type === "group" ? {} : o.type === "list" ? [] : void 0;
      };
      i._e.pause(i);
      const n = Us(e);
      return e && !As(e) && (i.props.initial = Ph(n) ? ud(n) : n, i.props._init = i.props.initial), i.input(r(i), !1), i.walk((o) => {
        o.type === "list" && o.sync || o.input(r(o), !1);
      }), i.input(
        As(n) && n ? n : r(i),
        !1
      ), i.type !== "input" && e && !As(e) && Ph(e) && i.walk((o) => {
        o.props.initial = Ph(o.value) ? ud(o.value) : o.value, o.props._init = o.props.initial;
      }), i._e.play(i), WCe(i), i.emit("reset", i), i;
    }
    gc(152, t);
  }
  var KCe = {
    delimiter: ".",
    delay: 0,
    locale: "en",
    rootClasses: (t) => ({ [`formkit-${jL(t)}`]: !0 })
  }, wO = Symbol("index"), NM = Symbol("removed"), UM = Symbol("moved"), CO = Symbol("inserted");
  function XCe(t) {
    return t.type === "list" && Array.isArray(t._value);
  }
  function Uf(t) {
    return t && typeof t == "object" && t.__FKNode__ === !0;
  }
  var qm = (t, e, i) => {
    zn(102, [t, i]);
  }, ZCe = {
    _c: Jt(Ebe, qm, !1),
    add: Jt(cbe),
    addProps: Jt(lbe),
    address: Jt(Bbe, qm, !1),
    at: Jt(wbe),
    bubble: Jt(FCe),
    clearErrors: Jt(Sbe),
    calm: Jt(obe),
    config: Jt(!1),
    define: Jt(Abe),
    disturb: Jt(sbe),
    destroy: Jt(abe),
    extend: Jt(Tbe),
    hydrate: Jt(rbe),
    index: Jt(mbe, pbe, !1),
    input: Jt(IO),
    each: Jt(hbe),
    emit: Jt(QCe),
    find: Jt(bbe),
    on: Jt(SCe),
    off: Jt(DCe),
    parent: Jt(!1, ube),
    plugins: Jt(!1),
    remove: Jt(dbe),
    root: Jt(Ibe, qm, !1),
    reset: Jt(Qbe),
    resetConfig: Jt(fbe),
    setErrors: Jt(Fbe),
    submit: Jt(xbe),
    t: Jt(vbe),
    use: Jt(dQ),
    name: Jt(ybe, !1, !1),
    walk: Jt(gbe)
  };
  function qCe() {
    return new Map(Object.entries(ZCe));
  }
  function Jt(t, e, i = !0) {
    return {
      get: t ? (r, n) => i ? (...s) => t(r, n, ...s) : t(r, n) : !1,
      set: e !== void 0 ? e : qm.bind(null)
    };
  }
  function $Ce() {
    const t = /* @__PURE__ */ new Map();
    return new Proxy(t, {
      get(e, i) {
        return t.has(i) || t.set(i, aQ()), t.get(i);
      }
    });
  }
  var bO = 0, ebe = 0;
  function tbe(t) {
    var e, i;
    return ((e = t.parent) == null ? void 0 : e.type) === "list" ? wO : t.name || `${((i = t.props) == null ? void 0 : i.type) || "input"}_${++bO}`;
  }
  function MO(t) {
    return t.type === "group" ? ud(
      t.value && typeof t.value == "object" && !Array.isArray(t.value) ? t.value : {}
    ) : t.type === "list" ? ud(Array.isArray(t.value) ? t.value : []) : t.value;
  }
  function IO(t, e, i, r = !0) {
    return e._value = ibe(t, t.hook.input.dispatch(i)), t.emit("input", e._value), t.isCreated && t.type === "input" && Lr(e._value, e.value) && !t.props.mergeStrategy ? (t.emit("commitRaw", e.value), e.settled) : (e.isSettled && t.disturb(), r ? (e._tmo && clearTimeout(e._tmo), e._tmo = setTimeout(
      py,
      t.props.delay,
      t,
      e
    )) : py(t, e), e.settled);
  }
  function ibe(t, e) {
    switch (t.type) {
      case "input":
        break;
      case "group":
        (!e || typeof e != "object") && zn(107, [t, e]);
        break;
      case "list":
        Array.isArray(e) || zn(108, [t, e]);
        break;
    }
    return e;
  }
  function py(t, e, i = !0, r = !0) {
    e._value = e.value = t.hook.commit.dispatch(e._value), t.type !== "input" && r && t.hydrate(), t.emit("commitRaw", e.value), t.emit("commit", e.value), i && t.calm();
  }
  function vO(t, { name: e, value: i, from: r }) {
    if (!Object.isFrozen(t._value)) {
      if (XCe(t)) {
        const n = i === NM ? [] : i === UM && typeof r == "number" ? t._value.splice(r, 1) : [i];
        t._value.splice(
          e,
          i === UM || r === CO ? 0 : 1,
          ...n
        );
        return;
      }
      i !== NM ? t._value[e] = i : delete t._value[e];
    }
  }
  function rbe(t, e) {
    const i = e._value;
    return t.type === "list" && t.sync && nbe(t, e), e.children.forEach((r) => {
      if (typeof i == "object")
        if (r.name in i) {
          const n = r.type !== "input" || i[r.name] && typeof i[r.name] == "object" ? ud(i[r.name]) : i[r.name];
          if (!r.isSettled || (!Ph(n) || r.props.mergeStrategy) && Lr(n, r._value))
            return;
          r.input(n, !1);
        } else
          (t.type !== "list" || typeof r.name == "number") && vO(e, { name: r.name, value: r.value }), i.__init || (r.type === "group" ? r.input({}, !1) : r.type === "list" ? r.input([], !1) : r.input(void 0, !1));
    }), t;
  }
  function nbe(t, e) {
    const i = t._value;
    if (!Array.isArray(i))
      return;
    const r = [], n = new Set(e.children), s = /* @__PURE__ */ new Map();
    i.forEach((a, A) => {
      if (e.children[A] && e.children[A]._value === a)
        r.push(e.children[A]), n.delete(e.children[A]);
      else {
        r.push(null);
        const l = s.get(a) || [];
        l.push(A), s.set(a, l);
      }
    }), n.size && s.size && n.forEach((a) => {
      if (s.has(a._value)) {
        const A = s.get(a._value), l = A.shift();
        r[l] = a, n.delete(a), A.length || s.delete(a._value);
      }
    });
    const o = [];
    for (s.forEach((a) => {
      o.push(...a);
    }); n.size && o.length; ) {
      const a = n.values().next().value, A = o.shift();
      if (A === void 0)
        break;
      r[A] = a, n.delete(a);
    }
    o.forEach((a, A) => {
      r[a] = Ybe({ value: A });
    }), n.size && n.forEach((a) => {
      if (!("__FKP" in a)) {
        const A = a._c.parent;
        if (!A || hQ(A))
          return;
        A.ledger.unmerge(a), a._c.parent = null, a.destroy();
      }
    }), e.children = r;
  }
  function sbe(t, e) {
    var i;
    return e._d <= 0 && (e.isSettled = !1, t.emit("settled", !1, !1), e.settled = new Promise((r) => {
      e._resolve = r;
    }), t.parent && ((i = t.parent) == null || i.disturb())), e._d++, t;
  }
  function obe(t, e, i) {
    var r;
    if (i !== void 0 && t.type !== "input") {
      vO(e, i);
      const n = !!(t.config.mergeStrategy && t.config.mergeStrategy[i.name]);
      return py(t, e, !0, n);
    }
    e._d > 0 && e._d--, e._d === 0 && (e.isSettled = !0, t.emit("settled", !0, !1), t.parent && ((r = t.parent) == null || r.calm({ name: t.name, value: e.value })), e._resolve && e._resolve(e.value));
  }
  function abe(t, e) {
    t.emit("destroying", t), t.store.filter(() => !1), t.parent && t.parent.remove(t), HCe(t), t.emit("destroyed", t), e._e.flush(), e._value = e.value = void 0;
    for (const i in e.context)
      delete e.context[i];
    e.plugins.clear(), e.context = null;
  }
  function Abe(t, e, i) {
    e.type = i.type;
    const r = cd(i);
    t.props.__propDefs = xO(
      t.props.__propDefs ?? [],
      (r == null ? void 0 : r.props) || []
    ), r.props = t.props.__propDefs, e.props.definition = r, e.value = e._value = MO({
      type: t.type,
      value: e.value
    }), i.forceTypeProp && (t.props.type && (t.props.originalType = t.props.type), e.props.type = i.forceTypeProp), i.family && (e.props.family = i.family), i.features && i.features.forEach((n) => n(t)), i.props && t.addProps(i.props), t.emit("defined", i);
  }
  function lbe(t, e, i) {
    const r = Array.isArray(i) ? i : Object.keys(i), n = Array.isArray(i) ? {} : r.reduce((o, a) => ("default" in i[a] && (o[a] = i[a].default), o), {});
    if (t.props.attrs) {
      const o = { ...t.props.attrs };
      t.props._emit = !1;
      for (const A in o) {
        const l = Ru(A);
        r.includes(l) && (t.props[l] = o[A], delete o[A]);
      }
      Array.isArray(i) || r.forEach((A) => {
        "default" in i[A] && t.props[A] === void 0 && (t.props[A] = n[A]);
      });
      const a = Us(e._value);
      t.props.initial = t.type !== "input" ? ud(a) : a, t.props._emit = !0, t.props.attrs = o;
    }
    const s = xO(t.props.__propDefs ?? [], i);
    return t.props.definition && (t.props.definition.props = s), t.props.__propDefs = s, t.emit("added-props", i), t;
  }
  function LM(t) {
    return Array.isArray(t) ? t.reduce((e, i) => (e[i] = {}, e), {}) : t;
  }
  function xO(t, e) {
    return Array.isArray(t) && Array.isArray(e) ? t.concat(e) : TA(LM(t), LM(e));
  }
  function cbe(t, e, i, r) {
    if (t.type === "input" && zn(100, t), i.parent && i.parent !== t && i.parent.remove(i), !e.children.includes(i)) {
      if (r !== void 0 && t.type === "list") {
        const n = e.children[r];
        n && "__FKP" in n ? (i._c.uid = n.uid, e.children.splice(r, 1, i)) : e.children.splice(r, 0, i), Array.isArray(t.value) && t.value.length < e.children.length && t.disturb().calm({
          name: r,
          value: i.value,
          from: CO
        });
      } else
        e.children.push(i);
      i.isSettled || t.disturb();
    }
    if (i.parent !== t) {
      if (i.parent = t, i.parent !== t)
        return t.remove(i), i.parent.add(i), t;
    } else
      i.use(t.plugins);
    return py(t, e, !1), t.ledger.merge(i), t.emit("child", i), t;
  }
  function ube(t, e, i, r) {
    return Uf(r) ? (t.parent && t.parent !== r && t.parent.remove(t), e.parent = r, t.resetConfig(), r.children.includes(t) ? t.use(r.plugins) : r.add(t), !0) : r === null ? (e.parent = null, !0) : !1;
  }
  function dbe(t, e, i) {
    const r = e.children.indexOf(i);
    if (r !== -1) {
      i.isSettled && t.disturb(), e.children.splice(r, 1);
      let n = ns(i.props.preserve), s = i.parent;
      for (; n === void 0 && s; )
        n = ns(s.props.preserve), s = s.parent;
      n ? t.calm() : t.calm({
        name: t.type === "list" ? r : i.name,
        value: NM
      }), i.parent = null, i.config._rmn = i;
    }
    return t.ledger.unmerge(i), t.emit("childRemoved", i), t;
  }
  function hbe(t, e, i) {
    e.children.forEach((r) => !("__FKP" in r) && i(r));
  }
  function gbe(t, e, i, r = !1, n = !1) {
    e.children.some((s) => {
      if ("__FKP" in s)
        return !1;
      const o = i(s);
      return r && o === !1 ? !0 : n && o === !1 ? !1 : s.walk(i, r, n);
    });
  }
  function fbe(t, e) {
    const i = t.parent || void 0;
    e.config = QO(t.config._t, i), t.walk((r) => r.resetConfig());
  }
  function dQ(t, e, i, r = !0, n = !0) {
    return Array.isArray(i) || i instanceof Set ? (i.forEach((s) => dQ(t, e, s)), t) : (e.plugins.has(i) || (n && typeof i.library == "function" && i.library(t), r && i(t) !== !1 && (e.plugins.add(i), t.children.forEach((s) => s.use(i)))), t);
  }
  function pbe(t, e, i, r) {
    if (Uf(t.parent)) {
      const n = t.parent.children, s = r >= n.length ? n.length - 1 : r < 0 ? 0 : r, o = n.indexOf(t);
      return o === -1 ? !1 : (n.splice(o, 1), n.splice(s, 0, t), t.parent.children = n, t.parent.type === "list" && t.parent.disturb().calm({ name: s, value: UM, from: o }), !0);
    }
    return !1;
  }
  function mbe(t) {
    if (t.parent) {
      const e = [...t.parent.children].indexOf(t);
      return e === -1 ? t.parent.children.length : e;
    }
    return -1;
  }
  function Ebe(t, e) {
    return e;
  }
  function ybe(t, e) {
    var i;
    return ((i = t.parent) == null ? void 0 : i.type) === "list" ? t.index : e.name !== wO ? e.name : t.index;
  }
  function Bbe(t, e) {
    return e.parent ? e.parent.address.concat([t.name]) : [t.name];
  }
  function wbe(t, e, i) {
    const r = typeof i == "string" ? i.split(t.config.delimiter) : i;
    if (!r.length)
      return;
    const n = r[0];
    let s = t.parent;
    for (s || (String(r[0]) === String(t.name) && r.shift(), s = t), n === "$parent" && r.shift(); s && r.length; ) {
      const o = r.shift();
      switch (o) {
        case "$root":
          s = t.root;
          break;
        case "$parent":
          s = s.parent;
          break;
        case "$self":
          s = t;
          break;
        default:
          s = s.children.find(
            (a) => !("__FKP" in a) && String(a.name) === String(o)
          ) || Cbe(s, o);
      }
    }
    return s || void 0;
  }
  function Cbe(t, e) {
    const i = String(e).match(/^(find)\((.*)\)$/);
    if (i) {
      const [, r, n] = i, s = n.split(",").map((o) => o.trim());
      switch (r) {
        case "find":
          return t.find(s[0], s[1]);
        default:
          return;
      }
    }
  }
  function bbe(t, e, i, r) {
    return Mbe(t, i, r);
  }
  function Mbe(t, e, i = "name") {
    const r = typeof i == "string" ? (s) => s[i] == e : i, n = [t];
    for (; n.length; ) {
      const s = n.shift();
      if (!("__FKP" in s)) {
        if (r(s, e))
          return s;
        n.push(...s.children);
      }
    }
  }
  function Ibe(t) {
    let e = t;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  function QO(t = {}, e) {
    let i;
    return new Proxy(t, {
      get(...r) {
        const n = r[1];
        if (n === "_t")
          return t;
        const s = Reflect.get(...r);
        if (s !== void 0)
          return s;
        if (e) {
          const o = e.config[n];
          if (o !== void 0)
            return o;
        }
        if (t.rootConfig && typeof n == "string") {
          const o = t.rootConfig[n];
          if (o !== void 0)
            return o;
        }
        return n === "delay" && (i == null ? void 0 : i.type) === "input" ? 20 : KCe[n];
      },
      set(...r) {
        const n = r[1], s = r[2];
        if (n === "_n")
          return i = s, t.rootConfig && t.rootConfig._add(i), !0;
        if (n === "_rmn")
          return t.rootConfig && t.rootConfig._rm(i), i = void 0, !0;
        if (!Lr(t[n], s, !1)) {
          const o = Reflect.set(...r);
          return i && (i.emit(`config:${n}`, s, !1), YM(i, n, s), i.walk((a) => YM(a, n, s), !1, !0)), o;
        }
        return !0;
      }
    });
  }
  function vbe(t, e, i, r = "ui") {
    const n = typeof i == "string" ? { key: i, value: i, type: r } : i, s = t.hook.text.dispatch(n);
    return t.emit("text", s, !1), s.value;
  }
  function xbe(t) {
    const e = t.name;
    do {
      if (t.props.isForm === !0)
        break;
      t.parent || zn(106, e), t = t.parent;
    } while (t);
    t.props.id && yO(t.props.id, t.props.__root);
  }
  function Qbe(t, e, i) {
    return BO(t, i);
  }
  function Fbe(t, e, i, r) {
    const n = `${t.name}-set`, s = t.hook.setErrors.dispatch({ localErrors: i, childErrors: r });
    return UCe(t, s.localErrors, s.childErrors).forEach(
      (o) => {
        t.store.apply(o, (a) => a.meta.source === n);
      }
    ), t;
  }
  function Sbe(t, e, i = !0, r) {
    return t.store.filter((n) => !(r === void 0 || n.meta.source === r), "error"), i && (r = r || `${t.name}-set`, t.walk((n) => {
      n.store.filter((s) => !(s.type === "error" && s.meta && s.meta.source === r));
    })), t;
  }
  function Dbe(t) {
    const e = {
      initial: typeof t == "object" ? Us(t) : t
    };
    let i, r = !0, n = {};
    return new Proxy(e, {
      get(...s) {
        var c, u, d, h;
        const [o, a] = s;
        let A;
        gt(e, a) ? (A = Reflect.get(...s), (c = n[a]) != null && c.boolean && (A = Wne(A))) : i && typeof a == "string" && i.config[a] !== void 0 ? (A = i.config[a], a === "mergeStrategy" && (i == null ? void 0 : i.type) === "input" && NE(A) && i.name in A && (A = A[i.name])) : A = (u = n[a]) == null ? void 0 : u.default;
        const l = (d = n[a]) == null ? void 0 : d.getter;
        return (h = n[a]) != null && h.boolean && (A = !!A), l ? l(A, i) : A;
      },
      set(s, o, a, A) {
        var d;
        if (o === "_n")
          return i = a, !0;
        if (o === "_emit")
          return r = a, !0;
        let { prop: l, value: c } = i.hook.prop.dispatch({
          prop: o,
          value: a
        });
        const u = (d = n[l]) == null ? void 0 : d.setter;
        if (c = u ? u(c, i) : c, !Lr(e[l], c, !1) || typeof c == "object") {
          const h = Reflect.set(s, l, c, A);
          return l === "__propDefs" && (n = LM(c)), r && (i.emit("prop", { prop: l, value: c }), typeof l == "string" && i.emit(`prop:${l}`, c)), h;
        }
        return !0;
      }
    });
  }
  function Tbe(t, e, i, r) {
    return e.traps.set(i, r), t;
  }
  function Rbe(t, e) {
    if (t.props.definition)
      return t.define(t.props.definition);
    for (const i of e) {
      if (t.props.definition)
        return;
      typeof i.library == "function" && i.library(t);
    }
  }
  function _be(t) {
    const e = MO(t), i = QO(t.config || {}, t.parent);
    return {
      _d: 0,
      _e: fO(),
      uid: Symbol(),
      _resolve: !1,
      _tmo: !1,
      _value: e,
      children: Une(t.children || []),
      config: i,
      hook: $Ce(),
      isCreated: !1,
      isSettled: !0,
      ledger: PCe(),
      name: tbe(t),
      parent: t.parent || null,
      plugins: /* @__PURE__ */ new Set(),
      props: Dbe(e),
      settled: Promise.resolve(e),
      store: TCe(!0),
      sync: t.sync || !1,
      traps: qCe(),
      type: t.type || "input",
      value: e
    };
  }
  function kbe(t, e) {
    var r, n;
    const i = (r = e.props) == null ? void 0 : r.id;
    if (i || (n = e.props) == null || delete n.id, t.ledger.init(t.store._n = t.props._n = t.config._n = t), t.props._emit = !1, Object.assign(
      t.props,
      i ? {} : { id: `input_${ebe++}` },
      e.props ?? {}
    ), t.props._emit = !0, Rbe(
      t,
      /* @__PURE__ */ new Set([
        ...e.plugins || [],
        ...t.parent ? t.parent.plugins : []
      ])
    ), e.plugins)
      for (const s of e.plugins)
        dQ(t, t._c, s, !0, !1);
    return t.each((s) => t.add(s)), t.parent && t.parent.add(t, e.index), t.type === "input" && t.children.length && zn(100, t), IO(t, t._c, t._value, !1), t.store.release(), i && jCe(t), t.emit("created", t), t.isCreated = !0, t;
  }
  function Ybe(t) {
    return {
      __FKP: !0,
      uid: Symbol(),
      name: (t == null ? void 0 : t.name) ?? `p_${bO++}`,
      value: (t == null ? void 0 : t.value) ?? null,
      _value: (t == null ? void 0 : t.value) ?? null,
      type: (t == null ? void 0 : t.type) ?? "input",
      props: {},
      use: () => {
      },
      input(e) {
        return this._value = e, this.value = e, Promise.resolve();
      },
      isSettled: !0
    };
  }
  function hQ(t) {
    return "__FKP" in t;
  }
  function Nbe(t) {
    const e = t || {}, i = _be(e), r = new Proxy(i, {
      get(...n) {
        const [, s] = n;
        if (s === "__FKNode__")
          return !0;
        const o = i.traps.get(s);
        return o && o.get ? o.get(r, i) : Reflect.get(...n);
      },
      set(...n) {
        const [, s, o] = n, a = i.traps.get(s);
        return a && a.set ? a.set(r, i, s, o) : Reflect.set(...n);
      }
    });
    return kbe(r, e);
  }
  function _g(t) {
    return typeof t != "string" && gt(t, "$el");
  }
  function my(t) {
    return typeof t != "string" && gt(t, "$cmp");
  }
  function na(t) {
    return !t || typeof t == "string" ? !1 : gt(t, "if") && gt(t, "then");
  }
  function Ube(t) {
    return typeof t != "string" && "$formkit" in t;
  }
  function Lbe(t) {
    if (typeof t == "string")
      return {
        $el: "text",
        children: t
      };
    if (Ube(t)) {
      const {
        $formkit: e,
        for: i,
        if: r,
        children: n,
        bind: s,
        ...o
      } = t;
      return Object.assign(
        {
          $cmp: "FormKit",
          props: { ...o, type: e }
        },
        r ? { if: r } : {},
        i ? { for: i } : {},
        n ? { children: n } : {},
        s ? { bind: s } : {}
      );
    }
    return t;
  }
  function Qs(t) {
    let e;
    const i = /* @__PURE__ */ new Set(), r = function(p, m) {
      return typeof p == "function" ? p(m) : p;
    }, n = [
      {
        "&&": (f, p, m) => r(f, m) && r(p, m),
        "||": (f, p, m) => r(f, m) || r(p, m)
      },
      {
        "===": (f, p, m) => r(f, m) === r(p, m),
        "!==": (f, p, m) => r(f, m) !== r(p, m),
        "==": (f, p, m) => r(f, m) == r(p, m),
        "!=": (f, p, m) => r(f, m) != r(p, m),
        ">=": (f, p, m) => r(f, m) >= r(p, m),
        "<=": (f, p, m) => r(f, m) <= r(p, m),
        ">": (f, p, m) => r(f, m) > r(p, m),
        "<": (f, p, m) => r(f, m) < r(p, m)
      },
      {
        "+": (f, p, m) => r(f, m) + r(p, m),
        "-": (f, p, m) => r(f, m) - r(p, m)
      },
      {
        "*": (f, p, m) => r(f, m) * r(p, m),
        "/": (f, p, m) => r(f, m) / r(p, m),
        "%": (f, p, m) => r(f, m) % r(p, m)
      }
    ], s = n.reduce((f, p) => f.concat(Object.keys(p)), []), o = new Set(s.map((f) => f.charAt(0)));
    function a(f, p, m, E) {
      const y = f.filter((C) => C.startsWith(p));
      return y.length ? y.find((C) => E.length >= m + C.length && E.substring(m, m + C.length) === C ? C : !1) : !1;
    }
    function A(f, p, m = 1) {
      let E = m ? p.substring(f + 1).trim() : p.substring(0, f).trim();
      if (!E.length)
        return -1;
      if (!m) {
        const C = E.split("").reverse(), w = C.findIndex((M) => o.has(M));
        E = C.slice(w).join("");
      }
      const y = E[0];
      return n.findIndex((C) => {
        const w = Object.keys(C);
        return !!a(w, y, 0, E);
      });
    }
    function l(f, p) {
      let m = "";
      const E = p.length;
      let y = 0;
      for (let C = f; C < E; C++) {
        const w = p.charAt(C);
        if (w === "(")
          y++;
        else if (w === ")")
          y--;
        else if (y === 0 && w === " ")
          continue;
        if (y === 0 && a(s, w, C, p))
          return [m, C - 1];
        m += w;
      }
      return [m, p.length - 1];
    }
    function c(f, p = 0) {
      const m = n[p], E = f.length, y = Object.keys(m);
      let C = 0, w = !1, M = null, I = "", b = null, B, x = "", Q = "", v = "", T = "", S = 0;
      const D = (F, R) => {
        F ? v += R : I += R;
      };
      for (let F = 0; F < E; F++)
        if (x = Q, Q = f.charAt(F), (Q === "'" || Q === '"') && x !== "\\" && (C === 0 && !w || C && !T)) {
          C ? T = Q : w = Q, D(C, Q);
          continue;
        } else if (w && (Q !== w || x === "\\") || T && (Q !== T || x === "\\")) {
          D(C, Q);
          continue;
        } else if (w === Q) {
          w = !1, D(C, Q);
          continue;
        } else if (T === Q) {
          T = !1, D(C, Q);
          continue;
        } else {
          if (Q === " ")
            continue;
          if (Q === "(")
            C === 0 ? S = F : v += Q, C++;
          else if (Q === ")")
            if (C--, C === 0) {
              const R = typeof I == "string" && I.startsWith("$") ? I : void 0, Y = R && f.charAt(F + 1) === ".";
              let L = "";
              Y && ([L, F] = l(F + 2, f));
              const N = M ? p : A(S, f, 0), H = A(F, f);
              N === -1 && H === -1 ? (I = u(v, -1, R, L), typeof I == "string" && (I = v)) : M && (N >= H || H === -1) && p === N ? (b = M.bind(null, u(v, -1, R, L)), M = null, I = "") : H > N && p === H ? I = u(v, -1, R, L) : I += `(${v})${Y ? `.${L}` : ""}`, v = "";
            } else
              v += Q;
          else if (C === 0 && (B = a(y, Q, F, f))) {
            F === 0 && zn(103, [B, f]), F += B.length - 1, F === f.length - 1 && zn(104, [B, f]), M ? I && (b = M.bind(null, u(I, p)), M = m[B].bind(null, b), I = "") : b ? (M = m[B].bind(null, u(b, p)), b = null) : (M = m[B].bind(null, u(I, p)), I = "");
            continue;
          } else
            D(C, Q);
        }
      return I && M && (M = M.bind(null, u(I, p))), M = !M && b ? b : M, !M && I && (M = (F, R) => typeof F == "function" ? F(R) : F, M = M.bind(null, u(I, p))), !M && !I && zn(105, f), M;
    }
    function u(f, p, m, E) {
      if (m) {
        const y = u(m, n.length);
        let C, w = E ? Qs(`$${E}`) : !1;
        if (typeof y == "function") {
          const M = jne(String(f)).map(
            (I) => u(I, -1)
          );
          return (I) => {
            const b = y(I);
            return typeof b != "function" ? (gc(150, m), b) : (C = b(
              ...M.map(
                (B) => typeof B == "function" ? B(I) : B
              )
            ), w && (w = w.provide((B) => {
              const x = e(B);
              return B.reduce(
                (v, T) => {
                  if (T === E || (E == null ? void 0 : E.startsWith(`${T}(`))) {
                    const D = Hne(C, T);
                    v[T] = () => D;
                  } else
                    v[T] = x[T];
                  return v;
                },
                {}
              );
            })), w ? w() : C);
          };
        }
      } else if (typeof f == "string") {
        if (f === "true")
          return !0;
        if (f === "false")
          return !1;
        if (f === "undefined")
          return;
        if (One(f))
          return Gne(f.substring(1, f.length - 1));
        if (!isNaN(+f))
          return Number(f);
        if (p < n.length - 1)
          return c(f, p + 1);
        if (f.startsWith("$")) {
          const y = f.substring(1);
          return i.add(y), function(w) {
            return y in w ? w[y]() : void 0;
          };
        }
        return f;
      }
      return f;
    }
    const d = c(
      t.startsWith("$:") ? t.substring(2) : t
    ), h = Array.from(i);
    function g(f) {
      return e = f, Object.assign(
        // @ts-ignore - @rollup/plugin-typescript doesn't like this
        d.bind(null, f(h)),
        { provide: g }
      );
    }
    return Object.assign(d, {
      provide: g
    });
  }
  function $m(t, e, i) {
    return i ? typeof i == "string" ? i.split(" ").reduce(
      (n, s) => Object.assign(n, { [s]: !0 }),
      {}
    ) : typeof i == "function" ? $m(
      t,
      e,
      i(e, t)
    ) : i : {};
  }
  function zbe(t, e, ...i) {
    const r = i.reduce((n, s) => {
      if (!s)
        return DC(n);
      const { $reset: o, ...a } = s;
      return DC(o ? a : Object.assign(n, a));
    }, {});
    return Object.keys(
      t.hook.classes.dispatch({ property: e, classes: r }).classes
    ).filter((n) => r[n]).join(" ") || null;
  }
  function DC(t) {
    const e = "$remove:";
    let i = !1;
    const r = Object.keys(t).filter((n) => (t[n] && n.startsWith(e) && (i = !0), t[n]));
    return r.length > 1 && i && r.filter((s) => s.startsWith(e)).map((s) => {
      const o = s.substring(e.length);
      t[o] = !1, t[s] = !1;
    }), t;
  }
  function Pbe(t, e, i) {
    const r = Nf(t);
    r ? r.setErrors(e, i) : gc(651, t);
  }
  function Obe(t, e = !0) {
    const i = Nf(t);
    i ? i.clearErrors(e) : gc(652, t);
  }
  var Ey = "1.6.9", FO = /* @__PURE__ */ new WeakSet();
  function aw(t, e) {
    const i = e || Object.assign(/* @__PURE__ */ new Map(), { active: !1 }), r = /* @__PURE__ */ new Map(), n = function(c) {
      var u;
      i.active && (i.has(t) || i.set(t, /* @__PURE__ */ new Set()), (u = i.get(t)) == null || u.add(c));
    }, s = function(c) {
      return new Proxy(c, {
        get(...u) {
          return typeof u[1] == "string" && n(`prop:${u[1]}`), Reflect.get(...u);
        }
      });
    }, o = function(c) {
      return new Proxy(c, {
        get(...u) {
          return u[1] === "value" ? (d) => (n(`count:${d}`), c.value(d)) : Reflect.get(...u);
        }
      });
    }, a = function(c, u) {
      return Uf(c) ? aw(c, i) : (u === "value" && n("commit"), u === "_value" && n("input"), u === "props" ? s(c) : u === "ledger" ? o(c) : (u === "children" && (n("child"), n("childRemoved")), c));
    }, {
      proxy: A,
      revoke: l
    } = Proxy.revocable(t, {
      get(...c) {
        switch (c[1]) {
          case "_node":
            return t;
          case "deps":
            return i;
          case "watch":
            return (d, h, g) => TO(A, d, h, g);
          case "observe":
            return () => {
              const d = new Map(i);
              return i.clear(), i.active = !0, d;
            };
          case "stopObserve":
            return () => {
              const d = new Map(i);
              return i.active = !1, d;
            };
          case "receipts":
            return r;
          case "kill":
            return () => {
              DO(r), FO.add(c[2]), l();
            };
        }
        const u = Reflect.get(...c);
        return typeof u == "function" ? (...d) => {
          const h = u(...d);
          return a(h, c[1]);
        } : a(u, c[1]);
      }
    });
    return A;
  }
  function SO(t, [e, i], r, n) {
    e.forEach((s, o) => {
      s.forEach((a) => {
        t.receipts.has(o) || t.receipts.set(o, {});
        const A = t.receipts.get(o) ?? {};
        A[a] = A[a] ?? [], A[a].push(o.on(a, r, n)), t.receipts.set(o, A);
      });
    }), i.forEach((s, o) => {
      s.forEach((a) => {
        if (t.receipts.has(o)) {
          const A = t.receipts.get(o);
          A && gt(A, a) && (A[a].map(o.off), delete A[a], t.receipts.set(o, A));
        }
      });
    });
  }
  function DO(t) {
    t.forEach((e, i) => {
      for (const r in e)
        e[r].map(i.off);
    }), t.clear();
  }
  function TO(t, e, i, r) {
    const n = (a) => {
      const A = t.stopObserve();
      SO(
        t,
        RO(s, A),
        () => TO(t, e, i, r),
        r
      ), i && i(a);
    }, s = new Map(t.deps);
    t.observe();
    const o = e(t);
    o instanceof Promise ? o.then((a) => n(a)) : n(o);
  }
  function RO(t, e) {
    const i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
    return e.forEach((n, s) => {
      if (!t.has(s))
        i.set(s, n);
      else {
        const o = /* @__PURE__ */ new Set(), a = t.get(s);
        n.forEach(
          (A) => !(a != null && a.has(A)) && o.add(A)
        ), i.set(s, o);
      }
    }), t.forEach((n, s) => {
      if (!e.has(s))
        r.set(s, n);
      else {
        const o = /* @__PURE__ */ new Set(), a = e.get(s);
        n.forEach(
          (A) => !(a != null && a.has(A)) && o.add(A)
        ), r.set(s, o);
      }
    }), [i, r];
  }
  function gQ(t) {
    return FO.has(t);
  }
  var _O = function({ value: e }) {
    return ["yes", "on", "1", 1, !0, "true"].includes(e);
  };
  _O.skipEmpty = !1;
  var Gbe = _O, jbe = function({ value: t }, e = !1) {
    const i = Date.parse(e || /* @__PURE__ */ new Date()), r = Date.parse(String(t));
    return isNaN(r) ? !1 : r > i;
  }, Hbe = jbe, Jbe = function({ value: t }, e = !1) {
    const i = Date.parse(e || /* @__PURE__ */ new Date()), r = Date.parse(String(t));
    return isNaN(r) ? !1 : r > i || r === i;
  }, Vbe = Jbe, Wbe = function(t, e) {
    var n;
    if (!e)
      return !1;
    const i = Date.parse(String(t.value)), r = Date.parse(String((n = t.at(e)) == null ? void 0 : n.value));
    return isNaN(r) ? !0 : isNaN(i) ? !1 : i > r;
  }, Kbe = Wbe, Xbe = function({ value: t }, e = "default") {
    const i = {
      default: new RegExp("^\\p{L}+$", "u"),
      latin: /^[a-z]+$/i
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, Zbe = Xbe, qbe = function({ value: t }, e = "default") {
    const i = {
      default: /^[\p{L} ]+$/u,
      latin: /^[a-z ]+$/i
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, $be = qbe, eMe = function({ value: t }, e = "default") {
    const i = {
      default: /^[0-9\p{L}]+$/u,
      latin: /^[0-9a-z]+$/i
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, tMe = eMe, iMe = function({ value: t }, e = !1) {
    const i = Date.parse(e || /* @__PURE__ */ new Date()), r = Date.parse(String(t));
    return isNaN(r) ? !1 : r < i;
  }, rMe = iMe, nMe = function(t, e) {
    var n;
    if (!e)
      return !1;
    const i = Date.parse(String(t.value)), r = Date.parse(String((n = t.at(e)) == null ? void 0 : n.value));
    return isNaN(r) ? !0 : isNaN(i) ? !1 : i < r;
  }, sMe = nMe, oMe = function({ value: t }, e = !1) {
    const i = Date.parse(e || /* @__PURE__ */ new Date()), r = Date.parse(String(t));
    return isNaN(r) ? !1 : r < i || r === i;
  }, aMe = oMe, AMe = function({ value: e }, i, r) {
    if (!isNaN(e) && !isNaN(i) && !isNaN(r)) {
      const n = 1 * e;
      i = Number(i), r = Number(r);
      const [s, o] = i <= r ? [i, r] : [r, i];
      return n >= 1 * s && n <= 1 * o;
    }
    return !1;
  }, lMe = AMe, x2 = /(_confirm(?:ed)?)$/, cMe = function(e, i, r = "loose") {
    var s;
    i || (i = x2.test(e.name) ? e.name.replace(x2, "") : `${e.name}_confirm`);
    const n = (s = e.at(i)) == null ? void 0 : s.value;
    return r === "strict" ? e.value === n : e.value == n;
  }, uMe = cMe, dMe = function({ value: t }, e = "default") {
    const i = {
      default: new RegExp("\\p{L}", "u"),
      latin: /[a-z]/i
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, hMe = dMe, gMe = function({ value: t }, e = "default") {
    const i = {
      default: /[\p{L} ]/u,
      latin: /[a-z ]/i
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, fMe = gMe, pMe = function({ value: t }, e = "default") {
    const i = {
      default: /[0-9\p{L}]/u,
      latin: /[0-9a-z]/i
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, mMe = pMe, EMe = function({ value: t }, e = "default") {
    const i = {
      default: new RegExp("\\p{Ll}", "u"),
      latin: /[a-z]/
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, yMe = EMe, BMe = function({ value: e }) {
    return /[0-9]/.test(String(e));
  }, wMe = BMe, CMe = function({ value: t }) {
    return /[!-/:-@[-`{-~]/.test(String(t));
  }, bMe = CMe, MMe = function({ value: t }, e = "default") {
    const i = {
      default: new RegExp("\\p{Lu}", "u"),
      latin: /[A-Z]/
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, IMe = MMe, vMe = function({ value: e }, i, r) {
    i = i instanceof Date ? i.getTime() : Date.parse(i), r = r instanceof Date ? r.getTime() : Date.parse(r);
    const n = e instanceof Date ? e.getTime() : Date.parse(String(e));
    if (i && !r)
      r = i, i = Date.now();
    else if (!i || !n)
      return !1;
    return n >= i && n <= r;
  }, xMe = vMe, QMe = function({ value: e }, i) {
    return i && typeof i == "string" ? Pne(i).test(String(e)) : !isNaN(Date.parse(String(e)));
  }, FMe = QMe, SMe = function({ value: e }) {
    return /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i.test(String(e));
  }, DMe = SMe, TMe = function({ value: e }, ...i) {
    return typeof e == "string" && i.length ? i.some((r) => e.endsWith(r)) : typeof e == "string" && i.length === 0;
  }, RMe = TMe, _Me = function({ value: e }, ...i) {
    return i.some((r) => typeof r == "object" ? Lr(r, e) : r == e);
  }, kMe = _Me, YMe = function({ value: e }, i = 0, r = 1 / 0) {
    i = parseInt(i), r = isNaN(parseInt(r)) ? 1 / 0 : parseInt(r);
    const n = i <= r ? i : r, s = r >= i ? r : i;
    if (typeof e == "string" || Array.isArray(e))
      return e.length >= n && e.length <= s;
    if (e && typeof e == "object") {
      const o = Object.keys(e).length;
      return o >= n && o <= s;
    }
    return !1;
  }, NMe = YMe, UMe = function({ value: t }, e = "default") {
    const i = {
      default: new RegExp("^\\p{Ll}+$", "u"),
      allow_non_alpha: /^[0-9\p{Ll}!-/:-@[-`{-~]+$/u,
      allow_numeric: /^[0-9\p{Ll}]+$/u,
      allow_numeric_dashes: /^[0-9\p{Ll}-]+$/u,
      latin: /^[a-z]+$/
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, LMe = UMe, zMe = function({ value: e }, ...i) {
    return i.some((r) => (typeof r == "string" && r.substr(0, 1) === "/" && r.substr(-1) === "/" && (r = new RegExp(r.substr(1, r.length - 2))), r instanceof RegExp ? r.test(String(e)) : r === e));
  }, PMe = zMe, OMe = function({ value: e }, i = 10) {
    return Array.isArray(e) ? e.length <= i : Number(e) <= Number(i);
  }, GMe = OMe, jMe = function({ value: e }, i = 1) {
    return Array.isArray(e) ? e.length >= i : Number(e) >= Number(i);
  }, HMe = jMe, JMe = function({ value: e }, ...i) {
    return !i.some((r) => typeof r == "object" ? Lr(r, e) : r === e);
  }, VMe = JMe, WMe = function({ value: e }) {
    return !isNaN(e);
  }, KMe = WMe, kO = function(t, ...e) {
    return As(t.value) ? e.map((r) => {
      var n;
      return (n = t.at(r)) == null ? void 0 : n.value;
    }).some((r) => !As(r)) : !0;
  };
  kO.skipEmpty = !1;
  var XMe = kO, YO = function({ value: e }, i = "default") {
    return i === "trim" && typeof e == "string" ? !As(e.trim()) : !As(e);
  };
  YO.skipEmpty = !1;
  var ZMe = YO, qMe = function({ value: e }, ...i) {
    return typeof e == "string" && i.length ? i.some((r) => e.startsWith(r)) : typeof e == "string" && i.length === 0;
  }, $Me = qMe, eIe = function({ value: t }) {
    return /^[!-/:-@[-`{-~]+$/.test(String(t));
  }, tIe = eIe, iIe = function({ value: t }, e = "default") {
    const i = {
      default: new RegExp("^\\p{Lu}+$", "u"),
      latin: /^[A-Z]+$/
    }, r = gt(i, e) ? e : "default";
    return i[r].test(String(t));
  }, rIe = iIe, nIe = function({ value: e }, ...i) {
    try {
      const r = i.length ? i : ["http:", "https:"], n = new URL(String(e));
      return r.includes(n.protocol);
    } catch {
      return !1;
    }
  }, sIe = nIe;
  const oIe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    accepted: Gbe,
    alpha: Zbe,
    alpha_spaces: $be,
    alphanumeric: tMe,
    between: lMe,
    confirm: uMe,
    contains_alpha: hMe,
    contains_alpha_spaces: fMe,
    contains_alphanumeric: mMe,
    contains_lowercase: yMe,
    contains_numeric: wMe,
    contains_symbol: bMe,
    contains_uppercase: IMe,
    date_after: Hbe,
    date_after_node: Kbe,
    date_after_or_equal: Vbe,
    date_before: rMe,
    date_before_node: sMe,
    date_before_or_equal: aMe,
    date_between: xMe,
    date_format: FMe,
    email: DMe,
    ends_with: RMe,
    is: kMe,
    length: NMe,
    lowercase: LMe,
    matches: PMe,
    max: GMe,
    min: HMe,
    not: VMe,
    number: KMe,
    require_one: XMe,
    required: ZMe,
    starts_with: $Me,
    symbol: tIe,
    uppercase: rIe,
    url: sIe
  }, Symbol.toStringTag, { value: "Module" }));
  var zM = /* @__PURE__ */ nn({
    type: "state",
    blocking: !0,
    visible: !1,
    value: !0,
    key: "validating"
  });
  function aIe(t = {}) {
    return function(i) {
      let r = Us(i.props.validationRules || {}), n = { ...t, ...r };
      const s = { input: Ld(), rerun: null, isPassing: !0 };
      let o = Us(i.props.validation);
      i.on("prop:validation", ({ payload: A }) => a(A, r)), i.on(
        "prop:validationRules",
        ({ payload: A }) => a(o, A)
      );
      function a(A, l) {
        var c;
        Lr(Object.keys(r || {}), Object.keys(l || {})) && Lr(o, A) || (r = Us(l), o = Us(A), n = { ...t, ...r }, (c = i.props.parsedRules) == null || c.forEach((u) => {
          NO(u), DO(u.observer.receipts), u.observer.kill();
        }), i.store.filter(() => !1, "validation"), i.props.parsedRules = F2(A, n, i), s.isPassing = !0, PM(i, i.props.parsedRules, s));
      }
      i.props.parsedRules = F2(o, n, i), PM(i, i.props.parsedRules, s);
    };
  }
  function PM(t, e, i) {
    gQ(t) || (i.input = Ld(), t.store.set(
      /* @__PURE__ */ nn({
        key: "failing",
        value: !i.isPassing,
        visible: !1
      })
    ), i.isPassing = !0, t.store.filter((r) => !r.meta.removeImmediately, "validation"), e.forEach(
      (r) => r.debounce && clearTimeout(r.timer)
    ), e.length && (t.store.set(zM), OM(0, e, i, !1, () => {
      t.store.remove(zM.key), t.store.set(
        /* @__PURE__ */ nn({
          key: "failing",
          value: !i.isPassing,
          visible: !1
        })
      );
    })));
  }
  function OM(t, e, i, r, n) {
    const s = e[t];
    if (!s)
      return n();
    const o = s.observer;
    if (gQ(o))
      return;
    const a = i.input;
    s.state = null;
    function A(l, c) {
      if (i.input !== a)
        return;
      i.isPassing = i.isPassing && !!c, s.queued = !1;
      const u = o.stopObserve(), d = RO(s.deps, u);
      if (SO(
        o,
        d,
        function() {
          try {
            o.store.set(zM);
          } catch {
          }
          s.queued = !0, i.rerun && clearTimeout(i.rerun), i.rerun = setTimeout(
            PM,
            0,
            o,
            e,
            i
          );
        },
        "unshift"
        // We want these listeners to run before other events are emitted so the 'state.validating' will be reliable.
      ), s.deps = u, s.state = c, c === !1 ? lIe(s, r || l) : NO(s), e.length > t + 1) {
        const h = e[t + 1];
        (c || h.force || !h.skipEmpty) && h.state === null && (h.queued = !0), OM(t + 1, e, i, r || l, n);
      } else
        n();
    }
    (!As(o.value) || !s.skipEmpty) && (i.isPassing || s.force) ? s.queued ? AIe(s, o, (l) => {
      l instanceof Promise ? l.then((c) => A(!0, c)) : A(!1, l);
    }) : OM(t + 1, e, i, r, n) : As(o.value) && s.skipEmpty && i.isPassing ? (o.observe(), o.value, A(!1, i.isPassing)) : A(!1, null);
  }
  function AIe(t, e, i) {
    t.debounce ? t.timer = setTimeout(() => {
      e.observe(), i(t.rule(e, ...t.args));
    }, t.debounce) : (e.observe(), i(t.rule(e, ...t.args)));
  }
  function NO(t) {
    const e = `rule_${t.name}`;
    t.messageObserver && (t.messageObserver = t.messageObserver.kill()), gt(t.observer.store, e) && t.observer.store.remove(e);
  }
  function lIe(t, e) {
    const i = t.observer;
    gQ(i) || (t.messageObserver || (t.messageObserver = aw(i._node)), t.messageObserver.watch(
      (r) => uIe(
        r,
        t
      ),
      (r) => {
        const n = cIe(i, t, r), s = /* @__PURE__ */ nn({
          blocking: t.blocking,
          key: `rule_${t.name}`,
          meta: {
            /**
             * Use this key instead of the message root key to produce i18n validation
             * messages.
             */
            messageKey: t.name,
            /**
             * For messages that were created *by or after* a debounced or async
             * validation rule — we make note of it so we can immediately remove them
             * as soon as the next commit happens.
             */
            removeImmediately: e,
            /**
             * Determines if this message should be passed to localization.
             */
            localize: !n,
            /**
             * The arguments that will be passed to the validation rules
             */
            i18nArgs: r
          },
          type: "validation",
          value: n || "This field is not valid."
        });
        i.store.set(s);
      }
    ));
  }
  function cIe(t, e, i) {
    const r = t.props.validationMessages && gt(t.props.validationMessages, e.name) ? t.props.validationMessages[e.name] : void 0;
    return typeof r == "function" ? r(...i) : r;
  }
  function uIe(t, e) {
    return [
      {
        node: t,
        name: fQ(t),
        args: e.args
      }
    ];
  }
  function fQ(t) {
    return typeof t.props.validationLabel == "function" ? t.props.validationLabel(t) : t.props.validationLabel || t.props.label || t.props.name || String(t.name);
  }
  var UO = "(?:[\\*+?()0-9]+)", LO = "[a-zA-Z][a-zA-Z0-9_]+", dIe = new RegExp(
    `^(${UO}?${LO})(?:\\:(.*)+)?$`,
    "i"
  ), hIe = new RegExp(`^(${UO})(${LO})$`, "i"), gIe = /([\*+?]+)?(\(\d+\))([\*+?]+)?/, Q2 = /\(\d+\)/, fIe = {
    blocking: !0,
    debounce: 0,
    force: !1,
    skipEmpty: !0,
    name: ""
  };
  function F2(t, e, i) {
    return t ? (typeof t == "string" ? pIe(t) : cd(t)).reduce((n, s) => {
      let o = s.shift();
      const a = {};
      if (typeof o == "string") {
        const [A, l] = EIe(o);
        gt(e, A) && (o = e[A], Object.assign(a, l));
      }
      return typeof o == "function" && n.push({
        observer: aw(i),
        rule: o,
        args: s,
        timer: 0,
        state: null,
        queued: !0,
        deps: /* @__PURE__ */ new Map(),
        ...fIe,
        ...yIe(a, o)
      }), n;
    }, []) : [];
  }
  function pIe(t) {
    return t.split("|").reduce((e, i) => {
      const r = mIe(i);
      return r && e.push(r), e;
    }, []);
  }
  function mIe(t) {
    const e = t.trim();
    if (e) {
      const i = e.match(dIe);
      if (i && typeof i[1] == "string") {
        const r = i[1].trim(), n = i[2] && typeof i[2] == "string" ? i[2].split(",").map((s) => s.trim()) : [];
        return [r, ...n];
      }
    }
    return !1;
  }
  function EIe(t) {
    const e = t.match(hIe);
    if (!e)
      return [t, { name: t }];
    const i = {
      "*": { force: !0 },
      "+": { skipEmpty: !1 },
      "?": { blocking: !1 }
    }, [, r, n] = e, s = Q2.test(r) ? r.match(gIe) || [] : [, r];
    return [
      n,
      [s[1], s[2], s[3]].reduce(
        (o, a) => (a && (Q2.test(a) ? o.debounce = parseInt(a.substr(1, a.length - 1)) : a.split("").forEach(
          (A) => gt(i, A) && Object.assign(o, i[A])
        )), o),
        { name: n }
      )
    ];
  }
  function yIe(t, e) {
    return t.name || (t.name = e.ruleName || e.name), ["skipEmpty", "force", "debounce", "blocking"].reduce(
      (i, r) => (gt(e, r) && !gt(i, r) && Object.assign(i, {
        [r]: e[r]
      }), i),
      t
    );
  }
  function ke(t) {
    return t[0].toUpperCase() + t.substr(1);
  }
  function yy(t, e = "or") {
    return t.reduce((i, r, n) => (i += r, n <= t.length - 2 && t.length > 2 && (i += ", "), n === t.length - 2 && (i += `${t.length === 2 ? " " : ""}${e} `), i), "");
  }
  function EA(t) {
    const e = typeof t == "string" ? new Date(Date.parse(t)) : t;
    return e instanceof Date ? new Intl.DateTimeFormat(void 0, {
      dateStyle: "medium",
      timeZone: "UTC"
    }).format(e) : "(unknown)";
  }
  function BIe(t, e) {
    return Number(t) >= Number(e) ? [e, t] : [t, e];
  }
  var wIe = {
    /**
     * Shown on buttons for adding new items.
     */
    add: "Hinzufügen",
    /**
     * Shown when a button to remove items is visible.
     */
    remove: "Entfernen",
    /**
     * Shown when there are multiple items to remove at the same time.
     */
    removeAll: "Alles entfernen",
    /**
     * Shown when all fields are not filled out correctly.
     */
    incomplete: "Entschuldigung, nicht alle Felder wurden korrekt ausgefüllt.",
    /**
     * Shown in a button inside a form to submit the form.
     */
    submit: "Senden",
    /**
     * Shown when no files are selected.
     */
    noFiles: "Keine Datei ausgewählt",
    /**
     * Shown on buttons that move fields up in a list.
     */
    moveUp: "Gehe nach oben",
    /**
     * Shown on buttons that move fields down in a list.
     */
    moveDown: "Gehen Sie nach unten",
    /**
     * Shown when something is actively loading.
     */
    isLoading: "Wird geladen...",
    /**
     * Shown when there is more to load.
     */
    loadMore: "Mehr laden",
    /**
     * Shown on buttons that navigate state forward
     */
    next: "Weiter",
    /**
     * Shown on buttons that navigate state backward
     */
    prev: "Zurück",
    /**
     * Shown when adding all values.
     */
    addAllValues: "Alle Werte hinzufügen",
    /**
     * Shown when adding selected values.
     */
    addSelectedValues: "Ausgewählte Werte hinzufügen",
    /**
     * Shown when removing all values.
     */
    removeAllValues: "Alle Werte entfernen",
    /**
     * Shown when removing selected values.
     */
    removeSelectedValues: "Ausgewählte Werte entfernen",
    /**
     * Shown when there is a date to choose.
     */
    chooseDate: "Datum wählen",
    /**
     * Shown when there is a date to change.
     */
    changeDate: "Datum ändern",
    /**
     * Shown when there is something to close
     */
    close: "Schliessen",
    /**
     * Shown when there is something to open.
     */
    open: "Offen"
  }, CIe = {
    /**
     * The value is not an accepted value.
     * @see {@link https://formkit.com/essentials/validation#accepted}
     */
    accepted({ name: t }) {
      return `Bitte ${t} akzeptieren.`;
    },
    /**
     * The date is not after
     * @see {@link https://formkit.com/essentials/validation#date-after}
     */
    date_after({ name: t, args: e }) {
      return Array.isArray(e) && e.length ? `${ke(t)} muss nach dem ${EA(e[0])} liegen.` : `${ke(t)} muss in der Zukunft liegen.`;
    },
    /**
     * The value is not a letter.
     * @see {@link https://formkit.com/essentials/validation#alpha}
     */
    alpha({ name: t }) {
      return `${ke(t)} darf nur Buchstaben enthalten.`;
    },
    /**
     * The value is not alphanumeric
     * @see {@link https://formkit.com/essentials/validation#alphanumeric}
     */
    alphanumeric({ name: t }) {
      return `${ke(t)} darf nur Buchstaben und Zahlen enthalten.`;
    },
    /**
     * The value is not letter and/or spaces
     * @see {@link https://formkit.com/essentials/validation#alpha-spaces}
     */
    alpha_spaces({ name: t }) {
      return `${ke(t)} dürfen nur Buchstaben und Leerzeichen enthalten.`;
    },
    /**
     * The value have no letter.
     * @see {@link https://formkit.com/essentials/validation#contains_alpha}
     */
    contains_alpha({ name: t }) {
      return `${ke(t)} muss alphabetische Zeichen enthalten.`;
    },
    /**
     * The value have no alphanumeric
     * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}
     */
    contains_alphanumeric({ name: t }) {
      return `${ke(t)} muss Buchstaben oder Zahlen enthalten.`;
    },
    /**
     * The value have no letter and/or spaces
     * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}
     */
    contains_alpha_spaces({ name: t }) {
      return `${ke(t)} muss Buchstaben oder Leerzeichen enthalten.`;
    },
    /**
     * The value have no symbol
     * @see {@link https://formkit.com/essentials/validation#contains_symbol}
     */
    contains_symbol({ name: t }) {
      return `${ke(t)} muss ein Symbol enthalten.`;
    },
    /**
     * The value have no uppercase
     * @see {@link https://formkit.com/essentials/validation#contains_uppercase}
     */
    contains_uppercase({ name: t }) {
      return `${ke(t)} muss Großbuchstaben enthalten.`;
    },
    /**
     * The value have no lowercase
     * @see {@link https://formkit.com/essentials/validation#contains_lowercase}
     */
    contains_lowercase({ name: t }) {
      return `${ke(t)} muss Kleinbuchstaben enthalten.`;
    },
    /**
     *  The value have no numeric
     * @see {@link https://formkit.com/essentials/validation#contains_numeric}
     */
    contains_numeric({ name: t }) {
      return `${ke(t)} muss Zahlen enthalten.`;
    },
    /**
     * The value is not symbol
     * @see {@link https://formkit.com/essentials/validation#symbol}
     */
    symbol({ name: t }) {
      return `${ke(t)} muss ein Symbol sein.`;
    },
    /**
     * The value is not uppercase
     * @see {@link https://formkit.com/essentials/validation#uppercase}
     */
    uppercase({ name: t }) {
      return `${ke(t)} kann nur Großbuchstaben enthalten.`;
    },
    /**
     * The value is not lowercase
     * @see {@link https://formkit.com/essentials/validation#lowercase}
     */
    lowercase({ name: t }) {
      return `${ke(t)} kann nur Kleinbuchstaben enthalten.`;
    },
    /**
     * The date is not before
     * @see {@link https://formkit.com/essentials/validation#date-before}
     */
    date_before({ name: t, args: e }) {
      return Array.isArray(e) && e.length ? `${ke(t)} muss vor dem ${EA(e[0])} liegen.` : `${ke(t)} muss in der Vergangenheit liegen.`;
    },
    /**
     * The value is not between two numbers
     * @see {@link https://formkit.com/essentials/validation#between}
     */
    between({ name: t, args: e }) {
      return isNaN(e[0]) || isNaN(e[1]) ? "Dieses Feld wurde falsch konfiguriert und kann nicht übermittelt werden." : `${ke(t)} muss zwischen ${e[0]} und ${e[1]} sein.`;
    },
    /**
     * The confirmation field does not match
     * @see {@link https://formkit.com/essentials/validation#confirm}
     */
    confirm({ name: t }) {
      return `${ke(t)} stimmt nicht überein.`;
    },
    /**
     * The value is not a valid date
     * @see {@link https://formkit.com/essentials/validation#date-format}
     */
    date_format({ name: t, args: e }) {
      return Array.isArray(e) && e.length ? `${ke(t)} ist kein gültiges Datum im Format ${e[0]}.` : "Dieses Feld wurde falsch konfiguriert und kann nicht übermittelt werden.";
    },
    /**
     * Is not within expected date range
     * @see {@link https://formkit.com/essentials/validation#date-between}
     */
    date_between({ name: t, args: e }) {
      return `${ke(t)} muss zwischen ${EA(e[0])} und ${EA(
        e[1]
      )} liegen.`;
    },
    /**
     * Shown when the user-provided value is not a valid email address.
     * @see {@link https://formkit.com/essentials/validation#email}
     */
    email: "E-Mail Adresse ist ungültig.",
    /**
     * Does not end with the specified value
     * @see {@link https://formkit.com/essentials/validation#ends-with}
     */
    ends_with({ name: t, args: e }) {
      return `${ke(t)} endet nicht mit ${yy(e)}.`;
    },
    /**
     * Is not an allowed value
     * @see {@link https://formkit.com/essentials/validation#is}
     */
    is({ name: t }) {
      return `${ke(t)} enthält einen ungültigen Wert.`;
    },
    /**
     * Does not match specified length
     * @see {@link https://formkit.com/essentials/validation#length}
     */
    length({ name: t, args: [e = 0, i = 1 / 0] }) {
      const r = e <= i ? e : i, n = i >= e ? i : e;
      return r == 1 && n === 1 / 0 ? `${ke(t)} muss mindestens ein Zeichen enthalten.` : r == 0 && n ? `${ke(t)} darf maximal ${n} Zeichen enthalten.` : r === n ? `${ke(t)} sollte ${n} Zeichen lang sein.` : r && n === 1 / 0 ? `${ke(t)} muss mindestens ${r} Zeichen enthalten.` : `${ke(t)} muss zwischen ${r} und ${n} Zeichen enthalten.`;
    },
    /**
     * Value is not a match
     * @see {@link https://formkit.com/essentials/validation#matches}
     */
    matches({ name: t }) {
      return `${ke(t)} enthält einen ungültigen Wert.`;
    },
    /**
     * Exceeds maximum allowed value
     * @see {@link https://formkit.com/essentials/validation#max}
     */
    max({ name: t, node: { value: e }, args: i }) {
      return Array.isArray(e) ? `Darf maximal ${i[0]} ${t} haben.` : `${ke(t)} darf maximal ${i[0]} sein.`;
    },
    /**
     * The (field-level) value does not match specified mime type
     * @see {@link https://formkit.com/essentials/validation#mime}
     */
    mime({ name: t, args: e }) {
      return e[0] ? `${ke(t)} muss vom Typ ${e[0]} sein.` : "Keine Dateiformate konfiguriert.";
    },
    /**
     * Does not fulfill minimum allowed value
     * @see {@link https://formkit.com/essentials/validation#min}
     */
    min({ name: t, node: { value: e }, args: i }) {
      return Array.isArray(e) ? `Mindestens ${i[0]} ${t} erforderlich.` : `${ke(t)} muss mindestens ${i[0]} sein.`;
    },
    /**
     * Is not an allowed value
     * @see {@link https://formkit.com/essentials/validation#not}
     */
    not({ name: t, node: { value: e } }) {
      return `“${e}” ist kein gültiger Wert für ${t}.`;
    },
    /**
     *  Is not a number
     * @see {@link https://formkit.com/essentials/validation#number}
     */
    number({ name: t }) {
      return `${ke(t)} muss eine Zahl sein.`;
    },
    /**
     * Require one field.
     * @see {@link https://formkit.com/essentials/validation#require-one}
     */
    require_one: ({ name: t, node: e, args: i }) => {
      const r = i.map((n) => {
        const s = e.at(n);
        return s ? fQ(s) : !1;
      }).filter((n) => !!n);
      return r.unshift(t), `${r.join(" oder ")} ist erforderlich.`;
    },
    /**
     * Required field.
     * @see {@link https://formkit.com/essentials/validation#required}
     */
    required({ name: t }) {
      return `${ke(t)} ist erforderlich.`;
    },
    /**
     * Does not start with specified value
     * @see {@link https://formkit.com/essentials/validation#starts-with}
     */
    starts_with({ name: t, args: e }) {
      return `${ke(t)} beginnt nicht mit ${yy(e)}.`;
    },
    /**
     * Is not a url
     * @see {@link https://formkit.com/essentials/validation#url}
     */
    url() {
      return "Bitte geben Sie eine gültige URL ein.";
    },
    /**
     * Shown when the date is invalid.
     */
    invalidDate: "Das gewählte Datum ist ungültig."
  }, bIe = { ui: wIe, validation: CIe }, MIe = {
    /**
     * Shown on a button for adding additional items.
     */
    add: "Add",
    /**
     * Shown when a button to remove items is visible.
     */
    remove: "Remove",
    /**
     * Shown when there are multiple items to remove at the same time.
     */
    removeAll: "Remove all",
    /**
     * Shown when all fields are not filled out correctly.
     */
    incomplete: "Sorry, not all fields are filled out correctly.",
    /**
     * Shown in a button inside a form to submit the form.
     */
    submit: "Submit",
    /**
     * Shown when no files are selected.
     */
    noFiles: "No file chosen",
    /**
     * Shown on buttons that move fields up in a list.
     */
    moveUp: "Move up",
    /**
     * Shown on buttons that move fields down in a list.
     */
    moveDown: "Move down",
    /**
     * Shown when something is actively loading.
     */
    isLoading: "Loading...",
    /**
     * Shown when there is more to load.
     */
    loadMore: "Load more",
    /**
     * Show on buttons that navigate state forward
     */
    next: "Next",
    /**
     * Show on buttons that navigate state backward
     */
    prev: "Previous",
    /**
     * Shown when adding all values.
     */
    addAllValues: "Add all values",
    /**
     * Shown when adding selected values.
     */
    addSelectedValues: "Add selected values",
    /**
     * Shown when removing all values.
     */
    removeAllValues: "Remove all values",
    /**
     * Shown when removing selected values.
     */
    removeSelectedValues: "Remove selected values",
    /**
     * Shown when there is a date to choose.
     */
    chooseDate: "Choose date",
    /**
     * Shown when there is a date to change.
     */
    changeDate: "Change date",
    /**
     * Shown above error summaries when someone attempts to submit a form with
     * errors and the developer has implemented `<FormKitSummary />`.
     */
    summaryHeader: "There were errors in your form.",
    /*
     * Shown when there is something to close
     */
    close: "Close",
    /**
     * Shown when there is something to open.
     */
    open: "Open"
  }, IIe = {
    /**
     * The value is not an accepted value.
     * @see {@link https://formkit.com/essentials/validation#accepted}
     */
    accepted({ name: t }) {
      return `Please accept the ${t}.`;
    },
    /**
     * The date is not after
     * @see {@link https://formkit.com/essentials/validation#date-after}
     */
    date_after({ name: t, args: e }) {
      return Array.isArray(e) && e.length ? `${ke(t)} must be after ${EA(e[0])}.` : `${ke(t)} must be in the future.`;
    },
    /**
     * The value is not a letter.
     * @see {@link https://formkit.com/essentials/validation#alpha}
     */
    alpha({ name: t }) {
      return `${ke(t)} can only contain alphabetical characters.`;
    },
    /**
     * The value is not alphanumeric
     * @see {@link https://formkit.com/essentials/validation#alphanumeric}
     */
    alphanumeric({ name: t }) {
      return `${ke(t)} can only contain letters and numbers.`;
    },
    /**
     * The value is not letter and/or spaces
     * @see {@link https://formkit.com/essentials/validation#alpha-spaces}
     */
    alpha_spaces({ name: t }) {
      return `${ke(t)} can only contain letters and spaces.`;
    },
    /**
     * The value have no letter.
     * @see {@link https://formkit.com/essentials/validation#contains_alpha}
     */
    contains_alpha({ name: t }) {
      return `${ke(t)} must contain alphabetical characters.`;
    },
    /**
     * The value have no alphanumeric
     * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}
     */
    contains_alphanumeric({ name: t }) {
      return `${ke(t)} must contain letters or numbers.`;
    },
    /**
     * The value have no letter and/or spaces
     * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}
     */
    contains_alpha_spaces({ name: t }) {
      return `${ke(t)} must contain letters or spaces.`;
    },
    /**
     * The value have no symbol
     * @see {@link https://formkit.com/essentials/validation#contains_symbol}
     */
    contains_symbol({ name: t }) {
      return `${ke(t)} must contain a symbol.`;
    },
    /**
     * The value have no uppercase
     * @see {@link https://formkit.com/essentials/validation#contains_uppercase}
     */
    contains_uppercase({ name: t }) {
      return `${ke(t)} must contain an uppercase letter.`;
    },
    /**
     * The value have no lowercase
     * @see {@link https://formkit.com/essentials/validation#contains_lowercase}
     */
    contains_lowercase({ name: t }) {
      return `${ke(t)} must contain a lowercase letter.`;
    },
    /**
     *  The value have no numeric
     * @see {@link https://formkit.com/essentials/validation#contains_numeric}
     */
    contains_numeric({ name: t }) {
      return `${ke(t)} must contain numbers.`;
    },
    /**
     * The value is not symbol
     * @see {@link https://formkit.com/essentials/validation#symbol}
     */
    symbol({ name: t }) {
      return `${ke(t)} must be a symbol.`;
    },
    /**
     * The value is not uppercase
     * @see {@link https://formkit.com/essentials/validation#uppercase}
     */
    uppercase({ name: t }) {
      return `${ke(t)} can only contain uppercase letters.`;
    },
    /**
     * The value is not lowercase
     * @see {@link https://formkit.com/essentials/validation#lowercase}
     */
    lowercase({ name: t, args: e }) {
      let i = "";
      return Array.isArray(e) && e.length && (e[0] === "allow_non_alpha" && (i = ", numbers and symbols"), e[0] === "allow_numeric" && (i = " and numbers"), e[0] === "allow_numeric_dashes" && (i = ", numbers and dashes")), `${ke(t)} can only contain lowercase letters${i}.`;
    },
    /**
     * The date is not before
     * @see {@link https://formkit.com/essentials/validation#date-before}
     */
    date_before({ name: t, args: e }) {
      return Array.isArray(e) && e.length ? `${ke(t)} must be before ${EA(e[0])}.` : `${ke(t)} must be in the past.`;
    },
    /**
     * The value is not between two numbers
     * @see {@link https://formkit.com/essentials/validation#between}
     */
    between({ name: t, args: e }) {
      if (isNaN(e[0]) || isNaN(e[1]))
        return "This field was configured incorrectly and can’t be submitted.";
      const [i, r] = BIe(e[0], e[1]);
      return `${ke(t)} must be between ${i} and ${r}.`;
    },
    /**
     * The confirmation field does not match
     * @see {@link https://formkit.com/essentials/validation#confirm}
     */
    confirm({ name: t }) {
      return `${ke(t)} does not match.`;
    },
    /**
     * The value is not a valid date
     * @see {@link https://formkit.com/essentials/validation#date-format}
     */
    date_format({ name: t, args: e }) {
      return Array.isArray(e) && e.length ? `${ke(t)} is not a valid date, please use the format ${e[0]}` : "This field was configured incorrectly and can’t be submitted";
    },
    /**
     * Is not within expected date range
     * @see {@link https://formkit.com/essentials/validation#date-between}
     */
    date_between({ name: t, args: e }) {
      return `${ke(t)} must be between ${EA(e[0])} and ${EA(e[1])}`;
    },
    /**
     * Shown when the user-provided value is not a valid email address.
     * @see {@link https://formkit.com/essentials/validation#email}
     */
    email: "Please enter a valid email address.",
    /**
     * Does not end with the specified value
     * @see {@link https://formkit.com/essentials/validation#ends-with}
     */
    ends_with({ name: t, args: e }) {
      return `${ke(t)} doesn’t end with ${yy(e)}.`;
    },
    /**
     * Is not an allowed value
     * @see {@link https://formkit.com/essentials/validation#is}
     */
    is({ name: t }) {
      return `${ke(t)} is not an allowed value.`;
    },
    /**
     * Does not match specified length
     * @see {@link https://formkit.com/essentials/validation#length}
     */
    length({ name: t, args: [e = 0, i = 1 / 0] }) {
      const r = Number(e) <= Number(i) ? e : i, n = Number(i) >= Number(e) ? i : e;
      return r == 1 && n === 1 / 0 ? `${ke(t)} must be at least one character.` : r == 0 && n ? `${ke(t)} must be less than or equal to ${n} characters.` : r === n ? `${ke(t)} should be ${n} characters long.` : r && n === 1 / 0 ? `${ke(t)} must be greater than or equal to ${r} characters.` : `${ke(t)} must be between ${r} and ${n} characters.`;
    },
    /**
     * Value is not a match
     * @see {@link https://formkit.com/essentials/validation#matches}
     */
    matches({ name: t }) {
      return `${ke(t)} is not an allowed value.`;
    },
    /**
     * Exceeds maximum allowed value
     * @see {@link https://formkit.com/essentials/validation#max}
     */
    max({ name: t, node: { value: e }, args: i }) {
      return Array.isArray(e) ? `Cannot have more than ${i[0]} ${t}.` : `${ke(t)} must be no more than ${i[0]}.`;
    },
    /**
     * The (field-level) value does not match specified mime type
     * @see {@link https://formkit.com/essentials/validation#mime}
     */
    mime({ name: t, args: e }) {
      return e[0] ? `${ke(t)} must be of the type: ${e[0]}` : "No file formats allowed.";
    },
    /**
     * Does not fulfill minimum allowed value
     * @see {@link https://formkit.com/essentials/validation#min}
     */
    min({ name: t, node: { value: e }, args: i }) {
      return Array.isArray(e) ? `Cannot have fewer than ${i[0]} ${t}.` : `${ke(t)} must be at least ${i[0]}.`;
    },
    /**
     * Is not an allowed value
     * @see {@link https://formkit.com/essentials/validation#not}
     */
    not({ name: t, node: { value: e } }) {
      return `“${e}” is not an allowed ${t}.`;
    },
    /**
     *  Is not a number
     * @see {@link https://formkit.com/essentials/validation#number}
     */
    number({ name: t }) {
      return `${ke(t)} must be a number.`;
    },
    /**
     * Require one field.
     * @see {@link https://formkit.com/essentials/validation#require-one}
     */
    require_one: ({ name: t, node: e, args: i }) => {
      const r = i.map((n) => {
        const s = e.at(n);
        return s ? fQ(s) : !1;
      }).filter((n) => !!n);
      return r.unshift(t), `${r.join(" or ")} is required.`;
    },
    /**
     * Required field.
     * @see {@link https://formkit.com/essentials/validation#required}
     */
    required({ name: t }) {
      return `${ke(t)} is required.`;
    },
    /**
     * Does not start with specified value
     * @see {@link https://formkit.com/essentials/validation#starts-with}
     */
    starts_with({ name: t, args: e }) {
      return `${ke(t)} doesn’t start with ${yy(e)}.`;
    },
    /**
     * Is not a url
     * @see {@link https://formkit.com/essentials/validation#url}
     */
    url() {
      return "Please enter a valid URL.";
    },
    /**
     * Shown when the date is invalid.
     */
    invalidDate: "The selected date is invalid."
  }, vIe = { ui: MIe, validation: IIe }, S2 = /* @__PURE__ */ new Set();
  function xIe(t) {
    return function(i) {
      S2.add(i), i.on("destroying", () => S2.delete(i));
      let r = D2(i.config.locale, t), n = r ? t[r] : {};
      i.on("prop:locale", ({ payload: s }) => {
        r = D2(s, t), n = r ? t[r] : {}, i.store.touch();
      }), i.on("prop:label", () => i.store.touch()), i.on("prop:validationLabel", () => i.store.touch()), i.hook.text((s, o) => {
        var A, l;
        const a = ((A = s.meta) == null ? void 0 : A.messageKey) || s.key;
        if (gt(n, s.type) && gt(n[s.type], a)) {
          const c = n[s.type][a];
          typeof c == "function" ? s.value = Array.isArray((l = s.meta) == null ? void 0 : l.i18nArgs) ? c(...s.meta.i18nArgs) : c(s) : s.value = c;
        }
        return o(s);
      });
    };
  }
  function D2(t, e) {
    if (gt(e, t))
      return t;
    const [i] = t.split("-");
    if (gt(e, i))
      return i;
    for (const r in e)
      return r;
    return !1;
  }
  function QIe(...t) {
    const e = t.reduce(
      (r, n) => TA(r, n),
      {}
    ), i = () => {
    };
    return i.library = function(r) {
      const n = Ru(r.props.type);
      gt(e, n) && r.define(e[n]);
    }, i;
  }
  var FIe = [
    "classes",
    "config",
    "delay",
    "errors",
    "id",
    "index",
    "inputErrors",
    "library",
    "modelValue",
    "onUpdate:modelValue",
    "name",
    "number",
    "parent",
    "plugins",
    "sectionsSchema",
    "type",
    "validation",
    "validationLabel",
    "validationMessages",
    "validationRules",
    // Runtime event props:
    "onInput",
    "onInputRaw",
    "onUpdate:modelValue",
    "onNode",
    "onSubmit",
    "onSubmitInvalid",
    "onSubmitRaw"
  ];
  function Aw(t) {
    return t && typeof t == "object" && "group" in t && Array.isArray(t.options);
  }
  function zO(t, e = { count: 1 }) {
    return Array.isArray(t) ? t.map(
      (i) => {
        if (typeof i == "string" || typeof i == "number")
          return {
            label: String(i),
            value: String(i)
          };
        if (typeof i == "object") {
          if ("group" in i)
            return i.options = zO(i.options || [], e), i;
          "value" in i && typeof i.value != "string" && Object.assign(i, {
            value: `__mask_${e.count++}`,
            __original: i.value
          });
        }
        return i;
      }
    ) : Object.keys(t).map((i) => ({
      label: t[i],
      value: i
    }));
  }
  function Wl(t, e, i = !1) {
    if (Array.isArray(t)) {
      for (const r of t)
        if (!(typeof r != "object" && r)) {
          if (Aw(r)) {
            const n = Wl(r.options, e, !0);
            if (n !== void 0)
              return n;
          } else if (e == r.value)
            return "__original" in r ? r.__original : r.value;
        }
    }
    return i ? void 0 : e;
  }
  function yd(t, e) {
    return t === null && e === void 0 || t === void 0 && e === null ? !1 : t == e ? !0 : DA(t) && DA(e) ? Lr(t, e) : !1;
  }
  function pQ(t) {
    t.hook.prop((e, i) => {
      var r;
      return e.prop === "options" && (typeof e.value == "function" ? (t.props.optionsLoader = e.value, e.value = []) : ((r = t.props)._normalizeCounter ?? (r._normalizeCounter = { count: 1 }), e.value = zO(e.value, t.props._normalizeCounter))), i(e);
    });
  }
  // @__NO_SIDE_EFFECTS__
  function We(t, e, i = !1) {
    return (...r) => {
      const n = (s) => {
        const o = !e || typeof e == "string" ? { $el: e } : e();
        return (_g(o) || my(o)) && (o.meta ? o.meta.section = t : o.meta = { section: t }, r.length && !o.children && (o.children = [
          ...r.map(
            (a) => typeof a == "function" ? a(s) : a
          )
        ]), _g(o) && (o.attrs = {
          class: `$classes.${t}`,
          ...o.attrs || {}
        })), {
          if: `$slots.${t}`,
          then: `$slots.${t}`,
          else: t in s ? /* @__PURE__ */ Fh(o, s[t]) : o
        };
      };
      return n._s = t, i ? /* @__PURE__ */ SIe(n) : n;
    };
  }
  // @__NO_SIDE_EFFECTS__
  function SIe(t) {
    return (e) => [t(e)];
  }
  function By(t) {
    return !!(t && typeof t == "object" && ("$el" in t || "$cmp" in t || "$formkit" in t));
  }
  // @__NO_SIDE_EFFECTS__
  function Fh(t, e = {}) {
    return typeof t == "string" ? By(e) || typeof e == "string" ? e : t : Array.isArray(t) ? By(e) ? e : t : TA(t, e);
  }
  var DIe = /* @__PURE__ */ We("actions", () => ({
    $el: "div",
    if: "$actions"
  })), wy = /* @__PURE__ */ We("input", () => ({
    $el: "input",
    bind: "$attrs",
    attrs: {
      type: "$type",
      name: "$node.props.altName || $node.name",
      disabled: "$option.attrs.disabled || $disabled",
      onInput: "$handlers.toggleChecked",
      checked: "$fns.eq($_value, $onValue)",
      onBlur: "$handlers.blur",
      value: "$: true",
      id: "$id",
      "aria-describedby": {
        if: "$options.length",
        then: {
          if: "$option.help",
          then: '$: "help-" + $option.attrs.id',
          else: void 0
        },
        else: {
          if: "$help",
          then: '$: "help-" + $id',
          else: void 0
        }
      }
    }
  })), PO = /* @__PURE__ */ We("optionHelp", () => ({
    $el: "div",
    if: "$option.help",
    attrs: {
      id: '$: "help-" + $option.attrs.id'
    }
  })), Cy = /* @__PURE__ */ We("inner", "span"), by = /* @__PURE__ */ We("label", "span"), OO = /* @__PURE__ */ We("option", () => ({
    $el: "li",
    for: ["option", "$options"],
    attrs: {
      "data-disabled": "$option.attrs.disabled || $disabled || undefined"
    }
  })), GO = /* @__PURE__ */ We("options", "ul"), My = /* @__PURE__ */ We("wrapper", () => ({
    $el: "label",
    attrs: {
      "data-disabled": {
        if: "$options.length",
        then: void 0,
        else: "$disabled || undefined"
      },
      "data-checked": {
        if: "$options == undefined",
        then: "$fns.eq($_value, $onValue) || undefined",
        else: "$fns.isChecked($option.value) || undefined"
      }
    }
  })), TIe = /* @__PURE__ */ We("input", () => ({
    $el: "button",
    bind: "$attrs",
    attrs: {
      type: "$type",
      disabled: "$disabled",
      name: "$node.name",
      id: "$id"
    }
  })), RIe = /* @__PURE__ */ We("default", null), Iy = /* @__PURE__ */ We("decorator", () => ({
    $el: "span",
    attrs: {
      "aria-hidden": "true"
    }
  })), jO = /* @__PURE__ */ We("fieldset", () => ({
    $el: "fieldset",
    attrs: {
      id: "$id",
      "aria-describedby": {
        if: "$help",
        then: '$: "help-" + $id',
        else: void 0
      }
    }
  })), _Ie = /* @__PURE__ */ We("input", () => ({
    $el: "input",
    bind: "$attrs",
    attrs: {
      type: "file",
      disabled: "$disabled",
      name: "$node.name",
      onChange: "$handlers.files",
      onBlur: "$handlers.blur",
      id: "$id",
      "aria-describedby": "$describedBy",
      "aria-required": "$state.required || undefined"
    }
  })), kIe = /* @__PURE__ */ We("fileItem", () => ({
    $el: "li",
    for: ["file", "$value"]
  })), YIe = /* @__PURE__ */ We("fileList", () => ({
    $el: "ul",
    if: "$value.length",
    attrs: {
      "data-has-multiple": "$_hasMultipleFiles"
    }
  })), NIe = /* @__PURE__ */ We("fileName", () => ({
    $el: "span",
    attrs: {
      class: "$classes.fileName"
    }
  })), T2 = /* @__PURE__ */ We("fileRemove", () => ({
    $el: "button",
    attrs: {
      type: "button",
      onClick: "$handlers.resetFiles"
    }
  })), UIe = /* @__PURE__ */ We("form", () => ({
    $el: "form",
    bind: "$attrs",
    meta: {
      autoAnimate: !0
    },
    attrs: {
      id: "$id",
      name: "$node.name",
      onSubmit: "$handlers.submit",
      "data-loading": "$state.loading || undefined"
    }
  })), mQ = /* @__PURE__ */ We("wrapper", null, !0), ka = /* @__PURE__ */ We("help", () => ({
    $el: "div",
    if: "$help",
    attrs: {
      id: '$: "help-" + $id'
    }
  })), gr = (t, e) => (/* @__PURE__ */ We(`${t}Icon`, () => {
    const i = `_raw${t.charAt(0).toUpperCase()}${t.slice(1)}Icon`;
    return {
      if: `$${t}Icon && $${i}`,
      $el: `${e || "span"}`,
      attrs: {
        class: `$classes.${t}Icon + " " + $classes.icon`,
        innerHTML: `$${i}`,
        onClick: `$handlers.iconClick(${t})`,
        role: `$fns.iconRole(${t})`,
        tabindex: `$fns.iconRole(${t}) === "button" && "0" || undefined`,
        for: {
          if: `${e === "label"}`,
          then: "$id"
        }
      }
    };
  }))(), lw = /* @__PURE__ */ We("inner", "div"), cw = /* @__PURE__ */ We("label", () => ({
    $el: "label",
    if: "$label",
    attrs: {
      for: "$id"
    }
  })), HO = /* @__PURE__ */ We("legend", () => ({
    $el: "legend",
    if: "$label"
  })), XA = /* @__PURE__ */ We("message", () => ({
    $el: "li",
    for: ["message", "$messages"],
    attrs: {
      key: "$message.key",
      id: "$id + '-' + $message.key",
      "data-message-type": "$message.type"
    }
  })), ZA = /* @__PURE__ */ We("messages", () => ({
    $el: "ul",
    if: "$defaultMessagePlacement && $fns.length($messages)"
  })), LIe = /* @__PURE__ */ We("noFiles", () => ({
    $el: "span",
    if: "$value == null || $value.length == 0"
  })), zIe = /* @__PURE__ */ We("optGroup", () => ({
    $el: "optgroup",
    bind: "$option.attrs",
    attrs: {
      label: "$option.group"
    }
  })), R2 = /* @__PURE__ */ We("option", () => ({
    $el: "option",
    bind: "$option.attrs",
    attrs: {
      class: "$classes.option",
      value: "$option.value",
      selected: "$fns.isSelected($option)"
    }
  })), _2 = /* @__PURE__ */ We("options", () => ({
    $el: null,
    if: "$options.length",
    for: ["option", "$option.options || $options"]
  })), fc = /* @__PURE__ */ We("outer", () => ({
    $el: "div",
    meta: {
      autoAnimate: !0
    },
    attrs: {
      key: "$id",
      "data-family": "$family || undefined",
      "data-type": "$type",
      "data-multiple": '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
      "data-has-multiple": "$_hasMultipleFiles",
      "data-disabled": '$: ($disabled !== "false" && $disabled) || undefined',
      "data-empty": "$state.empty || undefined",
      "data-complete": "$state.complete || undefined",
      "data-invalid": "$state.invalid || undefined",
      "data-errors": "$state.errors || undefined",
      "data-submitted": "$state.submitted || undefined",
      "data-prefix-icon": "$_rawPrefixIcon !== undefined || undefined",
      "data-suffix-icon": "$_rawSuffixIcon !== undefined || undefined",
      "data-prefix-icon-click": "$onPrefixIconClick !== undefined || undefined",
      "data-suffix-icon-click": "$onSuffixIconClick !== undefined || undefined"
    }
  })), Ya = /* @__PURE__ */ We("prefix", null), PIe = /* @__PURE__ */ We("input", () => ({
    $el: "select",
    bind: "$attrs",
    attrs: {
      id: "$id",
      "data-placeholder": "$fns.showPlaceholder($_value, $placeholder)",
      disabled: "$disabled",
      class: "$classes.input",
      name: "$node.name",
      onChange: "$handlers.onChange",
      onInput: "$handlers.selectInput",
      onBlur: "$handlers.blur",
      "aria-describedby": "$describedBy",
      "aria-required": "$state.required || undefined"
    }
  })), OIe = /* @__PURE__ */ We("submit", () => ({
    $cmp: "FormKit",
    bind: "$submitAttrs",
    props: {
      type: "submit",
      label: "$submitLabel"
    }
  })), Na = /* @__PURE__ */ We("suffix", null), JO = /* @__PURE__ */ We("input", () => ({
    $el: "input",
    bind: "$attrs",
    attrs: {
      type: "$type",
      disabled: "$disabled",
      name: "$node.name",
      onInput: "$handlers.DOMInput",
      onBlur: "$handlers.blur",
      value: "$_value",
      id: "$id",
      "aria-describedby": "$describedBy",
      "aria-required": "$state.required || undefined"
    }
  })), GIe = /* @__PURE__ */ We("input", () => ({
    $el: "textarea",
    bind: "$attrs",
    attrs: {
      disabled: "$disabled",
      name: "$node.name",
      onInput: "$handlers.DOMInput",
      onBlur: "$handlers.blur",
      value: "$_value",
      id: "$id",
      "aria-describedby": "$describedBy",
      "aria-required": "$state.required || undefined"
    },
    children: "$initialValue"
  })), Lf = /* @__PURE__ */ We("wrapper", "div"), jIe = 0;
  function VO(t) {
    (t.type === "group" || t.type === "list") && t.plugins.add(HIe);
  }
  function HIe(t) {
    t.props.type === "radio" && (t.addProps(["altName"]), t.props.altName = `${t.name}_${jIe++}`);
  }
  function WO(t) {
    return function(e, i) {
      return e.prop === "options" && Array.isArray(e.value) && (e.value = e.value.map((r) => {
        var n;
        return (n = r.attrs) != null && n.id ? r : TA(r, {
          attrs: {
            id: `${t.props.id}-option-${yx(String(r.value))}`
          }
        });
      }), t.props.type === "checkbox" && !Array.isArray(t.value) && (t.isCreated ? t.input([], !1) : t.on("created", () => {
        Array.isArray(t.value) || t.input([], !1);
      }))), i(e);
    };
  }
  function JIe(t, e) {
    const i = e.target;
    if (i instanceof HTMLInputElement) {
      const r = Array.isArray(t.props.options) ? Wl(t.props.options, i.value) : i.value;
      Array.isArray(t.props.options) && t.props.options.length ? Array.isArray(t._value) ? t._value.some((n) => yd(r, n)) ? t.input(
        t._value.filter(
          (n) => !yd(r, n)
        )
      ) : t.input([...t._value, r]) : t.input([r]) : i.checked ? t.input(t.props.onValue) : t.input(t.props.offValue);
    }
  }
  function VIe(t, e) {
    var i, r;
    return (i = t.context) == null || i.value, (r = t.context) == null || r._value, Array.isArray(t._value) ? t._value.some(
      (n) => yd(Wl(t.props.options, e), n)
    ) : !1;
  }
  function WIe(t) {
    t.on("created", () => {
      var e, i;
      (e = t.context) != null && e.handlers && (t.context.handlers.toggleChecked = JIe.bind(null, t)), (i = t.context) != null && i.fns && (t.context.fns.isChecked = VIe.bind(null, t)), gt(t.props, "onValue") || (t.props.onValue = !0), gt(t.props, "offValue") || (t.props.offValue = !1);
    }), t.hook.prop(WO(t));
  }
  function kl(t, e) {
    return (i) => {
      i.props[`${t}Icon`] === void 0 && (i.props[`${t}Icon`] = e.startsWith("<svg") ? e : `default:${e}`);
    };
  }
  function zf(t) {
    t.on("created", () => {
      "disabled" in t.props && (t.props.disabled = ns(t.props.disabled), t.config.disabled = ns(t.props.disabled));
    }), t.hook.prop(({ prop: e, value: i }, r) => (i = e === "disabled" ? ns(i) : i, r({ prop: e, value: i }))), t.on("prop:disabled", ({ payload: e }) => {
      t.config.disabled = ns(e);
    });
  }
  function Pu(t, e) {
    return (i) => {
      i.store.set(
        /* @__PURE__ */ nn({
          key: t,
          type: "ui",
          value: e || t,
          meta: {
            localize: !0,
            i18nArgs: [i]
          }
        })
      );
    };
  }
  var TC = typeof window < "u";
  function KO(t) {
    t.target instanceof HTMLElement && t.target.hasAttribute("data-file-hover") && t.target.removeAttribute("data-file-hover");
  }
  function k2(t, e) {
    e.target instanceof HTMLInputElement ? t === "dragover" && e.target.setAttribute("data-file-hover", "true") : e.preventDefault(), t === "drop" && KO(e);
  }
  function KIe(t) {
    Pu("noFiles", "Select file")(t), Pu("removeAll", "Remove all")(t), Pu("remove")(t), t.addProps(["_hasMultipleFiles"]), TC && (window._FormKit_File_Drop || (window.addEventListener(
      "dragover",
      k2.bind(null, "dragover")
    ), window.addEventListener("drop", k2.bind(null, "drop")), window.addEventListener("dragleave", KO), window._FormKit_File_Drop = !0)), t.hook.input((e, i) => i(Array.isArray(e) ? e : [])), t.on("input", ({ payload: e }) => {
      t.props._hasMultipleFiles = Array.isArray(e) && e.length > 1 ? !0 : void 0;
    }), t.on("reset", () => {
      if (t.props.id && TC) {
        const e = document.getElementById(t.props.id);
        e && (e.value = "");
      }
    }), t.on("created", () => {
      Array.isArray(t.value) || t.input([], !1), t.context && (t.context.handlers.resetFiles = (e) => {
        if (e.preventDefault(), t.input([]), t.props.id && TC) {
          const i = document.getElementById(t.props.id);
          i && (i.value = ""), i == null || i.focus();
        }
      }, t.context.handlers.files = (e) => {
        var r, n;
        const i = [];
        if (e.target instanceof HTMLInputElement && e.target.files) {
          for (let s = 0; s < e.target.files.length; s++) {
            let o;
            (o = e.target.files.item(s)) && i.push({ name: o.name, file: o });
          }
          t.input(i);
        }
        t.context && (t.context.files = i), typeof ((r = t.props.attrs) == null ? void 0 : r.onChange) == "function" && ((n = t.props.attrs) == null || n.onChange(e));
      });
    });
  }
  var Y2 = /* @__PURE__ */ nn({
    key: "loading",
    value: !0,
    visible: !1
  });
  async function XIe(t, e) {
    const i = Math.random();
    if (t.props._submitNonce = i, e.preventDefault(), await t.settled, t.ledger.value("validating") && (t.store.set(Y2), await t.ledger.settled("validating"), t.store.remove("loading"), t.props._submitNonce !== i))
      return;
    const r = (n) => n.store.set(
      /* @__PURE__ */ nn({
        key: "submitted",
        value: !0,
        visible: !1
      })
    );
    if (t.walk(r), r(t), t.emit("submit-raw"), typeof t.props.onSubmitRaw == "function" && t.props.onSubmitRaw(e, t), t.ledger.value("blocking"))
      typeof t.props.onSubmitInvalid == "function" && t.props.onSubmitInvalid(t), t.props.incompleteMessage !== !1 && XO(t);
    else if (typeof t.props.onSubmit == "function") {
      const n = t.props.onSubmit(
        t.hook.submit.dispatch(cd(t.value)),
        t
      );
      if (n instanceof Promise) {
        const s = t.props.disabled === void 0 && t.props.submitBehavior !== "live";
        s && (t.props.disabled = !0), t.store.set(Y2), await n, s && (t.props.disabled = !1), t.store.remove("loading");
      }
    } else
      e.target instanceof HTMLFormElement && e.target.submit();
  }
  function XO(t) {
    t.store.set(
      /* @__PURE__ */ nn({
        blocking: !1,
        key: "incomplete",
        meta: {
          localize: t.props.incompleteMessage === void 0,
          i18nArgs: [{ node: t }],
          showAsMessage: !0
        },
        type: "ui",
        value: t.props.incompleteMessage || "Form incomplete."
      })
    );
  }
  function ZIe(t) {
    var e;
    t.props.isForm = !0, t.ledger.count("validating", (i) => i.key === "validating"), (e = t.props).submitAttrs ?? (e.submitAttrs = {
      disabled: t.props.disabled
    }), t.on("prop:disabled", ({ payload: i }) => {
      t.props.submitAttrs = { ...t.props.submitAttrs, disabled: i };
    }), t.on("created", () => {
      var i;
      (i = t.context) != null && i.handlers && (t.context.handlers.submit = XIe.bind(null, t)), gt(t.props, "actions") || (t.props.actions = !0);
    }), t.on("prop:incompleteMessage", () => {
      t.store.incomplete && XO(t);
    }), t.on("settled:blocking", () => t.store.remove("incomplete"));
  }
  function qIe(t) {
    t.props.ignore === void 0 && (t.props.ignore = !0, t.parent = null);
  }
  function $Ie(t) {
    t.on("created", () => {
      t.context && (t.context.initialValue = t.value || "");
    });
  }
  function ZO(t) {
    if (typeof t.props.number > "u")
      return;
    const e = ["number", "range", "hidden"].includes(t.props.type);
    t.hook.input((i, r) => {
      if (i === "")
        return r(void 0);
      const n = t.props.number === "integer" ? parseInt(i) : parseFloat(i);
      return Number.isFinite(n) ? r(n) : r(e ? void 0 : i);
    });
  }
  function eve(t, e) {
    e.target instanceof HTMLInputElement && t.input(Wl(t.props.options, e.target.value));
  }
  function tve(t, e) {
    var i, r;
    return (i = t.context) == null || i.value, (r = t.context) == null || r._value, yd(Wl(t.props.options, e), t._value);
  }
  function ive(t) {
    t.on("created", () => {
      var e, i;
      Array.isArray(t.props.options) || gc(350, {
        node: t,
        inputType: "radio"
      }), (e = t.context) != null && e.handlers && (t.context.handlers.toggleChecked = eve.bind(null, t)), (i = t.context) != null && i.fns && (t.context.fns.isChecked = tve.bind(null, t));
    }), t.hook.prop(WO(t));
  }
  function rve(t, e) {
    if (Aw(e))
      return !1;
    t.context && t.context.value;
    const i = "__original" in e ? e.__original : e.value;
    return Array.isArray(t._value) ? t._value.some((r) => yd(r, i)) : (t._value === void 0 || t._value === null && !qO(t.props.options, null)) && e.attrs && e.attrs["data-is-placeholder"] ? !0 : yd(i, t._value);
  }
  function qO(t, e) {
    return t.some((i) => Aw(i) ? qO(i.options, e) : ("__original" in i ? i.__original : i.value) === e);
  }
  async function nve(t, e) {
    var i;
    typeof ((i = t.props.attrs) == null ? void 0 : i.onChange) == "function" && (await new Promise((r) => setTimeout(r, 0)), await t.settled, t.props.attrs.onChange(e));
  }
  function sve(t, e) {
    const i = e.target, r = i.hasAttribute("multiple") ? Array.from(i.selectedOptions).map(
      (n) => Wl(t.props.options, n.value)
    ) : Wl(t.props.options, i.value);
    t.input(r);
  }
  function N2(t, e) {
    return t.some(
      (i) => i.attrs && i.attrs["data-is-placeholder"]
    ) ? t : [
      {
        label: e,
        value: "",
        attrs: {
          hidden: !0,
          disabled: !0,
          "data-is-placeholder": "true"
        }
      },
      ...t
    ];
  }
  function $O(t) {
    const e = t.length > 0 ? t[0] : void 0;
    if (e)
      return Aw(e) ? $O(e.options) : "__original" in e ? e.__original : e.value;
  }
  function ove(t) {
    t.on("created", () => {
      var i, r, n;
      const e = ns((i = t.props.attrs) == null ? void 0 : i.multiple);
      !e && t.props.placeholder && Array.isArray(t.props.options) && (t.hook.prop(({ prop: s, value: o }, a) => (s === "options" && (o = N2(o, t.props.placeholder)), a({ prop: s, value: o }))), t.props.options = N2(
        t.props.options,
        t.props.placeholder
      )), e ? t.value === void 0 && t.input([], !1) : t.context && !t.context.options && (t.props.attrs = Object.assign({}, t.props.attrs, {
        value: t._value
      }), t.on("input", ({ payload: s }) => {
        t.props.attrs = Object.assign({}, t.props.attrs, {
          value: s
        });
      })), (r = t.context) != null && r.handlers && (t.context.handlers.selectInput = sve.bind(null, t), t.context.handlers.onChange = nve.bind(null, t)), (n = t.context) != null && n.fns && (t.context.fns.isSelected = rve.bind(null, t), t.context.fns.showPlaceholder = (s, o) => {
        if (!Array.isArray(t.props.options))
          return !1;
        const a = t.props.options.some(
          (A) => {
            if (A.attrs && "data-is-placeholder" in A.attrs)
              return !1;
            const l = "__original" in A ? A.__original : A.value;
            return Lr(s, l);
          }
        );
        return o && !a ? !0 : void 0;
      });
    }), t.hook.input((e, i) => {
      var r, n, s;
      return !t.props.placeholder && e === void 0 && Array.isArray((r = t.props) == null ? void 0 : r.options) && t.props.options.length && !ns((s = (n = t.props) == null ? void 0 : n.attrs) == null ? void 0 : s.multiple) && (e = $O(t.props.options)), i(e);
    });
  }
  // @__NO_SIDE_EFFECTS__
  function GM(t) {
    return !!(na(t) && t.if && t.if.startsWith("$slots.") && typeof t.then == "string" && t.then.startsWith("$slots.") && "else" in t);
  }
  function iu(t, e, i = !1, r) {
    if (Array.isArray(t)) {
      for (const n of t) {
        const s = iu(
          n,
          e,
          i,
          t
        );
        if (s && i)
          return s;
      }
      return;
    }
    if (ave(t)) {
      const n = e(t.else, t, r);
      return n && i ? n : iu(t.else, e, i, t);
    } else {
      if ((my(t) || _g(t)) && t.children)
        return iu(
          t.children,
          e,
          i
        );
      if (na(t)) {
        let n;
        if (t.then && typeof t.then != "string" && (n = iu(
          t.then,
          e,
          i,
          t
        )), !n && t.else && typeof t.else != "string" && (n = iu(
          t.else,
          e,
          i,
          t
        )), n && i)
          return n;
      }
    }
  }
  function ave(t) {
    var e;
    return !!(na(t) && typeof t.then == "string" && t.else && typeof t.else != "string" && !Array.isArray(t.else) && !na(t.else) && ((e = t.else.meta) != null && e.section));
  }
  // @__NO_SIDE_EFFECTS__
  function ls(t, e, i) {
    const r = (n) => {
      const s = e(n);
      if (i || By(s) && "if" in s || /* @__PURE__ */ GM(s)) {
        const o = {
          if: t,
          then: s
        };
        return i && (o.else = i(n)), o;
      } else /* @__PURE__ */ GM(s) ? Object.assign(s.else, { if: t }) : By(s) && Object.assign(s, { if: t });
      return s;
    };
    return r._s = Ld(), r;
  }
  // @__NO_SIDE_EFFECTS__
  function Ou(t, e) {
    const i = (r) => {
      const n = t({});
      return /* @__PURE__ */ GM(n) ? (Array.isArray(n.else) || (n.else = /* @__PURE__ */ Fh(
        /* @__PURE__ */ Fh(n.else, e),
        t._s ? r[t._s] : {}
      )), n) : /* @__PURE__ */ Fh(
        /* @__PURE__ */ Fh(n, e),
        t._s ? r[t._s] : {}
      );
    };
    return i._s = t._s, i;
  }
  var U2 = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ fc(
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value")),
      /* @__PURE__ */ Lf(
        /* @__PURE__ */ TIe(
          /* @__PURE__ */ gr("prefix"),
          /* @__PURE__ */ Ya(),
          /* @__PURE__ */ RIe("$label || $ui.submit.value"),
          /* @__PURE__ */ Na(),
          /* @__PURE__ */ gr("suffix")
        )
      ),
      /* @__PURE__ */ ka("$help")
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: "button",
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [Pu("submit"), qIe],
    /**
     * A key to use for memoizing the schema. This is used to prevent the schema
     * from needing to be stringified when performing a memo lookup.
     */
    schemaMemoKey: "h6st4epl3j8"
  }, Ave = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ fc(
      /* @__PURE__ */ ls(
        "$options == undefined",
        /**
         * Single checkbox structure.
         */
        /* @__PURE__ */ My(
          /* @__PURE__ */ Cy(/* @__PURE__ */ Ya(), /* @__PURE__ */ wy(), /* @__PURE__ */ Iy(/* @__PURE__ */ gr("decorator")), /* @__PURE__ */ Na()),
          /* @__PURE__ */ Ou(/* @__PURE__ */ by("$label"), {
            if: "$label"
          })
        ),
        /**
         * Multi checkbox structure.
         */
        /* @__PURE__ */ jO(
          /* @__PURE__ */ HO("$label"),
          /* @__PURE__ */ ka("$help"),
          /* @__PURE__ */ GO(
            /* @__PURE__ */ OO(
              /* @__PURE__ */ My(
                /* @__PURE__ */ Cy(
                  /* @__PURE__ */ Ya(),
                  /* @__PURE__ */ Ou(/* @__PURE__ */ wy(), {
                    bind: "$option.attrs",
                    attrs: {
                      id: "$option.attrs.id",
                      value: "$option.value",
                      checked: "$fns.isChecked($option.value)"
                    }
                  }),
                  /* @__PURE__ */ Iy(/* @__PURE__ */ gr("decorator")),
                  /* @__PURE__ */ Na()
                ),
                /* @__PURE__ */ Ou(/* @__PURE__ */ by("$option.label"), {
                  if: "$option.label"
                })
              ),
              /* @__PURE__ */ PO("$option.help")
            )
          )
        )
      ),
      // Help text only goes under the input when it is a single.
      /* @__PURE__ */ ls("$options == undefined && $help", /* @__PURE__ */ ka("$help")),
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value"))
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: "box",
    /**
     * An array of extra props to accept for this input.
     */
    props: ["options", "onValue", "offValue", "optionsLoader"],
    /**
     * Additional features that should be added to your input
     */
    features: [
      pQ,
      WIe,
      kl("decorator", "checkboxDecorator")
    ],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: "qje02tb3gu8"
  }, lve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ fc(
      /* @__PURE__ */ Lf(
        /* @__PURE__ */ cw("$label"),
        /* @__PURE__ */ lw(
          /* @__PURE__ */ gr("prefix", "label"),
          /* @__PURE__ */ Ya(),
          /* @__PURE__ */ _Ie(),
          /* @__PURE__ */ YIe(
            /* @__PURE__ */ kIe(
              /* @__PURE__ */ gr("fileItem"),
              /* @__PURE__ */ NIe("$file.name"),
              /* @__PURE__ */ ls(
                "$value.length === 1",
                /* @__PURE__ */ T2(
                  /* @__PURE__ */ gr("fileRemove"),
                  '$ui.remove.value + " " + $file.name'
                )
              )
            )
          ),
          /* @__PURE__ */ ls("$value.length > 1", /* @__PURE__ */ T2("$ui.removeAll.value")),
          /* @__PURE__ */ LIe(/* @__PURE__ */ gr("noFiles"), "$ui.noFiles.value"),
          /* @__PURE__ */ Na(),
          /* @__PURE__ */ gr("suffix")
        )
      ),
      /* @__PURE__ */ ka("$help"),
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value"))
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: "text",
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [
      KIe,
      kl("fileItem", "fileItem"),
      kl("fileRemove", "fileRemove"),
      kl("noFiles", "noFiles")
    ],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: "9kqc4852fv8"
  }, cve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ UIe(
      "$slots.default",
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value")),
      /* @__PURE__ */ DIe(/* @__PURE__ */ OIe())
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "group",
    /**
     * An array of extra props to accept for this input.
     */
    props: [
      "actions",
      "submit",
      "submitLabel",
      "submitAttrs",
      "submitBehavior",
      "incompleteMessage"
    ],
    /**
     * Additional features that should be added to your input
     */
    features: [ZIe, zf],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: "5bg016redjo"
  }, uve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ mQ("$slots.default"),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "group",
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [zf, VO]
  }, dve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ JO(),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [ZO]
  }, hve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ mQ("$slots.default"),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "list",
    /**
     * An array of extra props to accept for this input.
     */
    props: ["sync", "dynamic"],
    /**
     * Additional features that should be added to your input
     */
    features: [zf, VO]
  }, gve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ mQ(),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: []
  }, fve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ fc(
      /* @__PURE__ */ ls(
        "$options == undefined",
        /**
         * Single radio structure.
         */
        /* @__PURE__ */ My(
          /* @__PURE__ */ Cy(/* @__PURE__ */ Ya(), /* @__PURE__ */ wy(), /* @__PURE__ */ Iy(/* @__PURE__ */ gr("decorator")), /* @__PURE__ */ Na()),
          /* @__PURE__ */ Ou(/* @__PURE__ */ by("$label"), {
            if: "$label"
          })
        ),
        /**
         * Multi radio structure.
         */
        /* @__PURE__ */ jO(
          /* @__PURE__ */ HO("$label"),
          /* @__PURE__ */ ka("$help"),
          /* @__PURE__ */ GO(
            /* @__PURE__ */ OO(
              /* @__PURE__ */ My(
                /* @__PURE__ */ Cy(
                  /* @__PURE__ */ Ya(),
                  /* @__PURE__ */ Ou(/* @__PURE__ */ wy(), {
                    bind: "$option.attrs",
                    attrs: {
                      id: "$option.attrs.id",
                      value: "$option.value",
                      checked: "$fns.isChecked($option.value)"
                    }
                  }),
                  /* @__PURE__ */ Iy(/* @__PURE__ */ gr("decorator")),
                  /* @__PURE__ */ Na()
                ),
                /* @__PURE__ */ Ou(/* @__PURE__ */ by("$option.label"), {
                  if: "$option.label"
                })
              ),
              /* @__PURE__ */ PO("$option.help")
            )
          )
        )
      ),
      // Help text only goes under the input when it is a single.
      /* @__PURE__ */ ls("$options == undefined && $help", /* @__PURE__ */ ka("$help")),
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value"))
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: "box",
    /**
     * An array of extra props to accept for this input.
     */
    props: ["options", "onValue", "offValue", "optionsLoader"],
    /**
     * Additional features that should be added to your input
     */
    features: [pQ, ive, kl("decorator", "radioDecorator")],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: "qje02tb3gu8"
  }, pve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ fc(
      /* @__PURE__ */ Lf(
        /* @__PURE__ */ cw("$label"),
        /* @__PURE__ */ lw(
          /* @__PURE__ */ gr("prefix"),
          /* @__PURE__ */ Ya(),
          /* @__PURE__ */ PIe(
            /* @__PURE__ */ ls(
              "$slots.default",
              () => "$slots.default",
              /* @__PURE__ */ _2(
                /* @__PURE__ */ ls(
                  "$option.group",
                  /* @__PURE__ */ zIe(/* @__PURE__ */ _2(/* @__PURE__ */ R2("$option.label"))),
                  /* @__PURE__ */ R2("$option.label")
                )
              )
            )
          ),
          /* @__PURE__ */ ls("$attrs.multiple !== undefined", () => "", /* @__PURE__ */ gr("select")),
          /* @__PURE__ */ Na(),
          /* @__PURE__ */ gr("suffix")
        )
      ),
      /* @__PURE__ */ ka("$help"),
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value"))
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * An array of extra props to accept for this input.
     */
    props: ["options", "placeholder", "optionsLoader"],
    /**
     * Additional features that should be added to your input
     */
    features: [pQ, ove, kl("select", "select")],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: "cb119h43krg"
  }, mve = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ fc(
      /* @__PURE__ */ Lf(
        /* @__PURE__ */ cw("$label"),
        /* @__PURE__ */ lw(
          /* @__PURE__ */ gr("prefix", "label"),
          /* @__PURE__ */ Ya(),
          /* @__PURE__ */ GIe(),
          /* @__PURE__ */ Na(),
          /* @__PURE__ */ gr("suffix")
        )
      ),
      /* @__PURE__ */ ka("$help"),
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value"))
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [$Ie],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: "b1n0td79m9g"
  }, cn = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: /* @__PURE__ */ fc(
      /* @__PURE__ */ Lf(
        /* @__PURE__ */ cw("$label"),
        /* @__PURE__ */ lw(
          /* @__PURE__ */ gr("prefix", "label"),
          /* @__PURE__ */ Ya(),
          /* @__PURE__ */ JO(),
          /* @__PURE__ */ Na(),
          /* @__PURE__ */ gr("suffix")
        )
      ),
      /* @__PURE__ */ ka("$help"),
      /* @__PURE__ */ ZA(/* @__PURE__ */ XA("$message.value"))
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "input",
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: "text",
    /**
     * An array of extra props to accept for this input.
     */
    props: [],
    /**
     * Additional features that should be added to your input
     */
    features: [ZO],
    /**
     * The key used to memoize the schema.
     */
    schemaMemoKey: "c3cc4kflsg"
  }, Eve = {
    button: U2,
    submit: U2,
    checkbox: Ave,
    file: lve,
    form: cve,
    group: uve,
    hidden: dve,
    list: hve,
    meta: gve,
    radio: fve,
    select: pve,
    textarea: mve,
    text: cn,
    color: cn,
    date: cn,
    datetimeLocal: cn,
    email: cn,
    month: cn,
    number: cn,
    password: cn,
    search: cn,
    tel: cn,
    time: cn,
    url: cn,
    week: cn,
    range: cn
  };
  function yve(t) {
    const e = {};
    return Object.keys(t).forEach((i) => {
      Object.keys(t[i]).forEach((r) => {
        e[r] ? e[r][i] = t[i][r] : e[r] = {
          [i]: t[i][r]
        };
      });
    }), Object.keys(e).forEach((i) => {
      const r = e[i];
      e[i] = function(n, s) {
        return Bve(n, s, r);
      };
    }), e;
  }
  function Bve(t, e, i) {
    const r = t.props.type, n = t.props.family;
    let s = "";
    i.global && (s += i.global + " "), i[`family:${n}`] && (s += i[`family:${n}`] + " "), i[r] && (s += i[r]);
    const o = s.split("$reset");
    return o.length > 1 ? `$reset ${o[o.length - 1].trim()}` : o[0].trim();
  }
  var Ps = void 0, po = null, vy, eG = !1, Sh = !1, wve = /* @__PURE__ */ new Promise((t) => {
    vy = () => {
      eG = !0, t();
    };
  }), ba = typeof window < "u" && typeof fetch < "u";
  Ps = ba ? /* @__PURE__ */ getComputedStyle(document.documentElement) : void 0;
  var bu = {}, RC = {};
  function Cve(t, e, i, r) {
    e && Object.assign(bu, e), ba && !Sh && (Ps != null && Ps.getPropertyValue("--formkit-theme")) ? (vy(), Sh = !0) : t && !Sh && ba ? bve(t) : !Sh && ba && vy();
    const n = function(o) {
      var a, A;
      o.addProps(["iconLoader", "iconLoaderUrl"]), o.props.iconHandler = L2(
        (a = o.props) != null && a.iconLoader ? o.props.iconLoader : r,
        (A = o.props) != null && A.iconLoaderUrl ? o.props.iconLoaderUrl : i
      ), vve(o, o.props.iconHandler), o.on("created", () => {
        var l, c;
        (l = o == null ? void 0 : o.context) != null && l.handlers && (o.context.handlers.iconClick = (u) => {
          const d = `on${u.charAt(0).toUpperCase()}${u.slice(1)}IconClick`, h = o.props[d];
          if (h && typeof h == "function")
            return (g) => h(o, g);
        }), (c = o == null ? void 0 : o.context) != null && c.fns && (o.context.fns.iconRole = (u) => {
          const d = `on${u.charAt(0).toUpperCase()}${u.slice(1)}IconClick`;
          return typeof o.props[d] == "function" ? "button" : null;
        });
      });
    };
    return n.iconHandler = L2(r, i), n;
  }
  function bve(t) {
    if (!(!t || !ba || typeof getComputedStyle != "function") && (Sh = !0, po = document.getElementById("formkit-theme"), t && // if we have a window object
    ba && // we don't have an existing theme OR the theme being set up is different
    (!(Ps != null && Ps.getPropertyValue("--formkit-theme")) && !po || po != null && po.getAttribute("data-theme") && (po == null ? void 0 : po.getAttribute("data-theme")) !== t))) {
      const i = `https://cdn.jsdelivr.net/npm/@formkit/themes@${Ey.startsWith("__") ? "latest" : Ey}/dist/${t}/theme.css`, r = document.createElement("link");
      r.type = "text/css", r.rel = "stylesheet", r.id = "formkit-theme", r.setAttribute("data-theme", t), r.onload = () => {
        Ps = getComputedStyle(document.documentElement), vy();
      }, document.head.appendChild(r), r.href = i, po && po.remove();
    }
  }
  function L2(t, e) {
    return (i) => {
      if (typeof i != "string")
        return;
      if (i.startsWith("<svg"))
        return i;
      const r = i.startsWith("default:");
      i = r ? i.split(":")[1] : i;
      const n = i in bu;
      let s;
      if (n)
        return bu[i];
      if (!RC[i]) {
        if (s = Mve(i), s = ba && typeof s > "u" ? Promise.resolve(s) : s, s instanceof Promise)
          RC[i] = s.then((o) => !o && typeof i == "string" && !r ? s = typeof t == "function" ? t(i) : Ive(i, e) : o).then((o) => (typeof i == "string" && (bu[r ? `default:${i}` : i] = o), o));
        else if (typeof s == "string")
          return bu[r ? `default:${i}` : i] = s, s;
      }
      return RC[i];
    };
  }
  function Mve(t) {
    if (ba)
      return eG ? z2(t) : wve.then(() => z2(t));
  }
  function z2(t) {
    const e = Ps == null ? void 0 : Ps.getPropertyValue(`--fk-icon-${t}`);
    if (e) {
      const i = atob(e);
      if (i.startsWith("<svg"))
        return bu[t] = i, i;
    }
  }
  function Ive(t, e) {
    const i = Ey.startsWith("__") ? "latest" : Ey, r = typeof e == "function" ? e(t) : `https://cdn.jsdelivr.net/npm/@formkit/icons@${i}/dist/icons/${t}.svg`;
    if (ba)
      return fetch(`${r}`).then(async (n) => {
        const s = await n.text();
        if (s.startsWith("<svg"))
          return s;
      }).catch((n) => {
        console.error(n);
      });
  }
  function vve(t, e) {
    const i = /^[a-zA-Z-]+(?:-icon|Icon)$/;
    Object.keys(t.props).filter((n) => i.test(n)).forEach((n) => xve(t, e, n));
  }
  function xve(t, e, i) {
    const r = t.props[i], n = e(r), s = `_raw${i.charAt(0).toUpperCase()}${i.slice(1)}`, o = `on${i.charAt(0).toUpperCase()}${i.slice(1)}Click`;
    if (t.addProps([s, o]), t.on(`prop:${i}`, Qve), n instanceof Promise)
      return n.then((a) => {
        t.props[s] = a;
      });
    t.props[s] = n;
  }
  function Qve(t) {
    var o;
    const e = t.origin, i = t.payload, r = (o = e == null ? void 0 : e.props) == null ? void 0 : o.iconHandler, n = t.name.split(":")[1], s = `_raw${n.charAt(0).toUpperCase()}${n.slice(1)}`;
    if (r && typeof r == "function") {
      const a = r(i);
      if (a instanceof Promise)
        return a.then((A) => {
          e.props[s] = A;
        });
      e.props[s] = a;
    }
  }
  var P2 = {
    /**
     * FormKit errors:
     */
    100: ({ data: t }) => `Only groups, lists, and forms can have children (${t.name}).`,
    101: ({ data: t }) => `You cannot directly modify the store (${t.name}). See: https://formkit.com/advanced/core#message-store`,
    102: ({
      data: [t, e]
    }) => `You cannot directly assign node.${e} (${t.name})`,
    103: ({ data: [t] }) => `Schema expressions cannot start with an operator (${t})`,
    104: ({ data: [t, e] }) => `Schema expressions cannot end with an operator (${t} in "${e}")`,
    105: ({ data: t }) => `Invalid schema expression: ${t}`,
    106: ({ data: t }) => `Cannot submit because (${t}) is not in a form.`,
    107: ({ data: [t, e] }) => `Cannot set ${t.name} to non object value: ${e}`,
    108: ({ data: [t, e] }) => `Cannot set ${t.name} to non array value: ${e}`,
    /**
     * Input specific errors:
     */
    300: ({ data: [t] }) => `Cannot set behavior prop to overscroll (on ${t.name} input) when options prop is a function.`,
    /**
     * FormKit vue errors:
     */
    600: ({ data: t }) => `Unknown input type${typeof t.props.type == "string" ? ' "' + t.props.type + '"' : ""} ("${t.name}")`,
    601: ({ data: t }) => `Input definition${typeof t.props.type == "string" ? ' "' + t.props.type + '"' : ""} is missing a schema or component property (${t.name}).`
  }, O2 = {
    /**
     * Core warnings:
     */
    150: ({ data: t }) => `Schema function "${t}()" is not a valid function.`,
    151: ({ data: t }) => `No form element with id: ${t}`,
    152: ({ data: t }) => `No input element with id: ${t}`,
    /**
     * Input specific warnings:
     */
    350: ({
      data: { node: t, inputType: e }
    }) => `Invalid options prop for ${t.name} input (${e}). See https://formkit.com/inputs/${e}`,
    /**
     * Vue warnings:
     */
    650: 'Schema "$get()" must use the id of an input to access.',
    651: ({ data: t }) => `Cannot setErrors() on "${t}" because no such id exists.`,
    652: ({ data: t }) => `Cannot clearErrors() on "${t}" because no such id exists.`,
    /**
     * Deprecation warnings:
     */
    800: ({ data: t }) => `${t} is deprecated.`
  }, Fve = (t, e) => {
    if (t.code in P2) {
      const i = P2[t.code];
      t.message = typeof i == "function" ? i(t) : i;
    }
    return e(t);
  }, G2 = !1;
  function Sve() {
    G2 || (AQ(Fve), lQ(Dve), G2 = !0);
  }
  var Dve = (t, e) => {
    if (t.code in O2) {
      const i = O2[t.code];
      t.message = typeof i == "function" ? i(t) : i;
    }
    return e(t);
  }, Tve = Object.defineProperty, Rve = Object.getOwnPropertyNames, tG = (t, e) => function() {
    return t && (e = (0, t[Rve(t)[0]])(t = 0)), e;
  }, _ve = (t, e) => {
    for (var i in e)
      Tve(t, i, { get: e[i], enumerable: !0 });
  }, j2, iG, rG = tG({
    "packages/vue/src/bindings.ts"() {
      j2 = function(e) {
        e.ledger.count("blocking", (v) => v.blocking);
        const i = ue(!e.ledger.value("blocking"));
        e.ledger.count("errors", (v) => v.type === "error");
        const r = ue(!!e.ledger.value("errors"));
        let n = !1;
        ji(() => {
          n = !0;
        });
        const s = su(
          e.store.reduce((v, T) => (T.visible && (v[T.key] = T), v), {})
        ), o = ue(
          e.props.validationVisibility || (e.props.type === "checkbox" ? "dirty" : "blur")
        );
        e.on("prop:validationVisibility", ({ payload: v }) => {
          o.value = v;
        });
        const a = ue(o.value === "live"), A = ue(!1), l = (v) => {
          A.value = (v ?? []).some(
            (T) => T.name === "required"
          );
        };
        l(e.props.parsedRules), e.on("prop:parsedRules", ({ payload: v }) => l(v));
        const c = ue(e.children.map((v) => v.uid)), u = O(() => {
          if (!I.state)
            return !1;
          if (I.state.submitted)
            return !0;
          if (!a.value && !I.state.settled)
            return !1;
          switch (o.value) {
            case "live":
              return !0;
            case "blur":
              return I.state.blurred;
            case "dirty":
              return I.state.dirty;
            default:
              return !1;
          }
        }), d = O(() => I.state.failing && u.value), h = O(() => I && g.value ? i.value && !r.value : I.state.dirty && !As(I.value)), g = ue(
          Array.isArray(e.props.parsedRules) && e.props.parsedRules.length > 0
        );
        e.on("prop:parsedRules", ({ payload: v }) => {
          g.value = Array.isArray(v) && v.length > 0;
        });
        const f = O(() => {
          const v = {};
          for (const T in s) {
            const S = s[T];
            (S.type !== "validation" || u.value) && (v[T] = S);
          }
          return v;
        }), p = su(
          e.store.reduce((v, T) => (T.type === "ui" && T.visible && (v[T.key] = T), v), {})
        ), m = O(() => !I.state.failing), E = su({}), y = new Proxy(E, {
          get(...v) {
            if (!e)
              return "";
            const [T, S] = v;
            let D = Reflect.get(...v);
            return !D && typeof S == "string" && !gt(T, S) && !S.startsWith("__v") && aw(e).watch((R) => {
              const Y = typeof R.config.rootClasses == "function" ? R.config.rootClasses(S, R) : {}, L = R.config.classes ? $m(S, R, R.config.classes[S]) : {}, N = $m(
                S,
                R,
                R.props[`_${S}Class`]
              ), H = $m(
                S,
                R,
                R.props[`${S}Class`]
              );
              D = zbe(
                R,
                S,
                Y,
                L,
                N,
                H
              ), T[S] = D ?? "";
            }), D;
          }
        });
        e.on("prop:rootClasses", () => {
          const v = Object.keys(E);
          for (const T of v)
            delete E[T];
        });
        const C = O(() => {
          if (!e)
            return;
          const v = [];
          I.help && v.push(`help-${e.props.id}`);
          for (const T in f.value)
            v.push(`${e.props.id}-${T}`);
          return v.length ? v.join(" ") : void 0;
        }), w = ue(e.value), M = ue(e.value), I = su({
          _value: M,
          attrs: e.props.attrs,
          disabled: e.props.disabled,
          describedBy: C,
          fns: {
            length: (v) => Object.keys(v).length,
            number: (v) => Number(v),
            string: (v) => String(v),
            json: (v) => JSON.stringify(v),
            eq: Lr
          },
          handlers: {
            blur: (v) => {
              e && (e.store.set(
                /* @__PURE__ */ nn({ key: "blurred", visible: !1, value: !0 })
              ), typeof e.props.attrs.onBlur == "function" && e.props.attrs.onBlur(v));
            },
            touch: () => {
              var S;
              const v = I.dirtyBehavior === "compare";
              if ((S = e.store.dirty) != null && S.value && !v)
                return;
              const T = !Lr(e.props._init, e._value);
              !T && !v || e.store.set(
                /* @__PURE__ */ nn({ key: "dirty", visible: !1, value: T })
              );
            },
            DOMInput: (v) => {
              e.input(v.target.value), e.emit("dom-input-event", v);
            }
          },
          help: e.props.help,
          id: e.props.id,
          items: c,
          label: e.props.label,
          messages: f,
          didMount: !1,
          node: qM(e),
          options: e.props.options,
          defaultMessagePlacement: !0,
          slots: e.props.__slots,
          state: {
            blurred: !1,
            complete: h,
            dirty: !1,
            empty: As(w),
            submitted: !1,
            settled: e.isSettled,
            valid: i,
            invalid: d,
            errors: r,
            rules: g,
            validationVisible: u,
            required: A,
            failing: !1,
            passing: m
          },
          type: e.props.type,
          family: e.props.family,
          ui: p,
          value: w,
          classes: y
        });
        e.on("created", () => {
          Lr(I.value, e.value) || (M.value = e.value, w.value = e.value, ll(w), ll(M)), (async () => (await e.settled, e && (e.props._init = Us(e.value))))();
        }), e.on("mounted", () => {
          I.didMount = !0;
        }), e.on("settled", ({ payload: v }) => {
          I.state.settled = v;
        });
        function b(v) {
          (Array.isArray(v) ? v : Object.keys(v)).forEach((S) => {
            S = Ru(S), gt(I, S) || (I[S] = e.props[S]), e.on(`prop:${S}`, ({ payload: D }) => {
              I[S] = D;
            });
          });
        }
        b((() => {
          const v = [
            "__root",
            "help",
            "label",
            "disabled",
            "options",
            "type",
            "attrs",
            "preserve",
            "preserveErrors",
            "id",
            "dirtyBehavior"
          ], T = /^[a-zA-Z-]+(?:-icon|Icon)$/, S = Object.keys(e.props).filter((D) => T.test(D));
          return v.concat(S);
        })());
        function x(v) {
          v.props && b(v.props);
        }
        e.props.definition && x(e.props.definition), e.on("added-props", ({ payload: v }) => b(v)), e.on("input", ({ payload: v }) => {
          e.type !== "input" && !eg(v) && !MQ(v) ? M.value = Tb(v) : (M.value = v, ll(M));
        }), e.on("commitRaw", ({ payload: v }) => {
          e.type !== "input" && !eg(v) && !MQ(v) ? w.value = M.value = Tb(v) : (w.value = M.value = v, ll(w)), e.emit("modelUpdated");
        }), e.on("commit", ({ payload: v }) => {
          var T;
          if ((!I.state.dirty || I.dirtyBehavior === "compare") && e.isCreated && n)
            if (!((T = e.store.validating) != null && T.value))
              I.handlers.touch();
            else {
              const S = e.on("message-removed", ({ payload: D }) => {
                D.key === "validating" && (I.handlers.touch(), e.off(S));
              });
            }
          h && e.type === "input" && r.value && !ns(e.props.preserveErrors) && e.store.filter(
            (S) => {
              var D;
              return !(S.type === "error" && ((D = S.meta) == null ? void 0 : D.autoClear) === !0);
            }
          ), e.type === "list" && e.sync && (c.value = e.children.map((S) => S.uid)), I.state.empty = As(v);
        });
        const Q = async (v) => {
          v.type === "ui" && v.visible && !v.meta.showAsMessage ? p[v.key] = v : v.visible ? s[v.key] = v : v.type === "state" && (I.state[v.key] = !!v.value);
        };
        e.on("message-added", (v) => Q(v.payload)), e.on("message-updated", (v) => Q(v.payload)), e.on("message-removed", ({ payload: v }) => {
          delete p[v.key], delete s[v.key], delete I.state[v.key];
        }), e.on("settled:blocking", () => {
          i.value = !0;
        }), e.on("unsettled:blocking", () => {
          i.value = !1;
        }), e.on("settled:errors", () => {
          r.value = !1;
        }), e.on("unsettled:errors", () => {
          r.value = !0;
        }), ct(u, (v) => {
          v && (a.value = !0);
        }), e.context = I, e.emit("context", e, !1), e.on("destroyed", () => {
          e.context = void 0, e = null;
        });
      }, iG = j2;
    }
  }), kve = {};
  _ve(kve, {
    defaultConfig: () => EQ
  });
  var EQ, Yve = tG({
    "packages/vue/src/defaultConfig.ts"() {
      rG(), EQ = (t = {}) => {
        Sve();
        const {
          rules: e = {},
          locales: i = {},
          inputs: r = {},
          messages: n = {},
          locale: s = void 0,
          theme: o = void 0,
          iconLoaderUrl: a = void 0,
          iconLoader: A = void 0,
          icons: l = {},
          ...c
        } = t, u = aIe({
          ...oIe,
          ...e || {}
        }), d = xIe(
          TA({ en: vIe, ...i || {} }, n)
        ), h = QIe(Eve, r), g = Cve(o, l, a, A);
        return TA(
          {
            plugins: [h, g, iG, d, u],
            ...s ? { config: { locale: s } } : {}
          },
          c || {},
          !0
        );
      };
    }
  }), Nve = typeof window > "u", _C = /* @__PURE__ */ new Map();
  function Uve(t, e) {
    var i;
    !Nve || !t || (_C.has(t) || _C.set(t, /* @__PURE__ */ new Set()), (i = _C.get(t)) == null || i.add(e));
  }
  var nG = typeof window > "u", qh = {}, Gu = {}, Jr, sa = /* @__PURE__ */ new WeakMap(), Lve = "__raw__", zve = /[a-zA-Z0-9\-][cC]lass$/;
  function Pve(t, e) {
    const i = ue(null);
    if (t === "get") {
      const n = {};
      return i.value = Ove.bind(null, n), i;
    }
    const r = t.split(".");
    return vi(() => {
      i.value = yQ(
        eg(e) ? e.value : e,
        r
      );
    }), i;
  }
  function yQ(t, e) {
    if (Array.isArray(t)) {
      for (const n of t) {
        const s = n !== !1 && yQ(n, e);
        if (s !== void 0)
          return s;
      }
      return;
    }
    let i, r = t;
    for (const n in e) {
      const s = e[n];
      if (typeof r != "object" || r === null) {
        i = void 0;
        break;
      }
      const o = r[s];
      if (Number(n) === e.length - 1 && o !== void 0) {
        i = typeof o == "function" ? o.bind(r) : o;
        break;
      }
      r = o;
    }
    return i;
  }
  function Ove(t, e) {
    if (typeof e != "string")
      return gc(650);
    if (e in t || (t[e] = ue(void 0)), t[e].value === void 0) {
      t[e].value = null;
      const i = Nf(e);
      i && (t[e].value = i.context), JCe(e, ({ payload: r }) => {
        t[e].value = Uf(r) ? r.context : r;
      });
    }
    return t[e].value;
  }
  function H2(t, e, i) {
    function r(h, g) {
      const f = u(Qs(g.if), { if: !0 }), p = l(h, g.then), m = g.else ? l(h, g.else) : null;
      return [f, p, m];
    }
    function n(h, g) {
      var E, y;
      const f = u(Qs(h.if));
      let p = () => g, m = () => g;
      return typeof h.then == "object" ? m = s(h.then, void 0) : typeof h.then == "string" && ((E = h.then) != null && E.startsWith("$")) ? m = u(Qs(h.then)) : m = () => h.then, gt(h, "else") && (typeof h.else == "object" ? p = s(h.else) : typeof h.else == "string" && ((y = h.else) != null && y.startsWith("$")) ? p = u(Qs(h.else)) : p = () => h.else), () => f() ? m() : p();
    }
    function s(h, g, f = {}) {
      const p = new Set(Object.keys(h || {})), m = g ? u(Qs(g)) : () => ({}), E = [
        (y) => {
          const C = m();
          for (const w in C)
            p.has(w) || (y[w] = C[w]);
        }
      ];
      if (h) {
        if (na(h))
          return n(
            h,
            f
          );
        for (let y in h) {
          const C = h[y];
          let w;
          const M = typeof C == "string";
          y.startsWith(Lve) ? (y = y.substring(7), w = () => C) : M && C.startsWith("$") && C.length > 1 && !(C.startsWith("$reset") && zve.test(y)) ? w = u(Qs(C)) : typeof C == "object" && na(C) ? w = n(C, void 0) : typeof C == "object" && DA(C) ? w = s(C) : w = () => C, E.push((I) => {
            I[y] = w();
          });
        }
      }
      return () => {
        const y = Array.isArray(h) ? [] : {};
        return E.forEach((C) => C(y)), y;
      };
    }
    function o(h, g) {
      let f = null, p = () => null, m = !1, E = null, y = null, C = null, w = !1;
      const M = Lbe(g);
      if (_g(M) ? (f = M.$el, p = M.$el !== "text" ? s(M.attrs, M.bind) : () => null) : my(M) ? (typeof M.$cmp == "string" ? gt(h, M.$cmp) ? f = h[M.$cmp] : (f = M.$cmp, w = !0) : f = M.$cmp, p = s(M.props, M.bind)) : na(M) && ([m, E, y] = r(h, M)), !na(M) && "if" in M ? m = u(Qs(M.if)) : !na(M) && f === null && (m = () => !0), "children" in M && M.children)
        if (typeof M.children == "string")
          if (M.children.startsWith("$slots."))
            f = f === "text" ? "slot" : f, E = u(Qs(M.children));
          else if (M.children.startsWith("$") && M.children.length > 1) {
            const I = u(Qs(M.children));
            E = () => String(I());
          } else
            E = () => String(M.children);
        else if (Array.isArray(M.children))
          E = l(h, M.children);
        else {
          const [I, b, B] = r(h, M.children);
          E = (x) => I && I() ? b && b(x) : B && B(x);
        }
      if (my(M))
        if (E) {
          const I = E;
          E = (b) => ({
            default(B, x) {
              var T, S, D, F;
              const Q = Jr;
              x && (Jr = x), B && ((T = sa.get(Jr)) == null || T.unshift(B)), b && ((S = sa.get(Jr)) == null || S.unshift(b));
              const v = I(b);
              return B && ((D = sa.get(Jr)) == null || D.shift()), b && ((F = sa.get(Jr)) == null || F.shift()), Jr = Q, v;
            }
          }), E.slot = !0;
        } else
          E = () => ({});
      if ("for" in M && M.for) {
        const I = M.for.length === 3 ? M.for[2] : M.for[1];
        C = [
          typeof I == "string" && I.startsWith("$") ? u(Qs(I)) : () => I,
          M.for[0],
          M.for.length === 3 ? String(M.for[1]) : null
        ];
      }
      return [m, f, p, E, y, C, w];
    }
    function a(h, g) {
      const f = h(g), p = Jr;
      return Object.keys(f).reduce((m, E) => {
        const y = f && f[E];
        return m[E] = (C) => y && y(C, p) || null, m;
      }, {});
    }
    function A(h, g) {
      const [f, p, m, E, y, C, w] = o(h, g);
      let M = (I) => {
        if (f && p === null && E)
          return f() ? E(I) : y && y(I);
        if (p && (!f || f())) {
          if (p === "text" && E)
            return Ct(String(E()));
          if (p === "slot" && E)
            return E(I);
          const b = w ? Os(p) : p, B = E != null && E.slot ? a(E, I) : null;
          return ju(
            b,
            m(),
            B || (E ? E(I) : [])
          );
        }
        return typeof y == "function" ? y(I) : y;
      };
      if (C) {
        const I = M, [b, B, x] = C;
        M = () => {
          const Q = b(), v = Number.isFinite(Q) ? Array(Number(Q)).fill(0).map((F, R) => R) : Q, T = [];
          if (typeof v != "object")
            return null;
          const S = sa.get(Jr) || [], D = Array.isArray(v);
          for (const F in v) {
            if (D && F in Array.prototype)
              continue;
            const R = Object.defineProperty(
              {
                ...S.reduce(
                  (Y, L) => Y.__idata ? { ...Y, ...L } : L,
                  {}
                ),
                [B]: v[F],
                ...x !== null ? { [x]: D ? Number(F) : F } : {}
              },
              "__idata",
              { enumerable: !1, value: !0 }
            );
            S.unshift(R), T.push(I.bind(null, R)()), S.shift();
          }
          return T;
        };
      }
      return M;
    }
    function l(h, g) {
      if (Array.isArray(g)) {
        const p = g.map(A.bind(null, h));
        return (m) => p.map((E) => E(m));
      }
      const f = A(h, g);
      return (p) => f(p);
    }
    const c = [];
    function u(h, g = {}) {
      const f = /* @__PURE__ */ new WeakMap();
      return c.push((p, m) => {
        f.set(
          m,
          h.provide((E) => p(E, g))
        );
      }), () => f.get(Jr)();
    }
    function d(h, g) {
      i ?? (i = oG(e));
      const [f, p] = gt(qh, i) ? qh[i] : [l(t, e), c];
      return nG || (Gu[i] ?? (Gu[i] = 0), Gu[i]++, qh[i] = [f, p]), p.forEach((m) => {
        m(h, g);
      }), () => (Jr = g, f());
    }
    return d;
  }
  function sG(t, e) {
    const i = sa.get(Jr) || [];
    let r;
    return i.length && (r = yQ(i, t.split("."))), r === void 0 ? e : r;
  }
  function Gve(t, e) {
    return new Proxy(t, {
      get(...i) {
        let r;
        const n = i[1];
        if (typeof n == "string") {
          const s = Jr;
          Jr = e, r = sG(n, void 0), Jr = s;
        }
        return r !== void 0 ? r : Reflect.get(...i);
      }
    });
  }
  function J2(t, e, i) {
    return t(
      (r, n = {}) => r.reduce((s, o) => {
        if (o.startsWith("slots.")) {
          const a = o.substring(6), A = () => e.slots && gt(e.slots, a) && typeof e.slots[a] == "function";
          if (n.if)
            s[o] = A;
          else if (e.slots) {
            const l = Gve(e, i);
            s[o] = () => A() ? e.slots[a](l) : null;
          }
        } else {
          const a = Pve(o, e);
          s[o] = () => sG(o, a.value);
        }
        return s;
      }, {}),
      i
    );
  }
  function V2(t, e, i) {
    if (e ?? (e = oG(t)), Gu[e]--, Gu[e] === 0) {
      delete Gu[e];
      const [, r] = qh[e];
      delete qh[e], r.length = 0;
    }
    sa.delete(i);
  }
  function oG(t) {
    return JSON.stringify(t, (e, i) => typeof i == "function" ? i.toString() : i);
  }
  var aG = /* @__PURE__ */ je({
    name: "FormKitSchema",
    props: {
      schema: {
        type: [Array, Object],
        required: !0
      },
      data: {
        type: Object,
        default: () => ({})
      },
      library: {
        type: Object,
        default: () => ({})
      },
      memoKey: {
        type: String,
        required: !1
      }
    },
    emits: ["mounted"],
    setup(t, e) {
      var l;
      const i = Uo();
      let r = {};
      sa.set(r, []);
      const n = { FormKit: qM(lG), ...t.library };
      let s = H2(n, t.schema, t.memoKey), o, a;
      nG || ct(
        () => t.schema,
        (c, u) => {
          var h;
          const d = r;
          r = {}, sa.set(r, []), s = H2(n, t.schema, t.memoKey), o = J2(s, a, r), c === u && ((h = i == null ? void 0 : i.proxy) == null ? void 0 : h.$forceUpdate).call(h), V2(t.schema, t.memoKey, d);
        },
        { deep: !0 }
      ), vi(() => {
        a = Object.assign(su(t.data ?? {}), {
          slots: e.slots
        }), e.slots, o = J2(s, a, r);
      });
      function A() {
        V2(t.schema, t.memoKey, r), a && (a.node && a.node.destroy(), a.slots = null, a = null), o = null;
      }
      return er(() => e.emit("mounted")), Fs(A), Uve((l = Uo()) == null ? void 0 : l.appContext.app, A), () => o ? o() : null;
    }
  }), jve = aG, Hve = typeof window > "u", W2 = Symbol("FormKitParent"), Jve = Symbol("FormKitComponentCallback");
  function Vve(t, e) {
    const i = txe(t, e);
    if (i.props.definition || zn(600, i), i.props.definition.component)
      return () => {
        var l;
        return ju(
          (l = i.props.definition) == null ? void 0 : l.component,
          {
            context: i.context
          },
          { ...e.slots }
        );
      };
    const r = ue([]);
    let n = i.props.definition.schemaMemoKey;
    const s = () => {
      var c, u;
      const l = (u = (c = i.props) == null ? void 0 : c.definition) == null ? void 0 : u.schema;
      l || zn(601, i), typeof l == "function" ? (r.value = l({ ...t.sectionsSchema || {} }), (n && t.sectionsSchema || "memoKey" in l && typeof l.memoKey == "string") && (n = (n ?? (l == null ? void 0 : l.memoKey)) + JSON.stringify(t.sectionsSchema))) : r.value = l;
    };
    s(), Hve || i.on("schema", () => {
      n += "♻️", s();
    }), e.emit("node", i);
    const o = i.props.definition.library, a = {
      FormKit: qM(AG),
      ...o,
      ...t.library ?? {}
    };
    function A() {
      i.emit("mounted");
    }
    return e.expose({ node: i }), () => ju(
      aG,
      {
        schema: r.value,
        data: i.context,
        onMounted: A,
        library: a,
        memoKey: n
      },
      { ...e.slots }
    );
  }
  var AG = /* @__PURE__ */ je(
    Vve,
    {
      props: FIe,
      inheritAttrs: !1
    }
  ), lG = AG, Wve = Symbol();
  function Kve(t, e) {
    return t.component(e.alias || "FormKit", lG).component(e.schemaAlias || "FormKitSchema", jve), {
      get: Nf,
      setLocale: (i) => {
        var r;
        (r = e.config) != null && r.rootConfig && (e.config.rootConfig.locale = i);
      },
      clearErrors: Obe,
      setErrors: Pbe,
      submit: yO,
      reset: BO
    };
  }
  var cG = Symbol.for("FormKitOptions"), Xve = Symbol.for("FormKitConfig"), Zve = {
    install(t, e) {
      const i = Object.assign(
        {
          alias: "FormKit",
          schemaAlias: "FormKitSchema"
        },
        typeof e == "function" ? e() : e
      ), r = VCe(i.config || {});
      i.config = { rootConfig: r }, t.config.globalProperties.$formkit = Kve(t, i), t.provide(cG, i), t.provide(Xve, r), typeof window < "u" && (globalThis.__FORMKIT_CONFIGS__ = (globalThis.__FORMKIT_CONFIGS__ || []).concat([r]));
    }
  }, qve = typeof window < "u", kC = [
    // Boolean props
    "ignore",
    "disabled",
    "preserve",
    // String props
    "help",
    "label",
    /^preserve(-e|E)rrors/,
    /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,
    /^[a-zA-Z-]+(?:-class|Class)$/,
    "prefixIcon",
    "suffixIcon",
    /^[a-zA-Z-]+(?:-icon|Icon)$/
  ], $ve = ["disabled", "ignore", "preserve"];
  function K2(t, e) {
    e.classes && Object.keys(e.classes).forEach(
      (i) => {
        typeof i == "string" && (t.props[`_${i}Class`] = e.classes[i], Ph(e.classes[i]) && i === "inner" && Object.values(e.classes[i]));
      }
    );
  }
  function exe(t) {
    return t ? ["Submit", "SubmitRaw", "SubmitInvalid"].reduce(
      (i, r) => {
        const n = `on${r}`;
        return n in t && typeof t[n] == "function" && (i[n] = t[n]), i;
      },
      {}
    ) : {};
  }
  function txe(t, e, i = {}) {
    const r = Object.assign({}, bo(cG) || {}, i), n = bo(Wve, ue(qve ? document : void 0)), s = bo(Jve, () => {
    }), o = Uo(), a = exe(o == null ? void 0 : o.vnode.props), A = ["modelValue", "model-value"].some(
      (M) => M in ((o == null ? void 0 : o.vnode.props) ?? {})
    );
    let l = !1;
    er(() => {
      l = !0;
    });
    const c = t.modelValue !== void 0 ? t.modelValue : Us(e.attrs.value);
    function u() {
      const M = {
        ...Sc(t),
        ...a,
        type: t.type ?? "text",
        __root: n.value,
        __slots: e.slots
      }, I = ET(Sc(e.attrs), kC);
      I.key || (I.key = Ld()), M.attrs = I;
      const b = yT(Sc(e.attrs), kC);
      for (const x in b)
        $ve.includes(x) && b[x] === "" && (b[x] = !0), M[Ru(x)] = b[x];
      const B = { props: {} };
      return K2(B, t), Object.assign(M, B.props), typeof M.type != "string" && (M.definition = M.type, delete M.type), M;
    }
    const d = u(), h = d.ignore ? null : t.parent || bo(W2, null), g = Nbe(
      TA(
        r || {},
        {
          name: t.name || void 0,
          value: c,
          parent: h,
          plugins: (r.plugins || []).concat(t.plugins ?? []),
          config: t.config || {},
          props: d,
          index: t.index,
          sync: !!ns(e.attrs.sync || e.attrs.dynamic)
        },
        !1,
        !0
      )
    );
    s(g), g.props.definition || zn(600, g);
    const f = ue(
      new Set(
        Array.isArray(g.props.__propDefs) ? g.props.__propDefs : Object.keys(g.props.__propDefs ?? {})
      )
    );
    g.on(
      "added-props",
      ({ payload: M }) => {
        (Array.isArray(M) ? M : Object.keys(M ?? {})).forEach((b) => f.value.add(b));
      }
    );
    const p = O(
      () => kC.concat([...f.value]).reduce((M, I) => (typeof I == "string" ? (M.push(Ru(I)), M.push(jL(I))) : M.push(I), M), [])
    );
    vi(() => K2(g, t));
    const m = Sc(t);
    for (const M in m)
      ct(
        () => t[M],
        () => {
          t[M] !== void 0 && (g.props[M] = t[M]);
        }
      );
    vi(() => {
      g.props.__root = n.value;
    });
    const E = /* @__PURE__ */ new Set(), y = Sc(e.attrs);
    vi(() => {
      C(yT(y, p.value));
    });
    function C(M) {
      E.forEach((I) => {
        I(), E.delete(I);
      });
      for (const I in M) {
        const b = Ru(I);
        E.add(
          ct(
            () => e.attrs[I],
            () => {
              g.props[b] = e.attrs[I];
            }
          )
        );
      }
    }
    if (vi(() => {
      const M = ET(Sc(e.attrs), p.value);
      "multiple" in M && (M.multiple = ns(M.multiple)), typeof M.onBlur == "function" && (M.onBlur = Vne(M.onBlur)), g.props.attrs = Object.assign({}, g.props.attrs || {}, M);
    }), vi(() => {
      const M = (t.errors ?? []).map(
        (I) => /* @__PURE__ */ nn({
          key: yx(I),
          type: "error",
          value: I,
          meta: { source: "prop" }
        })
      );
      g.store.apply(
        M,
        (I) => I.type === "error" && I.meta.source === "prop"
      );
    }), g.type !== "input") {
      const M = `${g.name}-prop`;
      vi(() => {
        const I = t.inputErrors ?? {}, b = Object.keys(I);
        b.length || g.clearErrors(!0, M);
        const B = b.reduce((x, Q) => {
          let v = I[Q];
          return typeof v == "string" && (v = [v]), Array.isArray(v) && (x[Q] = v.map(
            (T) => /* @__PURE__ */ nn({
              key: T,
              type: "error",
              value: T,
              meta: { source: M }
            })
          )), x;
        }, {});
        g.store.apply(
          B,
          (x) => x.type === "error" && x.meta.source === M
        );
      });
    }
    vi(() => Object.assign(g.config, t.config)), g.type !== "input" && bd(W2, g);
    let w;
    return g.on("modelUpdated", () => {
      var M, I;
      e.emit("inputRaw", (M = g.context) == null ? void 0 : M.value, g), l && e.emit("input", (I = g.context) == null ? void 0 : I.value, g), A && g.context && (w = Us(g.value), e.emit("update:modelValue", Tb(g.value)));
    }), A && (ct(
      sk(t, "modelValue"),
      (M) => {
        Lr(w, M) || g.input(M, !1);
      },
      { deep: !0 }
    ), g.value !== c && g.emit("modelUpdated")), XM(() => g.destroy()), g;
  }
  var ixe = /* @__PURE__ */ We("messages", () => ({
    $el: "ul",
    if: "$fns.length($messages)"
  })), rxe = /* @__PURE__ */ We("message", () => ({
    $el: "li",
    for: ["message", "$messages"],
    attrs: {
      key: "$message.key",
      id: "$id + '-' + $message.key",
      "data-message-type": "$message.type"
    }
  }));
  ixe(rxe("$message.value"));
  var nxe = /* @__PURE__ */ We("summary", () => ({
    $el: "div",
    attrs: {
      "aria-live": "polite"
    }
  })), sxe = /* @__PURE__ */ We("summaryInner", () => ({
    $el: "div",
    if: "$summaries.length && $showSummaries"
  })), oxe = /* @__PURE__ */ We("messages", () => ({
    $el: "ul",
    if: "$summaries.length && $showSummaries"
  })), axe = /* @__PURE__ */ We("message", () => ({
    $el: "li",
    for: ["summary", "$summaries"],
    attrs: {
      key: "$summary.key",
      "data-message-type": "$summary.type"
    }
  })), Axe = /* @__PURE__ */ We("summaryHeader", () => ({
    $el: "h2",
    attrs: {
      id: "$id"
    }
  })), lxe = /* @__PURE__ */ We("messageLink", () => ({
    $el: "a",
    attrs: {
      id: "$summary.key",
      href: '$: "#" + $summary.id',
      onClick: "$jumpLink"
    }
  }));
  nxe(
    sxe(
      Axe("$summaryHeader"),
      oxe(axe(lxe("$summary.message")))
    )
  );
  Yve();
  rG();
  const uG = /* @__PURE__ */ new Set(), In = /* @__PURE__ */ new WeakMap(), Bd = /* @__PURE__ */ new WeakMap(), Kl = /* @__PURE__ */ new WeakMap(), jM = /* @__PURE__ */ new WeakMap(), cxe = /* @__PURE__ */ new WeakMap(), wd = /* @__PURE__ */ new WeakMap(), xy = /* @__PURE__ */ new WeakMap(), Dh = /* @__PURE__ */ new WeakSet();
  let kA, BQ = 0, wQ = 0;
  const Aa = "__aa_tgt", kg = "__aa_del", Qy = "__aa_new", uxe = (t) => {
    const e = mxe(t);
    e && e.forEach((i) => Exe(i));
  }, dxe = (t) => {
    t.forEach((e) => {
      e.target === kA && gxe(), In.has(e.target) && pc(e.target);
    });
  };
  function hxe(t) {
    const e = jM.get(t);
    e == null || e.disconnect();
    let i = In.get(t), r = 0;
    const n = 5;
    i || (i = Cd(t), In.set(t, i));
    const { offsetWidth: s, offsetHeight: o } = kA, A = [
      i.top - n,
      s - (i.left + n + i.width),
      o - (i.top + n + i.height),
      i.left - n
    ].map((c) => `${-1 * Math.floor(c)}px`).join(" "), l = new IntersectionObserver(() => {
      ++r > 1 && pc(t);
    }, {
      root: kA,
      threshold: 1,
      rootMargin: A
    });
    l.observe(t), jM.set(t, l);
  }
  function pc(t) {
    clearTimeout(xy.get(t));
    const e = uw(t), i = Yg(e) ? 500 : e.duration;
    xy.set(t, setTimeout(async () => {
      const r = Kl.get(t);
      try {
        await (r == null ? void 0 : r.finished), In.set(t, Cd(t)), hxe(t);
      } catch {
      }
    }, i));
  }
  function gxe() {
    clearTimeout(xy.get(kA)), xy.set(kA, setTimeout(() => {
      uG.forEach((t) => fG(t, (e) => dG(() => pc(e))));
    }, 100));
  }
  function fxe(t) {
    setTimeout(() => {
      cxe.set(t, setInterval(() => dG(pc.bind(null, t)), 2e3));
    }, Math.round(2e3 * Math.random()));
  }
  function dG(t) {
    typeof requestIdleCallback == "function" ? requestIdleCallback(() => t()) : requestAnimationFrame(() => t());
  }
  let HM, Mu;
  const pxe = typeof window < "u" && "ResizeObserver" in window;
  pxe && (kA = document.documentElement, HM = new MutationObserver(uxe), Mu = new ResizeObserver(dxe), window.addEventListener("scroll", () => {
    wQ = window.scrollY, BQ = window.scrollX;
  }), Mu.observe(kA));
  function mxe(t) {
    return t.reduce((r, n) => [
      ...r,
      ...Array.from(n.addedNodes),
      ...Array.from(n.removedNodes)
    ], []).every((r) => r.nodeName === "#comment") ? !1 : t.reduce((r, n) => {
      if (r === !1)
        return !1;
      if (n.target instanceof Element) {
        if (YC(n.target), !r.has(n.target)) {
          r.add(n.target);
          for (let s = 0; s < n.target.children.length; s++) {
            const o = n.target.children.item(s);
            if (o) {
              if (kg in o)
                return !1;
              YC(n.target, o), r.add(o);
            }
          }
        }
        if (n.removedNodes.length)
          for (let s = 0; s < n.removedNodes.length; s++) {
            const o = n.removedNodes[s];
            if (kg in o)
              return !1;
            o instanceof Element && (r.add(o), YC(n.target, o), Bd.set(o, [
              n.previousSibling,
              n.nextSibling
            ]));
          }
      }
      return r;
    }, /* @__PURE__ */ new Set());
  }
  function YC(t, e) {
    !e && !(Aa in t) ? Object.defineProperty(t, Aa, { value: t }) : e && !(Aa in e) && Object.defineProperty(e, Aa, { value: t });
  }
  function Exe(t) {
    var e;
    const i = t.isConnected, r = In.has(t);
    i && Bd.has(t) && Bd.delete(t), Kl.has(t) && ((e = Kl.get(t)) === null || e === void 0 || e.cancel()), Qy in t ? X2(t) : r && i ? Bxe(t) : r && !i ? wxe(t) : X2(t);
  }
  function yo(t) {
    return Number(t.replace(/[^0-9.\-]/g, ""));
  }
  function yxe(t) {
    let e = t.parentElement;
    for (; e; ) {
      if (e.scrollLeft || e.scrollTop)
        return { x: e.scrollLeft, y: e.scrollTop };
      e = e.parentElement;
    }
    return { x: 0, y: 0 };
  }
  function Cd(t) {
    const e = t.getBoundingClientRect(), { x: i, y: r } = yxe(t);
    return {
      top: e.top + r,
      left: e.left + i,
      width: e.width,
      height: e.height
    };
  }
  function hG(t, e, i) {
    let r = e.width, n = e.height, s = i.width, o = i.height;
    const a = getComputedStyle(t);
    if (a.getPropertyValue("box-sizing") === "content-box") {
      const l = yo(a.paddingTop) + yo(a.paddingBottom) + yo(a.borderTopWidth) + yo(a.borderBottomWidth), c = yo(a.paddingLeft) + yo(a.paddingRight) + yo(a.borderRightWidth) + yo(a.borderLeftWidth);
      r -= c, s -= c, n -= l, o -= l;
    }
    return [r, s, n, o].map(Math.round);
  }
  function uw(t) {
    return Aa in t && wd.has(t[Aa]) ? wd.get(t[Aa]) : { duration: 250, easing: "ease-in-out" };
  }
  function gG(t) {
    if (Aa in t)
      return t[Aa];
  }
  function CQ(t) {
    const e = gG(t);
    return e ? Dh.has(e) : !1;
  }
  function fG(t, ...e) {
    e.forEach((i) => i(t, wd.has(t)));
    for (let i = 0; i < t.children.length; i++) {
      const r = t.children.item(i);
      r && e.forEach((n) => n(r, wd.has(r)));
    }
  }
  function bQ(t) {
    return Array.isArray(t) ? t : [t];
  }
  function Yg(t) {
    return typeof t == "function";
  }
  function Bxe(t) {
    const e = In.get(t), i = Cd(t);
    if (!CQ(t))
      return In.set(t, i);
    let r;
    if (!e)
      return;
    const n = uw(t);
    if (typeof n != "function") {
      const s = e.left - i.left, o = e.top - i.top, [a, A, l, c] = hG(t, e, i), u = {
        transform: `translate(${s}px, ${o}px)`
      }, d = {
        transform: "translate(0, 0)"
      };
      a !== A && (u.width = `${a}px`, d.width = `${A}px`), l !== c && (u.height = `${l}px`, d.height = `${c}px`), r = t.animate([u, d], {
        duration: n.duration,
        easing: n.easing
      });
    } else {
      const [s] = bQ(n(t, "remain", e, i));
      r = new Animation(s), r.play();
    }
    Kl.set(t, r), In.set(t, i), r.addEventListener("finish", pc.bind(null, t));
  }
  function X2(t) {
    Qy in t && delete t[Qy];
    const e = Cd(t);
    In.set(t, e);
    const i = uw(t);
    if (!CQ(t))
      return;
    let r;
    if (typeof i != "function")
      r = t.animate([
        { transform: "scale(.98)", opacity: 0 },
        { transform: "scale(0.98)", opacity: 0, offset: 0.5 },
        { transform: "scale(1)", opacity: 1 }
      ], {
        duration: i.duration * 1.5,
        easing: "ease-in"
      });
    else {
      const [n] = bQ(i(t, "add", e));
      r = new Animation(n), r.play();
    }
    Kl.set(t, r), r.addEventListener("finish", pc.bind(null, t));
  }
  function Z2(t, e) {
    var i;
    t.remove(), In.delete(t), Bd.delete(t), Kl.delete(t), (i = jM.get(t)) === null || i === void 0 || i.disconnect(), setTimeout(() => {
      if (kg in t && delete t[kg], Object.defineProperty(t, Qy, { value: !0, configurable: !0 }), e && t instanceof HTMLElement)
        for (const r in e)
          t.style[r] = "";
    }, 0);
  }
  function wxe(t) {
    var e;
    if (!Bd.has(t) || !In.has(t))
      return;
    const [i, r] = Bd.get(t);
    Object.defineProperty(t, kg, { value: !0, configurable: !0 });
    const n = window.scrollX, s = window.scrollY;
    if (r && r.parentNode && r.parentNode instanceof Element ? r.parentNode.insertBefore(t, r) : i && i.parentNode ? i.parentNode.appendChild(t) : (e = gG(t)) === null || e === void 0 || e.appendChild(t), !CQ(t))
      return Z2(t);
    const [o, a, A, l] = bxe(t), c = uw(t), u = In.get(t);
    (n !== BQ || s !== wQ) && Cxe(t, n, s, c);
    let d, h = {
      position: "absolute",
      top: `${o}px`,
      left: `${a}px`,
      width: `${A}px`,
      height: `${l}px`,
      margin: "0",
      pointerEvents: "none",
      transformOrigin: "center",
      zIndex: "100"
    };
    if (!Yg(c))
      Object.assign(t.style, h), d = t.animate([
        {
          transform: "scale(1)",
          opacity: 1
        },
        {
          transform: "scale(.98)",
          opacity: 0
        }
      ], { duration: c.duration, easing: "ease-out" });
    else {
      const [g, f] = bQ(c(t, "remove", u));
      (f == null ? void 0 : f.styleReset) !== !1 && (h = (f == null ? void 0 : f.styleReset) || h, Object.assign(t.style, h)), d = new Animation(g), d.play();
    }
    Kl.set(t, d), d.addEventListener("finish", Z2.bind(null, t, h));
  }
  function Cxe(t, e, i, r) {
    const n = BQ - e, s = wQ - i, o = document.documentElement.style.scrollBehavior;
    if (getComputedStyle(kA).scrollBehavior === "smooth" && (document.documentElement.style.scrollBehavior = "auto"), window.scrollTo(window.scrollX + n, window.scrollY + s), !t.parentElement)
      return;
    const A = t.parentElement;
    let l = A.clientHeight, c = A.clientWidth;
    const u = performance.now();
    function d() {
      requestAnimationFrame(() => {
        if (!Yg(r)) {
          const h = l - A.clientHeight, g = c - A.clientWidth;
          u + r.duration > performance.now() ? (window.scrollTo({
            left: window.scrollX - g,
            top: window.scrollY - h
          }), l = A.clientHeight, c = A.clientWidth, d()) : document.documentElement.style.scrollBehavior = o;
        }
      });
    }
    d();
  }
  function bxe(t) {
    const e = In.get(t), [i, , r] = hG(t, e, Cd(t));
    let n = t.parentElement;
    for (; n && (getComputedStyle(n).position === "static" || n instanceof HTMLBodyElement); )
      n = n.parentElement;
    n || (n = document.body);
    const s = getComputedStyle(n), o = In.get(n) || Cd(n), a = Math.round(e.top - o.top) - yo(s.borderTopWidth), A = Math.round(e.left - o.left) - yo(s.borderLeftWidth);
    return [a, A, i, r];
  }
  function pG(t, e = {}) {
    return HM && Mu && (window.matchMedia("(prefers-reduced-motion: reduce)").matches && !Yg(e) && !e.disrespectUserMotionPreference || (Dh.add(t), getComputedStyle(t).position === "static" && Object.assign(t.style, { position: "relative" }), fG(t, pc, fxe, (n) => Mu == null ? void 0 : Mu.observe(n)), Yg(e) ? wd.set(t, e) : wd.set(t, { duration: 250, easing: "ease-in-out", ...e }), HM.observe(t, { childList: !0 }), uG.add(t))), Object.freeze({
      parent: t,
      enable: () => {
        Dh.add(t);
      },
      disable: () => {
        Dh.delete(t);
      },
      isEnabled: () => Dh.has(t)
    });
  }
  const Mxe = {
    mounted: (t, e) => {
      pG(t, e.value || {});
    },
    // ignore ssr see #96:
    getSSRProps: () => ({})
  };
  var Fy = /* @__PURE__ */ new Map(), mG = /* @__PURE__ */ new Map(), Ixe = 0, ru = null, q2 = 0;
  function vxe() {
    $2(), ru = new MutationObserver(() => {
      $2(), !Fy.size && ru && (ru.disconnect(), ru = null);
    }), ru.observe(document, { childList: !0, subtree: !0 });
  }
  function $2() {
    Fy.forEach((t, e) => {
      document.getElementById(e) && (clearTimeout(q2), Fy.delete(e), q2 = setTimeout(() => {
        document.querySelectorAll("[data-auto-animate]").forEach((n) => {
          let s;
          const o = n.getAttribute("data-auto-animate");
          o && (s = mG.get(o)), pG(n, s || t || {});
        });
      }, 250));
    });
  }
  function xxe(t, e = {}) {
    return (i) => {
      i.on("created", () => {
        var r;
        if (typeof ((r = i.props.definition) == null ? void 0 : r.schema) == "function") {
          if (typeof window === void 0)
            return;
          const n = i.props.definition.schema;
          i.props.definition.schema = (s) => {
            const o = n(s), a = Array.isArray(o) ? o[0] : o;
            return iu(
              a,
              (A) => {
                var l, c, u, d;
                if (_g(A)) {
                  let h = !1;
                  const g = (l = A == null ? void 0 : A.meta) == null ? void 0 : l.section;
                  let f = !0;
                  if ((c = A == null ? void 0 : A.meta) != null && c.autoAnimate && (h = !0, typeof A.meta.autoAnimate == "object")) {
                    const p = Object.assign(
                      {},
                      t,
                      A.meta.autoAnimate
                    );
                    f = `${i.props.id}-${Ixe++}`, mG.set(f, p);
                  }
                  if (!h && g && typeof g == "string" && ((u = e.global) != null && u.includes(g) || (d = e[i.props.type]) != null && d.includes(g)) && (h = !0), !h)
                    return;
                  A != null && A.attrs ? Object.assign(A.attrs, {
                    "data-auto-animate": f
                  }) : A.attrs = { "data-auto-animate": f }, i.props.id && Fy.set(i.props.id, t);
                }
              }
            ), a;
          };
        }
        !ru && typeof window < "u" && vxe();
      });
    };
  }
  var Qxe = /* @__PURE__ */ We("wrapper", () => ({
    $el: "div",
    attrs: {
      "data-tab-style": "$tabStyle",
      "data-hide-labels": "$hideProgressLabels"
    }
  })), ek = /* @__PURE__ */ We("badge", () => ({
    $el: "span",
    attrs: {
      role: "presentation"
    }
  })), Fxe = /* @__PURE__ */ We("stepActions", () => ({
    $el: "div"
  })), Sxe = /* @__PURE__ */ We("stepInner", "div"), Dxe = /* @__PURE__ */ We("stepNext", () => ({
    $el: "div",
    if: "$isLastStep === false || $stepIndex === 0",
    children: [
      {
        $cmp: "FormKit",
        bind: "$nextAttrs",
        props: {
          type: "button",
          label: {
            if: "$nextLabel",
            then: "$nextLabel",
            else: "$ui.next.value"
          },
          "data-next": "$isLastStep === false",
          onClick: "$handlers.next"
        }
      }
    ]
  })), Txe = /* @__PURE__ */ We("stepOuter", () => ({
    $el: "div",
    attrs: {
      key: "$id",
      "data-type": "step",
      "data-disabled": "$disabled || undefined",
      "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
      "data-errors": "$state.errors || undefined",
      "data-submitted": "$state.submitted || undefined",
      id: "$id",
      role: "tabpanel",
      "aria-labelledby": '$node.parent.props.id + "_tab_" + $stepIndex',
      class: "$classes.step",
      hidden: "$isActiveStep === false || undefined"
    }
  })), Rxe = /* @__PURE__ */ We("stepPrevious", () => ({
    $el: "div",
    if: "$isFirstStep === false",
    children: [
      {
        $cmp: "FormKit",
        bind: "$previousAttrs",
        props: {
          type: "button",
          label: {
            if: "$previousLabel",
            then: "$previousLabel",
            else: "$ui.prev.value"
          },
          "data-prev": "$isFirstStep === false",
          onClick: "$handlers.previous"
        }
      }
    ]
  })), _xe = /* @__PURE__ */ We("steps", () => ({
    $el: "div"
  })), kxe = (t, e) => (/* @__PURE__ */ We(`${t}Icon`, () => {
    const i = `_raw${t.charAt(0).toUpperCase()}${t.slice(1)}Icon`;
    return {
      if: `$step.${t}Icon && $step.${i}`,
      then: {
        $el: "span",
        attrs: {
          class: `$classes.${t}Icon + " formkit-icon"`,
          innerHTML: `$step.${i}`,
          role: "presentation",
          onClick: `$handlers.iconClick(${t})`
        }
      },
      else: {
        if: `$${t}Icon && $${i}`,
        then: {
          $el: "span",
          attrs: {
            class: `$classes.${t}Icon + " formkit-icon"`,
            innerHTML: `$${i}`,
            role: "presentation",
            onClick: `$handlers.iconClick(${t})`
          }
        }
      }
    };
  }))(), Yxe = /* @__PURE__ */ We("tab", () => ({
    $el: "button",
    for: ["step", "index", "$fns.getSteps()"],
    attrs: {
      key: "$step.id",
      type: "button",
      onClick: "$step.makeActive",
      "data-active": "$step.isActiveStep",
      "data-valid": "$step.isValid",
      "data-visited": "$step.hasBeenVisited",
      role: "tab",
      id: '$id + "_tab_" + $index',
      "aria-selected": "$step.isActiveStep || false",
      "aria-controls": "$step.id",
      tabindex: {
        if: "$step.isActiveStep",
        then: "0",
        else: "-1"
      }
    }
  })), Nxe = /* @__PURE__ */ We("tabLabel", () => ({
    $el: "span"
  })), Uxe = /* @__PURE__ */ We("tabs", () => ({
    $el: "div",
    attrs: {
      role: "tablist"
    }
  })), Lxe = /* @__PURE__ */ We("multiStepOuter", () => ({
    $el: "div",
    attrs: {
      key: "$id",
      id: "$id",
      class: "$classes.outer",
      "data-prerender": "$fns.preRenderSteps()",
      "data-family": "$family || undefined",
      "data-type": "$type",
      "data-multiple": '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
      "data-disabled": "$disabled || undefined",
      "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
      "data-errors": "$state.errors || undefined",
      "data-submitted": "$state.submitted || undefined"
    }
  })), zxe = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: Lxe(
      Qxe(
        Uxe(
          Yxe(
            /* @__PURE__ */ ls(
              '$tabStyle === "tab" || ($tabStyle === "progress" && $hideProgressLabels === false)',
              Nxe("$step.stepName")
            ),
            /* @__PURE__ */ ls(
              "($step.totalErrorCount > 0) && $step.showStepErrors",
              ek("$step.totalErrorCount")
            ),
            /* @__PURE__ */ ls(
              "$step.isValid && $step.hasBeenVisited",
              ek(kxe("validStep"))
            )
          )
        ),
        _xe("$slots.default")
      )
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "group",
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: "multi-step",
    /**
     * An array of extra props to accept for this input.
     */
    props: [
      "allowIncomplete",
      "hideProgressLabels",
      "tabStyle",
      "beforeStepChange",
      "validStepIcon"
    ],
    /**
     * Additional features that should be added to your input
     */
    features: [kl("validStep", "check"), zf]
  }, Pxe = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: Txe(
      Sxe("$slots.default"),
      Fxe(Rxe(), Dxe())
    ),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: "group",
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: "",
    /**
     * An array of extra props to accept for this input.
     */
    props: [
      "previousLabel",
      "nextLabel",
      "beforeStepChange",
      "previousAttrs",
      "nextAttrs",
      "validStepIcon"
    ],
    /**
     * Additional features that should be added to your input
     */
    features: [Pu("next"), Pu("prev"), zf]
  }, EG = typeof window < "u", yG = (t) => t && t.replace(/([A-Z])/g, (e) => ` ${e}`).replace(/^./, (e) => e.toUpperCase()).trim();
  function tk(t, e) {
    if (!EG || !e)
      return e;
    const i = [...e];
    return i.sort((r, n) => {
      var a, A;
      const s = (a = t.props.__root) == null ? void 0 : a.getElementById(r.id), o = (A = t.props.__root) == null ? void 0 : A.getElementById(n.id);
      return !s || !o ? 0 : s.compareDocumentPosition(o) === 2 ? 1 : -1;
    }), i.map((r) => {
      r.ordered = !0;
    }), i;
  }
  function NC(t) {
    t && t.forEach((e, i) => {
      e.isFirstStep = i === 0, e.isLastStep = i === t.length - 1, e.stepIndex = i, e.steps = t;
    });
  }
  function Oxe(t) {
    if (t.showStepErrors)
      return parseInt(t.blockingCount) + parseInt(t.errorCount) > 0;
  }
  async function BG(t, e) {
    var l, c, u;
    if (t === e)
      return !0;
    const { allowIncomplete: i } = ((l = t.node.parent) == null ? void 0 : l.props) || {}, r = t.node.parent, n = r == null ? void 0 : r.props.steps.indexOf(t), s = r == null ? void 0 : r.props.steps.indexOf(e), o = JM(t);
    if (t.showStepErrors = !0, s >= n && !o && !i)
      return !1;
    const a = s - n;
    for (let d = 0; d < a; d++) {
      const h = r == null ? void 0 : r.props.steps[n + d];
      if (!(i || ((c = h.state) == null ? void 0 : c.valid)))
        return !1;
    }
    const A = t.node.props.beforeStepChange || ((u = t.node.parent) == null ? void 0 : u.props.beforeStepChange);
    if (A && typeof A == "function") {
      r && (r == null || r.store.set(
        /* @__PURE__ */ nn({
          key: "loading",
          value: !0,
          visible: !1
        })
      ), r.props.disabled = !0, t.disabled = !0);
      const d = await A({
        currentStep: t,
        targetStep: e,
        delta: s - n
      });
      if (r && (r == null || r.store.remove("loading"), r.props.disabled = !1, t.disabled = !1), typeof d == "boolean" && !d)
        return !1;
    }
    return !0;
  }
  async function Wp(t, e) {
    if (e && e.preventDefault(), t && t.node.name && t.node.parent) {
      const i = t.node.parent.props.steps.find(
        (n) => {
          var s;
          return n.node.name === ((s = t.node.parent) == null ? void 0 : s.props.activeStep);
        }
      );
      await BG(i, t) && t.node.parent.context && (t.node.parent.props.activeStep = t.node.name);
    }
  }
  async function nu(t, e) {
    if (e && e.node.name && e.node.parent) {
      const i = e.node.parent.props.steps, r = e.stepIndex, n = i[r + t];
      if (!n)
        return;
      const s = await BG(e, n);
      n && s && (e.node.parent.props.activeStep = n.node.name);
    }
  }
  function JM(t) {
    var e, i;
    return t.node.walk((r) => {
      r.store.set(
        /* @__PURE__ */ nn({
          key: "submitted",
          value: !0,
          visible: !1
        })
      );
    }), ((e = t.node.context) == null ? void 0 : e.state.valid) || ((i = t.node.parent) == null ? void 0 : i.props.allowIncomplete);
  }
  function Gxe(t, e) {
    e instanceof HTMLElement && e.addEventListener("keydown", (i) => {
      var r;
      if (i.target instanceof HTMLButtonElement && i.key === "Tab" && "data-next" in ((r = i.target) == null ? void 0 : r.attributes) && !i.shiftKey) {
        i.preventDefault();
        const n = t.children.find(
          (s) => !hQ(s) && s.name === t.props.activeStep
        );
        n && n.context && nu(1, n.context);
      }
    });
  }
  function jxe(t) {
    return !t || !t.length ? [] : (t[0].type == Symbol.for("v-fgt") && t[0].children ? t[0].children : t).map(
      (r, n) => {
        var s, o, a;
        return {
          __isPlaceholder: !0,
          stepName: ((s = r.props) == null ? void 0 : s.label) || yG((o = r.props) == null ? void 0 : o.name),
          isFirstStep: n === 0,
          isLastStep: n === t.length - 1,
          isActiveStep: n === 0,
          node: {
            name: (a = r.props) == null ? void 0 : a.name
          }
        };
      }
    );
  }
  function Hxe(t) {
    return () => {
      if (!t.context || t.props.steps)
        return;
      let e = [];
      t.context.slots && t.context.slots.default && (e = t.context.slots.default()), t.props.steps = t.props.steps || jxe(e), t.context.stepCount = t.props.steps.length;
    };
  }
  function Jxe(t) {
    let e = !0;
    const i = (r) => {
      var n, s;
      if (r.props.type === "multi-step") {
        if (!r.context)
          return;
        e = !0, r.addProps(["steps", "tabs", "activeStep"]), r.context.fns.preRenderSteps = Hxe(r), r.context.fns.getStepCount = () => {
          if (r.context)
            return r.context.stepCount;
        }, r.context.fns.getSteps = () => {
          if (r.context)
            return r.context.steps;
        }, r.props.allowIncomplete = typeof r.props.allowIncomplete == "boolean" ? r.props.allowIncomplete : !0, r.props.hideProgressLabels = typeof r.props.hideProgressLabels == "boolean" ? r.props.hideProgressLabels : !1, r.props.tabStyle = r.props.tabStyle || (t == null ? void 0 : t.tabStyle) || "tab", r.context.handlers.triggerStepValidations = JM, r.context.handlers.showStepErrors = Oxe, r.on("created", () => {
          r.context && (r.extend("next", {
            get: (o) => () => {
              var a;
              nu(
                1,
                (a = o == null ? void 0 : o.props) == null ? void 0 : a.steps.find(
                  (A) => A.isActiveStep
                )
              );
            },
            set: !1
          }), r.extend("previous", {
            get: (o) => () => {
              var a;
              nu(
                -1,
                (a = o == null ? void 0 : o.props) == null ? void 0 : a.steps.find(
                  (A) => A.isActiveStep
                )
              );
            },
            set: !1
          }), r.extend("goTo", {
            get: (o) => (a) => {
              if (typeof a == "number") {
                const A = o.props.steps[a];
                Wp(A);
              } else if (typeof a == "string") {
                const A = o.props.steps.find(
                  (l) => l.node.name === a
                );
                Wp(A);
              }
            },
            set: !1
          }), Rb(
            `${r.props.id}`,
            (o) => {
              Gxe(r, o);
            },
            r.props.__root
          ));
        }), r.on("child", ({ payload: o }) => {
          r.props.steps && r.props.steps.length && (r.props.steps = r.props.steps.filter(
            (a) => !a.__isPlaceholder
          )), r.props.steps = Array.isArray(r.props.steps) && r.props.steps.length > 0 ? [...r.props.steps, o.context] : [o.context], r.props.steps = tk(r, r.props.steps), NC(r.props.steps), o.props.stepName = o.props.label || yG(o.name), o.props.errorCount = 0, o.props.blockingCount = 0, o.props.isActiveStep = e, e = !1, r.props.activeStep = r.props.activeStep ? r.props.activeStep : r.props.steps[0] ? r.props.steps[0].node.name : "";
        }), r.on("prop:activeStep", ({ payload: o }) => {
          r.children.forEach((a) => {
            var A;
            if (!hQ(a) && (a.props.isActiveStep = a.name === o, EG && a.name === o)) {
              const l = (A = r.props.__root) == null ? void 0 : A.querySelector(
                `[aria-controls="${a.props.id}"]`
              );
              l instanceof HTMLButtonElement && l.focus();
            }
          });
        }), r.on("childRemoved", ({ payload: o }) => {
          let a = -1;
          if (o.props.ordered = !1, r.props.steps = r.props.steps.filter(
            (A, l) => A.node.name !== o.name ? !0 : (a = l, !1)
          ), NC(r.props.steps), r.props.activeStep === o.name) {
            const A = a > 0 ? a - 1 : 0;
            r.props.activeStep = r.props.steps[A] ? r.props.steps[A].node.name : "";
          }
        });
      } else if (r.props.type === "step" && ((n = r.parent) == null ? void 0 : n.props.type) === "multi-step") {
        let o = function(A) {
          A.props.totalErrorCount = A.props.errorCount + A.props.blockingCount;
        };
        if (!r.context || !r.parent || !r.parent.context)
          return;
        r.addProps([
          "isActiveStep",
          "isFirstStep",
          "isLastStep",
          "stepName",
          "errorCount",
          "blockingCount",
          "totalErrorCount",
          "showStepErrors",
          "isValid",
          "hasBeenVisited",
          "ordered"
        ]);
        const a = r.parent;
        r.on("created", () => {
          !r.context || !a.context || Rb(
            `${r.props.id}`,
            () => {
              a.props.steps = tk(r, a.props.steps), NC(a.props.steps);
            },
            r.props.__root
          );
        }), r.context && a.context && (a.context.handlers.setActiveStep = (A) => Wp.bind(null, A), r.context.handlers.incrementStep = (A) => () => nu(A, r.context), r.context.makeActive = () => {
          Wp(r.context);
        }, r.context.handlers.next = () => nu(1, r.context), r.context.handlers.previous = () => nu(-1, r.context)), r.on("count:errors", ({ payload: A }) => {
          r.props.errorCount = A;
        }), r.on("count:blocking", ({ payload: A }) => {
          r.props.blockingCount = A;
        }), r.on("prop:errorCount", () => o(r)), r.on("prop:blockingCount", () => o(r)), r.on("prop:totalErrorCount", () => {
          r.props.isValid = r.props.totalErrorCount <= 0;
        }), r.on("message-added", ({ payload: A }) => {
          A.key === "submitted" && (o(r), r.context && (JM(r.context), r.props.showStepErrors = !0));
        }), r.on("prop:isActiveStep", () => {
          !r.props.hasBeenVisited && r.props.isActiveStep && (r.props.hasBeenVisited = !0);
        });
      } else ((s = r.parent) == null ? void 0 : s.props.type) === "multi-step" && console.warn(
        'Invalid FormKit input location. <FormKit type="multi-step"> should only have <FormKit type="step"> inputs as immediate children. Failure to wrap child inputs in <FormKit type="step"> can lead to undesired behaviors.'
      );
    };
    return i.library = (r) => {
      switch (r.props.type) {
        case "multi-step":
          return r.define(zxe);
        case "step":
          return (!r.parent || r.parent.props.type !== "multi-step") && console.warn(
            'Invalid use of <FormKit type="step">. <FormKit type="step"> must be an immediate child of a <FormKit type="multi-step"> component.'
          ), r.define(Pxe);
      }
    }, i;
  }
  const Vxe = Mxe, Wxe = {
    install(t) {
      t.directive("auto-animate", Vxe);
    }
  }, Kxe = yve({
    // applies to all input types
    global: {
      outer: "",
      wrapper: "form-field",
      label: "form-label fw-semibold",
      inner: "input-group",
      input: "form-control",
      help: "form-text",
      prefixIcon: "input-group-text",
      suffixIcon: "input-group-text",
      message: "pt-1"
    },
    // only applies to forms
    form: {
      messages: "mb-3",
      message: "fs-6",
      summaryHeader: "fs-5 fw-bold text-danger"
    },
    // only applies to radio input type
    radio: {
      wrapper: "form-check",
      fieldset: "input-field",
      legend: "form-label fs-6 fw-semibold",
      inner: "$reset d-block",
      options: "input-field input-group",
      option: "input-option py-1",
      input: "form-check-input",
      label: "form-check-label"
    },
    // only applies to checkbox input type
    checkbox: {
      wrapper: "form-check",
      fieldset: "input-field",
      legend: "form-label fs-6 fw-semibold",
      inner: "$reset d-block",
      options: "input-field input-group",
      option: "input-option py-1",
      input: "form-check-input",
      label: "form-check-label"
    },
    // only applies to select input type
    select: {
      input: "$reset form-control form-select arrowed",
      option: "$reset input-option ",
      inner: "select"
    },
    // only applies to custom katalog input type
    tag: {
      dropdown: "dropdown",
      menu: "dropdown-menu",
      dropdownItem: "dropdown-item clickable",
      searchbar: "searchbar form-control",
      input: "form-select",
      suffix: "input-group-text",
      tag: "badge rounded-pill",
      empty: "py-2 px-3",
      placeholder: "opacity-90",
      loading: "spinner-grow spinner-grow-sm text-gray",
      close: "dps-icon dps-icon--close d-print-none"
    },
    // only applies to multi-step input type
    "multi-step": {
      tabs: "nav nav-tabs",
      tab: "nav-link",
      badge: "badge rounded-pill",
      tabLabel: "fw-semibold"
    },
    // only applies to transfer-list input type
    "transfer-list": {
      outer: "d-flex",
      sourceHeader: "pb-2",
      sourceHeaderLabel: "fw-bold",
      sourceContainer: "d-flex",
      sourceList: "list-group overflow-y-scroll box focus-ring",
      sourceItem: "list-group-item",
      sourceItemSelected: "active",
      sourceControls: "d-flex flex-column justify-content-center mx-4",
      targetHeader: "pb-2",
      targetHeaderLabel: "fw-bold",
      targetContainer: "d-flex",
      targetList: "list-group overflow-y-scroll box focus-ring",
      targetItem: "list-group-item",
      targetItemSelected: "active",
      targetControls: "d-flex flex-column justify-content-center mx-4",
      control: "mb-2"
    }
  }), ik = {
    // applies to all input types
    global: {
      messages: { $el: "div" },
      message: { $el: "span" }
    },
    // only applies to radio input type
    radio: {
      inner: { $el: null },
      decorator: { $el: null },
      options: { $el: "div" },
      option: { $el: "span" }
    },
    // only applies to checkbox input type
    checkbox: {
      decorator: { $el: null }
    }
  }, Xxe = {
    config: {
      /** add global css classes for speific nodes based on node type */
      classes: Kxe
    },
    plugins: [
      /** edit all nodes on create */
      (t) => {
        t.on("created", () => {
          var i, r;
          if (!((i = t.props) != null && i.definition)) return;
          const e = (r = t.props.definition) == null ? void 0 : r.schema;
          t.props.definition.schema = (n = {}) => {
            const s = ik.global || {}, o = ik[t.props.type] || {};
            return n = Object.assign(n, s, o), e(n);
          };
        });
      }
    ]
  };
  function Zxe() {
    const t = ["checkbox_multi", "radio_multi", "repeater", "transferlist"];
    function e(i) {
      ["button", "submit", "hidden", "group", "list", "meta"].includes(i.props.type) || i.on("created", () => {
        var s, o, a;
        if (!((s = i.props) != null && s.definition)) return;
        const r = t.includes(
          `${i.props.type}${i.props.options ? "_multi" : ""}`
        ) ? "legend" : "label";
        (o = i.props.definition) != null && o.schemaMemoKey && (i.props.definition.schemaMemoKey += `${i.props.options ? "_multi" : ""}_add_asterisk`);
        const n = (a = i.props.definition) == null ? void 0 : a.schema;
        i.props.definition.schema = (A = {}) => (A[r] = {
          children: [
            "$label",
            {
              $el: "span",
              if: "$state.required",
              attrs: {
                class: "$classes.asterisk"
              },
              children: ["*"]
            }
          ]
        }, n(A));
      });
    }
    return e;
  }
  function qxe() {
    return (e) => {
      e.props.type === "textarea" && (e.addProps(["autoHeight", "maxAutoHeight", "minAutoHeight"]), e.on("mounted", () => {
        const i = ns(e.props.autoHeight), r = Number.isFinite(e.props.maxAutoHeight) ? parseInt(e.props.maxAutoHeight) : void 0, n = Number.isFinite(e.props.minAutoHeight) ? parseInt(e.props.minAutoHeight) : void 0;
        if (!i || !e.context) return;
        let s = null;
        Rb(
          e.context.id,
          () => {
            var d, h;
            if (s = (h = e.props.__root) == null ? void 0 : h.getElementById(
              (d = e == null ? void 0 : e.context) != null && d.id ? e.context.id : ""
            ), !(s instanceof HTMLTextAreaElement)) return;
            if (!document.getElementById("formkit-auto-height-textarea-style")) {
              const g = document.createElement("style");
              g.setAttribute("id", "formkit-auto-height-textarea-style"), g.textContent = ".formkit-auto-height-textarea { scrollbar-width: none; } .formkit-auto-height-textarea::-webkit-scrollbar { display: none; }", document.body.appendChild(g);
            }
            const o = s.cloneNode(!1);
            o.classList.add("formkit-auto-height-textarea"), (!r || !n) && s.classList.add("formkit-auto-height-textarea"), o.setAttribute(
              "style",
              "height: 0; min-height: 0; pointer-events: none; opacity: 0;  left: -9999px; padding-top: 0; padding-bottom: 0; position: absolute; display: block; top: 0; z-index: -1; scrollbar-width: none;"
            ), o.setAttribute("aria-hidden", "true"), o.setAttribute("tabindex", "-1"), o.removeAttribute("name"), o.removeAttribute("id"), o.removeAttribute("aria-describedby");
            const a = getComputedStyle(s).boxSizing === "border-box", A = parseInt(getComputedStyle(s).paddingTop) + parseInt(getComputedStyle(s).paddingBottom), l = parseInt(getComputedStyle(s).paddingTop) + parseInt(getComputedStyle(s).paddingBottom);
            let c = e._value;
            s.after(o), u({ payload: e._value }), e.on("input", u), e.root.on("stepChange", () => {
              const g = String(e.value);
              u({ payload: g });
            });
            async function u({ payload: g }) {
              if (c = g, !s || (await new Promise((E) => setTimeout(E, 10)), c !== g)) return;
              o.value = g;
              const f = a ? s.offsetWidth : s.offsetWidth - l;
              o.style.width = `${f}px`;
              const p = o.scrollHeight;
              let m = a ? p + A : p;
              n && m < n && (m = n), m = r ? Math.min(m, r) : m, s.style.height || (s.style.height = "0px"), s.style.minHeight = `${m}px`;
            }
          },
          e.props.__root
        );
      }));
    };
  }
  const $xe = {
    /**
     * Add FormKit to the Vue instance
     * @param app Vue app instance
     * @param options pass external config to formikit via the options property
     */
    install: (t, e = {}) => {
      let i = {
        // Define additional locales
        locales: { de: bIe },
        // Define the active locale
        locale: "de",
        // Override individual messages
        messages: {
          de: {
            ui: {
              summaryHeader: "Validierungsfehler:"
            }
          }
        },
        // add global plugins
        plugins: [
          // adds smooth transitions when showing and hiding validation messages
          xxe(),
          Zxe(),
          // allows to easily break forms into multi step forms
          Jxe(),
          qxe()
        ]
      };
      i = VM(i, Xxe), i = VM(i, e), t.use(Zve, EQ(i)), t.use(Wxe), console.debug("FormKit Plugin is initialised.");
    }
  };
  function VM(t, e) {
    const i = (r) => r && typeof r == "object";
    return !i(t) || !i(e) ? e : (Object.keys(e).forEach((r) => {
      const n = t[r], s = e[r];
      Array.isArray(n) && Array.isArray(s) ? t[r] = n.concat(s) : i(n) && i(s) ? t[r] = VM({ ...n }, s) : t[r] = s;
    }), t);
  }
  const e1e = {
    install: (t) => {
      t.component("MapFrame", _M), t.use(xCe), t.use($xe);
    }
  }, t1e = `@charset "UTF-8";.btn-close{--diplan-btn-close-color: #04071a;--diplan-btn-close-bg: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%2304071a'%3e%3cpath d='M.293.293a1 1 0 0 1 1.414 0L8 6.586 14.293.293a1 1 0 1 1 1.414 1.414L9.414 8l6.293 6.293a1 1 0 0 1-1.414 1.414L8 9.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L6.586 8 .293 1.707a1 1 0 0 1 0-1.414'/%3e%3c/svg%3e");--diplan-btn-close-opacity: .5;--diplan-btn-close-hover-opacity: .75;--diplan-btn-close-focus-shadow: 0 0 0 .25rem rgba(51, 117, 212, .25);--diplan-btn-close-focus-opacity: 1;--diplan-btn-close-disabled-opacity: .25;box-sizing:content-box;width:1em;height:1em;padding:.25em;color:var(--diplan-btn-close-color);background:transparent var(--diplan-btn-close-bg) center/1em auto no-repeat;filter:var(--diplan-btn-close-filter);border:0;border-radius:2px;opacity:var(--diplan-btn-close-opacity)}.btn-close:hover{color:var(--diplan-btn-close-color);text-decoration:none;opacity:var(--diplan-btn-close-hover-opacity)}.btn-close:focus{outline:0;box-shadow:var(--diplan-btn-close-focus-shadow);opacity:var(--diplan-btn-close-focus-opacity)}.btn-close:disabled,.btn-close.disabled{pointer-events:none;-webkit-user-select:none;user-select:none;opacity:var(--diplan-btn-close-disabled-opacity)}.btn-close-white,.variant-dark>.btn-close,.variant-light>.btn-close,.variant-danger>.btn-close,.variant-warning>.btn-close,.variant-info>.btn-close,.variant-success>.btn-close,.variant-secondary>.btn-close,.variant-primary>.btn-close{--diplan-btn-close-filter: invert(1) grayscale(100%) brightness(200%)}:root,:host,[data-bs-theme=light]{--diplan-btn-close-filter: }[data-bs-theme=dark]{--diplan-btn-close-filter: invert(1) grayscale(100%) brightness(200%)}:root,:host,[data-bs-theme=light]{--diplan-blue: #0d6efd;--diplan-indigo: #6610f2;--diplan-purple: #6f42c1;--diplan-pink: #d63384;--diplan-red: #dc3545;--diplan-orange: #fd7e14;--diplan-yellow: #ffc107;--diplan-green: #198754;--diplan-teal: #20c997;--diplan-cyan: #0dcaf0;--diplan-black: #04071a;--diplan-white: #fff;--diplan-gray: #f7f8fa;--diplan-gray-dark: #343a40;--diplan-medium-gray: #909194;--diplan-gray-light: #dee2e6;--diplan-gray-100: #f8f9fa;--diplan-gray-200: #e9ecef;--diplan-gray-300: #dee2e6;--diplan-gray-400: #ced4da;--diplan-gray-500: #adb5bd;--diplan-gray-600: #6c757d;--diplan-gray-700: #495057;--diplan-gray-800: #343a40;--diplan-gray-900: #212529;--diplan-primary: #3375d4;--diplan-secondary: #ccc;--diplan-success: #00a645;--diplan-info: #ecf4ff;--diplan-warning: #edc700;--diplan-danger: #dc3545;--diplan-light: #ecf4ff;--diplan-dark: #2b3980;--diplan-primary-rgb: 51, 117, 212;--diplan-secondary-rgb: 204, 204, 204;--diplan-success-rgb: 0, 166, 69;--diplan-info-rgb: 236, 244, 255;--diplan-warning-rgb: 237, 199, 0;--diplan-danger-rgb: 220, 53, 69;--diplan-light-rgb: 236, 244, 255;--diplan-dark-rgb: 43, 57, 128;--diplan-primary-text-emphasis: rgb(20.4, 46.8, 84.8);--diplan-secondary-text-emphasis: rgb(81.6, 81.6, 81.6);--diplan-success-text-emphasis: rgb(0, 66.4, 27.6);--diplan-info-text-emphasis: rgb(94.4, 97.6, 102);--diplan-warning-text-emphasis: rgb(94.8, 79.6, 0);--diplan-danger-text-emphasis: rgb(88, 21.2, 27.6);--diplan-light-text-emphasis: #495057;--diplan-dark-text-emphasis: #495057;--diplan-primary-bg-subtle: rgb(214.2, 227.4, 246.4);--diplan-secondary-bg-subtle: rgb(244.8, 244.8, 244.8);--diplan-success-bg-subtle: rgb(204, 237.2, 217.8);--diplan-info-bg-subtle: rgb(251.2, 252.8, 255);--diplan-warning-bg-subtle: rgb(251.4, 243.8, 204);--diplan-danger-bg-subtle: rgb(248, 214.6, 217.8);--diplan-light-bg-subtle: rgb(251.5, 252, 252.5);--diplan-dark-bg-subtle: #ced4da;--diplan-primary-border-subtle: rgb(173.4, 199.8, 237.8);--diplan-secondary-border-subtle: rgb(234.6, 234.6, 234.6);--diplan-success-border-subtle: rgb(153, 219.4, 180.6);--diplan-info-border-subtle: rgb(247.4, 250.6, 255);--diplan-warning-border-subtle: rgb(247.8, 232.6, 153);--diplan-danger-border-subtle: rgb(241, 174.2, 180.6);--diplan-light-border-subtle: #e9ecef;--diplan-dark-border-subtle: #adb5bd;--diplan-white-rgb: 255, 255, 255;--diplan-black-rgb: 4, 7, 26;--diplan-font-sans-serif: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";--diplan-font-monospace: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;--diplan-gradient: linear-gradient(180deg, rgba(255, 255, 255, .15), rgba(255, 255, 255, 0));--diplan-body-font-family: var(--diplan-font-sans-serif);--diplan-body-font-size: 1rem;--diplan-body-font-weight: 400;--diplan-body-line-height: 1.5;--diplan-body-color: #04071a;--diplan-body-color-rgb: 4, 7, 26;--diplan-body-bg: #fff;--diplan-body-bg-rgb: 255, 255, 255;--diplan-emphasis-color: #04071a;--diplan-emphasis-color-rgb: 4, 7, 26;--diplan-secondary-color: rgba(4, 7, 26, .75);--diplan-secondary-color-rgb: 4, 7, 26;--diplan-secondary-bg: #e9ecef;--diplan-secondary-bg-rgb: 233, 236, 239;--diplan-tertiary-color: rgba(4, 7, 26, .5);--diplan-tertiary-color-rgb: 4, 7, 26;--diplan-tertiary-bg: #f8f9fa;--diplan-tertiary-bg-rgb: 248, 249, 250;--diplan-heading-color: inherit;--diplan-link-color: #3375d4;--diplan-link-color-rgb: 51, 117, 212;--diplan-link-decoration: underline;--diplan-link-hover-color: rgb(40.8, 93.6, 169.6);--diplan-link-hover-color-rgb: 41, 94, 170;--diplan-code-color: #d63384;--diplan-highlight-color: #04071a;--diplan-highlight-bg: rgb(255, 242.6, 205.4);--diplan-border-width: 1px;--diplan-border-style: solid;--diplan-border-color: #ccc;--diplan-border-color-translucent: rgba(4, 7, 26, .175);--diplan-border-radius: 2px;--diplan-border-radius-sm: .25rem;--diplan-border-radius-lg: .5rem;--diplan-border-radius-xl: 1rem;--diplan-border-radius-xxl: 2rem;--diplan-border-radius-2xl: var(--diplan-border-radius-xxl);--diplan-border-radius-pill: 50rem;--diplan-box-shadow: 0 .5rem 1rem rgba(4, 7, 26, .15);--diplan-box-shadow-sm: 0 .125rem .25rem rgba(4, 7, 26, .075);--diplan-box-shadow-lg: 0 1rem 3rem rgba(4, 7, 26, .175);--diplan-box-shadow-inset: inset 0 1px 2px rgba(4, 7, 26, .075);--diplan-focus-ring-width: .25rem;--diplan-focus-ring-opacity: .25;--diplan-focus-ring-color: rgba(51, 117, 212, .25);--diplan-form-valid-color: #00a645;--diplan-form-valid-border-color: #00a645;--diplan-form-invalid-color: #dc3545;--diplan-form-invalid-border-color: #dc3545}[data-bs-theme=dark]{color-scheme:dark;--diplan-body-color: #dee2e6;--diplan-body-color-rgb: 222, 226, 230;--diplan-body-bg: #212529;--diplan-body-bg-rgb: 33, 37, 41;--diplan-emphasis-color: #fff;--diplan-emphasis-color-rgb: 255, 255, 255;--diplan-secondary-color: rgba(222, 226, 230, .75);--diplan-secondary-color-rgb: 222, 226, 230;--diplan-secondary-bg: #343a40;--diplan-secondary-bg-rgb: 52, 58, 64;--diplan-tertiary-color: rgba(222, 226, 230, .5);--diplan-tertiary-color-rgb: 222, 226, 230;--diplan-tertiary-bg: rgb(42.5, 47.5, 52.5);--diplan-tertiary-bg-rgb: 43, 48, 53;--diplan-primary-text-emphasis: rgb(132.6, 172.2, 229.2);--diplan-secondary-text-emphasis: rgb(224.4, 224.4, 224.4);--diplan-success-text-emphasis: rgb(102, 201.6, 143.4);--diplan-info-text-emphasis: rgb(243.6, 248.4, 255);--diplan-warning-text-emphasis: rgb(244.2, 221.4, 102);--diplan-danger-text-emphasis: rgb(234, 133.8, 143.4);--diplan-light-text-emphasis: #f8f9fa;--diplan-dark-text-emphasis: #dee2e6;--diplan-primary-bg-subtle: rgb(10.2, 23.4, 42.4);--diplan-secondary-bg-subtle: rgb(40.8, 40.8, 40.8);--diplan-success-bg-subtle: rgb(0, 33.2, 13.8);--diplan-info-bg-subtle: rgb(47.2, 48.8, 51);--diplan-warning-bg-subtle: rgb(47.4, 39.8, 0);--diplan-danger-bg-subtle: rgb(44, 10.6, 13.8);--diplan-light-bg-subtle: #343a40;--diplan-dark-bg-subtle: rgb(28, 32.5, 45);--diplan-primary-border-subtle: rgb(30.6, 70.2, 127.2);--diplan-secondary-border-subtle: rgb(122.4, 122.4, 122.4);--diplan-success-border-subtle: rgb(0, 99.6, 41.4);--diplan-info-border-subtle: rgb(141.6, 146.4, 153);--diplan-warning-border-subtle: rgb(142.2, 119.4, 0);--diplan-danger-border-subtle: rgb(132, 31.8, 41.4);--diplan-light-border-subtle: #495057;--diplan-dark-border-subtle: #343a40;--diplan-heading-color: inherit;--diplan-link-color: rgb(132.6, 172.2, 229.2);--diplan-link-hover-color: rgb(157.08, 188.76, 234.36);--diplan-link-color-rgb: 133, 172, 229;--diplan-link-hover-color-rgb: 157, 189, 234;--diplan-code-color: rgb(230.4, 132.6, 181.2);--diplan-highlight-color: #dee2e6;--diplan-highlight-bg: rgb(102, 77.2, 2.8);--diplan-border-color: #495057;--diplan-border-color-translucent: rgba(255, 255, 255, .15);--diplan-form-valid-color: rgb(117, 183, 152.4);--diplan-form-valid-border-color: rgb(117, 183, 152.4);--diplan-form-invalid-color: rgb(234, 133.8, 143.4);--diplan-form-invalid-border-color: rgb(234, 133.8, 143.4)}@media (prefers-reduced-motion: no-preference){:root,:host{scroll-behavior:smooth}}body{margin:0;font-family:var(--diplan-body-font-family);font-size:var(--diplan-body-font-size);font-weight:var(--diplan-body-font-weight);line-height:var(--diplan-body-line-height);color:var(--diplan-body-color);text-align:var(--diplan-body-text-align);background-color:var(--diplan-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(4,7,26,0)}hr{margin:1rem 0;color:inherit;border:0;border-top:var(--diplan-border-width) solid;opacity:.25}h6,.h6,h5,.h5,h4,.h4,h3,.h3,h2,.h2,h1,.h1{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2;color:var(--diplan-heading-color)}h1,.h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width: 1200px){h1,.h1{font-size:2.5rem}}h2,.h2{font-size:calc(1.325rem + .9vw)}@media (min-width: 1200px){h2,.h2{font-size:2rem}}h3,.h3{font-size:calc(1.3rem + .6vw)}@media (min-width: 1200px){h3,.h3{font-size:1.75rem}}h4,.h4{font-size:calc(1.275rem + .3vw)}@media (min-width: 1200px){h4,.h4{font-size:1.5rem}}h5,.h5{font-size:1.25rem}h6,.h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[title]{text-decoration:underline dotted;cursor:help;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}ol,ul,dl{margin-top:0;margin-bottom:1rem}ol ol,ul ul,ol ul,ul ol{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}small,.small{font-size:.875em}mark,.mark{padding:.1875em;color:var(--diplan-highlight-color);background-color:var(--diplan-highlight-bg)}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}a{color:rgba(var(--diplan-link-color-rgb),var(--diplan-link-opacity, 1));text-decoration:underline}a:hover{--diplan-link-color-rgb: var(--diplan-link-hover-color-rgb)}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}pre,code,kbd,samp{font-family:var(--diplan-font-monospace);font-size:1em}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:var(--diplan-code-color);word-wrap:break-word}a>code{color:inherit}kbd{padding:.1875rem .375rem;font-size:.875em;color:var(--diplan-body-bg);background-color:var(--diplan-body-color);border-radius:.25rem}kbd kbd{padding:0;font-size:1em}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:var(--diplan-secondary-color);text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}thead,tbody,tfoot,tr,td,th{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}input,button,select,optgroup,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]:not([type=date]):not([type=datetime-local]):not([type=month]):not([type=week]):not([type=time])::-webkit-calendar-picker-indicator{display:none!important}button:not(:disabled),[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;line-height:inherit;font-size:calc(1.275rem + .3vw)}@media (min-width: 1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-text,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}[hidden]{display:none!important}.lead{font-size:1.25rem;font-weight:300}.display-1{font-weight:300;line-height:1.2;font-size:calc(1.625rem + 4.5vw)}@media (min-width: 1200px){.display-1{font-size:5rem}}.display-2{font-weight:300;line-height:1.2;font-size:calc(1.575rem + 3.9vw)}@media (min-width: 1200px){.display-2{font-size:4.5rem}}.display-3{font-weight:300;line-height:1.2;font-size:calc(1.525rem + 3.3vw)}@media (min-width: 1200px){.display-3{font-size:4rem}}.display-4{font-weight:300;line-height:1.2;font-size:calc(1.475rem + 2.7vw)}@media (min-width: 1200px){.display-4{font-size:3.5rem}}.display-5{font-weight:300;line-height:1.2;font-size:calc(1.425rem + 2.1vw)}@media (min-width: 1200px){.display-5{font-size:3rem}}.display-6{font-weight:300;line-height:1.2;font-size:calc(1.375rem + 1.5vw)}@media (min-width: 1200px){.display-6{font-size:2.5rem}}.list-unstyled,.list-inline{padding-left:0;list-style:none}.list-inline-item{display:inline-block}.list-inline-item:not(:last-child){margin-right:.5rem}.initialism{font-size:.875em;text-transform:uppercase}.blockquote{margin-bottom:1rem;font-size:1.25rem}.blockquote>:last-child{margin-bottom:0}.blockquote-footer{margin-top:-1rem;margin-bottom:1rem;font-size:.875em;color:#6c757d}.blockquote-footer:before{content:"— "}.img-fluid{max-width:100%;height:auto}.img-thumbnail{padding:.25rem;background-color:var(--diplan-body-bg);border:var(--diplan-border-width) solid var(--diplan-border-color);border-radius:var(--diplan-border-radius);max-width:100%;height:auto}.figure{display:inline-block}.figure-img{margin-bottom:.5rem;line-height:1}.figure-caption{font-size:.875em;color:var(--diplan-secondary-color)}.container,.container-fluid,.container-xxl,.container-xl,.container-lg,.container-md,.container-sm{--diplan-gutter-x: 1.5rem;--diplan-gutter-y: 0;width:100%;padding-right:calc(var(--diplan-gutter-x) * .5);padding-left:calc(var(--diplan-gutter-x) * .5);margin-right:auto;margin-left:auto}@media (min-width: 576px){.container-sm,.container{max-width:540px}}@media (min-width: 768px){.container-md,.container-sm,.container{max-width:720px}}@media (min-width: 992px){.container-lg,.container-md,.container-sm,.container{max-width:960px}}@media (min-width: 1200px){.container-xl,.container-lg,.container-md,.container-sm,.container{max-width:1140px}}@media (min-width: 1400px){.container-xxl,.container-xl,.container-lg,.container-md,.container-sm,.container{max-width:1320px}}:root,:host{--diplan-breakpoint-xs: 0;--diplan-breakpoint-sm: 576px;--diplan-breakpoint-md: 768px;--diplan-breakpoint-lg: 992px;--diplan-breakpoint-xl: 1200px;--diplan-breakpoint-xxl: 1400px}.row{--diplan-gutter-x: 1.5rem;--diplan-gutter-y: 0;display:flex;flex-wrap:wrap;margin-top:calc(-1 * var(--diplan-gutter-y));margin-right:calc(-.5 * var(--diplan-gutter-x));margin-left:calc(-.5 * var(--diplan-gutter-x))}.row>*{flex-shrink:0;width:100%;max-width:100%;padding-right:calc(var(--diplan-gutter-x) * .5);padding-left:calc(var(--diplan-gutter-x) * .5);margin-top:var(--diplan-gutter-y)}.col{flex:1 0 0}.row-cols-auto>*{flex:0 0 auto;width:auto}.row-cols-1>*{flex:0 0 auto;width:100%}.row-cols-2>*{flex:0 0 auto;width:50%}.row-cols-3>*{flex:0 0 auto;width:33.33333333%}.row-cols-4>*{flex:0 0 auto;width:25%}.row-cols-5>*{flex:0 0 auto;width:20%}.row-cols-6>*{flex:0 0 auto;width:16.66666667%}.col-auto{flex:0 0 auto;width:auto}.col-1{flex:0 0 auto;width:8.33333333%}.col-2{flex:0 0 auto;width:16.66666667%}.col-3{flex:0 0 auto;width:25%}.col-4{flex:0 0 auto;width:33.33333333%}.col-5{flex:0 0 auto;width:41.66666667%}.col-6{flex:0 0 auto;width:50%}.col-7{flex:0 0 auto;width:58.33333333%}.col-8{flex:0 0 auto;width:66.66666667%}.col-9{flex:0 0 auto;width:75%}.col-10{flex:0 0 auto;width:83.33333333%}.col-11{flex:0 0 auto;width:91.66666667%}.col-12{flex:0 0 auto;width:100%}.offset-1{margin-left:8.33333333%}.offset-2{margin-left:16.66666667%}.offset-3{margin-left:25%}.offset-4{margin-left:33.33333333%}.offset-5{margin-left:41.66666667%}.offset-6{margin-left:50%}.offset-7{margin-left:58.33333333%}.offset-8{margin-left:66.66666667%}.offset-9{margin-left:75%}.offset-10{margin-left:83.33333333%}.offset-11{margin-left:91.66666667%}.g-0,.gx-0{--diplan-gutter-x: 0}.g-0,.gy-0{--diplan-gutter-y: 0}.g-1,.gx-1{--diplan-gutter-x: .25rem}.g-1,.gy-1{--diplan-gutter-y: .25rem}.g-2,.gx-2{--diplan-gutter-x: .5rem}.g-2,.gy-2{--diplan-gutter-y: .5rem}.g-3,.gx-3{--diplan-gutter-x: 1rem}.g-3,.gy-3{--diplan-gutter-y: 1rem}.g-4,.gx-4{--diplan-gutter-x: 1.5rem}.g-4,.gy-4{--diplan-gutter-y: 1.5rem}.g-5,.gx-5{--diplan-gutter-x: 2rem}.g-5,.gy-5{--diplan-gutter-y: 2rem}.g-6,.gx-6{--diplan-gutter-x: 3rem}.g-6,.gy-6{--diplan-gutter-y: 3rem}@media (min-width: 576px){.col-sm{flex:1 0 0}.row-cols-sm-auto>*{flex:0 0 auto;width:auto}.row-cols-sm-1>*{flex:0 0 auto;width:100%}.row-cols-sm-2>*{flex:0 0 auto;width:50%}.row-cols-sm-3>*{flex:0 0 auto;width:33.33333333%}.row-cols-sm-4>*{flex:0 0 auto;width:25%}.row-cols-sm-5>*{flex:0 0 auto;width:20%}.row-cols-sm-6>*{flex:0 0 auto;width:16.66666667%}.col-sm-auto{flex:0 0 auto;width:auto}.col-sm-1{flex:0 0 auto;width:8.33333333%}.col-sm-2{flex:0 0 auto;width:16.66666667%}.col-sm-3{flex:0 0 auto;width:25%}.col-sm-4{flex:0 0 auto;width:33.33333333%}.col-sm-5{flex:0 0 auto;width:41.66666667%}.col-sm-6{flex:0 0 auto;width:50%}.col-sm-7{flex:0 0 auto;width:58.33333333%}.col-sm-8{flex:0 0 auto;width:66.66666667%}.col-sm-9{flex:0 0 auto;width:75%}.col-sm-10{flex:0 0 auto;width:83.33333333%}.col-sm-11{flex:0 0 auto;width:91.66666667%}.col-sm-12{flex:0 0 auto;width:100%}.offset-sm-0{margin-left:0}.offset-sm-1{margin-left:8.33333333%}.offset-sm-2{margin-left:16.66666667%}.offset-sm-3{margin-left:25%}.offset-sm-4{margin-left:33.33333333%}.offset-sm-5{margin-left:41.66666667%}.offset-sm-6{margin-left:50%}.offset-sm-7{margin-left:58.33333333%}.offset-sm-8{margin-left:66.66666667%}.offset-sm-9{margin-left:75%}.offset-sm-10{margin-left:83.33333333%}.offset-sm-11{margin-left:91.66666667%}.g-sm-0,.gx-sm-0{--diplan-gutter-x: 0}.g-sm-0,.gy-sm-0{--diplan-gutter-y: 0}.g-sm-1,.gx-sm-1{--diplan-gutter-x: .25rem}.g-sm-1,.gy-sm-1{--diplan-gutter-y: .25rem}.g-sm-2,.gx-sm-2{--diplan-gutter-x: .5rem}.g-sm-2,.gy-sm-2{--diplan-gutter-y: .5rem}.g-sm-3,.gx-sm-3{--diplan-gutter-x: 1rem}.g-sm-3,.gy-sm-3{--diplan-gutter-y: 1rem}.g-sm-4,.gx-sm-4{--diplan-gutter-x: 1.5rem}.g-sm-4,.gy-sm-4{--diplan-gutter-y: 1.5rem}.g-sm-5,.gx-sm-5{--diplan-gutter-x: 2rem}.g-sm-5,.gy-sm-5{--diplan-gutter-y: 2rem}.g-sm-6,.gx-sm-6{--diplan-gutter-x: 3rem}.g-sm-6,.gy-sm-6{--diplan-gutter-y: 3rem}}@media (min-width: 768px){.col-md{flex:1 0 0}.row-cols-md-auto>*{flex:0 0 auto;width:auto}.row-cols-md-1>*{flex:0 0 auto;width:100%}.row-cols-md-2>*{flex:0 0 auto;width:50%}.row-cols-md-3>*{flex:0 0 auto;width:33.33333333%}.row-cols-md-4>*{flex:0 0 auto;width:25%}.row-cols-md-5>*{flex:0 0 auto;width:20%}.row-cols-md-6>*{flex:0 0 auto;width:16.66666667%}.col-md-auto{flex:0 0 auto;width:auto}.col-md-1{flex:0 0 auto;width:8.33333333%}.col-md-2{flex:0 0 auto;width:16.66666667%}.col-md-3{flex:0 0 auto;width:25%}.col-md-4{flex:0 0 auto;width:33.33333333%}.col-md-5{flex:0 0 auto;width:41.66666667%}.col-md-6{flex:0 0 auto;width:50%}.col-md-7{flex:0 0 auto;width:58.33333333%}.col-md-8{flex:0 0 auto;width:66.66666667%}.col-md-9{flex:0 0 auto;width:75%}.col-md-10{flex:0 0 auto;width:83.33333333%}.col-md-11{flex:0 0 auto;width:91.66666667%}.col-md-12{flex:0 0 auto;width:100%}.offset-md-0{margin-left:0}.offset-md-1{margin-left:8.33333333%}.offset-md-2{margin-left:16.66666667%}.offset-md-3{margin-left:25%}.offset-md-4{margin-left:33.33333333%}.offset-md-5{margin-left:41.66666667%}.offset-md-6{margin-left:50%}.offset-md-7{margin-left:58.33333333%}.offset-md-8{margin-left:66.66666667%}.offset-md-9{margin-left:75%}.offset-md-10{margin-left:83.33333333%}.offset-md-11{margin-left:91.66666667%}.g-md-0,.gx-md-0{--diplan-gutter-x: 0}.g-md-0,.gy-md-0{--diplan-gutter-y: 0}.g-md-1,.gx-md-1{--diplan-gutter-x: .25rem}.g-md-1,.gy-md-1{--diplan-gutter-y: .25rem}.g-md-2,.gx-md-2{--diplan-gutter-x: .5rem}.g-md-2,.gy-md-2{--diplan-gutter-y: .5rem}.g-md-3,.gx-md-3{--diplan-gutter-x: 1rem}.g-md-3,.gy-md-3{--diplan-gutter-y: 1rem}.g-md-4,.gx-md-4{--diplan-gutter-x: 1.5rem}.g-md-4,.gy-md-4{--diplan-gutter-y: 1.5rem}.g-md-5,.gx-md-5{--diplan-gutter-x: 2rem}.g-md-5,.gy-md-5{--diplan-gutter-y: 2rem}.g-md-6,.gx-md-6{--diplan-gutter-x: 3rem}.g-md-6,.gy-md-6{--diplan-gutter-y: 3rem}}@media (min-width: 992px){.col-lg{flex:1 0 0}.row-cols-lg-auto>*{flex:0 0 auto;width:auto}.row-cols-lg-1>*{flex:0 0 auto;width:100%}.row-cols-lg-2>*{flex:0 0 auto;width:50%}.row-cols-lg-3>*{flex:0 0 auto;width:33.33333333%}.row-cols-lg-4>*{flex:0 0 auto;width:25%}.row-cols-lg-5>*{flex:0 0 auto;width:20%}.row-cols-lg-6>*{flex:0 0 auto;width:16.66666667%}.col-lg-auto{flex:0 0 auto;width:auto}.col-lg-1{flex:0 0 auto;width:8.33333333%}.col-lg-2{flex:0 0 auto;width:16.66666667%}.col-lg-3{flex:0 0 auto;width:25%}.col-lg-4{flex:0 0 auto;width:33.33333333%}.col-lg-5{flex:0 0 auto;width:41.66666667%}.col-lg-6{flex:0 0 auto;width:50%}.col-lg-7{flex:0 0 auto;width:58.33333333%}.col-lg-8{flex:0 0 auto;width:66.66666667%}.col-lg-9{flex:0 0 auto;width:75%}.col-lg-10{flex:0 0 auto;width:83.33333333%}.col-lg-11{flex:0 0 auto;width:91.66666667%}.col-lg-12{flex:0 0 auto;width:100%}.offset-lg-0{margin-left:0}.offset-lg-1{margin-left:8.33333333%}.offset-lg-2{margin-left:16.66666667%}.offset-lg-3{margin-left:25%}.offset-lg-4{margin-left:33.33333333%}.offset-lg-5{margin-left:41.66666667%}.offset-lg-6{margin-left:50%}.offset-lg-7{margin-left:58.33333333%}.offset-lg-8{margin-left:66.66666667%}.offset-lg-9{margin-left:75%}.offset-lg-10{margin-left:83.33333333%}.offset-lg-11{margin-left:91.66666667%}.g-lg-0,.gx-lg-0{--diplan-gutter-x: 0}.g-lg-0,.gy-lg-0{--diplan-gutter-y: 0}.g-lg-1,.gx-lg-1{--diplan-gutter-x: .25rem}.g-lg-1,.gy-lg-1{--diplan-gutter-y: .25rem}.g-lg-2,.gx-lg-2{--diplan-gutter-x: .5rem}.g-lg-2,.gy-lg-2{--diplan-gutter-y: .5rem}.g-lg-3,.gx-lg-3{--diplan-gutter-x: 1rem}.g-lg-3,.gy-lg-3{--diplan-gutter-y: 1rem}.g-lg-4,.gx-lg-4{--diplan-gutter-x: 1.5rem}.g-lg-4,.gy-lg-4{--diplan-gutter-y: 1.5rem}.g-lg-5,.gx-lg-5{--diplan-gutter-x: 2rem}.g-lg-5,.gy-lg-5{--diplan-gutter-y: 2rem}.g-lg-6,.gx-lg-6{--diplan-gutter-x: 3rem}.g-lg-6,.gy-lg-6{--diplan-gutter-y: 3rem}}@media (min-width: 1200px){.col-xl{flex:1 0 0}.row-cols-xl-auto>*{flex:0 0 auto;width:auto}.row-cols-xl-1>*{flex:0 0 auto;width:100%}.row-cols-xl-2>*{flex:0 0 auto;width:50%}.row-cols-xl-3>*{flex:0 0 auto;width:33.33333333%}.row-cols-xl-4>*{flex:0 0 auto;width:25%}.row-cols-xl-5>*{flex:0 0 auto;width:20%}.row-cols-xl-6>*{flex:0 0 auto;width:16.66666667%}.col-xl-auto{flex:0 0 auto;width:auto}.col-xl-1{flex:0 0 auto;width:8.33333333%}.col-xl-2{flex:0 0 auto;width:16.66666667%}.col-xl-3{flex:0 0 auto;width:25%}.col-xl-4{flex:0 0 auto;width:33.33333333%}.col-xl-5{flex:0 0 auto;width:41.66666667%}.col-xl-6{flex:0 0 auto;width:50%}.col-xl-7{flex:0 0 auto;width:58.33333333%}.col-xl-8{flex:0 0 auto;width:66.66666667%}.col-xl-9{flex:0 0 auto;width:75%}.col-xl-10{flex:0 0 auto;width:83.33333333%}.col-xl-11{flex:0 0 auto;width:91.66666667%}.col-xl-12{flex:0 0 auto;width:100%}.offset-xl-0{margin-left:0}.offset-xl-1{margin-left:8.33333333%}.offset-xl-2{margin-left:16.66666667%}.offset-xl-3{margin-left:25%}.offset-xl-4{margin-left:33.33333333%}.offset-xl-5{margin-left:41.66666667%}.offset-xl-6{margin-left:50%}.offset-xl-7{margin-left:58.33333333%}.offset-xl-8{margin-left:66.66666667%}.offset-xl-9{margin-left:75%}.offset-xl-10{margin-left:83.33333333%}.offset-xl-11{margin-left:91.66666667%}.g-xl-0,.gx-xl-0{--diplan-gutter-x: 0}.g-xl-0,.gy-xl-0{--diplan-gutter-y: 0}.g-xl-1,.gx-xl-1{--diplan-gutter-x: .25rem}.g-xl-1,.gy-xl-1{--diplan-gutter-y: .25rem}.g-xl-2,.gx-xl-2{--diplan-gutter-x: .5rem}.g-xl-2,.gy-xl-2{--diplan-gutter-y: .5rem}.g-xl-3,.gx-xl-3{--diplan-gutter-x: 1rem}.g-xl-3,.gy-xl-3{--diplan-gutter-y: 1rem}.g-xl-4,.gx-xl-4{--diplan-gutter-x: 1.5rem}.g-xl-4,.gy-xl-4{--diplan-gutter-y: 1.5rem}.g-xl-5,.gx-xl-5{--diplan-gutter-x: 2rem}.g-xl-5,.gy-xl-5{--diplan-gutter-y: 2rem}.g-xl-6,.gx-xl-6{--diplan-gutter-x: 3rem}.g-xl-6,.gy-xl-6{--diplan-gutter-y: 3rem}}@media (min-width: 1400px){.col-xxl{flex:1 0 0}.row-cols-xxl-auto>*{flex:0 0 auto;width:auto}.row-cols-xxl-1>*{flex:0 0 auto;width:100%}.row-cols-xxl-2>*{flex:0 0 auto;width:50%}.row-cols-xxl-3>*{flex:0 0 auto;width:33.33333333%}.row-cols-xxl-4>*{flex:0 0 auto;width:25%}.row-cols-xxl-5>*{flex:0 0 auto;width:20%}.row-cols-xxl-6>*{flex:0 0 auto;width:16.66666667%}.col-xxl-auto{flex:0 0 auto;width:auto}.col-xxl-1{flex:0 0 auto;width:8.33333333%}.col-xxl-2{flex:0 0 auto;width:16.66666667%}.col-xxl-3{flex:0 0 auto;width:25%}.col-xxl-4{flex:0 0 auto;width:33.33333333%}.col-xxl-5{flex:0 0 auto;width:41.66666667%}.col-xxl-6{flex:0 0 auto;width:50%}.col-xxl-7{flex:0 0 auto;width:58.33333333%}.col-xxl-8{flex:0 0 auto;width:66.66666667%}.col-xxl-9{flex:0 0 auto;width:75%}.col-xxl-10{flex:0 0 auto;width:83.33333333%}.col-xxl-11{flex:0 0 auto;width:91.66666667%}.col-xxl-12{flex:0 0 auto;width:100%}.offset-xxl-0{margin-left:0}.offset-xxl-1{margin-left:8.33333333%}.offset-xxl-2{margin-left:16.66666667%}.offset-xxl-3{margin-left:25%}.offset-xxl-4{margin-left:33.33333333%}.offset-xxl-5{margin-left:41.66666667%}.offset-xxl-6{margin-left:50%}.offset-xxl-7{margin-left:58.33333333%}.offset-xxl-8{margin-left:66.66666667%}.offset-xxl-9{margin-left:75%}.offset-xxl-10{margin-left:83.33333333%}.offset-xxl-11{margin-left:91.66666667%}.g-xxl-0,.gx-xxl-0{--diplan-gutter-x: 0}.g-xxl-0,.gy-xxl-0{--diplan-gutter-y: 0}.g-xxl-1,.gx-xxl-1{--diplan-gutter-x: .25rem}.g-xxl-1,.gy-xxl-1{--diplan-gutter-y: .25rem}.g-xxl-2,.gx-xxl-2{--diplan-gutter-x: .5rem}.g-xxl-2,.gy-xxl-2{--diplan-gutter-y: .5rem}.g-xxl-3,.gx-xxl-3{--diplan-gutter-x: 1rem}.g-xxl-3,.gy-xxl-3{--diplan-gutter-y: 1rem}.g-xxl-4,.gx-xxl-4{--diplan-gutter-x: 1.5rem}.g-xxl-4,.gy-xxl-4{--diplan-gutter-y: 1.5rem}.g-xxl-5,.gx-xxl-5{--diplan-gutter-x: 2rem}.g-xxl-5,.gy-xxl-5{--diplan-gutter-y: 2rem}.g-xxl-6,.gx-xxl-6{--diplan-gutter-x: 3rem}.g-xxl-6,.gy-xxl-6{--diplan-gutter-y: 3rem}}.table{--diplan-table-color-type: initial;--diplan-table-bg-type: initial;--diplan-table-color-state: initial;--diplan-table-bg-state: initial;--diplan-table-color: var(--diplan-emphasis-color);--diplan-table-bg: var(--diplan-body-bg);--diplan-table-border-color: var(--diplan-border-color);--diplan-table-accent-bg: transparent;--diplan-table-striped-color: var(--diplan-emphasis-color);--diplan-table-striped-bg: rgba(var(--diplan-emphasis-color-rgb), .05);--diplan-table-active-color: var(--diplan-emphasis-color);--diplan-table-active-bg: rgba(var(--diplan-emphasis-color-rgb), .1);--diplan-table-hover-color: var(--diplan-emphasis-color);--diplan-table-hover-bg: #f9fbff;width:100%;margin-bottom:1rem;vertical-align:top;border-color:var(--diplan-table-border-color)}.table>:not(caption)>*>*{padding:.5rem;color:var(--diplan-table-color-state, var(--diplan-table-color-type, var(--diplan-table-color)));background-color:var(--diplan-table-bg);border-bottom-width:var(--diplan-border-width);box-shadow:inset 0 0 0 9999px var(--diplan-table-bg-state, var(--diplan-table-bg-type, var(--diplan-table-accent-bg)))}.table>tbody{vertical-align:inherit}.table>thead{vertical-align:bottom}.table-group-divider{border-top:calc(var(--diplan-border-width) * 2) solid currentcolor}.caption-top{caption-side:top}.table-sm>:not(caption)>*>*{padding:.25rem}.table-bordered>:not(caption)>*{border-width:var(--diplan-border-width) 0}.table-bordered>:not(caption)>*>*{border-width:0 var(--diplan-border-width)}.table-borderless>:not(caption)>*>*{border-bottom-width:0}.table-borderless>:not(:first-child){border-top-width:0}.table-striped>tbody>tr:nth-of-type(odd)>*{--diplan-table-color-type: var(--diplan-table-striped-color);--diplan-table-bg-type: var(--diplan-table-striped-bg)}.table-striped-columns>:not(caption)>tr>:nth-child(2n){--diplan-table-color-type: var(--diplan-table-striped-color);--diplan-table-bg-type: var(--diplan-table-striped-bg)}.table-active{--diplan-table-color-state: var(--diplan-table-active-color);--diplan-table-bg-state: var(--diplan-table-active-bg)}.table-hover>tbody>tr:hover>*{--diplan-table-color-state: var(--diplan-table-hover-color);--diplan-table-bg-state: var(--diplan-table-hover-bg)}.table-primary{--diplan-table-color: #04071a;--diplan-table-bg: rgb(214.2, 227.4, 246.4);--diplan-table-border-color: rgb(172.16, 183.32, 202.32);--diplan-table-striped-bg: rgb(203.69, 216.38, 235.38);--diplan-table-striped-color: #04071a;--diplan-table-active-bg: rgb(193.18, 205.36, 224.36);--diplan-table-active-color: #04071a;--diplan-table-hover-bg: rgb(198.435, 210.87, 229.87);--diplan-table-hover-color: #04071a;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-secondary{--diplan-table-color: #04071a;--diplan-table-bg: rgb(244.8, 244.8, 244.8);--diplan-table-border-color: rgb(196.64, 197.24, 201.04);--diplan-table-striped-bg: rgb(232.76, 232.91, 233.86);--diplan-table-striped-color: #04071a;--diplan-table-active-bg: rgb(220.72, 221.02, 222.92);--diplan-table-active-color: #04071a;--diplan-table-hover-bg: rgb(226.74, 226.965, 228.39);--diplan-table-hover-color: #04071a;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-success{--diplan-table-color: #04071a;--diplan-table-bg: rgb(204, 237.2, 217.8);--diplan-table-border-color: rgb(164, 191.16, 179.44);--diplan-table-striped-bg: rgb(194, 225.69, 208.21);--diplan-table-striped-color: #04071a;--diplan-table-active-bg: rgb(184, 214.18, 198.62);--diplan-table-active-color: #04071a;--diplan-table-hover-bg: rgb(189, 219.935, 203.415);--diplan-table-hover-color: #04071a;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-info{--diplan-table-color: #04071a;--diplan-table-bg: rgb(251.2, 252.8, 255);--diplan-table-border-color: rgb(201.76, 203.64, 209.2);--diplan-table-striped-bg: rgb(238.84, 240.51, 243.55);--diplan-table-striped-color: #04071a;--diplan-table-active-bg: rgb(226.48, 228.22, 232.1);--diplan-table-active-color: #04071a;--diplan-table-hover-bg: rgb(232.66, 234.365, 237.825);--diplan-table-hover-color: #04071a;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-warning{--diplan-table-color: #04071a;--diplan-table-bg: rgb(251.4, 243.8, 204);--diplan-table-border-color: rgb(201.92, 196.44, 168.4);--diplan-table-striped-bg: rgb(239.03, 231.96, 195.1);--diplan-table-striped-color: #04071a;--diplan-table-active-bg: rgb(226.66, 220.12, 186.2);--diplan-table-active-color: #04071a;--diplan-table-hover-bg: rgb(232.845, 226.04, 190.65);--diplan-table-hover-color: #04071a;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-danger{--diplan-table-color: #04071a;--diplan-table-bg: rgb(248, 214.6, 217.8);--diplan-table-border-color: rgb(199.2, 173.08, 179.44);--diplan-table-striped-bg: rgb(235.8, 204.22, 208.21);--diplan-table-striped-color: #04071a;--diplan-table-active-bg: rgb(223.6, 193.84, 198.62);--diplan-table-active-color: #04071a;--diplan-table-hover-bg: rgb(229.7, 199.03, 203.415);--diplan-table-hover-color: #04071a;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-light{--diplan-table-color: #04071a;--diplan-table-bg: #ecf4ff;--diplan-table-border-color: rgb(189.6, 196.6, 209.2);--diplan-table-striped-bg: rgb(224.4, 232.15, 243.55);--diplan-table-striped-color: #04071a;--diplan-table-active-bg: rgb(212.8, 220.3, 232.1);--diplan-table-active-color: #04071a;--diplan-table-hover-bg: rgb(218.6, 226.225, 237.825);--diplan-table-hover-color: #04071a;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-dark{--diplan-table-color: #fff;--diplan-table-bg: #2b3980;--diplan-table-border-color: rgb(85.4, 96.6, 153.4);--diplan-table-striped-bg: rgb(53.6, 66.9, 134.35);--diplan-table-striped-color: #fff;--diplan-table-active-bg: rgb(64.2, 76.8, 140.7);--diplan-table-active-color: #fff;--diplan-table-hover-bg: rgb(58.9, 71.85, 137.525);--diplan-table-hover-color: #fff;color:var(--diplan-table-color);border-color:var(--diplan-table-border-color)}.table-responsive{overflow-x:auto;-webkit-overflow-scrolling:touch}@media (max-width: 575.98px){.table-responsive-sm{overflow-x:auto;-webkit-overflow-scrolling:touch}}@media (max-width: 767.98px){.table-responsive-md{overflow-x:auto;-webkit-overflow-scrolling:touch}}@media (max-width: 991.98px){.table-responsive-lg{overflow-x:auto;-webkit-overflow-scrolling:touch}}@media (max-width: 1199.98px){.table-responsive-xl{overflow-x:auto;-webkit-overflow-scrolling:touch}}@media (max-width: 1399.98px){.table-responsive-xxl{overflow-x:auto;-webkit-overflow-scrolling:touch}}.nav{--diplan-nav-link-padding-x: 1rem;--diplan-nav-link-padding-y: .5rem;--diplan-nav-link-font-weight: ;--diplan-nav-link-color: var(--diplan-link-color);--diplan-nav-link-hover-color: var(--diplan-link-hover-color);--diplan-nav-link-disabled-color: var(--diplan-secondary-color);display:flex;flex-wrap:wrap;padding-left:0;margin-bottom:0;list-style:none}.nav-link{display:block;padding:var(--diplan-nav-link-padding-y) var(--diplan-nav-link-padding-x);font-size:var(--diplan-nav-link-font-size);font-weight:var(--diplan-nav-link-font-weight);color:var(--diplan-nav-link-color);text-decoration:none;background:none;border:0;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out}@media (prefers-reduced-motion: reduce){.nav-link{transition:none}}.nav-link:hover,.nav-link:focus{color:var(--diplan-nav-link-hover-color)}.nav-link:focus-visible{outline:0;box-shadow:0 0 0 .25rem #3375d440}.nav-link.disabled,.nav-link:disabled{color:var(--diplan-nav-link-disabled-color);pointer-events:none;cursor:default}.nav-tabs,.tabs .nav-boxed{--diplan-nav-tabs-border-width: var(--diplan-border-width);--diplan-nav-tabs-border-color: var(--diplan-border-color);--diplan-nav-tabs-border-radius: var(--diplan-border-radius);--diplan-nav-tabs-link-hover-border-color: var(--diplan-secondary-bg) var(--diplan-secondary-bg) var(--diplan-border-color);--diplan-nav-tabs-link-active-color: #04071a;--diplan-nav-tabs-link-active-bg: var(--diplan-body-bg);--diplan-nav-tabs-link-active-border-color: var(--diplan-border-color) var(--diplan-border-color) var(--diplan-body-bg);border-bottom:var(--diplan-nav-tabs-border-width) solid var(--diplan-nav-tabs-border-color)}.nav-tabs .nav-link,.tabs .nav-boxed .nav-link{margin-bottom:calc(-1 * var(--diplan-nav-tabs-border-width));border:var(--diplan-nav-tabs-border-width) solid transparent;border-top-left-radius:var(--diplan-nav-tabs-border-radius);border-top-right-radius:var(--diplan-nav-tabs-border-radius)}.nav-tabs .nav-link:hover,.tabs .nav-boxed .nav-link:hover,.nav-tabs .nav-link:focus,.tabs .nav-boxed .nav-link:focus{isolation:isolate;border-color:var(--diplan-nav-tabs-link-hover-border-color)}.nav-tabs .nav-link.active,.tabs .nav-boxed .nav-link.active,.nav-tabs .nav-item.show .nav-link,.tabs .nav-boxed .nav-item.show .nav-link,.nav-tabs .nav-item.collapse .nav-link,.tabs .nav-boxed .nav-item.collapse .nav-link{color:var(--diplan-nav-tabs-link-active-color);background-color:var(--diplan-nav-tabs-link-active-bg);border-color:var(--diplan-nav-tabs-link-active-border-color)}.nav-tabs .dropdown-menu,.tabs .nav-boxed .dropdown-menu{margin-top:calc(-1 * var(--diplan-nav-tabs-border-width));border-top-left-radius:0;border-top-right-radius:0}.nav-pills{--diplan-nav-pills-border-radius: var(--diplan-border-radius);--diplan-nav-pills-link-active-color: #fff;--diplan-nav-pills-link-active-bg: hsl(0, 0%, 110%)}.nav-pills .nav-link{border-radius:var(--diplan-nav-pills-border-radius)}.nav-pills .nav-link.active,.nav-pills .show>.nav-link,.nav-pills .collapse>.nav-link{color:var(--diplan-nav-pills-link-active-color);background-color:var(--diplan-nav-pills-link-active-bg)}.nav-underline,.tabs .nav-default,.tabs .nav-toggle{--diplan-nav-underline-gap: 1rem;--diplan-nav-underline-border-width: .125rem;--diplan-nav-underline-link-active-color: var(--diplan-emphasis-color);gap:var(--diplan-nav-underline-gap)}.nav-underline .nav-link,.tabs .nav-default .nav-link,.tabs .nav-toggle .nav-link{padding-right:0;padding-left:0;border-bottom:var(--diplan-nav-underline-border-width) solid transparent}.nav-underline .nav-link:hover,.tabs .nav-default .nav-link:hover,.tabs .nav-toggle .nav-link:hover,.nav-underline .nav-link:focus,.tabs .nav-default .nav-link:focus,.tabs .nav-toggle .nav-link:focus{border-bottom-color:currentcolor}.nav-underline .nav-link.active,.tabs .nav-default .nav-link.active,.tabs .nav-toggle .nav-link.active,.nav-underline .show>.nav-link,.tabs .nav-default .show>.nav-link,.tabs .nav-toggle .show>.nav-link,.nav-underline .collapse>.nav-link,.tabs .nav-default .collapse>.nav-link,.tabs .nav-toggle .collapse>.nav-link{font-weight:700;color:var(--diplan-nav-underline-link-active-color);border-bottom-color:currentcolor}.nav-fill>.nav-link,.tabs.expanded:not(.vertical) .nav>.nav-link,.nav-fill .nav-item,.tabs.expanded:not(.vertical) .nav .nav-item{flex:1 1 auto;text-align:center}.nav-justified>.nav-link,.nav-justified .nav-item{flex-grow:1;flex-basis:0;text-align:center}.nav-fill .nav-item .nav-link,.tabs.expanded:not(.vertical) .nav .nav-item .nav-link,.nav-justified .nav-item .nav-link{width:100%}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.btn{--diplan-btn-padding-x: .75rem;--diplan-btn-padding-y: .375rem;--diplan-btn-font-family: ;--diplan-btn-font-size: 1rem;--diplan-btn-font-weight: 400;--diplan-btn-line-height: 1.5;--diplan-btn-color: var(--diplan-body-color);--diplan-btn-bg: transparent;--diplan-btn-border-width: var(--diplan-border-width);--diplan-btn-border-color: transparent;--diplan-btn-border-radius: var(--diplan-border-radius);--diplan-btn-hover-border-color: transparent;--diplan-btn-box-shadow: inset 0 1px 0 rgba(255, 255, 255, .15), 0 1px 1px rgba(4, 7, 26, .075);--diplan-btn-disabled-opacity: .65;--diplan-btn-focus-box-shadow: 0 0 0 .25rem rgba(var(--diplan-btn-focus-shadow-rgb), .5);display:inline-block;padding:var(--diplan-btn-padding-y) var(--diplan-btn-padding-x);font-family:var(--diplan-btn-font-family);font-size:var(--diplan-btn-font-size);font-weight:var(--diplan-btn-font-weight);line-height:var(--diplan-btn-line-height);color:var(--diplan-btn-color);text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;user-select:none;border:var(--diplan-btn-border-width) solid var(--diplan-btn-border-color);border-radius:var(--diplan-btn-border-radius);background-color:var(--diplan-btn-bg);transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion: reduce){.btn{transition:none}}.btn:hover{color:var(--diplan-btn-hover-color);background-color:var(--diplan-btn-hover-bg);border-color:var(--diplan-btn-hover-border-color)}.btn-check+.btn:hover{color:var(--diplan-btn-color);background-color:var(--diplan-btn-bg);border-color:var(--diplan-btn-border-color)}.btn:focus-visible{color:var(--diplan-btn-hover-color);background-color:var(--diplan-btn-hover-bg);border-color:var(--diplan-btn-hover-border-color);outline:0;box-shadow:var(--diplan-btn-focus-box-shadow)}.btn-check:focus-visible+.btn{border-color:var(--diplan-btn-hover-border-color);outline:0;box-shadow:var(--diplan-btn-focus-box-shadow)}.btn-check:checked+.btn,:not(.btn-check)+.btn:active,.btn:first-child:active,.btn.active,.btn.show,.btn.collapse{color:var(--diplan-btn-active-color);background-color:var(--diplan-btn-active-bg);border-color:var(--diplan-btn-active-border-color)}.btn-check:checked+.btn:focus-visible,:not(.btn-check)+.btn:active:focus-visible,.btn:first-child:active:focus-visible,.btn.active:focus-visible,.btn.show:focus-visible,.btn.collapse:focus-visible{box-shadow:var(--diplan-btn-focus-box-shadow)}.btn-check:checked:focus-visible+.btn{box-shadow:var(--diplan-btn-focus-box-shadow)}.btn:disabled,.btn.disabled,fieldset:disabled .btn{color:var(--diplan-btn-disabled-color);pointer-events:none;background-color:var(--diplan-btn-disabled-bg);border-color:var(--diplan-btn-disabled-border-color);opacity:var(--diplan-btn-disabled-opacity)}.btn-primary{--diplan-btn-color: #fff;--diplan-btn-bg: #3375d4;--diplan-btn-border-color: #3375d4;--diplan-btn-hover-color: #fff;--diplan-btn-hover-bg: rgb(43.35, 99.45, 180.2);--diplan-btn-hover-border-color: rgb(40.8, 93.6, 169.6);--diplan-btn-focus-shadow-rgb: 82, 138, 218;--diplan-btn-active-color: #fff;--diplan-btn-active-bg: rgb(40.8, 93.6, 169.6);--diplan-btn-active-border-color: rgb(38.25, 87.75, 159);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #fff;--diplan-btn-disabled-bg: #3375d4;--diplan-btn-disabled-border-color: #3375d4}.btn-secondary{--diplan-btn-color: #04071a;--diplan-btn-bg: #ccc;--diplan-btn-border-color: #ccc;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: rgb(211.65, 211.65, 211.65);--diplan-btn-hover-border-color: rgb(209.1, 209.1, 209.1);--diplan-btn-focus-shadow-rgb: 174, 174, 177;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: rgb(214.2, 214.2, 214.2);--diplan-btn-active-border-color: rgb(209.1, 209.1, 209.1);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #04071a;--diplan-btn-disabled-bg: #ccc;--diplan-btn-disabled-border-color: #ccc}.btn-success{--diplan-btn-color: #04071a;--diplan-btn-bg: #00a645;--diplan-btn-border-color: #00a645;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: rgb(38.25, 179.35, 96.9);--diplan-btn-hover-border-color: rgb(25.5, 174.9, 87.6);--diplan-btn-focus-shadow-rgb: 1, 142, 63;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: rgb(51, 183.8, 106.2);--diplan-btn-active-border-color: rgb(25.5, 174.9, 87.6);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #04071a;--diplan-btn-disabled-bg: #00a645;--diplan-btn-disabled-border-color: #00a645}.btn-info{--diplan-btn-color: #04071a;--diplan-btn-bg: #ecf4ff;--diplan-btn-border-color: #ecf4ff;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: rgb(238.85, 245.65, 255);--diplan-btn-hover-border-color: rgb(237.9, 245.1, 255);--diplan-btn-focus-shadow-rgb: 201, 208, 221;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: rgb(239.8, 246.2, 255);--diplan-btn-active-border-color: rgb(237.9, 245.1, 255);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #04071a;--diplan-btn-disabled-bg: #ecf4ff;--diplan-btn-disabled-border-color: #ecf4ff}.btn-warning{--diplan-btn-color: #04071a;--diplan-btn-bg: #edc700;--diplan-btn-border-color: #edc700;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: rgb(239.7, 207.4, 38.25);--diplan-btn-hover-border-color: rgb(238.8, 204.6, 25.5);--diplan-btn-focus-shadow-rgb: 202, 170, 4;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: rgb(240.6, 210.2, 51);--diplan-btn-active-border-color: rgb(238.8, 204.6, 25.5);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #04071a;--diplan-btn-disabled-bg: #edc700;--diplan-btn-disabled-border-color: #edc700}.btn-danger{--diplan-btn-color: #fff;--diplan-btn-bg: #dc3545;--diplan-btn-border-color: #dc3545;--diplan-btn-hover-color: #fff;--diplan-btn-hover-bg: rgb(187, 45.05, 58.65);--diplan-btn-hover-border-color: rgb(176, 42.4, 55.2);--diplan-btn-focus-shadow-rgb: 225, 83, 97;--diplan-btn-active-color: #fff;--diplan-btn-active-bg: rgb(176, 42.4, 55.2);--diplan-btn-active-border-color: rgb(165, 39.75, 51.75);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #fff;--diplan-btn-disabled-bg: #dc3545;--diplan-btn-disabled-border-color: #dc3545}.btn-light{--diplan-btn-color: #04071a;--diplan-btn-bg: #ecf4ff;--diplan-btn-border-color: #ecf4ff;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: rgb(200.6, 207.4, 216.75);--diplan-btn-hover-border-color: rgb(188.8, 195.2, 204);--diplan-btn-focus-shadow-rgb: 201, 208, 221;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: rgb(188.8, 195.2, 204);--diplan-btn-active-border-color: rgb(177, 183, 191.25);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #04071a;--diplan-btn-disabled-bg: #ecf4ff;--diplan-btn-disabled-border-color: #ecf4ff}.btn-dark{--diplan-btn-color: #fff;--diplan-btn-bg: #2b3980;--diplan-btn-border-color: #2b3980;--diplan-btn-hover-color: #fff;--diplan-btn-hover-bg: rgb(74.8, 86.7, 147.05);--diplan-btn-hover-border-color: rgb(64.2, 76.8, 140.7);--diplan-btn-focus-shadow-rgb: 75, 87, 147;--diplan-btn-active-color: #fff;--diplan-btn-active-bg: rgb(85.4, 96.6, 153.4);--diplan-btn-active-border-color: rgb(64.2, 76.8, 140.7);--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #fff;--diplan-btn-disabled-bg: #2b3980;--diplan-btn-disabled-border-color: #2b3980}.btn-outline-primary{--diplan-btn-color: #3375d4;--diplan-btn-border-color: #3375d4;--diplan-btn-hover-color: #fff;--diplan-btn-hover-bg: #3375d4;--diplan-btn-hover-border-color: #3375d4;--diplan-btn-focus-shadow-rgb: 51, 117, 212;--diplan-btn-active-color: #fff;--diplan-btn-active-bg: #3375d4;--diplan-btn-active-border-color: #3375d4;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #3375d4;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #3375d4;--diplan-gradient: none}.btn-outline-secondary{--diplan-btn-color: #ccc;--diplan-btn-border-color: #ccc;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: #ccc;--diplan-btn-hover-border-color: #ccc;--diplan-btn-focus-shadow-rgb: 204, 204, 204;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: #ccc;--diplan-btn-active-border-color: #ccc;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #ccc;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #ccc;--diplan-gradient: none}.btn-outline-success{--diplan-btn-color: #00a645;--diplan-btn-border-color: #00a645;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: #00a645;--diplan-btn-hover-border-color: #00a645;--diplan-btn-focus-shadow-rgb: 0, 166, 69;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: #00a645;--diplan-btn-active-border-color: #00a645;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #00a645;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #00a645;--diplan-gradient: none}.btn-outline-info{--diplan-btn-color: #ecf4ff;--diplan-btn-border-color: #ecf4ff;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: #ecf4ff;--diplan-btn-hover-border-color: #ecf4ff;--diplan-btn-focus-shadow-rgb: 236, 244, 255;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: #ecf4ff;--diplan-btn-active-border-color: #ecf4ff;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #ecf4ff;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #ecf4ff;--diplan-gradient: none}.btn-outline-warning{--diplan-btn-color: #edc700;--diplan-btn-border-color: #edc700;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: #edc700;--diplan-btn-hover-border-color: #edc700;--diplan-btn-focus-shadow-rgb: 237, 199, 0;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: #edc700;--diplan-btn-active-border-color: #edc700;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #edc700;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #edc700;--diplan-gradient: none}.btn-outline-danger{--diplan-btn-color: #dc3545;--diplan-btn-border-color: #dc3545;--diplan-btn-hover-color: #fff;--diplan-btn-hover-bg: #dc3545;--diplan-btn-hover-border-color: #dc3545;--diplan-btn-focus-shadow-rgb: 220, 53, 69;--diplan-btn-active-color: #fff;--diplan-btn-active-bg: #dc3545;--diplan-btn-active-border-color: #dc3545;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #dc3545;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #dc3545;--diplan-gradient: none}.btn-outline-light{--diplan-btn-color: #ecf4ff;--diplan-btn-border-color: #ecf4ff;--diplan-btn-hover-color: #04071a;--diplan-btn-hover-bg: #ecf4ff;--diplan-btn-hover-border-color: #ecf4ff;--diplan-btn-focus-shadow-rgb: 236, 244, 255;--diplan-btn-active-color: #04071a;--diplan-btn-active-bg: #ecf4ff;--diplan-btn-active-border-color: #ecf4ff;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #ecf4ff;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #ecf4ff;--diplan-gradient: none}.btn-outline-dark{--diplan-btn-color: #2b3980;--diplan-btn-border-color: #2b3980;--diplan-btn-hover-color: #fff;--diplan-btn-hover-bg: #2b3980;--diplan-btn-hover-border-color: #2b3980;--diplan-btn-focus-shadow-rgb: 43, 57, 128;--diplan-btn-active-color: #fff;--diplan-btn-active-bg: #2b3980;--diplan-btn-active-border-color: #2b3980;--diplan-btn-active-shadow: inset 0 3px 5px rgba(4, 7, 26, .125);--diplan-btn-disabled-color: #2b3980;--diplan-btn-disabled-bg: transparent;--diplan-btn-disabled-border-color: #2b3980;--diplan-gradient: none}.btn-link{--diplan-btn-font-weight: 400;--diplan-btn-color: var(--diplan-link-color);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-link-hover-color);--diplan-btn-hover-border-color: transparent;--diplan-btn-active-color: var(--diplan-link-hover-color);--diplan-btn-active-border-color: transparent;--diplan-btn-disabled-color: #6c757d;--diplan-btn-disabled-border-color: transparent;--diplan-btn-box-shadow: 0 0 0 #000;--diplan-btn-focus-shadow-rgb: 82, 138, 218;text-decoration:underline}.btn-link:focus-visible{color:var(--diplan-btn-color)}.btn-link:hover{color:var(--diplan-btn-hover-color)}.btn-lg{--diplan-btn-padding-y: .5rem;--diplan-btn-padding-x: 1rem;--diplan-btn-font-size: 1.25rem;--diplan-btn-border-radius: var(--diplan-border-radius-lg)}.btn-sm{--diplan-btn-padding-y: .25rem;--diplan-btn-padding-x: .5rem;--diplan-btn-font-size: .875rem;--diplan-btn-border-radius: var(--diplan-border-radius-sm)}.accordion{--diplan-accordion-color: var(--diplan-body-color);--diplan-accordion-bg: var(--diplan-body-bg);--diplan-accordion-transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out, border-radius .15s ease;--diplan-accordion-border-color: var(--diplan-border-color);--diplan-accordion-border-width: var(--diplan-border-width);--diplan-accordion-border-radius: var(--diplan-border-radius);--diplan-accordion-inner-border-radius: calc(var(--diplan-border-radius) - (var(--diplan-border-width)));--diplan-accordion-btn-padding-x: 1.25rem;--diplan-accordion-btn-padding-y: 1rem;--diplan-accordion-btn-color: var(--diplan-body-color);--diplan-accordion-btn-bg: var(--diplan-accordion-bg);--diplan-accordion-btn-icon: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='none' stroke='%2304071a' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='m2 5 6 6 6-6'/%3e%3c/svg%3e");--diplan-accordion-btn-icon-width: 1.25rem;--diplan-accordion-btn-icon-transform: rotate(-180deg);--diplan-accordion-btn-icon-transition: transform .2s ease-in-out;--diplan-accordion-btn-active-icon: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='none' stroke='rgb%2820.4, 46.8, 84.8%29' stroke-linecap='round' stroke-linejoin='round'%3e%3cpath d='m2 5 6 6 6-6'/%3e%3c/svg%3e");--diplan-accordion-btn-focus-box-shadow: 0 0 0 .25rem rgba(51, 117, 212, .25);--diplan-accordion-body-padding-x: 1.25rem;--diplan-accordion-body-padding-y: 1rem;--diplan-accordion-active-color: var(--diplan-primary-text-emphasis);--diplan-accordion-active-bg: var(--diplan-primary-bg-subtle)}.accordion-button{position:relative;display:flex;align-items:center;width:100%;padding:var(--diplan-accordion-btn-padding-y) var(--diplan-accordion-btn-padding-x);font-size:1rem;color:var(--diplan-accordion-btn-color);text-align:left;background-color:var(--diplan-accordion-btn-bg);border:0;border-radius:0;overflow-anchor:none;transition:var(--diplan-accordion-transition)}@media (prefers-reduced-motion: reduce){.accordion-button{transition:none}}.accordion-button:not(.collapsed){color:var(--diplan-accordion-active-color);background-color:var(--diplan-accordion-active-bg);box-shadow:inset 0 calc(-1 * var(--diplan-accordion-border-width)) 0 var(--diplan-accordion-border-color)}.accordion-button:not(.collapsed):after{background-image:var(--diplan-accordion-btn-active-icon);transform:var(--diplan-accordion-btn-icon-transform)}.accordion-button:after{flex-shrink:0;width:var(--diplan-accordion-btn-icon-width);height:var(--diplan-accordion-btn-icon-width);margin-left:auto;content:"";background-image:var(--diplan-accordion-btn-icon);background-repeat:no-repeat;background-size:var(--diplan-accordion-btn-icon-width);transition:var(--diplan-accordion-btn-icon-transition)}@media (prefers-reduced-motion: reduce){.accordion-button:after{transition:none}}.accordion-button:hover{z-index:2}.accordion-button:focus{z-index:3;outline:0;box-shadow:var(--diplan-accordion-btn-focus-box-shadow)}.accordion-header{margin-bottom:0}.accordion-item{color:var(--diplan-accordion-color);background-color:var(--diplan-accordion-bg);border:var(--diplan-accordion-border-width) solid var(--diplan-accordion-border-color)}.accordion-item:first-of-type{border-top-left-radius:var(--diplan-accordion-border-radius);border-top-right-radius:var(--diplan-accordion-border-radius)}.accordion-item:first-of-type>.accordion-header .accordion-button{border-top-left-radius:var(--diplan-accordion-inner-border-radius);border-top-right-radius:var(--diplan-accordion-inner-border-radius)}.accordion-item:not(:first-of-type){border-top:0}.accordion-item:last-of-type{border-bottom-right-radius:var(--diplan-accordion-border-radius);border-bottom-left-radius:var(--diplan-accordion-border-radius)}.accordion-item:last-of-type>.accordion-header .accordion-button.collapsed{border-bottom-right-radius:var(--diplan-accordion-inner-border-radius);border-bottom-left-radius:var(--diplan-accordion-inner-border-radius)}.accordion-item:last-of-type>.accordion-collapse{border-bottom-right-radius:var(--diplan-accordion-border-radius);border-bottom-left-radius:var(--diplan-accordion-border-radius)}.accordion-body{padding:var(--diplan-accordion-body-padding-y) var(--diplan-accordion-body-padding-x)}.accordion-flush>.accordion-item{border-right:0;border-left:0;border-radius:0}.accordion-flush>.accordion-item:first-child{border-top:0}.accordion-flush>.accordion-item:last-child{border-bottom:0}.accordion-flush>.accordion-item>.accordion-collapse,.accordion-flush>.accordion-item>.accordion-header .accordion-button,.accordion-flush>.accordion-item>.accordion-header .accordion-button.collapsed{border-radius:0}[data-bs-theme=dark] .accordion-button:after{--diplan-accordion-btn-icon: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='rgb%28132.6, 172.2, 229.2%29'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708'/%3e%3c/svg%3e");--diplan-accordion-btn-active-icon: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='rgb%28132.6, 172.2, 229.2%29'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708'/%3e%3c/svg%3e")}.tooltip{--diplan-tooltip-zindex: 1080;--diplan-tooltip-max-width: 320px;--diplan-tooltip-padding-x: .5rem;--diplan-tooltip-padding-y: .25rem;--diplan-tooltip-margin: ;--diplan-tooltip-font-size: .875rem;--diplan-tooltip-color: var(--diplan-body-bg);--diplan-tooltip-bg: var(--diplan-emphasis-color);--diplan-tooltip-border-radius: var(--diplan-border-radius);--diplan-tooltip-opacity: .9;--diplan-tooltip-arrow-width: .8rem;--diplan-tooltip-arrow-height: .4rem;z-index:var(--diplan-tooltip-zindex);display:block;margin:var(--diplan-tooltip-margin);font-family:var(--diplan-font-sans-serif);font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;white-space:normal;word-spacing:normal;line-break:auto;font-size:var(--diplan-tooltip-font-size);word-wrap:break-word;opacity:0}.tooltip.show,.tooltip.collapse{opacity:var(--diplan-tooltip-opacity)}.tooltip .tooltip-arrow{display:block;width:var(--diplan-tooltip-arrow-width);height:var(--diplan-tooltip-arrow-height)}.tooltip .tooltip-arrow:before{position:absolute;content:"";border-color:transparent;border-style:solid}.bs-tooltip-top .tooltip-arrow,.bs-tooltip-auto[data-popper-placement^=top] .tooltip-arrow{bottom:calc(-1 * var(--diplan-tooltip-arrow-height))}.bs-tooltip-top .tooltip-arrow:before,.bs-tooltip-auto[data-popper-placement^=top] .tooltip-arrow:before{top:-1px;border-width:var(--diplan-tooltip-arrow-height) calc(var(--diplan-tooltip-arrow-width) * .5) 0;border-top-color:var(--diplan-tooltip-bg)}.bs-tooltip-end .tooltip-arrow,.bs-tooltip-auto[data-popper-placement^=right] .tooltip-arrow{left:calc(-1 * var(--diplan-tooltip-arrow-height));width:var(--diplan-tooltip-arrow-height);height:var(--diplan-tooltip-arrow-width)}.bs-tooltip-end .tooltip-arrow:before,.bs-tooltip-auto[data-popper-placement^=right] .tooltip-arrow:before{right:-1px;border-width:calc(var(--diplan-tooltip-arrow-width) * .5) var(--diplan-tooltip-arrow-height) calc(var(--diplan-tooltip-arrow-width) * .5) 0;border-right-color:var(--diplan-tooltip-bg)}.bs-tooltip-bottom .tooltip-arrow,.bs-tooltip-auto[data-popper-placement^=bottom] .tooltip-arrow{top:calc(-1 * var(--diplan-tooltip-arrow-height))}.bs-tooltip-bottom .tooltip-arrow:before,.bs-tooltip-auto[data-popper-placement^=bottom] .tooltip-arrow:before{bottom:-1px;border-width:0 calc(var(--diplan-tooltip-arrow-width) * .5) var(--diplan-tooltip-arrow-height);border-bottom-color:var(--diplan-tooltip-bg)}.bs-tooltip-start .tooltip-arrow,.bs-tooltip-auto[data-popper-placement^=left] .tooltip-arrow{right:calc(-1 * var(--diplan-tooltip-arrow-height));width:var(--diplan-tooltip-arrow-height);height:var(--diplan-tooltip-arrow-width)}.bs-tooltip-start .tooltip-arrow:before,.bs-tooltip-auto[data-popper-placement^=left] .tooltip-arrow:before{left:-1px;border-width:calc(var(--diplan-tooltip-arrow-width) * .5) 0 calc(var(--diplan-tooltip-arrow-width) * .5) var(--diplan-tooltip-arrow-height);border-left-color:var(--diplan-tooltip-bg)}.tooltip-inner{max-width:var(--diplan-tooltip-max-width);padding:var(--diplan-tooltip-padding-y) var(--diplan-tooltip-padding-x);color:var(--diplan-tooltip-color);text-align:center;background-color:var(--diplan-tooltip-bg);border-radius:var(--diplan-tooltip-border-radius)}.clearfix:after{display:block;clear:both;content:""}.text-bg-primary{color:#fff;background-color:RGBA(var(--diplan-primary-rgb),var(--diplan-bg-opacity, 1))}.text-bg-secondary{color:#04071a;background-color:RGBA(var(--diplan-secondary-rgb),var(--diplan-bg-opacity, 1))}.text-bg-success{color:#04071a;background-color:RGBA(var(--diplan-success-rgb),var(--diplan-bg-opacity, 1))}.text-bg-info{color:#04071a;background-color:RGBA(var(--diplan-info-rgb),var(--diplan-bg-opacity, 1))}.text-bg-warning{color:#04071a;background-color:RGBA(var(--diplan-warning-rgb),var(--diplan-bg-opacity, 1))}.text-bg-danger{color:#fff;background-color:RGBA(var(--diplan-danger-rgb),var(--diplan-bg-opacity, 1))}.text-bg-light{color:#04071a;background-color:RGBA(var(--diplan-light-rgb),var(--diplan-bg-opacity, 1))}.text-bg-dark{color:#fff;background-color:RGBA(var(--diplan-dark-rgb),var(--diplan-bg-opacity, 1))}.link-primary{color:RGBA(var(--diplan-primary-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-primary-rgb),var(--diplan-link-underline-opacity, 1))}.link-primary:hover,.link-primary:focus{color:RGBA(41,94,170,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(41,94,170,var(--diplan-link-underline-opacity, 1))}.link-secondary{color:RGBA(var(--diplan-secondary-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-secondary-rgb),var(--diplan-link-underline-opacity, 1))}.link-secondary:hover,.link-secondary:focus{color:RGBA(214,214,214,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(214,214,214,var(--diplan-link-underline-opacity, 1))}.link-success{color:RGBA(var(--diplan-success-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-success-rgb),var(--diplan-link-underline-opacity, 1))}.link-success:hover,.link-success:focus{color:RGBA(51,184,106,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(51,184,106,var(--diplan-link-underline-opacity, 1))}.link-info{color:RGBA(var(--diplan-info-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-info-rgb),var(--diplan-link-underline-opacity, 1))}.link-info:hover,.link-info:focus{color:RGBA(240,246,255,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(240,246,255,var(--diplan-link-underline-opacity, 1))}.link-warning{color:RGBA(var(--diplan-warning-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-warning-rgb),var(--diplan-link-underline-opacity, 1))}.link-warning:hover,.link-warning:focus{color:RGBA(241,210,51,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(241,210,51,var(--diplan-link-underline-opacity, 1))}.link-danger{color:RGBA(var(--diplan-danger-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-danger-rgb),var(--diplan-link-underline-opacity, 1))}.link-danger:hover,.link-danger:focus{color:RGBA(176,42,55,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(176,42,55,var(--diplan-link-underline-opacity, 1))}.link-light{color:RGBA(var(--diplan-light-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-light-rgb),var(--diplan-link-underline-opacity, 1))}.link-light:hover,.link-light:focus{color:RGBA(240,246,255,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(240,246,255,var(--diplan-link-underline-opacity, 1))}.link-dark{color:RGBA(var(--diplan-dark-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-dark-rgb),var(--diplan-link-underline-opacity, 1))}.link-dark:hover,.link-dark:focus{color:RGBA(34,46,102,var(--diplan-link-opacity, 1));text-decoration-color:RGBA(34,46,102,var(--diplan-link-underline-opacity, 1))}.link-body-emphasis{color:RGBA(var(--diplan-emphasis-color-rgb),var(--diplan-link-opacity, 1));text-decoration-color:RGBA(var(--diplan-emphasis-color-rgb),var(--diplan-link-underline-opacity, 1))}.link-body-emphasis:hover,.link-body-emphasis:focus{color:RGBA(var(--diplan-emphasis-color-rgb),var(--diplan-link-opacity, .75));text-decoration-color:RGBA(var(--diplan-emphasis-color-rgb),var(--diplan-link-underline-opacity, .75))}.focus-ring:focus,.formkit-inner.border:focus,.select.variant-primary input.formkit-inner:focus,.select.variant-primary textarea.formkit-inner:focus,.select.variant-primary select.formkit-inner:focus,.input.variant-primary input.formkit-inner:focus,.input.variant-primary textarea.formkit-inner:focus,.input.variant-primary select.formkit-inner:focus,.select.variant-secondary input.formkit-inner:focus,.select.variant-secondary textarea.formkit-inner:focus,.select.variant-secondary select.formkit-inner:focus,.input.variant-secondary input.formkit-inner:focus,.input.variant-secondary textarea.formkit-inner:focus,.input.variant-secondary select.formkit-inner:focus,.select.variant-success input.formkit-inner:focus,.select.variant-success textarea.formkit-inner:focus,.select.variant-success select.formkit-inner:focus,.input.variant-success input.formkit-inner:focus,.input.variant-success textarea.formkit-inner:focus,.input.variant-success select.formkit-inner:focus,.select.variant-info input.formkit-inner:focus,.select.variant-info textarea.formkit-inner:focus,.select.variant-info select.formkit-inner:focus,.input.variant-info input.formkit-inner:focus,.input.variant-info textarea.formkit-inner:focus,.input.variant-info select.formkit-inner:focus,.select.variant-warning input.formkit-inner:focus,.select.variant-warning textarea.formkit-inner:focus,.select.variant-warning select.formkit-inner:focus,.input.variant-warning input.formkit-inner:focus,.input.variant-warning textarea.formkit-inner:focus,.input.variant-warning select.formkit-inner:focus,.select.variant-danger input.formkit-inner:focus,.select.variant-danger textarea.formkit-inner:focus,.select.variant-danger select.formkit-inner:focus,.input.variant-danger input.formkit-inner:focus,.input.variant-danger textarea.formkit-inner:focus,.input.variant-danger select.formkit-inner:focus,.select.variant-light input.formkit-inner:focus,.select.variant-light textarea.formkit-inner:focus,.select.variant-light select.formkit-inner:focus,.input.variant-light input.formkit-inner:focus,.input.variant-light textarea.formkit-inner:focus,.input.variant-light select.formkit-inner:focus,.select.variant-dark input.formkit-inner:focus,.select.variant-dark textarea.formkit-inner:focus,.select.variant-dark select.formkit-inner:focus,.input.variant-dark input.formkit-inner:focus,.input.variant-dark textarea.formkit-inner:focus,.input.variant-dark select.formkit-inner:focus,.btn:focus:not([class*=btn-]){outline:0;box-shadow:var(--diplan-focus-ring-x, 0) var(--diplan-focus-ring-y, 0) var(--diplan-focus-ring-blur, 0) var(--diplan-focus-ring-width) var(--diplan-focus-ring-color)}.icon-link{display:inline-flex;gap:.375rem;align-items:center;text-decoration-color:rgba(var(--diplan-link-color-rgb),var(--diplan-link-opacity, .5));text-underline-offset:.25em;backface-visibility:hidden}.icon-link>.bi{flex-shrink:0;width:1em;height:1em;fill:currentcolor;transition:.2s ease-in-out transform}@media (prefers-reduced-motion: reduce){.icon-link>.bi{transition:none}}.icon-link-hover:hover>.bi,.icon-link-hover:focus-visible>.bi{transform:var(--diplan-icon-link-transform, translate3d(.25em, 0, 0))}.ratio{position:relative;width:100%}.ratio:before{display:block;padding-top:var(--diplan-aspect-ratio);content:""}.ratio>*{position:absolute;top:0;left:0;width:100%;height:100%}.ratio-1x1{--diplan-aspect-ratio: 100%}.ratio-4x3{--diplan-aspect-ratio: 75%}.ratio-16x9{--diplan-aspect-ratio: 56.25%}.ratio-21x9{--diplan-aspect-ratio: 42.8571428571%}.fixed-top{position:fixed;top:0;right:0;left:0;z-index:1030}.fixed-bottom{position:fixed;right:0;bottom:0;left:0;z-index:1030}.sticky-top{position:sticky;top:0;z-index:1020}.sticky-bottom{position:sticky;bottom:0;z-index:1020}@media (min-width: 576px){.sticky-sm-top{position:sticky;top:0;z-index:1020}.sticky-sm-bottom{position:sticky;bottom:0;z-index:1020}}@media (min-width: 768px){.sticky-md-top{position:sticky;top:0;z-index:1020}.sticky-md-bottom{position:sticky;bottom:0;z-index:1020}}@media (min-width: 992px){.sticky-lg-top{position:sticky;top:0;z-index:1020}.sticky-lg-bottom{position:sticky;bottom:0;z-index:1020}}@media (min-width: 1200px){.sticky-xl-top{position:sticky;top:0;z-index:1020}.sticky-xl-bottom{position:sticky;bottom:0;z-index:1020}}@media (min-width: 1400px){.sticky-xxl-top{position:sticky;top:0;z-index:1020}.sticky-xxl-bottom{position:sticky;bottom:0;z-index:1020}}.hstack{display:flex;flex-direction:row;align-items:center;align-self:stretch}.vstack{display:flex;flex:1 1 auto;flex-direction:column;align-self:stretch}.visually-hidden,.visually-hidden-focusable:not(:focus):not(:focus-within){width:1px!important;height:1px!important;padding:0!important;margin:-1px!important;overflow:hidden!important;clip:rect(0,0,0,0)!important;white-space:nowrap!important;border:0!important}.visually-hidden:not(caption),.visually-hidden-focusable:not(:focus):not(:focus-within):not(caption){position:absolute!important}.stretched-link:after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:1;content:""}.text-truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.vr{display:inline-block;align-self:stretch;width:var(--diplan-border-width);min-height:1em;background-color:currentcolor;opacity:.25}.form-check{display:block;min-height:1.5rem;padding-left:2.5em;margin-bottom:.125rem}.form-check .form-check-input{float:left;margin-left:-2.5em}.form-check-reverse{padding-right:2.5em;padding-left:0;text-align:right}.form-check-reverse .form-check-input{float:right;margin-right:-2.5em;margin-left:0}.form-check-input{--diplan-form-check-bg: #fff;flex-shrink:0;width:1.5em;height:1.5em;margin-top:0;vertical-align:top;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--diplan-form-check-bg);background-image:var(--diplan-form-check-bg-image);background-repeat:no-repeat;background-position:center;background-size:contain;border:var(--diplan-border-width) solid var(--diplan-border-color);-webkit-print-color-adjust:exact;print-color-adjust:exact}.form-check-input[type=checkbox]{border-radius:var(--diplan-border-radius)}.form-check-input[type=radio]{border-radius:50%}.form-check-input:active{filter:brightness(90%)}.form-check-input:focus{border-color:#ccc;outline:0;box-shadow:0 0 0 .25rem #3375d440}.form-check-input:checked{background-color:#3375d4;border-color:#3375d4}.form-check-input:checked[type=checkbox]{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check-input:checked[type=radio]{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23fff'/%3e%3c/svg%3e")}.form-check-input[type=checkbox]:indeterminate{background-color:#fff;border-color:#fff;--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check-input:disabled{pointer-events:none;filter:none;opacity:.5}.form-check-input[disabled]~.form-check-label,.form-check-input:disabled~.form-check-label{cursor:default;opacity:.5}.form-switch{padding-left:2.5em}.form-switch .form-check-input{--diplan-form-switch-bg: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='rgba%284, 7, 26, 0.25%29'/%3e%3c/svg%3e");width:2em;margin-left:-2.5em;background-image:var(--diplan-form-switch-bg);background-position:left center;border-radius:2em;transition:background-position .15s ease-in-out}@media (prefers-reduced-motion: reduce){.form-switch .form-check-input{transition:none}}.form-switch .form-check-input:focus{--diplan-form-switch-bg: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23ccc'/%3e%3c/svg%3e")}.form-switch .form-check-input:checked{background-position:right center;--diplan-form-switch-bg: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e")}.form-switch.form-check-reverse{padding-right:2.5em;padding-left:0}.form-switch.form-check-reverse .form-check-input{margin-right:-2.5em;margin-left:0}.form-check-inline,.input-field.input-group .form-check{display:inline-block;margin-right:1rem}.btn-check{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.btn-check[disabled]+.btn,.btn-check:disabled+.btn{pointer-events:none;filter:none;opacity:1}[data-bs-theme=dark] .form-switch .form-check-input:not(:checked):not(:focus){--diplan-form-switch-bg: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='rgba%28255, 255, 255, 0.25%29'/%3e%3c/svg%3e")}.align-baseline{vertical-align:baseline}.align-top{vertical-align:top}.align-middle{vertical-align:middle}.align-bottom{vertical-align:bottom}.align-text-bottom{vertical-align:text-bottom}.align-text-top{vertical-align:text-top}.float-start{float:left}.float-end{float:right}.float-none{float:none}.object-fit-contain{object-fit:contain}.object-fit-cover{object-fit:cover}.object-fit-fill{object-fit:fill}.object-fit-scale{object-fit:scale-down}.object-fit-none{object-fit:none}.opacity-0{opacity:0}.opacity-25{opacity:.25}.opacity-50{opacity:.5}.opacity-75{opacity:.75}.opacity-100{opacity:1}.opacity-90{opacity:.9}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-scroll{overflow:scroll}.overflow-x-auto{overflow-x:auto}.overflow-x-hidden{overflow-x:hidden}.overflow-x-visible{overflow-x:visible}.overflow-x-scroll{overflow-x:scroll}.overflow-y-auto{overflow-y:auto}.overflow-y-hidden{overflow-y:hidden}.overflow-y-visible{overflow-y:visible}.overflow-y-scroll{overflow-y:scroll}.d-inline{display:inline}.d-inline-block{display:inline-block}.d-block{display:block}.d-grid{display:grid}.d-inline-grid{display:inline-grid}.d-table{display:table}.d-table-row{display:table-row}.d-table-cell{display:table-cell}.d-flex{display:flex}.d-inline-flex{display:inline-flex}.d-none{display:none}.shadow{box-shadow:var(--diplan-box-shadow)}.shadow-sm{box-shadow:var(--diplan-box-shadow-sm)}.shadow-lg{box-shadow:var(--diplan-box-shadow-lg)}.shadow-none{box-shadow:none}.focus-ring-primary{--diplan-focus-ring-color: rgba(var(--diplan-primary-rgb), var(--diplan-focus-ring-opacity))}.focus-ring-secondary{--diplan-focus-ring-color: rgba(var(--diplan-secondary-rgb), var(--diplan-focus-ring-opacity))}.focus-ring-success{--diplan-focus-ring-color: rgba(var(--diplan-success-rgb), var(--diplan-focus-ring-opacity))}.focus-ring-info{--diplan-focus-ring-color: rgba(var(--diplan-info-rgb), var(--diplan-focus-ring-opacity))}.focus-ring-warning{--diplan-focus-ring-color: rgba(var(--diplan-warning-rgb), var(--diplan-focus-ring-opacity))}.focus-ring-danger{--diplan-focus-ring-color: rgba(var(--diplan-danger-rgb), var(--diplan-focus-ring-opacity))}.focus-ring-light{--diplan-focus-ring-color: rgba(var(--diplan-light-rgb), var(--diplan-focus-ring-opacity))}.focus-ring-dark{--diplan-focus-ring-color: rgba(var(--diplan-dark-rgb), var(--diplan-focus-ring-opacity))}.position-static{position:static}.position-relative{position:relative}.position-absolute{position:absolute}.position-fixed{position:fixed}.position-sticky{position:sticky}.top-0{top:0}.top-50{top:50%}.top-100{top:100%}.bottom-0{bottom:0}.bottom-50{bottom:50%}.bottom-100{bottom:100%}.start-0{left:0}.start-50{left:50%}.start-100{left:100%}.end-0{right:0}.end-50{right:50%}.end-100{right:100%}.translate-middle{transform:translate(-50%,-50%)}.translate-middle-x{transform:translate(-50%)}.translate-middle-y{transform:translateY(-50%)}.border,.select.variant-dark input,.select.variant-dark textarea,.select.variant-dark select,.input.variant-dark input,.input.variant-dark textarea,.input.variant-dark select,.select.variant-light input,.select.variant-light textarea,.select.variant-light select,.input.variant-light input,.input.variant-light textarea,.input.variant-light select,.select.variant-danger input,.select.variant-danger textarea,.select.variant-danger select,.input.variant-danger input,.input.variant-danger textarea,.input.variant-danger select,.select.variant-warning input,.select.variant-warning textarea,.select.variant-warning select,.input.variant-warning input,.input.variant-warning textarea,.input.variant-warning select,.select.variant-info input,.select.variant-info textarea,.select.variant-info select,.input.variant-info input,.input.variant-info textarea,.input.variant-info select,.select.variant-success input,.select.variant-success textarea,.select.variant-success select,.input.variant-success input,.input.variant-success textarea,.input.variant-success select,.select.variant-secondary input,.select.variant-secondary textarea,.select.variant-secondary select,.input.variant-secondary input,.input.variant-secondary textarea,.input.variant-secondary select,.select.variant-primary input,.select.variant-primary textarea,.select.variant-primary select,.input.variant-primary input,.input.variant-primary textarea,.input.variant-primary select{border:var(--diplan-border-width) var(--diplan-border-style) var(--diplan-border-color)}.border-0{border:0}.border-top{border-top:var(--diplan-border-width) var(--diplan-border-style) var(--diplan-border-color)}.border-top-0{border-top:0}.border-end{border-right:var(--diplan-border-width) var(--diplan-border-style) var(--diplan-border-color)}.border-end-0{border-right:0}.border-bottom{border-bottom:var(--diplan-border-width) var(--diplan-border-style) var(--diplan-border-color)}.border-bottom-0{border-bottom:0}.border-start{border-left:var(--diplan-border-width) var(--diplan-border-style) var(--diplan-border-color)}.border-start-0{border-left:0}.border-primary,.select.variant-primary input,.select.variant-primary textarea,.select.variant-primary select,.input.variant-primary input,.input.variant-primary textarea,.input.variant-primary select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-primary-rgb),var(--diplan-border-opacity))}.border-secondary,.select.variant-secondary input,.select.variant-secondary textarea,.select.variant-secondary select,.input.variant-secondary input,.input.variant-secondary textarea,.input.variant-secondary select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-secondary-rgb),var(--diplan-border-opacity))}.border-success,.select.variant-success input,.select.variant-success textarea,.select.variant-success select,.input.variant-success input,.input.variant-success textarea,.input.variant-success select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-success-rgb),var(--diplan-border-opacity))}.border-info,.select.variant-info input,.select.variant-info textarea,.select.variant-info select,.input.variant-info input,.input.variant-info textarea,.input.variant-info select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-info-rgb),var(--diplan-border-opacity))}.border-warning,.select.variant-warning input,.select.variant-warning textarea,.select.variant-warning select,.input.variant-warning input,.input.variant-warning textarea,.input.variant-warning select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-warning-rgb),var(--diplan-border-opacity))}.border-danger,.select.variant-danger input,.select.variant-danger textarea,.select.variant-danger select,.input.variant-danger input,.input.variant-danger textarea,.input.variant-danger select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-danger-rgb),var(--diplan-border-opacity))}.border-light,.select.variant-light input,.select.variant-light textarea,.select.variant-light select,.input.variant-light input,.input.variant-light textarea,.input.variant-light select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-light-rgb),var(--diplan-border-opacity))}.border-dark,.select.variant-dark input,.select.variant-dark textarea,.select.variant-dark select,.input.variant-dark input,.input.variant-dark textarea,.input.variant-dark select{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-dark-rgb),var(--diplan-border-opacity))}.border-black{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-black-rgb),var(--diplan-border-opacity))}.border-white{--diplan-border-opacity: 1;border-color:rgba(var(--diplan-white-rgb),var(--diplan-border-opacity))}.border-primary-subtle{border-color:var(--diplan-primary-border-subtle)}.border-secondary-subtle{border-color:var(--diplan-secondary-border-subtle)}.border-success-subtle{border-color:var(--diplan-success-border-subtle)}.border-info-subtle{border-color:var(--diplan-info-border-subtle)}.border-warning-subtle{border-color:var(--diplan-warning-border-subtle)}.border-danger-subtle{border-color:var(--diplan-danger-border-subtle)}.border-light-subtle{border-color:var(--diplan-light-border-subtle)}.border-dark-subtle{border-color:var(--diplan-dark-border-subtle)}.border-1{border-width:1px}.border-2{border-width:2px}.border-3{border-width:3px}.border-4{border-width:4px}.border-5{border-width:5px}.border-opacity-10{--diplan-border-opacity: .1}.border-opacity-25{--diplan-border-opacity: .25}.border-opacity-50{--diplan-border-opacity: .5}.border-opacity-75{--diplan-border-opacity: .75}.border-opacity-100{--diplan-border-opacity: 1}.w-25{width:25%}.w-50{width:50%}.w-75{width:75%}.w-100{width:100%}.w-auto{width:auto}.mw-100{max-width:100%}.vw-100{width:100vw}.min-vw-100{min-width:100vw}.h-25{height:25%}.h-50{height:50%}.h-75{height:75%}.h-100{height:100%}.h-auto{height:auto}.mh-100{max-height:100%}.vh-100{height:100vh}.min-vh-100{min-height:100vh}.flex-fill{flex:1 1 auto}.flex-row{flex-direction:row}.flex-column{flex-direction:column}.flex-row-reverse{flex-direction:row-reverse}.flex-column-reverse{flex-direction:column-reverse}.flex-grow-0{flex-grow:0}.flex-grow-1{flex-grow:1}.flex-shrink-0{flex-shrink:0}.flex-shrink-1{flex-shrink:1}.flex-wrap{flex-wrap:wrap}.flex-nowrap{flex-wrap:nowrap}.flex-wrap-reverse{flex-wrap:wrap-reverse}.justify-content-start{justify-content:flex-start}.justify-content-end{justify-content:flex-end}.justify-content-center{justify-content:center}.justify-content-between{justify-content:space-between}.justify-content-around{justify-content:space-around}.justify-content-evenly{justify-content:space-evenly}.align-items-start{align-items:flex-start}.align-items-end{align-items:flex-end}.align-items-center{align-items:center}.align-items-baseline{align-items:baseline}.align-items-stretch{align-items:stretch}.align-content-start{align-content:flex-start}.align-content-end{align-content:flex-end}.align-content-center{align-content:center}.align-content-between{align-content:space-between}.align-content-around{align-content:space-around}.align-content-stretch{align-content:stretch}.align-self-auto{align-self:auto}.align-self-start{align-self:flex-start}.align-self-end{align-self:flex-end}.align-self-center{align-self:center}.align-self-baseline{align-self:baseline}.align-self-stretch{align-self:stretch}.order-first{order:-1}.order-0{order:0}.order-1{order:1}.order-2{order:2}.order-3{order:3}.order-4{order:4}.order-5{order:5}.order-last{order:6}.m-0{margin:0}.m-1{margin:.25rem}.m-2{margin:.5rem}.m-3{margin:1rem}.m-4{margin:1.5rem}.m-5{margin:2rem}.m-6{margin:3rem}.m-auto{margin:auto}.mx-0{margin-right:0;margin-left:0}.mx-1{margin-right:.25rem;margin-left:.25rem}.mx-2{margin-right:.5rem;margin-left:.5rem}.mx-3{margin-right:1rem;margin-left:1rem}.mx-4{margin-right:1.5rem;margin-left:1.5rem}.mx-5{margin-right:2rem;margin-left:2rem}.mx-6{margin-right:3rem;margin-left:3rem}.mx-auto{margin-right:auto;margin-left:auto}.my-0{margin-top:0;margin-bottom:0}.my-1{margin-top:.25rem;margin-bottom:.25rem}.my-2{margin-top:.5rem;margin-bottom:.5rem}.my-3{margin-top:1rem;margin-bottom:1rem}.my-4{margin-top:1.5rem;margin-bottom:1.5rem}.my-5{margin-top:2rem;margin-bottom:2rem}.my-6{margin-top:3rem;margin-bottom:3rem}.my-auto{margin-top:auto;margin-bottom:auto}.mt-0{margin-top:0}.mt-1{margin-top:.25rem}.mt-2{margin-top:.5rem}.mt-3{margin-top:1rem}.mt-4{margin-top:1.5rem}.mt-5{margin-top:2rem}.mt-6{margin-top:3rem}.mt-auto{margin-top:auto}.me-0{margin-right:0}.me-1{margin-right:.25rem}.me-2{margin-right:.5rem}.me-3{margin-right:1rem}.me-4{margin-right:1.5rem}.me-5{margin-right:2rem}.me-6{margin-right:3rem}.me-auto{margin-right:auto}.mb-0{margin-bottom:0}.mb-1{margin-bottom:.25rem}.mb-2{margin-bottom:.5rem}.mb-3{margin-bottom:1rem}.mb-4{margin-bottom:1.5rem}.mb-5{margin-bottom:2rem}.mb-6{margin-bottom:3rem}.mb-auto{margin-bottom:auto}.ms-0{margin-left:0}.ms-1{margin-left:.25rem}.ms-2{margin-left:.5rem}.ms-3{margin-left:1rem}.ms-4{margin-left:1.5rem}.ms-5{margin-left:2rem}.ms-6{margin-left:3rem}.ms-auto{margin-left:auto}.p-0{padding:0}.p-1{padding:.25rem}.p-2{padding:.5rem}.p-3{padding:1rem}.p-4{padding:1.5rem}.p-5{padding:2rem}.p-6{padding:3rem}.px-0{padding-right:0;padding-left:0}.px-1{padding-right:.25rem;padding-left:.25rem}.px-2{padding-right:.5rem;padding-left:.5rem}.px-3{padding-right:1rem;padding-left:1rem}.px-4{padding-right:1.5rem;padding-left:1.5rem}.px-5{padding-right:2rem;padding-left:2rem}.px-6{padding-right:3rem;padding-left:3rem}.py-0{padding-top:0;padding-bottom:0}.py-1{padding-top:.25rem;padding-bottom:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.py-3{padding-top:1rem;padding-bottom:1rem}.py-4{padding-top:1.5rem;padding-bottom:1.5rem}.py-5{padding-top:2rem;padding-bottom:2rem}.py-6{padding-top:3rem;padding-bottom:3rem}.pt-0{padding-top:0}.pt-1{padding-top:.25rem}.pt-2{padding-top:.5rem}.pt-3{padding-top:1rem}.pt-4{padding-top:1.5rem}.pt-5{padding-top:2rem}.pt-6{padding-top:3rem}.pe-0{padding-right:0}.pe-1{padding-right:.25rem}.pe-2{padding-right:.5rem}.pe-3{padding-right:1rem}.pe-4{padding-right:1.5rem}.pe-5{padding-right:2rem}.pe-6{padding-right:3rem}.pb-0{padding-bottom:0}.pb-1{padding-bottom:.25rem}.pb-2{padding-bottom:.5rem}.pb-3{padding-bottom:1rem}.pb-4{padding-bottom:1.5rem}.pb-5{padding-bottom:2rem}.pb-6{padding-bottom:3rem}.ps-0{padding-left:0}.ps-1{padding-left:.25rem}.ps-2{padding-left:.5rem}.ps-3{padding-left:1rem}.ps-4{padding-left:1.5rem}.ps-5{padding-left:2rem}.ps-6{padding-left:3rem}.gap-0{gap:0}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-3{gap:1rem}.gap-4{gap:1.5rem}.gap-5{gap:2rem}.gap-6{gap:3rem}.row-gap-0{row-gap:0}.row-gap-1{row-gap:.25rem}.row-gap-2{row-gap:.5rem}.row-gap-3{row-gap:1rem}.row-gap-4{row-gap:1.5rem}.row-gap-5{row-gap:2rem}.row-gap-6{row-gap:3rem}.column-gap-0{column-gap:0}.column-gap-1{column-gap:.25rem}.column-gap-2{column-gap:.5rem}.column-gap-3{column-gap:1rem}.column-gap-4{column-gap:1.5rem}.column-gap-5{column-gap:2rem}.column-gap-6{column-gap:3rem}.font-monospace{font-family:var(--diplan-font-monospace)}.fs-1{font-size:calc(1.375rem + 1.5vw)}.fs-2{font-size:calc(1.325rem + .9vw)}.fs-3{font-size:calc(1.3rem + .6vw)}.fs-4{font-size:calc(1.275rem + .3vw)}.fs-5{font-size:1.25rem}.fs-6{font-size:1rem}.fst-italic{font-style:italic}.fst-normal{font-style:normal}.fw-lighter{font-weight:lighter}.fw-light{font-weight:300}.fw-normal{font-weight:400}.fw-medium{font-weight:500}.fw-semibold{font-weight:600}.fw-bold{font-weight:700}.fw-bolder{font-weight:bolder}.lh-1{line-height:1}.lh-sm{line-height:1.25}.lh-base{line-height:1.5}.lh-lg{line-height:2}.text-start{text-align:left}.text-end{text-align:right}.text-center{text-align:center}.text-decoration-none{text-decoration:none}.text-decoration-underline{text-decoration:underline}.text-decoration-line-through{text-decoration:line-through}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-wrap{white-space:normal}.text-nowrap{white-space:nowrap}.text-break{word-wrap:break-word;word-break:break-word}.text-primary{--diplan-text-opacity: 1;color:rgba(var(--diplan-primary-rgb),var(--diplan-text-opacity))}.text-secondary{--diplan-text-opacity: 1;color:rgba(var(--diplan-secondary-rgb),var(--diplan-text-opacity))}.text-success{--diplan-text-opacity: 1;color:rgba(var(--diplan-success-rgb),var(--diplan-text-opacity))}.text-info{--diplan-text-opacity: 1;color:rgba(var(--diplan-info-rgb),var(--diplan-text-opacity))}.text-warning{--diplan-text-opacity: 1;color:rgba(var(--diplan-warning-rgb),var(--diplan-text-opacity))}.text-danger{--diplan-text-opacity: 1;color:rgba(var(--diplan-danger-rgb),var(--diplan-text-opacity))}.text-light{--diplan-text-opacity: 1;color:rgba(var(--diplan-light-rgb),var(--diplan-text-opacity))}.text-dark{--diplan-text-opacity: 1;color:rgba(var(--diplan-dark-rgb),var(--diplan-text-opacity))}.text-black{--diplan-text-opacity: 1;color:rgba(var(--diplan-black-rgb),var(--diplan-text-opacity))}.text-white{--diplan-text-opacity: 1;color:rgba(var(--diplan-white-rgb),var(--diplan-text-opacity))}.text-body{--diplan-text-opacity: 1;color:rgba(var(--diplan-body-color-rgb),var(--diplan-text-opacity))}.text-muted{--diplan-text-opacity: 1;color:var(--diplan-secondary-color)}.text-black-50{--diplan-text-opacity: 1;color:#04071a80}.text-white-50{--diplan-text-opacity: 1;color:#ffffff80}.text-body-secondary{--diplan-text-opacity: 1;color:var(--diplan-secondary-color)}.text-body-tertiary{--diplan-text-opacity: 1;color:var(--diplan-tertiary-color)}.text-body-emphasis{--diplan-text-opacity: 1;color:var(--diplan-emphasis-color)}.text-reset{--diplan-text-opacity: 1;color:inherit}.text-opacity-25{--diplan-text-opacity: .25}.text-opacity-50{--diplan-text-opacity: .5}.text-opacity-75{--diplan-text-opacity: .75}.text-opacity-100{--diplan-text-opacity: 1}.text-primary-emphasis{color:var(--diplan-primary-text-emphasis)}.text-secondary-emphasis{color:var(--diplan-secondary-text-emphasis)}.text-success-emphasis{color:var(--diplan-success-text-emphasis)}.text-info-emphasis{color:var(--diplan-info-text-emphasis)}.text-warning-emphasis{color:var(--diplan-warning-text-emphasis)}.text-danger-emphasis{color:var(--diplan-danger-text-emphasis)}.text-light-emphasis{color:var(--diplan-light-text-emphasis)}.text-dark-emphasis{color:var(--diplan-dark-text-emphasis)}.link-opacity-10,.link-opacity-10-hover:hover{--diplan-link-opacity: .1}.link-opacity-25,.link-opacity-25-hover:hover{--diplan-link-opacity: .25}.link-opacity-50,.link-opacity-50-hover:hover{--diplan-link-opacity: .5}.link-opacity-75,.link-opacity-75-hover:hover{--diplan-link-opacity: .75}.link-opacity-100,.link-opacity-100-hover:hover{--diplan-link-opacity: 1}.link-offset-1,.link-offset-1-hover:hover{text-underline-offset:.125em}.link-offset-2,.link-offset-2-hover:hover{text-underline-offset:.25em}.link-offset-3,.link-offset-3-hover:hover{text-underline-offset:.375em}.link-underline-primary{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-primary-rgb),var(--diplan-link-underline-opacity))}.link-underline-secondary{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-secondary-rgb),var(--diplan-link-underline-opacity))}.link-underline-success{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-success-rgb),var(--diplan-link-underline-opacity))}.link-underline-info{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-info-rgb),var(--diplan-link-underline-opacity))}.link-underline-warning{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-warning-rgb),var(--diplan-link-underline-opacity))}.link-underline-danger{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-danger-rgb),var(--diplan-link-underline-opacity))}.link-underline-light{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-light-rgb),var(--diplan-link-underline-opacity))}.link-underline-dark{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-dark-rgb),var(--diplan-link-underline-opacity))}.link-underline{--diplan-link-underline-opacity: 1;text-decoration-color:rgba(var(--diplan-link-color-rgb),var(--diplan-link-underline-opacity, 1))}.link-underline-opacity-0,.link-underline-opacity-0-hover:hover{--diplan-link-underline-opacity: 0}.link-underline-opacity-10,.link-underline-opacity-10-hover:hover{--diplan-link-underline-opacity: .1}.link-underline-opacity-25,.link-underline-opacity-25-hover:hover{--diplan-link-underline-opacity: .25}.link-underline-opacity-50,.link-underline-opacity-50-hover:hover{--diplan-link-underline-opacity: .5}.link-underline-opacity-75,.link-underline-opacity-75-hover:hover{--diplan-link-underline-opacity: .75}.link-underline-opacity-100,.link-underline-opacity-100-hover:hover{--diplan-link-underline-opacity: 1}.bg-primary{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-primary-rgb),var(--diplan-bg-opacity))}.bg-secondary{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-secondary-rgb),var(--diplan-bg-opacity))}.bg-success{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-success-rgb),var(--diplan-bg-opacity))}.bg-info{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-info-rgb),var(--diplan-bg-opacity))}.bg-warning{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-warning-rgb),var(--diplan-bg-opacity))}.bg-danger{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-danger-rgb),var(--diplan-bg-opacity))}.bg-light{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-light-rgb),var(--diplan-bg-opacity))}.bg-dark{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-dark-rgb),var(--diplan-bg-opacity))}.bg-black{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-black-rgb),var(--diplan-bg-opacity))}.bg-white,.box{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-white-rgb),var(--diplan-bg-opacity))}.bg-body{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-body-bg-rgb),var(--diplan-bg-opacity))}.bg-transparent{--diplan-bg-opacity: 1;background-color:transparent}.bg-body-secondary{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-secondary-bg-rgb),var(--diplan-bg-opacity))}.bg-body-tertiary{--diplan-bg-opacity: 1;background-color:rgba(var(--diplan-tertiary-bg-rgb),var(--diplan-bg-opacity))}.bg-opacity-10{--diplan-bg-opacity: .1}.bg-opacity-25{--diplan-bg-opacity: .25}.bg-opacity-50{--diplan-bg-opacity: .5}.bg-opacity-75{--diplan-bg-opacity: .75}.bg-opacity-100{--diplan-bg-opacity: 1}.bg-primary-subtle{background-color:var(--diplan-primary-bg-subtle)}.bg-secondary-subtle{background-color:var(--diplan-secondary-bg-subtle)}.bg-success-subtle{background-color:var(--diplan-success-bg-subtle)}.bg-info-subtle{background-color:var(--diplan-info-bg-subtle)}.bg-warning-subtle{background-color:var(--diplan-warning-bg-subtle)}.bg-danger-subtle{background-color:var(--diplan-danger-bg-subtle)}.bg-light-subtle{background-color:var(--diplan-light-bg-subtle)}.bg-dark-subtle{background-color:var(--diplan-dark-bg-subtle)}.bg-gradient{background-image:var(--diplan-gradient)}.user-select-all{-webkit-user-select:all;user-select:all}.user-select-auto{-webkit-user-select:auto;user-select:auto}.user-select-none{-webkit-user-select:none;user-select:none}.pe-none{pointer-events:none}.pe-auto{pointer-events:auto}.rounded,.box{border-radius:var(--diplan-border-radius)}.rounded-0{border-radius:0}.rounded-1{border-radius:var(--diplan-border-radius-sm)}.rounded-2{border-radius:var(--diplan-border-radius)}.rounded-3{border-radius:var(--diplan-border-radius-lg)}.rounded-4{border-radius:var(--diplan-border-radius-xl)}.rounded-5{border-radius:var(--diplan-border-radius-xxl)}.rounded-circle{border-radius:50%}.rounded-pill{border-radius:var(--diplan-border-radius-pill)}.rounded-top{border-top-left-radius:var(--diplan-border-radius);border-top-right-radius:var(--diplan-border-radius)}.rounded-top-0{border-top-left-radius:0;border-top-right-radius:0}.rounded-top-1{border-top-left-radius:var(--diplan-border-radius-sm);border-top-right-radius:var(--diplan-border-radius-sm)}.rounded-top-2{border-top-left-radius:var(--diplan-border-radius);border-top-right-radius:var(--diplan-border-radius)}.rounded-top-3{border-top-left-radius:var(--diplan-border-radius-lg);border-top-right-radius:var(--diplan-border-radius-lg)}.rounded-top-4{border-top-left-radius:var(--diplan-border-radius-xl);border-top-right-radius:var(--diplan-border-radius-xl)}.rounded-top-5{border-top-left-radius:var(--diplan-border-radius-xxl);border-top-right-radius:var(--diplan-border-radius-xxl)}.rounded-top-circle{border-top-left-radius:50%;border-top-right-radius:50%}.rounded-top-pill{border-top-left-radius:var(--diplan-border-radius-pill);border-top-right-radius:var(--diplan-border-radius-pill)}.rounded-end{border-top-right-radius:var(--diplan-border-radius);border-bottom-right-radius:var(--diplan-border-radius)}.rounded-end-0{border-top-right-radius:0;border-bottom-right-radius:0}.rounded-end-1{border-top-right-radius:var(--diplan-border-radius-sm);border-bottom-right-radius:var(--diplan-border-radius-sm)}.rounded-end-2{border-top-right-radius:var(--diplan-border-radius);border-bottom-right-radius:var(--diplan-border-radius)}.rounded-end-3{border-top-right-radius:var(--diplan-border-radius-lg);border-bottom-right-radius:var(--diplan-border-radius-lg)}.rounded-end-4{border-top-right-radius:var(--diplan-border-radius-xl);border-bottom-right-radius:var(--diplan-border-radius-xl)}.rounded-end-5{border-top-right-radius:var(--diplan-border-radius-xxl);border-bottom-right-radius:var(--diplan-border-radius-xxl)}.rounded-end-circle{border-top-right-radius:50%;border-bottom-right-radius:50%}.rounded-end-pill{border-top-right-radius:var(--diplan-border-radius-pill);border-bottom-right-radius:var(--diplan-border-radius-pill)}.rounded-bottom{border-bottom-right-radius:var(--diplan-border-radius);border-bottom-left-radius:var(--diplan-border-radius)}.rounded-bottom-0{border-bottom-right-radius:0;border-bottom-left-radius:0}.rounded-bottom-1{border-bottom-right-radius:var(--diplan-border-radius-sm);border-bottom-left-radius:var(--diplan-border-radius-sm)}.rounded-bottom-2{border-bottom-right-radius:var(--diplan-border-radius);border-bottom-left-radius:var(--diplan-border-radius)}.rounded-bottom-3{border-bottom-right-radius:var(--diplan-border-radius-lg);border-bottom-left-radius:var(--diplan-border-radius-lg)}.rounded-bottom-4{border-bottom-right-radius:var(--diplan-border-radius-xl);border-bottom-left-radius:var(--diplan-border-radius-xl)}.rounded-bottom-5{border-bottom-right-radius:var(--diplan-border-radius-xxl);border-bottom-left-radius:var(--diplan-border-radius-xxl)}.rounded-bottom-circle{border-bottom-right-radius:50%;border-bottom-left-radius:50%}.rounded-bottom-pill{border-bottom-right-radius:var(--diplan-border-radius-pill);border-bottom-left-radius:var(--diplan-border-radius-pill)}.rounded-start{border-bottom-left-radius:var(--diplan-border-radius);border-top-left-radius:var(--diplan-border-radius)}.rounded-start-0{border-bottom-left-radius:0;border-top-left-radius:0}.rounded-start-1{border-bottom-left-radius:var(--diplan-border-radius-sm);border-top-left-radius:var(--diplan-border-radius-sm)}.rounded-start-2{border-bottom-left-radius:var(--diplan-border-radius);border-top-left-radius:var(--diplan-border-radius)}.rounded-start-3{border-bottom-left-radius:var(--diplan-border-radius-lg);border-top-left-radius:var(--diplan-border-radius-lg)}.rounded-start-4{border-bottom-left-radius:var(--diplan-border-radius-xl);border-top-left-radius:var(--diplan-border-radius-xl)}.rounded-start-5{border-bottom-left-radius:var(--diplan-border-radius-xxl);border-top-left-radius:var(--diplan-border-radius-xxl)}.rounded-start-circle{border-bottom-left-radius:50%;border-top-left-radius:50%}.rounded-start-pill{border-bottom-left-radius:var(--diplan-border-radius-pill);border-top-left-radius:var(--diplan-border-radius-pill)}.visible{visibility:visible}.invisible{visibility:hidden}.z-n1{z-index:-1}.z-0{z-index:0}.z-1{z-index:1}.z-2{z-index:2}.z-3{z-index:3}@media (min-width: 576px){.float-sm-start{float:left}.float-sm-end{float:right}.float-sm-none{float:none}.object-fit-sm-contain{object-fit:contain}.object-fit-sm-cover{object-fit:cover}.object-fit-sm-fill{object-fit:fill}.object-fit-sm-scale{object-fit:scale-down}.object-fit-sm-none{object-fit:none}.d-sm-inline{display:inline}.d-sm-inline-block{display:inline-block}.d-sm-block{display:block}.d-sm-grid{display:grid}.d-sm-inline-grid{display:inline-grid}.d-sm-table{display:table}.d-sm-table-row{display:table-row}.d-sm-table-cell{display:table-cell}.d-sm-flex{display:flex}.d-sm-inline-flex{display:inline-flex}.d-sm-none{display:none}.flex-sm-fill{flex:1 1 auto}.flex-sm-row{flex-direction:row}.flex-sm-column{flex-direction:column}.flex-sm-row-reverse{flex-direction:row-reverse}.flex-sm-column-reverse{flex-direction:column-reverse}.flex-sm-grow-0{flex-grow:0}.flex-sm-grow-1{flex-grow:1}.flex-sm-shrink-0{flex-shrink:0}.flex-sm-shrink-1{flex-shrink:1}.flex-sm-wrap{flex-wrap:wrap}.flex-sm-nowrap{flex-wrap:nowrap}.flex-sm-wrap-reverse{flex-wrap:wrap-reverse}.justify-content-sm-start{justify-content:flex-start}.justify-content-sm-end{justify-content:flex-end}.justify-content-sm-center{justify-content:center}.justify-content-sm-between{justify-content:space-between}.justify-content-sm-around{justify-content:space-around}.justify-content-sm-evenly{justify-content:space-evenly}.align-items-sm-start{align-items:flex-start}.align-items-sm-end{align-items:flex-end}.align-items-sm-center{align-items:center}.align-items-sm-baseline{align-items:baseline}.align-items-sm-stretch{align-items:stretch}.align-content-sm-start{align-content:flex-start}.align-content-sm-end{align-content:flex-end}.align-content-sm-center{align-content:center}.align-content-sm-between{align-content:space-between}.align-content-sm-around{align-content:space-around}.align-content-sm-stretch{align-content:stretch}.align-self-sm-auto{align-self:auto}.align-self-sm-start{align-self:flex-start}.align-self-sm-end{align-self:flex-end}.align-self-sm-center{align-self:center}.align-self-sm-baseline{align-self:baseline}.align-self-sm-stretch{align-self:stretch}.order-sm-first{order:-1}.order-sm-0{order:0}.order-sm-1{order:1}.order-sm-2{order:2}.order-sm-3{order:3}.order-sm-4{order:4}.order-sm-5{order:5}.order-sm-last{order:6}.m-sm-0{margin:0}.m-sm-1{margin:.25rem}.m-sm-2{margin:.5rem}.m-sm-3{margin:1rem}.m-sm-4{margin:1.5rem}.m-sm-5{margin:2rem}.m-sm-6{margin:3rem}.m-sm-auto{margin:auto}.mx-sm-0{margin-right:0;margin-left:0}.mx-sm-1{margin-right:.25rem;margin-left:.25rem}.mx-sm-2{margin-right:.5rem;margin-left:.5rem}.mx-sm-3{margin-right:1rem;margin-left:1rem}.mx-sm-4{margin-right:1.5rem;margin-left:1.5rem}.mx-sm-5{margin-right:2rem;margin-left:2rem}.mx-sm-6{margin-right:3rem;margin-left:3rem}.mx-sm-auto{margin-right:auto;margin-left:auto}.my-sm-0{margin-top:0;margin-bottom:0}.my-sm-1{margin-top:.25rem;margin-bottom:.25rem}.my-sm-2{margin-top:.5rem;margin-bottom:.5rem}.my-sm-3{margin-top:1rem;margin-bottom:1rem}.my-sm-4{margin-top:1.5rem;margin-bottom:1.5rem}.my-sm-5{margin-top:2rem;margin-bottom:2rem}.my-sm-6{margin-top:3rem;margin-bottom:3rem}.my-sm-auto{margin-top:auto;margin-bottom:auto}.mt-sm-0{margin-top:0}.mt-sm-1{margin-top:.25rem}.mt-sm-2{margin-top:.5rem}.mt-sm-3{margin-top:1rem}.mt-sm-4{margin-top:1.5rem}.mt-sm-5{margin-top:2rem}.mt-sm-6{margin-top:3rem}.mt-sm-auto{margin-top:auto}.me-sm-0{margin-right:0}.me-sm-1{margin-right:.25rem}.me-sm-2{margin-right:.5rem}.me-sm-3{margin-right:1rem}.me-sm-4{margin-right:1.5rem}.me-sm-5{margin-right:2rem}.me-sm-6{margin-right:3rem}.me-sm-auto{margin-right:auto}.mb-sm-0{margin-bottom:0}.mb-sm-1{margin-bottom:.25rem}.mb-sm-2{margin-bottom:.5rem}.mb-sm-3{margin-bottom:1rem}.mb-sm-4{margin-bottom:1.5rem}.mb-sm-5{margin-bottom:2rem}.mb-sm-6{margin-bottom:3rem}.mb-sm-auto{margin-bottom:auto}.ms-sm-0{margin-left:0}.ms-sm-1{margin-left:.25rem}.ms-sm-2{margin-left:.5rem}.ms-sm-3{margin-left:1rem}.ms-sm-4{margin-left:1.5rem}.ms-sm-5{margin-left:2rem}.ms-sm-6{margin-left:3rem}.ms-sm-auto{margin-left:auto}.p-sm-0{padding:0}.p-sm-1{padding:.25rem}.p-sm-2{padding:.5rem}.p-sm-3{padding:1rem}.p-sm-4{padding:1.5rem}.p-sm-5{padding:2rem}.p-sm-6{padding:3rem}.px-sm-0{padding-right:0;padding-left:0}.px-sm-1{padding-right:.25rem;padding-left:.25rem}.px-sm-2{padding-right:.5rem;padding-left:.5rem}.px-sm-3{padding-right:1rem;padding-left:1rem}.px-sm-4{padding-right:1.5rem;padding-left:1.5rem}.px-sm-5{padding-right:2rem;padding-left:2rem}.px-sm-6{padding-right:3rem;padding-left:3rem}.py-sm-0{padding-top:0;padding-bottom:0}.py-sm-1{padding-top:.25rem;padding-bottom:.25rem}.py-sm-2{padding-top:.5rem;padding-bottom:.5rem}.py-sm-3{padding-top:1rem;padding-bottom:1rem}.py-sm-4{padding-top:1.5rem;padding-bottom:1.5rem}.py-sm-5{padding-top:2rem;padding-bottom:2rem}.py-sm-6{padding-top:3rem;padding-bottom:3rem}.pt-sm-0{padding-top:0}.pt-sm-1{padding-top:.25rem}.pt-sm-2{padding-top:.5rem}.pt-sm-3{padding-top:1rem}.pt-sm-4{padding-top:1.5rem}.pt-sm-5{padding-top:2rem}.pt-sm-6{padding-top:3rem}.pe-sm-0{padding-right:0}.pe-sm-1{padding-right:.25rem}.pe-sm-2{padding-right:.5rem}.pe-sm-3{padding-right:1rem}.pe-sm-4{padding-right:1.5rem}.pe-sm-5{padding-right:2rem}.pe-sm-6{padding-right:3rem}.pb-sm-0{padding-bottom:0}.pb-sm-1{padding-bottom:.25rem}.pb-sm-2{padding-bottom:.5rem}.pb-sm-3{padding-bottom:1rem}.pb-sm-4{padding-bottom:1.5rem}.pb-sm-5{padding-bottom:2rem}.pb-sm-6{padding-bottom:3rem}.ps-sm-0{padding-left:0}.ps-sm-1{padding-left:.25rem}.ps-sm-2{padding-left:.5rem}.ps-sm-3{padding-left:1rem}.ps-sm-4{padding-left:1.5rem}.ps-sm-5{padding-left:2rem}.ps-sm-6{padding-left:3rem}.gap-sm-0{gap:0}.gap-sm-1{gap:.25rem}.gap-sm-2{gap:.5rem}.gap-sm-3{gap:1rem}.gap-sm-4{gap:1.5rem}.gap-sm-5{gap:2rem}.gap-sm-6{gap:3rem}.row-gap-sm-0{row-gap:0}.row-gap-sm-1{row-gap:.25rem}.row-gap-sm-2{row-gap:.5rem}.row-gap-sm-3{row-gap:1rem}.row-gap-sm-4{row-gap:1.5rem}.row-gap-sm-5{row-gap:2rem}.row-gap-sm-6{row-gap:3rem}.column-gap-sm-0{column-gap:0}.column-gap-sm-1{column-gap:.25rem}.column-gap-sm-2{column-gap:.5rem}.column-gap-sm-3{column-gap:1rem}.column-gap-sm-4{column-gap:1.5rem}.column-gap-sm-5{column-gap:2rem}.column-gap-sm-6{column-gap:3rem}.text-sm-start{text-align:left}.text-sm-end{text-align:right}.text-sm-center{text-align:center}}@media (min-width: 768px){.float-md-start{float:left}.float-md-end{float:right}.float-md-none{float:none}.object-fit-md-contain{object-fit:contain}.object-fit-md-cover{object-fit:cover}.object-fit-md-fill{object-fit:fill}.object-fit-md-scale{object-fit:scale-down}.object-fit-md-none{object-fit:none}.d-md-inline{display:inline}.d-md-inline-block{display:inline-block}.d-md-block{display:block}.d-md-grid{display:grid}.d-md-inline-grid{display:inline-grid}.d-md-table{display:table}.d-md-table-row{display:table-row}.d-md-table-cell{display:table-cell}.d-md-flex{display:flex}.d-md-inline-flex{display:inline-flex}.d-md-none{display:none}.flex-md-fill{flex:1 1 auto}.flex-md-row{flex-direction:row}.flex-md-column{flex-direction:column}.flex-md-row-reverse{flex-direction:row-reverse}.flex-md-column-reverse{flex-direction:column-reverse}.flex-md-grow-0{flex-grow:0}.flex-md-grow-1{flex-grow:1}.flex-md-shrink-0{flex-shrink:0}.flex-md-shrink-1{flex-shrink:1}.flex-md-wrap{flex-wrap:wrap}.flex-md-nowrap{flex-wrap:nowrap}.flex-md-wrap-reverse{flex-wrap:wrap-reverse}.justify-content-md-start{justify-content:flex-start}.justify-content-md-end{justify-content:flex-end}.justify-content-md-center{justify-content:center}.justify-content-md-between{justify-content:space-between}.justify-content-md-around{justify-content:space-around}.justify-content-md-evenly{justify-content:space-evenly}.align-items-md-start{align-items:flex-start}.align-items-md-end{align-items:flex-end}.align-items-md-center{align-items:center}.align-items-md-baseline{align-items:baseline}.align-items-md-stretch{align-items:stretch}.align-content-md-start{align-content:flex-start}.align-content-md-end{align-content:flex-end}.align-content-md-center{align-content:center}.align-content-md-between{align-content:space-between}.align-content-md-around{align-content:space-around}.align-content-md-stretch{align-content:stretch}.align-self-md-auto{align-self:auto}.align-self-md-start{align-self:flex-start}.align-self-md-end{align-self:flex-end}.align-self-md-center{align-self:center}.align-self-md-baseline{align-self:baseline}.align-self-md-stretch{align-self:stretch}.order-md-first{order:-1}.order-md-0{order:0}.order-md-1{order:1}.order-md-2{order:2}.order-md-3{order:3}.order-md-4{order:4}.order-md-5{order:5}.order-md-last{order:6}.m-md-0{margin:0}.m-md-1{margin:.25rem}.m-md-2{margin:.5rem}.m-md-3{margin:1rem}.m-md-4{margin:1.5rem}.m-md-5{margin:2rem}.m-md-6{margin:3rem}.m-md-auto{margin:auto}.mx-md-0{margin-right:0;margin-left:0}.mx-md-1{margin-right:.25rem;margin-left:.25rem}.mx-md-2{margin-right:.5rem;margin-left:.5rem}.mx-md-3{margin-right:1rem;margin-left:1rem}.mx-md-4{margin-right:1.5rem;margin-left:1.5rem}.mx-md-5{margin-right:2rem;margin-left:2rem}.mx-md-6{margin-right:3rem;margin-left:3rem}.mx-md-auto{margin-right:auto;margin-left:auto}.my-md-0{margin-top:0;margin-bottom:0}.my-md-1{margin-top:.25rem;margin-bottom:.25rem}.my-md-2{margin-top:.5rem;margin-bottom:.5rem}.my-md-3{margin-top:1rem;margin-bottom:1rem}.my-md-4{margin-top:1.5rem;margin-bottom:1.5rem}.my-md-5{margin-top:2rem;margin-bottom:2rem}.my-md-6{margin-top:3rem;margin-bottom:3rem}.my-md-auto{margin-top:auto;margin-bottom:auto}.mt-md-0{margin-top:0}.mt-md-1{margin-top:.25rem}.mt-md-2{margin-top:.5rem}.mt-md-3{margin-top:1rem}.mt-md-4{margin-top:1.5rem}.mt-md-5{margin-top:2rem}.mt-md-6{margin-top:3rem}.mt-md-auto{margin-top:auto}.me-md-0{margin-right:0}.me-md-1{margin-right:.25rem}.me-md-2{margin-right:.5rem}.me-md-3{margin-right:1rem}.me-md-4{margin-right:1.5rem}.me-md-5{margin-right:2rem}.me-md-6{margin-right:3rem}.me-md-auto{margin-right:auto}.mb-md-0{margin-bottom:0}.mb-md-1{margin-bottom:.25rem}.mb-md-2{margin-bottom:.5rem}.mb-md-3{margin-bottom:1rem}.mb-md-4{margin-bottom:1.5rem}.mb-md-5{margin-bottom:2rem}.mb-md-6{margin-bottom:3rem}.mb-md-auto{margin-bottom:auto}.ms-md-0{margin-left:0}.ms-md-1{margin-left:.25rem}.ms-md-2{margin-left:.5rem}.ms-md-3{margin-left:1rem}.ms-md-4{margin-left:1.5rem}.ms-md-5{margin-left:2rem}.ms-md-6{margin-left:3rem}.ms-md-auto{margin-left:auto}.p-md-0{padding:0}.p-md-1{padding:.25rem}.p-md-2{padding:.5rem}.p-md-3{padding:1rem}.p-md-4{padding:1.5rem}.p-md-5{padding:2rem}.p-md-6{padding:3rem}.px-md-0{padding-right:0;padding-left:0}.px-md-1{padding-right:.25rem;padding-left:.25rem}.px-md-2{padding-right:.5rem;padding-left:.5rem}.px-md-3{padding-right:1rem;padding-left:1rem}.px-md-4{padding-right:1.5rem;padding-left:1.5rem}.px-md-5{padding-right:2rem;padding-left:2rem}.px-md-6{padding-right:3rem;padding-left:3rem}.py-md-0{padding-top:0;padding-bottom:0}.py-md-1{padding-top:.25rem;padding-bottom:.25rem}.py-md-2{padding-top:.5rem;padding-bottom:.5rem}.py-md-3{padding-top:1rem;padding-bottom:1rem}.py-md-4{padding-top:1.5rem;padding-bottom:1.5rem}.py-md-5{padding-top:2rem;padding-bottom:2rem}.py-md-6{padding-top:3rem;padding-bottom:3rem}.pt-md-0{padding-top:0}.pt-md-1{padding-top:.25rem}.pt-md-2{padding-top:.5rem}.pt-md-3{padding-top:1rem}.pt-md-4{padding-top:1.5rem}.pt-md-5{padding-top:2rem}.pt-md-6{padding-top:3rem}.pe-md-0{padding-right:0}.pe-md-1{padding-right:.25rem}.pe-md-2{padding-right:.5rem}.pe-md-3{padding-right:1rem}.pe-md-4{padding-right:1.5rem}.pe-md-5{padding-right:2rem}.pe-md-6{padding-right:3rem}.pb-md-0{padding-bottom:0}.pb-md-1{padding-bottom:.25rem}.pb-md-2{padding-bottom:.5rem}.pb-md-3{padding-bottom:1rem}.pb-md-4{padding-bottom:1.5rem}.pb-md-5{padding-bottom:2rem}.pb-md-6{padding-bottom:3rem}.ps-md-0{padding-left:0}.ps-md-1{padding-left:.25rem}.ps-md-2{padding-left:.5rem}.ps-md-3{padding-left:1rem}.ps-md-4{padding-left:1.5rem}.ps-md-5{padding-left:2rem}.ps-md-6{padding-left:3rem}.gap-md-0{gap:0}.gap-md-1{gap:.25rem}.gap-md-2{gap:.5rem}.gap-md-3{gap:1rem}.gap-md-4{gap:1.5rem}.gap-md-5{gap:2rem}.gap-md-6{gap:3rem}.row-gap-md-0{row-gap:0}.row-gap-md-1{row-gap:.25rem}.row-gap-md-2{row-gap:.5rem}.row-gap-md-3{row-gap:1rem}.row-gap-md-4{row-gap:1.5rem}.row-gap-md-5{row-gap:2rem}.row-gap-md-6{row-gap:3rem}.column-gap-md-0{column-gap:0}.column-gap-md-1{column-gap:.25rem}.column-gap-md-2{column-gap:.5rem}.column-gap-md-3{column-gap:1rem}.column-gap-md-4{column-gap:1.5rem}.column-gap-md-5{column-gap:2rem}.column-gap-md-6{column-gap:3rem}.text-md-start{text-align:left}.text-md-end{text-align:right}.text-md-center{text-align:center}}@media (min-width: 992px){.float-lg-start{float:left}.float-lg-end{float:right}.float-lg-none{float:none}.object-fit-lg-contain{object-fit:contain}.object-fit-lg-cover{object-fit:cover}.object-fit-lg-fill{object-fit:fill}.object-fit-lg-scale{object-fit:scale-down}.object-fit-lg-none{object-fit:none}.d-lg-inline{display:inline}.d-lg-inline-block{display:inline-block}.d-lg-block{display:block}.d-lg-grid{display:grid}.d-lg-inline-grid{display:inline-grid}.d-lg-table{display:table}.d-lg-table-row{display:table-row}.d-lg-table-cell{display:table-cell}.d-lg-flex{display:flex}.d-lg-inline-flex{display:inline-flex}.d-lg-none{display:none}.flex-lg-fill{flex:1 1 auto}.flex-lg-row{flex-direction:row}.flex-lg-column{flex-direction:column}.flex-lg-row-reverse{flex-direction:row-reverse}.flex-lg-column-reverse{flex-direction:column-reverse}.flex-lg-grow-0{flex-grow:0}.flex-lg-grow-1{flex-grow:1}.flex-lg-shrink-0{flex-shrink:0}.flex-lg-shrink-1{flex-shrink:1}.flex-lg-wrap{flex-wrap:wrap}.flex-lg-nowrap{flex-wrap:nowrap}.flex-lg-wrap-reverse{flex-wrap:wrap-reverse}.justify-content-lg-start{justify-content:flex-start}.justify-content-lg-end{justify-content:flex-end}.justify-content-lg-center{justify-content:center}.justify-content-lg-between{justify-content:space-between}.justify-content-lg-around{justify-content:space-around}.justify-content-lg-evenly{justify-content:space-evenly}.align-items-lg-start{align-items:flex-start}.align-items-lg-end{align-items:flex-end}.align-items-lg-center{align-items:center}.align-items-lg-baseline{align-items:baseline}.align-items-lg-stretch{align-items:stretch}.align-content-lg-start{align-content:flex-start}.align-content-lg-end{align-content:flex-end}.align-content-lg-center{align-content:center}.align-content-lg-between{align-content:space-between}.align-content-lg-around{align-content:space-around}.align-content-lg-stretch{align-content:stretch}.align-self-lg-auto{align-self:auto}.align-self-lg-start{align-self:flex-start}.align-self-lg-end{align-self:flex-end}.align-self-lg-center{align-self:center}.align-self-lg-baseline{align-self:baseline}.align-self-lg-stretch{align-self:stretch}.order-lg-first{order:-1}.order-lg-0{order:0}.order-lg-1{order:1}.order-lg-2{order:2}.order-lg-3{order:3}.order-lg-4{order:4}.order-lg-5{order:5}.order-lg-last{order:6}.m-lg-0{margin:0}.m-lg-1{margin:.25rem}.m-lg-2{margin:.5rem}.m-lg-3{margin:1rem}.m-lg-4{margin:1.5rem}.m-lg-5{margin:2rem}.m-lg-6{margin:3rem}.m-lg-auto{margin:auto}.mx-lg-0{margin-right:0;margin-left:0}.mx-lg-1{margin-right:.25rem;margin-left:.25rem}.mx-lg-2{margin-right:.5rem;margin-left:.5rem}.mx-lg-3{margin-right:1rem;margin-left:1rem}.mx-lg-4{margin-right:1.5rem;margin-left:1.5rem}.mx-lg-5{margin-right:2rem;margin-left:2rem}.mx-lg-6{margin-right:3rem;margin-left:3rem}.mx-lg-auto{margin-right:auto;margin-left:auto}.my-lg-0{margin-top:0;margin-bottom:0}.my-lg-1{margin-top:.25rem;margin-bottom:.25rem}.my-lg-2{margin-top:.5rem;margin-bottom:.5rem}.my-lg-3{margin-top:1rem;margin-bottom:1rem}.my-lg-4{margin-top:1.5rem;margin-bottom:1.5rem}.my-lg-5{margin-top:2rem;margin-bottom:2rem}.my-lg-6{margin-top:3rem;margin-bottom:3rem}.my-lg-auto{margin-top:auto;margin-bottom:auto}.mt-lg-0{margin-top:0}.mt-lg-1{margin-top:.25rem}.mt-lg-2{margin-top:.5rem}.mt-lg-3{margin-top:1rem}.mt-lg-4{margin-top:1.5rem}.mt-lg-5{margin-top:2rem}.mt-lg-6{margin-top:3rem}.mt-lg-auto{margin-top:auto}.me-lg-0{margin-right:0}.me-lg-1{margin-right:.25rem}.me-lg-2{margin-right:.5rem}.me-lg-3{margin-right:1rem}.me-lg-4{margin-right:1.5rem}.me-lg-5{margin-right:2rem}.me-lg-6{margin-right:3rem}.me-lg-auto{margin-right:auto}.mb-lg-0{margin-bottom:0}.mb-lg-1{margin-bottom:.25rem}.mb-lg-2{margin-bottom:.5rem}.mb-lg-3{margin-bottom:1rem}.mb-lg-4{margin-bottom:1.5rem}.mb-lg-5{margin-bottom:2rem}.mb-lg-6{margin-bottom:3rem}.mb-lg-auto{margin-bottom:auto}.ms-lg-0{margin-left:0}.ms-lg-1{margin-left:.25rem}.ms-lg-2{margin-left:.5rem}.ms-lg-3{margin-left:1rem}.ms-lg-4{margin-left:1.5rem}.ms-lg-5{margin-left:2rem}.ms-lg-6{margin-left:3rem}.ms-lg-auto{margin-left:auto}.p-lg-0{padding:0}.p-lg-1{padding:.25rem}.p-lg-2{padding:.5rem}.p-lg-3{padding:1rem}.p-lg-4{padding:1.5rem}.p-lg-5{padding:2rem}.p-lg-6{padding:3rem}.px-lg-0{padding-right:0;padding-left:0}.px-lg-1{padding-right:.25rem;padding-left:.25rem}.px-lg-2{padding-right:.5rem;padding-left:.5rem}.px-lg-3{padding-right:1rem;padding-left:1rem}.px-lg-4{padding-right:1.5rem;padding-left:1.5rem}.px-lg-5{padding-right:2rem;padding-left:2rem}.px-lg-6{padding-right:3rem;padding-left:3rem}.py-lg-0{padding-top:0;padding-bottom:0}.py-lg-1{padding-top:.25rem;padding-bottom:.25rem}.py-lg-2{padding-top:.5rem;padding-bottom:.5rem}.py-lg-3{padding-top:1rem;padding-bottom:1rem}.py-lg-4{padding-top:1.5rem;padding-bottom:1.5rem}.py-lg-5{padding-top:2rem;padding-bottom:2rem}.py-lg-6{padding-top:3rem;padding-bottom:3rem}.pt-lg-0{padding-top:0}.pt-lg-1{padding-top:.25rem}.pt-lg-2{padding-top:.5rem}.pt-lg-3{padding-top:1rem}.pt-lg-4{padding-top:1.5rem}.pt-lg-5{padding-top:2rem}.pt-lg-6{padding-top:3rem}.pe-lg-0{padding-right:0}.pe-lg-1{padding-right:.25rem}.pe-lg-2{padding-right:.5rem}.pe-lg-3{padding-right:1rem}.pe-lg-4{padding-right:1.5rem}.pe-lg-5{padding-right:2rem}.pe-lg-6{padding-right:3rem}.pb-lg-0{padding-bottom:0}.pb-lg-1{padding-bottom:.25rem}.pb-lg-2{padding-bottom:.5rem}.pb-lg-3{padding-bottom:1rem}.pb-lg-4{padding-bottom:1.5rem}.pb-lg-5{padding-bottom:2rem}.pb-lg-6{padding-bottom:3rem}.ps-lg-0{padding-left:0}.ps-lg-1{padding-left:.25rem}.ps-lg-2{padding-left:.5rem}.ps-lg-3{padding-left:1rem}.ps-lg-4{padding-left:1.5rem}.ps-lg-5{padding-left:2rem}.ps-lg-6{padding-left:3rem}.gap-lg-0{gap:0}.gap-lg-1{gap:.25rem}.gap-lg-2{gap:.5rem}.gap-lg-3{gap:1rem}.gap-lg-4{gap:1.5rem}.gap-lg-5{gap:2rem}.gap-lg-6{gap:3rem}.row-gap-lg-0{row-gap:0}.row-gap-lg-1{row-gap:.25rem}.row-gap-lg-2{row-gap:.5rem}.row-gap-lg-3{row-gap:1rem}.row-gap-lg-4{row-gap:1.5rem}.row-gap-lg-5{row-gap:2rem}.row-gap-lg-6{row-gap:3rem}.column-gap-lg-0{column-gap:0}.column-gap-lg-1{column-gap:.25rem}.column-gap-lg-2{column-gap:.5rem}.column-gap-lg-3{column-gap:1rem}.column-gap-lg-4{column-gap:1.5rem}.column-gap-lg-5{column-gap:2rem}.column-gap-lg-6{column-gap:3rem}.text-lg-start{text-align:left}.text-lg-end{text-align:right}.text-lg-center{text-align:center}}@media (min-width: 1200px){.float-xl-start{float:left}.float-xl-end{float:right}.float-xl-none{float:none}.object-fit-xl-contain{object-fit:contain}.object-fit-xl-cover{object-fit:cover}.object-fit-xl-fill{object-fit:fill}.object-fit-xl-scale{object-fit:scale-down}.object-fit-xl-none{object-fit:none}.d-xl-inline{display:inline}.d-xl-inline-block{display:inline-block}.d-xl-block{display:block}.d-xl-grid{display:grid}.d-xl-inline-grid{display:inline-grid}.d-xl-table{display:table}.d-xl-table-row{display:table-row}.d-xl-table-cell{display:table-cell}.d-xl-flex{display:flex}.d-xl-inline-flex{display:inline-flex}.d-xl-none{display:none}.flex-xl-fill{flex:1 1 auto}.flex-xl-row{flex-direction:row}.flex-xl-column{flex-direction:column}.flex-xl-row-reverse{flex-direction:row-reverse}.flex-xl-column-reverse{flex-direction:column-reverse}.flex-xl-grow-0{flex-grow:0}.flex-xl-grow-1{flex-grow:1}.flex-xl-shrink-0{flex-shrink:0}.flex-xl-shrink-1{flex-shrink:1}.flex-xl-wrap{flex-wrap:wrap}.flex-xl-nowrap{flex-wrap:nowrap}.flex-xl-wrap-reverse{flex-wrap:wrap-reverse}.justify-content-xl-start{justify-content:flex-start}.justify-content-xl-end{justify-content:flex-end}.justify-content-xl-center{justify-content:center}.justify-content-xl-between{justify-content:space-between}.justify-content-xl-around{justify-content:space-around}.justify-content-xl-evenly{justify-content:space-evenly}.align-items-xl-start{align-items:flex-start}.align-items-xl-end{align-items:flex-end}.align-items-xl-center{align-items:center}.align-items-xl-baseline{align-items:baseline}.align-items-xl-stretch{align-items:stretch}.align-content-xl-start{align-content:flex-start}.align-content-xl-end{align-content:flex-end}.align-content-xl-center{align-content:center}.align-content-xl-between{align-content:space-between}.align-content-xl-around{align-content:space-around}.align-content-xl-stretch{align-content:stretch}.align-self-xl-auto{align-self:auto}.align-self-xl-start{align-self:flex-start}.align-self-xl-end{align-self:flex-end}.align-self-xl-center{align-self:center}.align-self-xl-baseline{align-self:baseline}.align-self-xl-stretch{align-self:stretch}.order-xl-first{order:-1}.order-xl-0{order:0}.order-xl-1{order:1}.order-xl-2{order:2}.order-xl-3{order:3}.order-xl-4{order:4}.order-xl-5{order:5}.order-xl-last{order:6}.m-xl-0{margin:0}.m-xl-1{margin:.25rem}.m-xl-2{margin:.5rem}.m-xl-3{margin:1rem}.m-xl-4{margin:1.5rem}.m-xl-5{margin:2rem}.m-xl-6{margin:3rem}.m-xl-auto{margin:auto}.mx-xl-0{margin-right:0;margin-left:0}.mx-xl-1{margin-right:.25rem;margin-left:.25rem}.mx-xl-2{margin-right:.5rem;margin-left:.5rem}.mx-xl-3{margin-right:1rem;margin-left:1rem}.mx-xl-4{margin-right:1.5rem;margin-left:1.5rem}.mx-xl-5{margin-right:2rem;margin-left:2rem}.mx-xl-6{margin-right:3rem;margin-left:3rem}.mx-xl-auto{margin-right:auto;margin-left:auto}.my-xl-0{margin-top:0;margin-bottom:0}.my-xl-1{margin-top:.25rem;margin-bottom:.25rem}.my-xl-2{margin-top:.5rem;margin-bottom:.5rem}.my-xl-3{margin-top:1rem;margin-bottom:1rem}.my-xl-4{margin-top:1.5rem;margin-bottom:1.5rem}.my-xl-5{margin-top:2rem;margin-bottom:2rem}.my-xl-6{margin-top:3rem;margin-bottom:3rem}.my-xl-auto{margin-top:auto;margin-bottom:auto}.mt-xl-0{margin-top:0}.mt-xl-1{margin-top:.25rem}.mt-xl-2{margin-top:.5rem}.mt-xl-3{margin-top:1rem}.mt-xl-4{margin-top:1.5rem}.mt-xl-5{margin-top:2rem}.mt-xl-6{margin-top:3rem}.mt-xl-auto{margin-top:auto}.me-xl-0{margin-right:0}.me-xl-1{margin-right:.25rem}.me-xl-2{margin-right:.5rem}.me-xl-3{margin-right:1rem}.me-xl-4{margin-right:1.5rem}.me-xl-5{margin-right:2rem}.me-xl-6{margin-right:3rem}.me-xl-auto{margin-right:auto}.mb-xl-0{margin-bottom:0}.mb-xl-1{margin-bottom:.25rem}.mb-xl-2{margin-bottom:.5rem}.mb-xl-3{margin-bottom:1rem}.mb-xl-4{margin-bottom:1.5rem}.mb-xl-5{margin-bottom:2rem}.mb-xl-6{margin-bottom:3rem}.mb-xl-auto{margin-bottom:auto}.ms-xl-0{margin-left:0}.ms-xl-1{margin-left:.25rem}.ms-xl-2{margin-left:.5rem}.ms-xl-3{margin-left:1rem}.ms-xl-4{margin-left:1.5rem}.ms-xl-5{margin-left:2rem}.ms-xl-6{margin-left:3rem}.ms-xl-auto{margin-left:auto}.p-xl-0{padding:0}.p-xl-1{padding:.25rem}.p-xl-2{padding:.5rem}.p-xl-3{padding:1rem}.p-xl-4{padding:1.5rem}.p-xl-5{padding:2rem}.p-xl-6{padding:3rem}.px-xl-0{padding-right:0;padding-left:0}.px-xl-1{padding-right:.25rem;padding-left:.25rem}.px-xl-2{padding-right:.5rem;padding-left:.5rem}.px-xl-3{padding-right:1rem;padding-left:1rem}.px-xl-4{padding-right:1.5rem;padding-left:1.5rem}.px-xl-5{padding-right:2rem;padding-left:2rem}.px-xl-6{padding-right:3rem;padding-left:3rem}.py-xl-0{padding-top:0;padding-bottom:0}.py-xl-1{padding-top:.25rem;padding-bottom:.25rem}.py-xl-2{padding-top:.5rem;padding-bottom:.5rem}.py-xl-3{padding-top:1rem;padding-bottom:1rem}.py-xl-4{padding-top:1.5rem;padding-bottom:1.5rem}.py-xl-5{padding-top:2rem;padding-bottom:2rem}.py-xl-6{padding-top:3rem;padding-bottom:3rem}.pt-xl-0{padding-top:0}.pt-xl-1{padding-top:.25rem}.pt-xl-2{padding-top:.5rem}.pt-xl-3{padding-top:1rem}.pt-xl-4{padding-top:1.5rem}.pt-xl-5{padding-top:2rem}.pt-xl-6{padding-top:3rem}.pe-xl-0{padding-right:0}.pe-xl-1{padding-right:.25rem}.pe-xl-2{padding-right:.5rem}.pe-xl-3{padding-right:1rem}.pe-xl-4{padding-right:1.5rem}.pe-xl-5{padding-right:2rem}.pe-xl-6{padding-right:3rem}.pb-xl-0{padding-bottom:0}.pb-xl-1{padding-bottom:.25rem}.pb-xl-2{padding-bottom:.5rem}.pb-xl-3{padding-bottom:1rem}.pb-xl-4{padding-bottom:1.5rem}.pb-xl-5{padding-bottom:2rem}.pb-xl-6{padding-bottom:3rem}.ps-xl-0{padding-left:0}.ps-xl-1{padding-left:.25rem}.ps-xl-2{padding-left:.5rem}.ps-xl-3{padding-left:1rem}.ps-xl-4{padding-left:1.5rem}.ps-xl-5{padding-left:2rem}.ps-xl-6{padding-left:3rem}.gap-xl-0{gap:0}.gap-xl-1{gap:.25rem}.gap-xl-2{gap:.5rem}.gap-xl-3{gap:1rem}.gap-xl-4{gap:1.5rem}.gap-xl-5{gap:2rem}.gap-xl-6{gap:3rem}.row-gap-xl-0{row-gap:0}.row-gap-xl-1{row-gap:.25rem}.row-gap-xl-2{row-gap:.5rem}.row-gap-xl-3{row-gap:1rem}.row-gap-xl-4{row-gap:1.5rem}.row-gap-xl-5{row-gap:2rem}.row-gap-xl-6{row-gap:3rem}.column-gap-xl-0{column-gap:0}.column-gap-xl-1{column-gap:.25rem}.column-gap-xl-2{column-gap:.5rem}.column-gap-xl-3{column-gap:1rem}.column-gap-xl-4{column-gap:1.5rem}.column-gap-xl-5{column-gap:2rem}.column-gap-xl-6{column-gap:3rem}.text-xl-start{text-align:left}.text-xl-end{text-align:right}.text-xl-center{text-align:center}}@media (min-width: 1400px){.float-xxl-start{float:left}.float-xxl-end{float:right}.float-xxl-none{float:none}.object-fit-xxl-contain{object-fit:contain}.object-fit-xxl-cover{object-fit:cover}.object-fit-xxl-fill{object-fit:fill}.object-fit-xxl-scale{object-fit:scale-down}.object-fit-xxl-none{object-fit:none}.d-xxl-inline{display:inline}.d-xxl-inline-block{display:inline-block}.d-xxl-block{display:block}.d-xxl-grid{display:grid}.d-xxl-inline-grid{display:inline-grid}.d-xxl-table{display:table}.d-xxl-table-row{display:table-row}.d-xxl-table-cell{display:table-cell}.d-xxl-flex{display:flex}.d-xxl-inline-flex{display:inline-flex}.d-xxl-none{display:none}.flex-xxl-fill{flex:1 1 auto}.flex-xxl-row{flex-direction:row}.flex-xxl-column{flex-direction:column}.flex-xxl-row-reverse{flex-direction:row-reverse}.flex-xxl-column-reverse{flex-direction:column-reverse}.flex-xxl-grow-0{flex-grow:0}.flex-xxl-grow-1{flex-grow:1}.flex-xxl-shrink-0{flex-shrink:0}.flex-xxl-shrink-1{flex-shrink:1}.flex-xxl-wrap{flex-wrap:wrap}.flex-xxl-nowrap{flex-wrap:nowrap}.flex-xxl-wrap-reverse{flex-wrap:wrap-reverse}.justify-content-xxl-start{justify-content:flex-start}.justify-content-xxl-end{justify-content:flex-end}.justify-content-xxl-center{justify-content:center}.justify-content-xxl-between{justify-content:space-between}.justify-content-xxl-around{justify-content:space-around}.justify-content-xxl-evenly{justify-content:space-evenly}.align-items-xxl-start{align-items:flex-start}.align-items-xxl-end{align-items:flex-end}.align-items-xxl-center{align-items:center}.align-items-xxl-baseline{align-items:baseline}.align-items-xxl-stretch{align-items:stretch}.align-content-xxl-start{align-content:flex-start}.align-content-xxl-end{align-content:flex-end}.align-content-xxl-center{align-content:center}.align-content-xxl-between{align-content:space-between}.align-content-xxl-around{align-content:space-around}.align-content-xxl-stretch{align-content:stretch}.align-self-xxl-auto{align-self:auto}.align-self-xxl-start{align-self:flex-start}.align-self-xxl-end{align-self:flex-end}.align-self-xxl-center{align-self:center}.align-self-xxl-baseline{align-self:baseline}.align-self-xxl-stretch{align-self:stretch}.order-xxl-first{order:-1}.order-xxl-0{order:0}.order-xxl-1{order:1}.order-xxl-2{order:2}.order-xxl-3{order:3}.order-xxl-4{order:4}.order-xxl-5{order:5}.order-xxl-last{order:6}.m-xxl-0{margin:0}.m-xxl-1{margin:.25rem}.m-xxl-2{margin:.5rem}.m-xxl-3{margin:1rem}.m-xxl-4{margin:1.5rem}.m-xxl-5{margin:2rem}.m-xxl-6{margin:3rem}.m-xxl-auto{margin:auto}.mx-xxl-0{margin-right:0;margin-left:0}.mx-xxl-1{margin-right:.25rem;margin-left:.25rem}.mx-xxl-2{margin-right:.5rem;margin-left:.5rem}.mx-xxl-3{margin-right:1rem;margin-left:1rem}.mx-xxl-4{margin-right:1.5rem;margin-left:1.5rem}.mx-xxl-5{margin-right:2rem;margin-left:2rem}.mx-xxl-6{margin-right:3rem;margin-left:3rem}.mx-xxl-auto{margin-right:auto;margin-left:auto}.my-xxl-0{margin-top:0;margin-bottom:0}.my-xxl-1{margin-top:.25rem;margin-bottom:.25rem}.my-xxl-2{margin-top:.5rem;margin-bottom:.5rem}.my-xxl-3{margin-top:1rem;margin-bottom:1rem}.my-xxl-4{margin-top:1.5rem;margin-bottom:1.5rem}.my-xxl-5{margin-top:2rem;margin-bottom:2rem}.my-xxl-6{margin-top:3rem;margin-bottom:3rem}.my-xxl-auto{margin-top:auto;margin-bottom:auto}.mt-xxl-0{margin-top:0}.mt-xxl-1{margin-top:.25rem}.mt-xxl-2{margin-top:.5rem}.mt-xxl-3{margin-top:1rem}.mt-xxl-4{margin-top:1.5rem}.mt-xxl-5{margin-top:2rem}.mt-xxl-6{margin-top:3rem}.mt-xxl-auto{margin-top:auto}.me-xxl-0{margin-right:0}.me-xxl-1{margin-right:.25rem}.me-xxl-2{margin-right:.5rem}.me-xxl-3{margin-right:1rem}.me-xxl-4{margin-right:1.5rem}.me-xxl-5{margin-right:2rem}.me-xxl-6{margin-right:3rem}.me-xxl-auto{margin-right:auto}.mb-xxl-0{margin-bottom:0}.mb-xxl-1{margin-bottom:.25rem}.mb-xxl-2{margin-bottom:.5rem}.mb-xxl-3{margin-bottom:1rem}.mb-xxl-4{margin-bottom:1.5rem}.mb-xxl-5{margin-bottom:2rem}.mb-xxl-6{margin-bottom:3rem}.mb-xxl-auto{margin-bottom:auto}.ms-xxl-0{margin-left:0}.ms-xxl-1{margin-left:.25rem}.ms-xxl-2{margin-left:.5rem}.ms-xxl-3{margin-left:1rem}.ms-xxl-4{margin-left:1.5rem}.ms-xxl-5{margin-left:2rem}.ms-xxl-6{margin-left:3rem}.ms-xxl-auto{margin-left:auto}.p-xxl-0{padding:0}.p-xxl-1{padding:.25rem}.p-xxl-2{padding:.5rem}.p-xxl-3{padding:1rem}.p-xxl-4{padding:1.5rem}.p-xxl-5{padding:2rem}.p-xxl-6{padding:3rem}.px-xxl-0{padding-right:0;padding-left:0}.px-xxl-1{padding-right:.25rem;padding-left:.25rem}.px-xxl-2{padding-right:.5rem;padding-left:.5rem}.px-xxl-3{padding-right:1rem;padding-left:1rem}.px-xxl-4{padding-right:1.5rem;padding-left:1.5rem}.px-xxl-5{padding-right:2rem;padding-left:2rem}.px-xxl-6{padding-right:3rem;padding-left:3rem}.py-xxl-0{padding-top:0;padding-bottom:0}.py-xxl-1{padding-top:.25rem;padding-bottom:.25rem}.py-xxl-2{padding-top:.5rem;padding-bottom:.5rem}.py-xxl-3{padding-top:1rem;padding-bottom:1rem}.py-xxl-4{padding-top:1.5rem;padding-bottom:1.5rem}.py-xxl-5{padding-top:2rem;padding-bottom:2rem}.py-xxl-6{padding-top:3rem;padding-bottom:3rem}.pt-xxl-0{padding-top:0}.pt-xxl-1{padding-top:.25rem}.pt-xxl-2{padding-top:.5rem}.pt-xxl-3{padding-top:1rem}.pt-xxl-4{padding-top:1.5rem}.pt-xxl-5{padding-top:2rem}.pt-xxl-6{padding-top:3rem}.pe-xxl-0{padding-right:0}.pe-xxl-1{padding-right:.25rem}.pe-xxl-2{padding-right:.5rem}.pe-xxl-3{padding-right:1rem}.pe-xxl-4{padding-right:1.5rem}.pe-xxl-5{padding-right:2rem}.pe-xxl-6{padding-right:3rem}.pb-xxl-0{padding-bottom:0}.pb-xxl-1{padding-bottom:.25rem}.pb-xxl-2{padding-bottom:.5rem}.pb-xxl-3{padding-bottom:1rem}.pb-xxl-4{padding-bottom:1.5rem}.pb-xxl-5{padding-bottom:2rem}.pb-xxl-6{padding-bottom:3rem}.ps-xxl-0{padding-left:0}.ps-xxl-1{padding-left:.25rem}.ps-xxl-2{padding-left:.5rem}.ps-xxl-3{padding-left:1rem}.ps-xxl-4{padding-left:1.5rem}.ps-xxl-5{padding-left:2rem}.ps-xxl-6{padding-left:3rem}.gap-xxl-0{gap:0}.gap-xxl-1{gap:.25rem}.gap-xxl-2{gap:.5rem}.gap-xxl-3{gap:1rem}.gap-xxl-4{gap:1.5rem}.gap-xxl-5{gap:2rem}.gap-xxl-6{gap:3rem}.row-gap-xxl-0{row-gap:0}.row-gap-xxl-1{row-gap:.25rem}.row-gap-xxl-2{row-gap:.5rem}.row-gap-xxl-3{row-gap:1rem}.row-gap-xxl-4{row-gap:1.5rem}.row-gap-xxl-5{row-gap:2rem}.row-gap-xxl-6{row-gap:3rem}.column-gap-xxl-0{column-gap:0}.column-gap-xxl-1{column-gap:.25rem}.column-gap-xxl-2{column-gap:.5rem}.column-gap-xxl-3{column-gap:1rem}.column-gap-xxl-4{column-gap:1.5rem}.column-gap-xxl-5{column-gap:2rem}.column-gap-xxl-6{column-gap:3rem}.text-xxl-start{text-align:left}.text-xxl-end{text-align:right}.text-xxl-center{text-align:center}}@media (min-width: 1200px){.fs-1{font-size:2.5rem}.fs-2{font-size:2rem}.fs-3{font-size:1.75rem}.fs-4{font-size:1.5rem}}@media print{.d-print-inline{display:inline}.d-print-inline-block{display:inline-block}.d-print-block{display:block}.d-print-grid{display:grid}.d-print-inline-grid{display:inline-grid}.d-print-table{display:table}.d-print-table-row{display:table-row}.d-print-table-cell{display:table-cell}.d-print-flex{display:flex}.d-print-inline-flex{display:inline-flex}.d-print-none{display:none}}.btn-close>.icon,.btn-close.icon>i,.btn-close.icon>svg{visibility:hidden}html.scroll-clipped,body.scroll-clipped{overflow:hidden;padding-right:1rem}html.scroll-hidden,body.scroll-hidden{position:fixed;width:100%;bottom:0;overflow-x:hidden;overflow-y:scroll}.clickable{cursor:pointer}.not-clickable{cursor:unset!important}.fit-content{width:fit-content}.max-content{width:max-content}.max-width,.fullwidth{width:100%}.width-unset{width:unset}.max-height,.fullheight{height:100%}.height-unset{height:unset}.text-right{text-align:right}.text-left{text-align:left}.text-centered,.text-center{text-align:center}.z-dropdown{z-index:1000}.z-sticky{z-index:1020}.z-fixed{z-index:1030}.z-offcanvas-backdrop{z-index:1040}.z-offcanvas{z-index:1045}.z-modal-backdrop{z-index:1050}.z-modal{z-index:1055}.z-popover{z-index:1070}.z-tooltip{z-index:1080}.z-toast{z-index:1090}.bg-blue{background-color:rgba(var(--diplan-blue-rgb),var(--diplan-bg-opacity, 1))}.bg-blue-subtle{background-color:rgba(207,226,255,var(--diplan-bg-opacity, 1))}.text-blue{color:var(--diplan-blue)}.bg-indigo{background-color:rgba(var(--diplan-indigo-rgb),var(--diplan-bg-opacity, 1))}.bg-indigo-subtle{background-color:rgba(224,207,252,var(--diplan-bg-opacity, 1))}.text-indigo{color:var(--diplan-indigo)}.bg-purple{background-color:rgba(var(--diplan-purple-rgb),var(--diplan-bg-opacity, 1))}.bg-purple-subtle{background-color:rgba(226,217,243,var(--diplan-bg-opacity, 1))}.text-purple{color:var(--diplan-purple)}.bg-pink{background-color:rgba(var(--diplan-pink-rgb),var(--diplan-bg-opacity, 1))}.bg-pink-subtle{background-color:rgba(247,214,230,var(--diplan-bg-opacity, 1))}.text-pink{color:var(--diplan-pink)}.bg-red{background-color:rgba(var(--diplan-red-rgb),var(--diplan-bg-opacity, 1))}.bg-red-subtle{background-color:rgba(248,215,218,var(--diplan-bg-opacity, 1))}.text-red{color:var(--diplan-red)}.bg-orange{background-color:rgba(var(--diplan-orange-rgb),var(--diplan-bg-opacity, 1))}.bg-orange-subtle{background-color:rgba(255,229,208,var(--diplan-bg-opacity, 1))}.text-orange{color:var(--diplan-orange)}.bg-yellow{background-color:rgba(var(--diplan-yellow-rgb),var(--diplan-bg-opacity, 1))}.bg-yellow-subtle{background-color:rgba(255,243,205,var(--diplan-bg-opacity, 1))}.text-yellow{color:var(--diplan-yellow)}.bg-green{background-color:rgba(var(--diplan-green-rgb),var(--diplan-bg-opacity, 1))}.bg-green-subtle{background-color:rgba(209,231,221,var(--diplan-bg-opacity, 1))}.text-green{color:var(--diplan-green)}.bg-teal{background-color:rgba(var(--diplan-teal-rgb),var(--diplan-bg-opacity, 1))}.bg-teal-subtle{background-color:rgba(210,244,234,var(--diplan-bg-opacity, 1))}.text-teal{color:var(--diplan-teal)}.bg-cyan{background-color:rgba(var(--diplan-cyan-rgb),var(--diplan-bg-opacity, 1))}.bg-cyan-subtle{background-color:rgba(207,244,252,var(--diplan-bg-opacity, 1))}.text-cyan{color:var(--diplan-cyan)}.bg-black{background-color:rgba(var(--diplan-black-rgb),var(--diplan-bg-opacity, 1))}.bg-black-subtle{background-color:rgba(205,205,209,var(--diplan-bg-opacity, 1))}.text-black{color:var(--diplan-black)}.bg-white,.box{background-color:rgba(var(--diplan-white-rgb),var(--diplan-bg-opacity, 1))}.bg-white-subtle{background-color:rgba(255,255,255,var(--diplan-bg-opacity, 1))}.text-white{color:var(--diplan-white)}.bg-gray{background-color:rgba(var(--diplan-gray-rgb),var(--diplan-bg-opacity, 1))}.bg-gray-subtle{background-color:rgba(253,254,254,var(--diplan-bg-opacity, 1))}.text-gray{color:var(--diplan-gray)}.bg-gray-dark{background-color:rgba(var(--diplan-gray-dark-rgb),var(--diplan-bg-opacity, 1))}.bg-gray-dark-subtle{background-color:rgba(214,216,217,var(--diplan-bg-opacity, 1))}.text-gray-dark{color:var(--diplan-gray-dark)}.bg-medium-gray{background-color:rgba(var(--diplan-medium-gray-rgb),var(--diplan-bg-opacity, 1))}.bg-medium-gray-subtle{background-color:rgba(233,233,234,var(--diplan-bg-opacity, 1))}.text-medium-gray{color:var(--diplan-medium-gray)}.bg-gray-light{background-color:rgba(var(--diplan-gray-light-rgb),var(--diplan-bg-opacity, 1))}.bg-gray-light-subtle{background-color:rgba(248,249,250,var(--diplan-bg-opacity, 1))}.text-gray-light{color:var(--diplan-gray-light)}:root,:host{--diplan-blue-rgb: 13, 110, 253;--diplan-indigo-rgb: 102, 16, 242;--diplan-purple-rgb: 111, 66, 193;--diplan-pink-rgb: 214, 51, 132;--diplan-red-rgb: 220, 53, 69;--diplan-orange-rgb: 253, 126, 20;--diplan-yellow-rgb: 255, 193, 7;--diplan-green-rgb: 25, 135, 84;--diplan-teal-rgb: 32, 201, 151;--diplan-cyan-rgb: 13, 202, 240;--diplan-black-rgb: 4, 7, 26;--diplan-white-rgb: 255, 255, 255;--diplan-gray-rgb: 247, 248, 250;--diplan-gray-dark-rgb: 52, 58, 64;--diplan-medium-gray-rgb: 144, 145, 148;--diplan-gray-light-rgb: 222, 226, 230;--diplan-primary-contrast: #fff;--diplan-secondary-contrast: #04071a;--diplan-success-contrast: #04071a;--diplan-info-contrast: #04071a;--diplan-warning-contrast: #04071a;--diplan-danger-contrast: #fff;--diplan-light-contrast: #04071a;--diplan-dark-contrast: #fff}.autocomplete{--diplan-autocomplete-menu-max-height: 200px;display:inline-block}.autocomplete .dropdown-menu{max-height:var(--diplan-autocomplete-menu-max-height);overflow:auto;width:100%}.btn{--diplan-btn-spacer: .5rem;--diplan-btn-height: 2.35em;--diplan-btn-border-color: var(--diplan-border-color);--diplan-btn-hover-border-color: var(--diplan-border-color);--diplan-btn-hover-box-shadow: 0 .125rem .25rem rgba(4, 7, 26, .075);--diplan-btn-disabled-border-color: var(--diplan-btn-border-color);display:inline-flex;align-items:center;justify-content:center;min-height:var(--diplan-btn-height)}.btn .button-wrapper{display:inline-flex;align-items:center}.btn .icon{margin:0 4px}.btn .icon:not(:last-child){margin-right:var(--diplan-btn-spacer)}.btn .icon:not(:first-child){margin-left:var(--diplan-btn-spacer)}.btn:hover{box-shadow:var(--diplan-btn-hover-box-shadow)}.btn.expanded{width:100%}.btn.disabled,.btn.btn-disabled{pointer-events:auto;cursor:auto}.btn.btn-inverted{--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent}.btn.variant-primary-inverted,.btn.btn-inverted-primary{--diplan-btn-color: var(--diplan-primary);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-primary);--diplan-btn-hover-bg: var(--diplan-primary-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-primary-border-subtle )}.btn.variant-primary-subtle,.btn.btn-primary-subtle{--diplan-btn-color: var(--diplan-primary);--diplan-btn-bg: var(--diplan-primary-bg-subtle);--diplan-btn-border-color: var( --diplan-primary-border-subtle );--diplan-btn-hover-color: var(--diplan-primary-contrast);--diplan-btn-hover-bg: var(--diplan-primary);--diplan-btn-hover-border-color: var(--diplan-primary)}.btn.variant-secondary-inverted,.btn.btn-inverted-secondary{--diplan-btn-color: var(--diplan-secondary);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-secondary);--diplan-btn-hover-bg: var(--diplan-secondary-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-secondary-border-subtle )}.btn.variant-secondary-subtle,.btn.btn-secondary-subtle{--diplan-btn-color: var(--diplan-secondary);--diplan-btn-bg: var(--diplan-secondary-bg-subtle);--diplan-btn-border-color: var( --diplan-secondary-border-subtle );--diplan-btn-hover-color: var(--diplan-secondary-contrast);--diplan-btn-hover-bg: var(--diplan-secondary);--diplan-btn-hover-border-color: var(--diplan-secondary)}.btn.variant-success-inverted,.btn.btn-inverted-success{--diplan-btn-color: var(--diplan-success);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-success);--diplan-btn-hover-bg: var(--diplan-success-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-success-border-subtle )}.btn.variant-success-subtle,.btn.btn-success-subtle{--diplan-btn-color: var(--diplan-success);--diplan-btn-bg: var(--diplan-success-bg-subtle);--diplan-btn-border-color: var( --diplan-success-border-subtle );--diplan-btn-hover-color: var(--diplan-success-contrast);--diplan-btn-hover-bg: var(--diplan-success);--diplan-btn-hover-border-color: var(--diplan-success)}.btn.variant-info-inverted,.btn.btn-inverted-info{--diplan-btn-color: var(--diplan-info);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-info);--diplan-btn-hover-bg: var(--diplan-info-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-info-border-subtle )}.btn.variant-info-subtle,.btn.btn-info-subtle{--diplan-btn-color: var(--diplan-info);--diplan-btn-bg: var(--diplan-info-bg-subtle);--diplan-btn-border-color: var( --diplan-info-border-subtle );--diplan-btn-hover-color: var(--diplan-info-contrast);--diplan-btn-hover-bg: var(--diplan-info);--diplan-btn-hover-border-color: var(--diplan-info)}.btn.variant-warning-inverted,.btn.btn-inverted-warning{--diplan-btn-color: var(--diplan-warning);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-warning);--diplan-btn-hover-bg: var(--diplan-warning-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-warning-border-subtle )}.btn.variant-warning-subtle,.btn.btn-warning-subtle{--diplan-btn-color: var(--diplan-warning);--diplan-btn-bg: var(--diplan-warning-bg-subtle);--diplan-btn-border-color: var( --diplan-warning-border-subtle );--diplan-btn-hover-color: var(--diplan-warning-contrast);--diplan-btn-hover-bg: var(--diplan-warning);--diplan-btn-hover-border-color: var(--diplan-warning)}.btn.variant-danger-inverted,.btn.btn-inverted-danger{--diplan-btn-color: var(--diplan-danger);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-danger);--diplan-btn-hover-bg: var(--diplan-danger-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-danger-border-subtle )}.btn.variant-danger-subtle,.btn.btn-danger-subtle{--diplan-btn-color: var(--diplan-danger);--diplan-btn-bg: var(--diplan-danger-bg-subtle);--diplan-btn-border-color: var( --diplan-danger-border-subtle );--diplan-btn-hover-color: var(--diplan-danger-contrast);--diplan-btn-hover-bg: var(--diplan-danger);--diplan-btn-hover-border-color: var(--diplan-danger)}.btn.variant-light-inverted,.btn.btn-inverted-light{--diplan-btn-color: var(--diplan-light);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-light);--diplan-btn-hover-bg: var(--diplan-light-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-light-border-subtle )}.btn.variant-light-subtle,.btn.btn-light-subtle{--diplan-btn-color: var(--diplan-light);--diplan-btn-bg: var(--diplan-light-bg-subtle);--diplan-btn-border-color: var( --diplan-light-border-subtle );--diplan-btn-hover-color: var(--diplan-light-contrast);--diplan-btn-hover-bg: var(--diplan-light);--diplan-btn-hover-border-color: var(--diplan-light)}.btn.variant-dark-inverted,.btn.btn-inverted-dark{--diplan-btn-color: var(--diplan-dark);--diplan-btn-bg: transparent;--diplan-btn-border-color: transparent;--diplan-btn-hover-color: var(--diplan-dark);--diplan-btn-hover-bg: var(--diplan-dark-bg-subtle);--diplan-btn-hover-border-color: var( --diplan-dark-border-subtle )}.btn.variant-dark-subtle,.btn.btn-dark-subtle{--diplan-btn-color: var(--diplan-dark);--diplan-btn-bg: var(--diplan-dark-bg-subtle);--diplan-btn-border-color: var( --diplan-dark-border-subtle );--diplan-btn-hover-color: var(--diplan-dark-contrast);--diplan-btn-hover-bg: var(--diplan-dark);--diplan-btn-hover-border-color: var(--diplan-dark)}.form-check.variant-primary input[type=radio],.form-check.variant-primary input[type=checkbox]{background-color:var(--diplan-primary);border-color:var(--diplan-primary)}.form-check.variant-secondary input[type=radio],.form-check.variant-secondary input[type=checkbox]{background-color:var(--diplan-secondary);border-color:var(--diplan-secondary)}.form-check.variant-success input[type=radio],.form-check.variant-success input[type=checkbox]{background-color:var(--diplan-success);border-color:var(--diplan-success)}.form-check.variant-info input[type=radio],.form-check.variant-info input[type=checkbox]{background-color:var(--diplan-info);border-color:var(--diplan-info)}.form-check.variant-warning input[type=radio],.form-check.variant-warning input[type=checkbox]{background-color:var(--diplan-warning);border-color:var(--diplan-warning)}.form-check.variant-danger input[type=radio],.form-check.variant-danger input[type=checkbox]{background-color:var(--diplan-danger);border-color:var(--diplan-danger)}.form-check.variant-light input[type=radio],.form-check.variant-light input[type=checkbox]{background-color:var(--diplan-light);border-color:var(--diplan-light)}.form-check.variant-dark input[type=radio],.form-check.variant-dark input[type=checkbox]{background-color:var(--diplan-dark);border-color:var(--diplan-dark)}.form-check.variant-primary-inverted input[type=radio],.form-check.variant-primary-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-primary)}.form-check.variant-primary-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-primary-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%233375d4' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-primary-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-primary-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%233375d4' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-primary-inverted input[type=radio][type=radio]:checked,.form-check.variant-primary-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%233375d4'/%3e%3c/svg%3e")}.form-check.variant-primary-subtle input[type=radio],.form-check.variant-primary-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-primary-border-subtle)}.form-check.variant-primary-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-primary-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28214.2, 227.4, 246.4%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-primary-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-primary-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28214.2, 227.4, 246.4%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-primary-subtle input[type=radio][type=radio]:checked,.form-check.variant-primary-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='rgb%28214.2, 227.4, 246.4%29'/%3e%3c/svg%3e")}.form-check.variant-secondary-inverted input[type=radio],.form-check.variant-secondary-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-secondary)}.form-check.variant-secondary-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-secondary-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ccc' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-secondary-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-secondary-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ccc' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-secondary-inverted input[type=radio][type=radio]:checked,.form-check.variant-secondary-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23ccc'/%3e%3c/svg%3e")}.form-check.variant-secondary-subtle input[type=radio],.form-check.variant-secondary-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-secondary-border-subtle)}.form-check.variant-secondary-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-secondary-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28244.8, 244.8, 244.8%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-secondary-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-secondary-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28244.8, 244.8, 244.8%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-secondary-subtle input[type=radio][type=radio]:checked,.form-check.variant-secondary-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='rgb%28244.8, 244.8, 244.8%29'/%3e%3c/svg%3e")}.form-check.variant-success-inverted input[type=radio],.form-check.variant-success-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-success)}.form-check.variant-success-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-success-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%2300a645' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-success-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-success-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%2300a645' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-success-inverted input[type=radio][type=radio]:checked,.form-check.variant-success-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%2300a645'/%3e%3c/svg%3e")}.form-check.variant-success-subtle input[type=radio],.form-check.variant-success-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-success-border-subtle)}.form-check.variant-success-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-success-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28204, 237.2, 217.8%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-success-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-success-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28204, 237.2, 217.8%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-success-subtle input[type=radio][type=radio]:checked,.form-check.variant-success-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='rgb%28204, 237.2, 217.8%29'/%3e%3c/svg%3e")}.form-check.variant-info-inverted input[type=radio],.form-check.variant-info-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-info)}.form-check.variant-info-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-info-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ecf4ff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-info-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-info-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ecf4ff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-info-inverted input[type=radio][type=radio]:checked,.form-check.variant-info-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23ecf4ff'/%3e%3c/svg%3e")}.form-check.variant-info-subtle input[type=radio],.form-check.variant-info-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-info-border-subtle)}.form-check.variant-info-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-info-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28251.2, 252.8, 255%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-info-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-info-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28251.2, 252.8, 255%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-info-subtle input[type=radio][type=radio]:checked,.form-check.variant-info-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='rgb%28251.2, 252.8, 255%29'/%3e%3c/svg%3e")}.form-check.variant-warning-inverted input[type=radio],.form-check.variant-warning-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-warning)}.form-check.variant-warning-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-warning-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23edc700' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-warning-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-warning-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23edc700' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-warning-inverted input[type=radio][type=radio]:checked,.form-check.variant-warning-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23edc700'/%3e%3c/svg%3e")}.form-check.variant-warning-subtle input[type=radio],.form-check.variant-warning-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-warning-border-subtle)}.form-check.variant-warning-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-warning-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28251.4, 243.8, 204%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-warning-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-warning-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28251.4, 243.8, 204%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-warning-subtle input[type=radio][type=radio]:checked,.form-check.variant-warning-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='rgb%28251.4, 243.8, 204%29'/%3e%3c/svg%3e")}.form-check.variant-danger-inverted input[type=radio],.form-check.variant-danger-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-danger)}.form-check.variant-danger-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-danger-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23dc3545' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-danger-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-danger-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23dc3545' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-danger-inverted input[type=radio][type=radio]:checked,.form-check.variant-danger-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23dc3545'/%3e%3c/svg%3e")}.form-check.variant-danger-subtle input[type=radio],.form-check.variant-danger-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-danger-border-subtle)}.form-check.variant-danger-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-danger-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28248, 214.6, 217.8%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-danger-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-danger-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28248, 214.6, 217.8%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-danger-subtle input[type=radio][type=radio]:checked,.form-check.variant-danger-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='rgb%28248, 214.6, 217.8%29'/%3e%3c/svg%3e")}.form-check.variant-light-inverted input[type=radio],.form-check.variant-light-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-light)}.form-check.variant-light-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-light-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ecf4ff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-light-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-light-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ecf4ff' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-light-inverted input[type=radio][type=radio]:checked,.form-check.variant-light-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23ecf4ff'/%3e%3c/svg%3e")}.form-check.variant-light-subtle input[type=radio],.form-check.variant-light-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-light-border-subtle)}.form-check.variant-light-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-light-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28251.5, 252, 252.5%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-light-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-light-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='rgb%28251.5, 252, 252.5%29' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-light-subtle input[type=radio][type=radio]:checked,.form-check.variant-light-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='rgb%28251.5, 252, 252.5%29'/%3e%3c/svg%3e")}.form-check.variant-dark-inverted input[type=radio],.form-check.variant-dark-inverted input[type=checkbox]{background-color:transparent;border-color:var(--diplan-dark)}.form-check.variant-dark-inverted input[type=radio][type=checkbox]:checked,.form-check.variant-dark-inverted input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%232b3980' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-dark-inverted input[type=radio][type=checkbox]:indeterminate,.form-check.variant-dark-inverted input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%232b3980' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-dark-inverted input[type=radio][type=radio]:checked,.form-check.variant-dark-inverted input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%232b3980'/%3e%3c/svg%3e")}.form-check.variant-dark-subtle input[type=radio],.form-check.variant-dark-subtle input[type=checkbox]{background-color:transparent;border-color:var(--diplan-dark-border-subtle)}.form-check.variant-dark-subtle input[type=radio][type=checkbox]:checked,.form-check.variant-dark-subtle input[type=checkbox][type=checkbox]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ced4da' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check.variant-dark-subtle input[type=radio][type=checkbox]:indeterminate,.form-check.variant-dark-subtle input[type=checkbox][type=checkbox]:indeterminate{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%23ced4da' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check.variant-dark-subtle input[type=radio][type=radio]:checked,.form-check.variant-dark-subtle input[type=checkbox][type=radio]:checked{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%23ced4da'/%3e%3c/svg%3e")}.form-check.size-x-small{font-size:.5rem}.form-check.size-x-small:not(.form-switch) input[type=radio],.form-check.size-x-small:not(.form-switch) input[type=checkbox]{width:.5rem;height:.5rem;margin-right:.25rem}.form-check.size-small{font-size:.75rem}.form-check.size-small:not(.form-switch) input[type=radio],.form-check.size-small:not(.form-switch) input[type=checkbox]{width:.75rem;height:.75rem;margin-right:.375rem}.form-check.size-medium{font-size:1.25rem}.form-check.size-medium:not(.form-switch) input[type=radio],.form-check.size-medium:not(.form-switch) input[type=checkbox]{width:1.25rem;height:1.25rem;margin-right:.625rem}.form-check.size-large{font-size:1.5rem}.form-check.size-large:not(.form-switch) input[type=radio],.form-check.size-large:not(.form-switch) input[type=checkbox]{width:1.5rem;height:1.5rem;margin-right:.75rem}.form-check.size-x-large{font-size:2rem}.form-check.size-x-large:not(.form-switch) input[type=radio],.form-check.size-x-large:not(.form-switch) input[type=checkbox]{width:2rem;height:2rem;margin-right:1rem}.form-check.disabled,.form-check.disabled .form-check-label{cursor:not-allowed}.form-check:not(.rounded):not(.box) input{border-radius:var(--diplan-border-radius)}.collapse-trigger{cursor:pointer;display:inline-block}.collapse-content{display:inherit}@keyframes icon-spin{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.icon{align-items:center;display:inline-flex;justify-content:center;transition:transform .15s ease-out,opacity .3s ease-out}.icon.spin{--diplan-icon-spin-duration: 1.5s;display:inline-block;animation-name:icon-spin;animation-iteration-count:infinite;animation-timing-function:linear;animation-duration:var(--diplan-icon-spin-duration)}.icon.size-x-small{font-size:.5rem}.icon.size-small{font-size:.75rem}.icon.size-medium{font-size:1.25rem}.icon.size-large{font-size:1.5rem}.icon.size-x-large{font-size:2rem}.select,.input{display:inline-block;position:relative}.select.expanded,.input.expanded{width:100%}.select .form-select,.select .form-control,.input .form-select,.input .form-control{--diplan-input-icon-padding: 2.5rem}.select .form-select.form-control-sm,.select .form-control.form-control-sm,.input .form-select.form-control-sm,.input .form-control.form-control-sm{--diplan-input-icon-padding: 2rem}.select .form-select.form-control-lg,.select .form-control.form-control-lg,.input .form-select.form-control-lg,.input .form-control.form-control-lg{--diplan-input-icon-padding: 3rem}.select .form-select.icon-left,.select .form-control.icon-left,.input .form-select.icon-left,.input .form-control.icon-left{padding-left:var(--diplan-input-icon-padding)}.select .form-select.icon-right,.select .form-control.icon-right,.input .form-select.icon-right,.input .form-control.icon-right{padding-right:var(--diplan-input-icon-padding)}.select .form-select:not(.arrowed),.input .form-select:not(.arrowed){--diplan-form-select-bg-img: unset}.select .icon,.input .icon{--diplan-input-icon-color: #04071a;--diplan-input-icon-spacer: .75rem;position:absolute;margin:0;top:0;height:100%;color:var(--diplan-input-icon-color)}.select .icon.icon-left,.input .icon.icon-left{left:var(--diplan-input-icon-spacer)}.select .icon.icon-right,.input .icon.icon-right{right:var(--diplan-input-icon-spacer)}.select.variant-primary input,.select.variant-primary textarea,.select.variant-primary select,.input.variant-primary input,.input.variant-primary textarea,.input.variant-primary select{--diplan-focus-ring-color: var( --diplan-primary-bg-subtle )}.select.variant-secondary input,.select.variant-secondary textarea,.select.variant-secondary select,.input.variant-secondary input,.input.variant-secondary textarea,.input.variant-secondary select{--diplan-focus-ring-color: var( --diplan-secondary-bg-subtle )}.select.variant-success input,.select.variant-success textarea,.select.variant-success select,.input.variant-success input,.input.variant-success textarea,.input.variant-success select{--diplan-focus-ring-color: var( --diplan-success-bg-subtle )}.select.variant-info input,.select.variant-info textarea,.select.variant-info select,.input.variant-info input,.input.variant-info textarea,.input.variant-info select{--diplan-focus-ring-color: var( --diplan-info-bg-subtle )}.select.variant-warning input,.select.variant-warning textarea,.select.variant-warning select,.input.variant-warning input,.input.variant-warning textarea,.input.variant-warning select{--diplan-focus-ring-color: var( --diplan-warning-bg-subtle )}.select.variant-danger input,.select.variant-danger textarea,.select.variant-danger select,.input.variant-danger input,.input.variant-danger textarea,.input.variant-danger select{--diplan-focus-ring-color: var( --diplan-danger-bg-subtle )}.select.variant-light input,.select.variant-light textarea,.select.variant-light select,.input.variant-light input,.input.variant-light textarea,.input.variant-light select{--diplan-focus-ring-color: var( --diplan-light-bg-subtle )}.select.variant-dark input,.select.variant-dark textarea,.select.variant-dark select,.input.variant-dark input,.input.variant-dark textarea,.input.variant-dark select{--diplan-focus-ring-color: var( --diplan-dark-bg-subtle )}.loading{--diplan-loading-zindex: 1020;--diplan-loading-overlay: rgba(255, 255, 255, .5);position:absolute;bottom:0;left:0;right:0;top:0;display:flex;align-items:center;justify-content:center;overflow:hidden;z-index:var(--diplan-loading-zindex)}.loading.fullpage{--diplan-loading-zindex: 1030;position:fixed}.loading-overlay{position:absolute;bottom:0;left:0;right:0;top:0;background-color:var(--diplan-loading-overlay)}.loading-label{margin-left:1rem}.tabs{--diplan-nav-tabs-spacer: 1rem;--diplan-nav-tabs-disabled-opacity: .5}.tabs .nav{margin-bottom:var(--diplan-nav-tabs-spacer)}.tabs .nav-item .icon{margin-right:.5em}.tabs .nav-item:not(.disabled){cursor:pointer}.tabs .nav-item.disabled{cursor:not-allowed;opacity:var(--diplan-nav-tabs-disabled-opacity)}.tabs:not(.nav-default) .nav-link{--diplan-nav-link-color: var(--diplan-body-color)}.tabs .nav-underline,.tabs .nav-default,.tabs .nav-toggle{--diplan-nav-underline-link-active-bg: var(--diplan-body-bg);--diplan-nav-underline-link-active-border-color: currentcolor}.tabs .nav-underline .nav-link.active,.tabs .nav-default .nav-link.active,.tabs .nav-toggle .nav-link.active{background-color:var(--diplan-nav-underline-link-active-bg);border-bottom-color:var(--diplan-nav-underline-link-active-border-color)}.tabs .tab-content{position:relative}.tabs.size-x-small{--diplan-nav-link-font-size: .5rem;--diplan-nav-link-padding-x: .5rem;--diplan-nav-link-padding-y: .25rem}.tabs.size-small{--diplan-nav-link-font-size: .75rem;--diplan-nav-link-padding-x: .75rem;--diplan-nav-link-padding-y: .375rem}.tabs.size-medium{--diplan-nav-link-font-size: 1.25rem;--diplan-nav-link-padding-x: 1.25rem;--diplan-nav-link-padding-y: .625rem}.tabs.size-large{--diplan-nav-link-font-size: 1.5rem;--diplan-nav-link-padding-x: 1.5rem;--diplan-nav-link-padding-y: .75rem}.tabs.size-x-large{--diplan-nav-link-font-size: 2rem;--diplan-nav-link-padding-x: 2rem;--diplan-nav-link-padding-y: 1rem}.tabs.vertical{--diplan-nav-underline-border-width: .125rem;--diplan-nav-underline-border-color: var(--diplan-border-color);display:flex;flex-direction:row}.tabs.vertical .nav{margin-bottom:var(--diplan-nav-tabs-spacer)}.tabs.vertical .nav .nav-item{width:100%}.tabs.vertical .nav-default .nav-item{border-bottom:var(--diplan-nav-underline-border-width) solid var(--diplan-nav-underline-border-color);text-align:left}.tabs.vertical .nav-tabs .nav-item:not(:has(+[aria-selected=true])) .nav-link,.tabs.vertical .nav-boxed .nav-item:not(:has(+[aria-selected=true])) .nav-link{border-bottom:var(--diplan-nav-underline-border-width) solid var(--diplan-nav-underline-border-color)}.tabs.vertical .nav-boxed{border-bottom:0}.tabs.vertical .nav-content{flex-grow:1}.tabs.vertical:not(.is-right) .nav{margin-right:var(--diplan-nav-tabs-spacer)}.tabs.vertical.position-right{flex-direction:row-reverse}.tabs.vertical.position-right .nav{margin-left:var(--diplan-nav-tabs-spacer)}.tooltip-wrapper{--diplan-tooltip-max-width: 320px;--diplan-tooltip-border-radius: var(--diplan-border-radius);--diplan-tooltip-font-size: .875rem;--diplan-tooltip-shadow: 0 .125rem .25rem rgba(4, 7, 26, .075);--diplan-tooltip-zindex: 1080;--diplan-tooltip-bg: var(--diplan-emphasis-color);--diplan-tooltip-color: var(--diplan-body-bg);--diplan-tooltip-arrow-width: .8rem;--diplan-tooltip-arrow-height: .4rem;--diplan-tooltip-arrow-spacer: 2px;--diplan-tooltip-content-multiline-width: 50vw;position:relative;display:inline-flex}.tooltip-wrapper .variant-primary{--diplan-tooltip-color: var(--diplan-primary-contrast);--diplan-tooltip-bg: var(--diplan-primary)}.tooltip-wrapper .variant-primary-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-primary-border-subtle)}.tooltip-wrapper .variant-secondary{--diplan-tooltip-color: var(--diplan-secondary-contrast);--diplan-tooltip-bg: var(--diplan-secondary)}.tooltip-wrapper .variant-secondary-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-secondary-border-subtle)}.tooltip-wrapper .variant-success{--diplan-tooltip-color: var(--diplan-success-contrast);--diplan-tooltip-bg: var(--diplan-success)}.tooltip-wrapper .variant-success-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-success-border-subtle)}.tooltip-wrapper .variant-info{--diplan-tooltip-color: var(--diplan-info-contrast);--diplan-tooltip-bg: var(--diplan-info)}.tooltip-wrapper .variant-info-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-info-border-subtle)}.tooltip-wrapper .variant-warning{--diplan-tooltip-color: var(--diplan-warning-contrast);--diplan-tooltip-bg: var(--diplan-warning)}.tooltip-wrapper .variant-warning-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-warning-border-subtle)}.tooltip-wrapper .variant-danger{--diplan-tooltip-color: var(--diplan-danger-contrast);--diplan-tooltip-bg: var(--diplan-danger)}.tooltip-wrapper .variant-danger-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-danger-border-subtle)}.tooltip-wrapper .variant-light{--diplan-tooltip-color: var(--diplan-light-contrast);--diplan-tooltip-bg: var(--diplan-light)}.tooltip-wrapper .variant-light-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-light-border-subtle)}.tooltip-wrapper .variant-dark{--diplan-tooltip-color: var(--diplan-dark-contrast);--diplan-tooltip-bg: var(--diplan-dark)}.tooltip-wrapper .variant-dark-subtle{--diplan-tooltip-color: var(--diplan-body-color);--diplan-tooltip-bg: var(--diplan-dark-border-subtle)}.tooltip-wrapper .tooltip-trigger{width:100%}.tooltip-wrapper .tooltip-content{position:absolute;white-space:nowrap;color:var(--diplan-tooltip-color);border-radius:var(--diplan-tooltip-border-radius);background:var(--diplan-tooltip-bg);box-shadow:var(--diplan-tooltip-shadow);width:auto;max-width:var(--diplan-tooltip-max-width);padding:.25rem .5rem;font-size:var(--diplan-tooltip-font-size);z-index:var(--diplan-tooltip-zindex)}.tooltip-wrapper .tooltip-content:before{position:absolute;content:"";pointer-events:none;border-top-color:var(--diplan-tooltip-bg);width:var(--diplan-tooltip-arrow-width);height:var(--diplan-tooltip-arrow-height);z-index:var(--diplan-tooltip-zindex)}.tooltip-wrapper .tooltip-content.always{visibility:visible}.tooltip-wrapper .tooltip-content.multiline{text-align:center;white-space:normal;width:var(--diplan-tooltip-content-multiline-width)}.tooltip-wrapper .tooltip-content.position-top{top:auto;right:auto;bottom:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));left:50%;transform:translate(-50%)}.tooltip-wrapper .tooltip-content.position-top:before{top:100%;right:auto;bottom:auto;left:50%;transform:translate(-50%);border-top:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg);border-right:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent;border-left:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent}.tooltip-wrapper .tooltip-content.position-bottom{top:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));right:auto;bottom:auto;left:50%;transform:translate(-50%)}.tooltip-wrapper .tooltip-content.position-bottom:before{top:auto;right:auto;bottom:100%;left:50%;transform:translate(-50%);border-right:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent;border-bottom:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg);border-left:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent}.tooltip-wrapper .tooltip-content.position-right{top:50%;right:auto;bottom:auto;left:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));transform:translateY(-50%)}.tooltip-wrapper .tooltip-content.position-right:before{top:50%;right:100%;bottom:auto;left:auto;transform:translateY(-50%);border-top:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent;border-right:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg);border-bottom:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent}.tooltip-wrapper .tooltip-content.position-left{top:50%;right:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));bottom:auto;left:auto;transform:translateY(-50%)}.tooltip-wrapper .tooltip-content.position-left:before{top:50%;right:auto;bottom:auto;left:100%;transform:translateY(-50%);border-top:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent;border-bottom:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid transparent;border-left:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg)}.tooltip-wrapper .tooltip-content.position-top-right{top:auto;right:0;bottom:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));left:auto;transform:translate(50%)}.tooltip-wrapper .tooltip-content.position-top-right:before{top:100%;right:auto;bottom:auto;left:50%;transform:translate(-50%);border-top:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg);border-right:calc(min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height))*2) solid transparent;border-left:0 solid transparent}.tooltip-wrapper .tooltip-content.position-top-left{top:auto;right:auto;bottom:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));left:0;transform:translate(-50%)}.tooltip-wrapper .tooltip-content.position-top-left:before{top:100%;right:auto;bottom:auto;left:50%;transform:translate(-50%);border-top:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg);border-right:0 solid transparent;border-left:calc(min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height))*2) solid transparent}.tooltip-wrapper .tooltip-content.position-bottom-right{top:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));right:0;bottom:auto;left:auto;transform:translate(50%)}.tooltip-wrapper .tooltip-content.position-bottom-right:before{top:auto;right:auto;bottom:100%;left:50%;transform:translate(-50%);border-right:calc(min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height))*2) solid transparent;border-bottom:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg);border-left:0 solid transparent}.tooltip-wrapper .tooltip-content.position-bottom-left{top:calc(100% + min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer));right:auto;bottom:auto;left:0;transform:translate(-50%)}.tooltip-wrapper .tooltip-content.position-bottom-left:before{top:auto;right:auto;bottom:100%;left:50%;transform:translate(-50%);border-right:0 solid transparent;border-left:calc(min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height))*2) solid transparent;border-bottom:min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) solid var(--diplan-tooltip-bg)}.tooltip-wrapper.teleported .position-top,.tooltip-wrapper.teleported .position-top-left,.tooltip-wrapper.teleported .position-top-right{margin-top:calc(-1 * (min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer)))}.tooltip-wrapper.teleported .position-bottom,.tooltip-wrapper.teleported .position-bottom-left,.tooltip-wrapper.teleported .position-bottom-right{margin-top:calc(min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer))}.tooltip-wrapper.teleported .position-right{margin-left:calc(min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer))}.tooltip-wrapper.teleported .position-left{margin-left:calc(-1 * (min(var(--diplan-tooltip-arrow-width),var(--diplan-tooltip-arrow-height)) + var(--diplan-tooltip-arrow-spacer)))}.tooltip-wrapper[disabled=true] .tooltip-content{display:none}.tooltip-wrapper.dashed .tooltip-content{border-bottom:1px dashed var(--diplan-gray-light)}.tooltip-wrapper.square .tooltip-content{border-radius:0}.formkit-outer[data-type=checkbox] .input-group .input-option,.formkit-outer[data-type=radio] .input-group .input-option{width:100%}.formkit-outer[data-type=checkbox] fieldset,.formkit-outer[data-type=radio] fieldset{padding:unset}.formkit-outer[data-type=checkbox] ul.input-group,.formkit-outer[data-type=radio] ul.input-group{padding-left:6px;list-style:none}.formkit-outer[data-type=checkbox] ul.input-group li.input-option,.formkit-outer[data-type=radio] ul.input-group li.input-option{margin-left:0!important}.formkit-outer[data-type=checkbox][data-invalid] .input-group,.formkit-outer[data-type=checkbox][data-complete] .input-group,.formkit-outer[data-type=radio][data-invalid] .input-group,.formkit-outer[data-type=radio][data-complete] .input-group{box-shadow:none}.formkit-outer[data-type=checkbox][data-invalid]>.form-field>.input-group input[type=radio],.formkit-outer[data-type=checkbox][data-invalid]>.form-field>.input-group input[type=checkbox],.formkit-outer[data-type=radio][data-invalid]>.form-field>.input-group input[type=radio],.formkit-outer[data-type=radio][data-invalid]>.form-field>.input-group input[type=checkbox]{border-color:#dc3545}@media print{.formkit-outer[data-type=checkbox] .formkit-input:checked,.formkit-outer[data-type=radio] .formkit-input:checked{text-align:center;border-color:#ccc}.formkit-outer[data-type=checkbox] .formkit-input:checked:before,.formkit-outer[data-type=radio] .formkit-input:checked:before{font-weight:700;content:"x"}}.formkit-form>.formkit-messages{color:#dc3545}@media screen{.formkit-form .formkit-outer:not([data-type=hidden]){margin-bottom:2rem}}@media print{.formkit-form .formkit-outer:not([data-type=hidden]){margin-bottom:1rem}}.formkit-summary .formkit-messages{margin-bottom:0;padding-left:0}.formkit-summary .formkit-message{list-style:inside}.formkit-summary .formkit-message-link{color:var(--diplan-danger)}.formkit-inner.select,.formkit-inner.input{display:flex}.formkit-outer .select .form-select[disabled]{cursor:auto}.formkit-icon svg{width:17px}.formkit-outer .input-group{border-radius:2px}.formkit-message{padding:.25rem;font-size:.875rem;font-weight:400}.formkit-message[data-message-type=error]{color:#dc3545}.formkit-outer[data-complete]>.formkit-messages>.formkit-message{color:#198754}.formkit-outer[data-invalid]>.formkit-messages>.formkit-message{color:#dc3545}.formkit-outer[data-invalid]>.form-field>.input-group{border-color:#dc3545;box-shadow:0 0 0 1px #dc3545}.formkit-label{font-size:1rem;line-height:normal}:root,:host{--dps-color-background: #f7f8fa;--dps-color-black-70: rgba(4, 7, 26, .7);--dps-color-black: #04071a;--dps-color-dark-gray: #6c6e72;--dps-color-dark: #2b3980;--dps-color-delay: #ba5d00;--dps-color-error: #dc3545;--dps-color-light-blue: #ecf4ff;--dps-color-light-gray: #c8cacc;--dps-color-medium-gray: #909194;--dps-color-plan: #7069d1;--dps-color-primary-50: rgba(51, 117, 212, .5);--dps-color-primary-darker: #2b6dcc;--dps-color-primary-disabled: #99bae9;--dps-color-primary-hover: #2964ba;--dps-color-primary-light: #ecf4ff;--dps-color-primary-shade: #2b3980;--dps-color-primary-tint: #99baea;--dps-color-primary: #3375d4;--dps-color-success-text: #00913d;--dps-color-success: #00a645;--dps-color-transparent: transparent;--dps-color-warning: #edc700;--dps-color-white: #fff;--dps-grid-breakpoint-xs: 0;--dps-grid-breakpoint-sm: 576px;--dps-grid-breakpoint-md: 768px;--dps-grid-breakpoint-lg: 992px;--dps-grid-breakpoint-xl: 1200px;--dps-grid-breakpoint-xxl: 2560px;--dps-container-max-width-sm: 540px;--dps-container-max-width-md: 720px;--dps-container-max-width-lg: 960px;--dps-container-max-width-xl: 2559.98px;--dps-container-max-width-xxl: 2560px;--dps-font-size-xxxs: 12px;--dps-font-size-xxs: 13px;--dps-font-size-xs: 14px;--dps-font-size-sm: 15px;--dps-font-size-md: 16px;--dps-font-size-lg: 18px;--dps-font-size-xl: 22px;--dps-font-size-xxl: 30px;--dps-font-size-xxxl: 40px;--dps-font-weight-light: 300;--dps-font-weight-normal: 400;--dps-font-weight-medium: 500;--dps-font-weight-semi-bold: 600;--dps-font-weight-bold: 700;--dps-font-weight-extra-bold: 800;--dps-spacing-xx-sm: 4px;--dps-spacing-x-sm: 8px;--dps-spacing-sm: 12px;--dps-spacing-md: 16px;--dps-spacing-x-md: 24px;--dps-spacing-xx-md: 32px;--dps-spacing-lg: 40px;--dps-spacing-x-lg: 48px;--dps-spacing-xx-lg: 56px;--dps-spacing-big: 64px;--dps-spacing-x-big: 72px;--dps-spacing-xx-big: 80px;--dps-spacing-xxx-big: 96px}:export{dps_color_background:#f7f8fa;dps_color_black_70:rgba(4,7,26,.7);dps_color_black:#04071a;dps_color_dark_gray:#6c6e72;dps_color_dark:#2b3980;dps_color_delay:#ba5d00;dps_color_error:#dc3545;dps_color_light_blue:#ecf4ff;dps_color_light_gray:#c8cacc;dps_color_medium_gray:#909194;dps_color_plan:#7069d1;dps_color_primary_50:rgba(51,117,212,.5);dps_color_primary_darker:#2b6dcc;dps_color_primary_disabled:#99bae9;dps_color_primary_hover:#2964ba;dps_color_primary_light:#ecf4ff;dps_color_primary_shade:#2b3980;dps_color_primary_tint:#99baea;dps_color_primary:#3375d4;dps_color_success_text:#00913d;dps_color_success:#00a645;dps_color_transparent:transparent;dps_color_warning:#edc700;dps_color_white:#fff;dps_grid_breakpoint_xs:0;dps_grid_breakpoint_sm:576px;dps_grid_breakpoint_md:768px;dps_grid_breakpoint_lg:992px;dps_grid_breakpoint_xl:1200px;dps_grid_breakpoint_xxl:2560px;dps_container_max_width_sm:540px;dps_container_max_width_md:720px;dps_container_max_width_lg:960px;dps_container_max_width_xl:2559.98px;dps_container_max_width_xxl:2560px;dps_font_size_xxxs:12px;dps_font_size_xxs:13px;dps_font_size_xs:14px;dps_font_size_sm:15px;dps_font_size_md:16px;dps_font_size_lg:18px;dps_font_size_xl:22px;dps_font_size_xxl:30px;dps_font_size_xxxl:40px;dps_font_weight_light:300;dps_font_weight_normal:400;dps_font_weight_medium:500;dps_font_weight_semi_bold:600;dps_font_weight_bold:700;dps_font_weight_extra_bold:800;dps_spacing_xx_sm:4px;dps_spacing_x_sm:8px;dps_spacing_sm:12px;dps_spacing_md:16px;dps_spacing_x_md:24px;dps_spacing_xx_md:32px;dps_spacing_lg:40px;dps_spacing_x_lg:48px;dps_spacing_xx_lg:56px;dps_spacing_big:64px;dps_spacing_x_big:72px;dps_spacing_xx_big:80px;dps_spacing_xxx_big:96px}/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}main{display:block}h1,.h1{font-size:2em;margin:.67em 0}hr{box-sizing:content-box;height:0;overflow:visible}pre{font-family:monospace,monospace;font-size:1em}a{background-color:transparent}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp{font-family:monospace,monospace;font-size:1em}small,.small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,input{overflow:visible}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring{outline:1px dotted ButtonText}fieldset{padding:.35em .75em .625em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}progress{vertical-align:baseline}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}details{display:block}summary{display:list-item}template{display:none}[hidden]{display:none}*,*:before,*:after{box-sizing:border-box}@font-face{font-family:OpenSans;font-style:normal;font-weight:300;src:url(data:font/ttf;base64,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AQcBUQCeAXcACrMkBQJyACvOMDH//wAAAAAEzQczAiYAJAAAAQcAagAeAXcADLQoHAUCcgArzs4wMf//AAAAAATNBx0CJgAkAAAABwFPAUIAmwAC//4AAAY2BbYADwATACtAFRMJCRADCg0DDQMNBQYCcg4BAQUIcgArMhEzKxE5OS8vETMRMzIRMzAxISERIQMjASEVIREhFSERIQEhESMGNvz2/iblbwKNA6v9XQJ7/YUCo/tFAbFiAgT9/AW2Xf3WXf2LAgQC9///AH/+FAS4BcsCJgAmAAAABwB6AhQAAP//AM4AAAPtB5gCJgAoAAABBwBDASMBdwAKsxICAnIAK84wMf//AM4AAAPtB5gCJgAoAAABBwB2AdYBdwAKsxICAnIAK84wMf//AM4AAAPtB5QCJgAoAAABBwFKAQIBdwAKsxICAnIAK84wMf//AM4AAAPtBzMCJgAoAAABBwBqACkBdwAMtCEVAgJyACvOzjAx/////gAAAXEHmAImACwAAAEHAEP/rAF3AAqzCgECcgArzjAx//8AoQAAAhQHmAImACwAAAEHAHYATwF3AAqzCgECcgArzjAx////3wAAAiUHlAImACwAAAEHAUr/jQF3AAqzCgECcgArzjAx//8AAwAAAgUHMwImACwAAAEHAGr+twF3AAy0DRkBAnIAK87OMDEAAgAtAAAFJgW2AA4AHAAfQA8MERELFBQJEA4CchUJCHIAKzIrMhE5LzMzETMwMQEyBBIVFAIEIyERIzUzEQUhESEVIREzIAARNAIkAlrpAT+krf6t+/6pp6cBb/73AZH+b+0BSwFIif7pBbak/sHq9f60qAKoXQKxW/2qXf2zAUUBRdEBGI0A//8AzgAABPYHQAImADEAAAEHAVEBLgF3AAqzFAoCcgArzjAx//8Af//sBZwHmAImADIAAAEHAEMBuwF3AAqzJw4DcgArzjAx//8Af//sBZwHmAImADIAAAEHAHYCbQF3AAqzKA4DcgArzjAx//8Af//sBZwHlAImADIAAAEHAUoBmQF3AAqzLQ4DcgArzjAx//8Af//sBZwHQAImADIAAAEHAVEBPwF3AAqzMg4DcgArzjAx//8Af//sBZwHMwImADIAAAEHAGoAwAF3AAy0NioOA3IAK87OMDEAAQCMARgEAwSOAAsAJEATBwkBAwgLAgUICgYA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A80AdgTDAHYEZQB2AmcAGgQoACQEuQC0Ac8AoAHP/5YD3wC0Ac8AtQcRALQEuQC0BLEAdgTDALUEwwByAx0AtQO6AFoCrQAZBLkApgOtAAAFyAAdA/sALwOsAAEDsQBSAtMANwRUAfsC0wBHBJEAbgIUAAAB7ACkBJEAswSRAE4EkQB3BJEAKwRUAfsEIQCABJ4BTAaoAGUCrgBNA3kAQASRAG0CkwBSBqgAZQQA//oDbQCFBJEAbQKxADUCsQAuAhYAUgTFALQFPQCkAegApAGkABcCsQBMAuQASAN5AD8FugAvBgkAJgYiAC0DXgBIBM4AAATOAAAEzgAABM4AAATOAAAEzgAABnb//gT3AH8EawDOBGsAzgRrAM4EawDOAgT//gIEAKECBP/fAgQAAwWmAC0FxQDOBh0AfwYdAH8GHQB/Bh0AfwYdAH8EkQCMBh0AfwXBAL8FwQC/BcEAvwXBAL8EOQAABK4AzgSqALMEPQBgBD0AYAQ9AGAEPQBgBD0AYAQ9AGAG2ABgA80AdgRlAHYEZQB2BGUAdgRlAHYBz//mAc8AmAHP/8QBz//mBJYAcwS5ALQEsQB2BLEAdgSxAHYEsQB2BLEAdgSRAG0EsQBwBLkApgS5AKYEuQCmBLkApgOsAAEEwwC1A6wAAQTOAAAEPQBgBM4AAAQ9AGAEzgAABD0AYAT3AH8DzQB2BPcAfwPNAHYE9wB/A80AdgT3AH8DzQB2BaYAzgTDAHYFpgAtBMMAdgRrAM4EZQB2BGsAzgRlAHYEawDOBGUAdgRrAM4EZQB2BGsAzgRlAHYFyQB/BCgAJAXJAH8EKAAkBckAfwQoACQFyQB/BCgAJAXBAM4Euf/DBcEAAAS5ABwCBP+nAc//agIE/+4Bz//RAgT/7wHP/9MCBAAyAc8AEgIEALsD/QDOA54AoAH5/0cBz/+WBKYAzgPfALQD3wC0BBoAtwHPAJgEGgDOAc8AcwQaAM4BzwC1BBoAzgHXALUEGgAXAc8ABgXFAM4EuQC0BcUAzgS5ALQFxQDOBLkAtAT2AAEFxQDOBLkAtAYdAH8EsQB2Bh0AfwSxAHYGHQB/BLEAdgdHAH8HrAB1BMEAzgMdALUEwQDOAx0AcwTBAM4DHQCoBF0AbwO6AFoEXQBvA7oAWgRdAG8DugBaBF0AbwO6AFoEMgAKAq0AGQQyAAoCrQAZ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) format("truetype")}@font-face{font-family:OpenSans;font-style:normal;font-weight:400;src:url(data:font/ttf;base64,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BOUAcQNFAK8D0ABnAtoAIAToAKMD/wAABjMAGAQwACcEAgACA8AAUAMAADkEZQHsAwAAQwSTAGcCFAAAAh0AlgSTALkEkwBEBJMAeQSTAB8EZQHsBBwAegSjATYGqABkAtMARAP3AE8EkwBnApMAUgaoAGQEAP/6A20AdQSTAGcCyAAyAsgAJQI4AFIE8gCvBT0AegIaAJYBxgAcAsgATAL9AEMD9wBNBewAQgYlACwGOgAhA3QANQUPAAAFDwAABQ8AAAUPAAAFDwAABQ8AAAby//4FCgB9BHIAyARyAMgEcgDIBHIAyAI8//QCPAC0Ajz/zgI8AAYFzgA6BgYAyAY5AH0GOQB9BjkAfQY5AH0GOQB9BJMAhQY5AH0F1QC5BdUAuQXVALkF1QC5BHkAAATQAMgE+wCvBHIAXgRyAF4EcgBeBHIAXgRyAF4EcgBeBuYAXgPVAHIEfgByBH4AcgR+AHIEfgByAgX/+AIFAI8CBf+1AgX/5wTMAHEE6ACvBNAAcgTQAHIE0AByBNAAcgTQAHIEkwBnBNAAcgToAKME6ACjBOgAowToAKMEAgACBOUArwQCAAIFDwAABHIAXgUPAAAEcgBeBQ8AAARyAF4FCgB9A9UAcgUKAH0D1QByBQoAfQPVAHIFCgB9A9UAcgXOAMgE5QByBc4AOgToAHIEcgDIBH4AcgRyAMgEfgByBHIAyAR+AHIEcgDIBH4AcgRyAMgEfgByBdEAfQRYAB8F0QB9BFgAHwXRAH0EWAAfBdEAfQRYAB8F5gDIBOj/twXmAAAE6AAUAjz/rQIF/4kCPP/zAgX/1gI8/+cCBf/TAjwAWAIFADECPAC9BGIAyAQKAKACJv9cAgX/kATmAMgENACvBDQArwQtAKcCBQCPBC0AyAIFAIMELQDIAgUArwQtAMgCFwCvBC0AGgIF//IGBgDIBOgArwYGAMgE6ACvBgYAyAToAK8FaQACBgYAyAToAK8GOQB9BNAAcgY5AH0E0AByBjkAfQTQAHIHZgB9B5YAcATwAMgDRQCvBPAAyANFAH0E8ADIA0UAlQRjAGkD0ABnBGMAaQPQAGcEYwBpA9AAZwRjAGkD0ABnBGgAEgLaACAEaAASAtoAIARoABIC2gAgBdUAuQToAKMF1QC5BOgAowXVALkE6ACjBdUAuQToAKMF1QC5BOgAowXVALkE6ACj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dW0BDHRudW0BEgEkAAAAAQAAAAEBcgABAAAAAQEqAAEAAAABATAABgAAAAEA/gAEAAAAAQDeAAQAAAABAN4AAQAAAAEAqgABAAAAAQCoAAEAAAABAKYAAQAAAAEApAABAAAAAQCiAAEAAAABAKAABAAAAAEArgAGAAAAAgDmAPgArgAFQ0FUIAEWTUFIIAEqTU9MIAE+TkFWIAFSUk9NIAFmAAAAAQAIAAAAAQAQAAAAAQAEAAAAAQADAAAAAQABAAAAAQAAAAAAAQACAAAAAQAHAAAAAQAOAAAAAQAPAAAAAwAJAAoACwABASgBoAABAQwBWQABARwBtAABASr/7AABARABqgABART+VgABAXgAAQD0AAEBfAABAPAAAQGcAAEBGgABAQoAAgDkAOgAAP//AAYAAAABAAIACAAJAAoAAgECAAQBSAFJASMBJAACAQAABAGjAawBpAGtAAMAAQD+AAEAyAAAAAEAAAAMAAMAAQDyAAEAtgAAAAEAAAANAAIA6gAIAaUBrgGmAa8BpwGwAagBsQAA//8ABwAAAAEAAgADAAgACQAKAAD//wAHAAAAAQACAAQACAAJAAoAAP//AAcAAAABAAIABQAIAAkACgAA//8ABwAAAAEAAgAGAAgACQAKAAD//wAHAAAAAQACAAcACAAJAAoAAQABABIAAQB+AAEAhgABALYAAQDCAAIAAQATABwAAAACAAEBvQHGAAAAAgABAccB0AAAAAEAAgAvAE8ABQByAHoAYABmAGwAAQAEAR8BIAGRAZIAAQAEAPwA/QEGAQcAAQABAWsAAgABAbMBvAAAAAEACADGAMcA2gDbAPAA8QEzATQBAQACAHkAAQABAE8BAAACAHkAAQABAC8BmwACAEkBnAACAEwBnQACAE8BngADAEkATAGfAAMASQBPAAEAAQBJAAAAAgB5AAEALwABAAAABgAAAAIAeQABAE8AAQAAAAUAAAABAAEACAADAAAAFAADAAAALAACd2R0aAEBAAB3Z2h0AQAAAWl0YWwBHAACAAYAEgAiAAEAAAACARoAZAAAAAMAAQACAQQBkAAAArwAAAADAAIAAgEdAAAAAAABAAAAAA==) format("truetype")}@font-face{font-family:OpenSans;font-style:normal;font-weight:500;src:url(data:font/ttf;base64,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K84wMf//AAAAAAUrB0gCJgAkAAABBwBqADwBaQAMtCgcBQJyACvOzjAx//8AAAAABSsHCgImACQAAAAHAU8BXQB4AAL//wAABqoFtgAPABMAK0AVEwkJEAMKDQMNAw0FBgJyDgEBBQhyACsyETMrETk5Ly8RMxEzMhEzMDEhIREhAyMBIRUhESEVIREhASERIwaq/On+CszSAqcEBP22AiT93AJK+0EBqHYBs/5NBbaw/k2u/gwBtAKd//8AfP4UBM0FywImACYAAAAHAHoCIQAA//8AxAAAA/kHigImACgAAAEHAEMA9AFpAAqzEgICcgArzjAx//8AxAAAA/kHigImACgAAAEHAHYBmQFpAAqzEgICcgArzjAx//8AxAAAA/kHigImACgAAAEHAUoAuAFpAAqzEgICcgArzjAx//8AxAAAA/kHSAImACgAAAEHAGoAFwFpAAy0IRUCAnIAK87OMDH////gAAABoAeKAiYALAAAAQcAQ/+OAWkACrMKAQJyACvOMDH//wC4AAACeAeKAiYALAAAAQcAdgBmAWkACrMKAQJyACvOMDH////DAAAClQeKAiYALAAAAQcBSv9xAWkACrMKAQJyACvOMDH//wAEAAACVwdIAiYALAAAAQcAav7VAWkADLQNGQECcgArzs4wMQACADcAAAVaBbYADgAcAB9ADwwREQsUFAkQDgJyFQkIcgArMisyETkvMzMRMzAxATIEEhUUAgQjIREjNTMRBSMRIRUhETMgABE0JiYCguABRrK2/qb2/nqXlwGk2AFS/q6zARsBG3vsBbaj/sHr9/61pwJ8rwKLrP4hr/4yARwBGbz0d///AMQAAAViB1MCJgAxAAABBwFRAUEBaQAKsxQKAnIAK84wMf//AHz/7AXHB4oCJgAyAAABBwBDAacBaQAKsycOA3IAK84wMf//AHz/7AXHB4oCJgAyAAABBwB2AksBaQAKsygOA3IAK84wMf//AHz/7AXHB4oCJgAyAAABBwFKAWsBaQAKsy0OA3IAK84wMf//AHz/7AXHB1MCJgAyAAABBwFRAU0BaQAKszIOA3IAK84wMf//AHz/7AXHB0gCJgAyAAABBwBqAMkBaQAMtDYqDgNyACvOzjAxAAEAhAEPBAwElwALACRAEwcJAQMICwIFCAoGAAAKCgYEBAYALzMvETMvMy8REhc5MDEBFwEBBwEBJwEBNwEDn23+qgFUbf6p/q9wAVP+rHABVASXbv6q/qtvAVP+rm4BVQFTcf6qAAMAfP+7BccF+gAaACUAMAA5QBwqHh4YGBUVLS0XFhIDch8pKQsLCAgiIgoJBQlyACvOMjMRMxEzETMRMyvOMjMRMxEzETMRMzAxARQCBgYjIiYnByc3JgI1NBIkMzIWFzcXBxYSBzQmJwEWFjMyNhIlFBYXASYmIyIGAgXHVqn9qXG6SWN/aV5blAEv5mq2Sl9+Zl9i2DAw/YszhFGhzGD8ZC4uAnUyf06gzmQC3an+68dsLy6OVJdkASG04QFSuy8rh1WQYv7gtnvISPx9IyeNAQOyeMVJA38iJIv+/wD//wC2/+wFKweKAiYAOAAAAQcAQwF3AWkACrMaCQJyACvOMDH//wC2/+wFKweKAiYAOAAAAQcAdgIcAWkACrMbCQJyACvOMDH//wC2/+wFKweKAiYAOAAAAQcBSgE7AWkACrMhCQJyACvOMDH//wC2/+wFKwdIAiYAOAAAAQcAagCaAWkADLQpHQkCcgArzs4wMf//AAAAAASaB4oCJgA8AAABBwB2AXcBaQAKsxAHAnIAK84wMQACAMQAAAR4BbYADgAYAB9ADw8GGAsGCwYLCAkCcggIcgArKxE5OS8vETMRMzAxARQOAiMjESMRMxUzIAQBMzI2NjU0JiMjBHg7hdyhqs3NyQEdAQH9GZCErFWpu7EDC16ogUr+xgW2+eX+DTp+Z4mEAAABAKv/7ATQBh8APAAVQAsuOQFyNApyGhILcgArMisrMjAxARQOAxUUFhYXHgIVFAYGIyImJzUeAjMyNjU0JiYnLgI1ND4DNTQmIyIGBhURIxE0NjYzMhYWBEw6VVU6IFJKR2c4YbJ6YZE3JF5qNGtjI1NKU2IqOFRTOI1vS3xJyXzViIjMdATtSGhPQT0lHi49MS5hdlNwlEkiIK4VJxhaTjFHSC40V1g4QVlDQEw3UVErY1b7aQSai6tPRYj//wBc/+wD5wYhAiYARAAAAQcAQwDJAAAACrMvAAdyACvOMDH//wBc/+wD5wYhAiYARAAAAQcAdgFvAAAACrMvAAdyACvOMDH//wBc/+wD5wYgAiYARAAAAQcBSgCOAAAACrM1AAdyACvOMDH//wBc/+wD5wXpAiYARAAAAQYBUXAAAAqzOgAHcgArzjAx//8AXP/sA+cF3wImAEQAAAEGAGrtAAAMtD4yAAdyACvOzjAx//8AXP/sA+cGkwImAEQAAAEHAU8BEAAAAA23AwIpAAEBgFYAKzQ0AAADAFz/7AadBGIAMQA9AEUAM0AaCRAQGEEGJSwHciEyBjIGADkYC3IvPj4AB3IAKzIRMysyEjk5Ly8zKzIRMxEzETMwMQEyFhYVFSEWFjMyNjcVBgYjIiYmJw4CIyImJjU0NjY3NzU0JiMiBgcnNjYzMhYXNjYBBwYGFRQWMzI2NjUBIgYHITQmJgTnh8Vq/TcEoZVlolRTo21eoHwqMXGZbmOeXG7dprt1ZFGbR0BNzGh9pys5rf6TkrSTZVRTgksB33WMCgH4M2oEYnvflnS4tygnqSYjNWdMSWg3SJFwcJdSBQhKemUvI5EpNVRcVF39tQcHcWVYUkOFYwISnJdbi00A//8Abf4UA6UEYgImAEYAAAAHAHoBbwAA//8Abf/sBCcGIQImAEgAAAEHAEMA0QAAAAqzJgAHcgArzjAx//8Abf/sBCcGIQImAEgAAAEHAHYBdgAAAAqzJgAHcgArzjAx//8Abf/sBCcGIAImAEgAAAEHAUoAlQAAAAqzLAAHcgArzjAx//8Abf/sBCcF3wImAEgAAAEGAGr1AAAMtDUpAAdyACvOzjAx////5wAAAacGIQImAakAAAEGAEOVAAAKswoCBnIAK84wMf//AIwAAAJMBiECJgGpAAABBgB2OgAACrMKAgZyACvOMDH///+qAAACfAYgAiYBqQAAAQcBSv9YAAAACrMQAgZyACvOMDH////mAAACOQXfAiYBqQAAAQcAav64AAAADLQZDQIGcgArzs4wMQACAGz/7ARqBh4AJAA0ACFAEyUEBSQDIQYeIB8JFhYALQ4LcgAALysyEjkvFzkzMDEBFhYXNxcHFhYSFRQCBiMiJiY1NDY2MzIWFhc3JiYnBSc3JiYnEyIGBhUUFhYzMjY1NC4CAbxFgjroT8NgjUx756GU5oF32JBJdlsdCSB+U/7+TtkpWy/9a4lBQodqn5QkSnMGHiBJKopzc1rl/umkvv77hnjgm5vddxozJwNwvEyXdX4cNxj9lU+Zb2OYVcW+OmhSMP//AKsAAARbBekCJgBRAAABBwFRAK0AAAAKsycAB3IAK84wMf//AG3/7ARuBiECJgBSAAABBwBDAPIAAAAKsycOB3IAK84wMf//AG3/7ARuBiECJgBSAAABBwB2AZcAAAAKsycOB3IAK84wMf//AG3/7ARuBiACJgBSAAABBwFKALYAAAAKsy0OB3IAK84wMf//AG3/7ARuBekCJgBSAAABBwFRAJkAAAAKszIOB3IAK84wMf//AG3/7ARuBd8CJgBSAAABBgBqFQAADLQqNg4HcgArzs4wMQADAGMA9QQuBK4AAwAPABsAFLcECgAWEAEBAAAvMhDOMhDOMjAxEzUhFQEiJjU0NjMyFhUUBgMiJjU0NjMyFhUUBmMDy/4aMUNDMS9DQy8xQ0MxL0NDAoScnP5xPUJFODhFQj0CvT1CRTg4RUI9AAMAbf+7BG4EiAAYACIALQA1QBodJiYWFiAgFRQQB3InHBwKCgcHKioJCAQLcgArzjIzETMRMxEzETMrzjIzETMRMxEzMDEBFAIGIyImJwcnNyYmNRAAMzIWFzcXBxYWBRQWFwEmJiMiBgU0JicBFhYzMjY2BG596J9MgjhTeFpARgEU70yHN056Vz5F/M0WFwGuIVU0npMCZBUV/lQfVDJpiEACKbb/AIciIXRSfEvQhQEQASklI25SeEnLgUp7MAJXFxnTv0V2Lv2sFhdit///AKH/7ARTBiECJgBYAAABBwBDAQQAAAAKsx4NBnIAK84wMf//AKH/7ARTBiECJgBYAAABBwB2AakAAAAKsx8NBnIAK84wMf//AKH/7ARTBiACJgBYAAABBwFKAMgAAAAKsx4NBnIAK84wMf//AKH/7ARTBd8CJgBYAAABBgBqJwAADLQtIQ0GcgArzs4wMf//AAL+EwQlBiECJgBcAAABBwB2ATwAAAAKsyUABnIAK84wMQACAKv+FgSDBhQAHAAqACFAEhYgIBoHchAAcg8OcgknJwQLcgArMhEzKysrMhEzMDEBFAYGIyImJicjHgIVESMRMxEUBgczPgIzMhIDNCYjIgYHFRQWMzI2NgSDbseGVoJcHw0DBgTKygUDCR9bglfJ8c6JkJ+GAoKmX3w9Aiq8/4MsSS0TQkQX/jgH/v5FJGUeMFAw/uD+6sjIubcjxdNgt///AAL+EwQlBd8CJgBcAAABBgBqugAADLQzJwAGcgArzs4wMf//AAAAAAUrBt0CJgAkAAABBwFMAQ0BaQAKsxUFAnIAK84wMf//AFz/7APnBXQCJgBEAAABBwFMAL0AAAAKsysAB3IAK84wMf//AAAAAAUrB2ECJgAkAAABBwFNAP8BaQAKsxcFAnIAK84wMf//AFz/7APnBfgCJgBEAAABBwFNAK8AAAAKsy0AB3IAK84wMf//AAD+NAUrBbwCJgAkAAAABwFQA3EAAP//AFz+NAQTBGECJgBEAAAABwFQAmMAAP//AHz/7ATNB4oCJgAmAAABBwB2AjEBaQAKsyYZA3IAK84wMf//AG3/7AOlBiECJgBGAAABBwB2AXEAAAAKsyQIB3IAK84wMf//AHz/7ATNB4oCJgAmAAABBwFKAU8BaQAKsywZA3IAK84wMf//AG3/7AO0BiACJgBGAAABBwFKAJAAAAAKsyoIB3IAK84wMf//AHz/7ATNB1gCJgAmAAABBwFOAkUBaQAKsyYZA3IAK84wMf//AG3/7AOlBe8CJgBGAAABBwFOAYQAAAAKsyQIB3IAK84wMf//AHz/7ATNB4oCJgAmAAABBwFLAU4BaQAKsyAZA3IAK84wMf//AG3/7AOxBiACJgBGAAABBwFLAI0AAAAKsx4IB3IAK84wMf//AMQAAAVaB4oCJgAnAAABBwFLASwBaQAKsxUGAnIAK84wMf//AG3/7AWYBhQCJgBHAAABBwFzAxIAAAALtgIxDwAAAFYAKzQA//8ANwAABVoFtgIGAJIAAAACAG3/7ATfBhQAHwAsACpAFRUSEhgPDwYaChMAcicKBgcbICAACwA/MhEzPzMzKz8ROS8zMxEzMDEFIgIREBIzMhYWFzMmJjU1ITUhNTMVMxUjESMnIw4CJzI2NzU0JiMiBhUUFgIoyvH1ylWAXh8MBgn+ZQGbyZuboCEJH1yAKKSFAYCsjI2NFAEaARMBGwEbLk0vInMob4+0tI/7L5kwTy6ktrUfw8zUvr3KAP//AMQAAAP5Bt0CJgAoAAABBwFMAOgBaQAKsw4CAnIAK84wMf//AG3/7AQnBXQCJgBIAAABBwFMAMUAAAAKsyIAB3IAK84wMf//AMQAAAP5B2ECJgAoAAABBwFNANkBaQAKsxACAnIAK84wMf//AG3/7AQnBfgCJgBIAAABBwFNALcAAAAKsyQAB3IAK84wMf//AMQAAAP5B1gCJgAoAAABBwFOAawBaQAKsxICAnIAK84wMf//AG3/7AQnBe8CJgBIAAABBwFOAYkAAAAKsyYAB3IAK84wMf//AMT+NAP5BbYCJgAoAAAABwFQAkIAAAADAG3+NAQnBGIAFQAtADUAKUAUIxIRER8fJjEcHBYDCiYLci4WB3IAKzIrzDISOS8zETMRMxEzMzAxBRQWMzI2NxUGBiMiJjU0NjY3Nw4CAzIWFhUVIRYWMzI2NxUGBiMiJiY1NBI2FyIGByEuAgMjMCshNBEdPSprbjtbMaNRWiPIkM5u/RQDsJ9ppFhTp3Sg8YZ63pV6lA0CHgE4ce0uLwoEfQgLa106bV0iEkJkUgUme+CYcrG9KCepJiOA+7i2AQOKnJ+UW4pOAP//AMQAAAP5B4oCJgAoAAABBwFLALYBaQAKswwCAnIAK84wMf//AG3/7AQnBiACJgBIAAABBwFLAJMAAAAKsyAAB3IAK84wMf//AHz/7AU0B4oCJgAqAAABBwFKAYIBaQAKsy4NA3IAK84wMf//ABn+FAQ/BiACJgBKAAABBgFKWwAAC7YDUhMBAXtWACs0AP//AHz/7AU0B2ECJgAqAAABBwFNAaMBaQAKsyYNA3IAK84wMf//ABn+FAQ/BfgCJgBKAAABBgFNeAAAC7YDUBMBAXtWACs0AP//AHz/7AU0B1gCJgAqAAABBwFOAncBaQAKsygNA3IAK84wMf//ABn+FAQ/Be8CJgBKAAABBwFOAVAAAAALtgNSEwEBllYAKzQA//8AfP47BTQFywImACoAAAAHAdMBNwAA//8AGf4UBD8GIAAmAXQiAAMGAEoAAAAKswUfB3IAK84wMf//AMQAAAUvB4oCJgArAAABBwFKAUQBaQAKsxgGAnIAK84wMf///60AAARbB+gCJgBLAAABBwFK/1sBxwALtgEhGgEBklYAKzQAAAIAAAAABfMFtgATABcAJ0ATCwQHBw4BFxIUFAAJBQJyEAAIcgArMisyETkvM84yMjIRMzMwMTMRIzUzNTMVITUzFTMVIxEjESERESE1IcTExM0C0c3ExM39LwLR/S8EM5nq6urqmfvNAqP9XQNU3wABABAAAARbBhQAIgAjQBIhHh4BBAQNIgByEx0KchcNBnIAKzIrMisSOS8zMxEzMDEBFSEVIRUUBgczPgIzMhYWFREjETQmIyIGBhURIxEjNTM1AXQBmv5mBgQNImeESoGwXMd0eHKIOsmbmwYUtJGSM2EhOk0oVbKM/VwCiIWFXK9//fgEz5G0AP///68AAAKsB1MCJgAsAAABBwFR/10BaQALtgEEAQEBlVYAKzQA////jQAAAooF6QImAakAAAEHAVH/OwAAAAqzFQIGcgArzjAx////9gAAAmEG3QImACwAAAEHAUz/pAFpAAu2AQYBAQGUVgArNAD////bAAACRQV0AiYBqQAAAQYBTIkAAAqzBgIGcgArzjAx////4AAAAncHYQImACwAAAEHAU3/jgFpAAu2AQgBAQGSVgArNAD////MAAACYwX4AiYBqQAAAQcBTf96AAAACrMIAgZyACvOMDH//wBk/jQBwQW2AiYALAAAAAYBUBIA//8APP40AZkF7wImAEwAAAAGAVDqAP//ALkAAAGiB1gCJgAsAAABBwFOAGcBaQALtgEKAQEBwVYAKzQA//8AxP50A+IFtgAmACwAAAAHAC0CVwAA//8Anf4UA6YF7wAmAEwAAAAHAE0CIAAA////X/50ApEHigImAC0AAAEHAUr/bQFpAAqzHgwCcgArzjAx////i/4UAnwGIAImAaoAAAEHAUr/WAAAAAqzHQsGcgArzjAx//8AxP47BQEFtgImAC4AAAAHAdMAsAAA//8Aq/47BFkGFAImAE4AAAAGAdM9AAABAKsAAARZBE4AEgAbQA8FBA0BEQUHEggGcgMHCnIAKzIrMhIXOTAxCQIjAQcRIxEzEQYGBzM2NjcBBDj+WwHG7P6ej9HRAQUFBBgzFwF5BE7+Ff2dAeVz/o4ETv7gTZYyHz4eAboA//8AowAABAwHigImAC8AAAEHAHYAUQFpAAqzDAECcgArzjAx//8AjAAAAkwH6AImAE8AAAEHAHYAOgHHAAqzCwIAcgArzjAx//8AxP47BAwFtgImAC8AAAAGAdNvAP//AIb+OwGXBhQCJgBPAAAABwHT/xcAAP//AMQAAAQYBbYCJgAvAAABBwFzAZP/ogALtgESAQAAAFYAKzQA//8AqwAAAssGFAImAE8AAAEGAXNGAAALtgEQAgAAAFYAKzQA//8AxAAABAwFtgImAC8AAAAHAU4CYv18//8AqwAAAqoGFAAmAE8AAAAHAU4Bb/2SAAEAFAAABAwFtgANABxAEQIBAwoEBwkICAAFAnILAAhyACsyKxIXOTAxMxEHJzcRMxE3FwURIRXEYU+wzf1Q/rMCewH9OYZrAwH9eZeLxP47sgAB/+8AAAI0BhQACwAaQBACAQMKBAkHCAgABQByAApyACsrEhc5MDEzEQcnNxEzETcXBxGjZFC0yXdRyAI2PoVyAyX9WlGFhf1L//8AxAAABWIHigImADEAAAEHAHYCPAFpAAqzGgoCcgArzjAx//8AqwAABFsGIQImAFEAAAEHAHYBrAAAAAqzHQAHcgArzjAx//8AxP47BWIFtgImADEAAAAHAdMBGgAA//8Aq/47BFsEYgImAFEAAAAHAdMAhwAA//8AxAAABWIHigImADEAAAEHAUsBWQFpAAqzFAoCcgArzjAx//8AqwAABFsGIAImAFEAAAEHAUsAyAAAAAqzFgAHcgArzjAx//8AAwAABPUFtgAnAFEAmwAAAAYBX+kAAAEAxP50BWIFtgAhABtADgsWDAMTHRUCchMIcgcAAC8yKysyEhc5MDEBIiYnNRYWMzI2NjcBIx4CFREjETMBMy4CNREzERQGBgPTNlQdIVAuPWI7AfzRCAQIBbz0AvIHAwYEvmOz/nQODKcIDCpjVQSrLY6dRPzuBbb7ozCIlUMCzfpSibRXAAABAKv+FARcBGIAJAAhQBIXGBgODhwHchUGchQKcgcAD3IAKzIrKysyETMRMzAxASImJzUWFjMyNjURNCYjIgYGFREjETMXMz4CMzIWFhURFAYGAyswTRwcOiM7TnR2cog8yZ8fCyNqhEqBsVtBhv4UDwqhCgpKZANSgoBar3/9zAROmzpOJ1SyjfyRZJZSAP//AHz/7AXHBt0CJgAyAAABBwFMAZoBaQAKsyMOA3IAK84wMf//AG3/7ARuBXQCJgBSAAABBwFMAOUAAAAKsyMOB3IAK84wMf//AHz/7AXHB2ECJgAyAAABBwFNAYwBaQAKsyUOA3IAK84wMf//AG3/7ARuBfgCJgBSAAABBwFNANcAAAAKsyUOB3IAK84wMf//AHz/7AXHB4oCJgAyAAABBwFSAcwBaQAMtCc0DgNyACvOzjAx//8Abf/sBG4GIQImAFIAAAEHAVIBFwAAAAy0JzQOB3IAK87OMDEAAgB8/+4HBAXMABgAKAAtQBglIiIRCXIHCgoDCw4IcgYDAnImGRkAA3IAKzIRMysyKzISOS8zKzIRMzAxATIWFyEVIREhFSERIRUhBgYjIiQCNTQSJBciDgIVFBIWMzI2NxEmJgMSNGktAyj9rwIr/dUCUfzeLGo04v7XkZEBJup2rnE4YsycOW0nKGkFzAsLsP5Nrv4MsQgKvAFT4uIBUbqxT5XUhrL+/owSEAQ7ERAAAAMAa//sBz4EYAAkADMAOwAtQBYhJSU3BgYWNAAAHgdyEywsCRAQFgtyACsyETMyETMrMhEzETkvMzIRMzAxATIWFhUVIRYWMzI2NxUGBiMiJicGBiMiJgI1NDY2MzIWFz4CBSIGFRQWFjMyNjY1NCYmJSIGByEuAgVzkM1u/RwFqZxspFZTpXON1kI/0IeV44F65Z6CzT0oc5D9RJuNP4NoaII+P4MCqXeRDAITATZwBGB635hyubUoJ6kmI29tbHCGAQG2tf2FcGtGYjOlzMaFtl1ctIOGtVwJmpdbikz//wDEAAAE7QeKAiYANQAAAQcAdgG0AWkACrMgDwJyACvOMDH//wCrAAADOgYhAiYAVQAAAQcAdgEYAAAACrMdDwZyACvOMDH//wDE/jsE7QW2AiYANQAAAAcB0wCyAAD//wCD/jsDOgRiAiYAVQAAAAcB0/8UAAD//wDEAAAE7QeKAiYANQAAAQcBSwDRAWkACrMZDwJyACvOMDH//wCGAAADWAYgAiYAVQAAAQYBSzQAAAqzFg8GcgArzjAx//8AZv/sBAcHigImADYAAAEHAHYBcAFpAAqzNx0DcgArzjAx//8AZf/sA4IGIQImAFYAAAEHAHYBGAAAAAqzMhkHcgArzjAx//8AZv/sBAcHigImADYAAAEHAUoAkAFpAAqzPR0DcgArzjAx//8AZf/sA4IGIAImAFYAAAEGAUo3AAAKszcZB3IAK84wMf//AGb+FAQHBcsCJgA2AAAABwB6AUAAAP//AGX+FAOCBGICJgBWAAAABwB6ARgAAP//AGb/7AQHB4oCJgA2AAABBwFLAI0BaQAKszAdA3IAK84wMf//AGX/7AOCBiACJgBWAAABBgFLNAAACrMrGQdyACvOMDH//wAY/jsEXQW2AiYANwAAAAYB00IA//8AJP47As4FSAImAFcAAAAGAdPHAP//ABgAAARdB4oCJgA3AAABBwFLAIEBaQAKswgEAnIAK84wMf//ACT/7APlBhQCJgBXAAAABwFzAWAAAAABABgAAARdBbYADwAhQBAKBgYOAgILAwMABwJyAAhyACsrETkvMzMRMzIRMzAxIREhNSERITUhFSERIRUhEQHT/tYBKv5FBEX+QwEo/tgCjqgBzrKy/jKo/XIAAAIAJP/sAs4FSAADABwAJUASEBkZFhITEwABgBUWBnIECwtyACsyK80azDIzETMRMxEzMDETNSEVAzI2NxUGBiMiJiY1ESM1NzczFSEVIREUFjUCeIIrWCAicTtakleZoEd8AT/+wVkCK5GR/mQPDJoPFT6WhQJuXUru+pv9lV1cAP//ALb/7AUrB1MCJgA4AAABBwFRASIBaQAKsxQJAnIAK84wMf//AKH/7ARTBekCJgBYAAABBwFRAK4AAAAKsxgNBnIAK84wMf//ALb/7AUrBt0CJgA4AAABBwFMAWoBaQAKsxYJAnIAK84wMf//AKH/7ARTBXQCJgBYAAABBwFMAPgAAAAKsxoNBnIAK84wMf//ALb/7AUrB2ECJgA4AAABBwFNAVwBaQAKsxgJAnIAK84wMf//AKH/7ARTBfgCJgBYAAABBwFNAOoAAAAKsxwNBnIAK84wMf//ALb/7AUrB/wCJgA4AAABBwFPAb0BaQANtwIBFBMBAZNWACs0NAD//wCh/+wEUwaTAiYAWAAAAQcBTwFLAAAADbcCARgXAQGSVgArNDQA//8Atv/sBSsHigImADgAAAEHAVIBnAFpAAy0GygJAnIAK87OMDH//wCh/+wEeAYhAiYAWAAAAQcBUgEpAAAADLQfLA0GcgArzs4wMQACALb+NAUrBbYAFQApAB9ADykfAnISEREkJAMKChsJcgArMi8zMhEzETMrMjAxBRQWMzI2NxUGBiMiJjU0NjY3Nw4CAREUBgQjIAA1ETMRFBYzMjY2NREDvjIrITISHT0qbG1AYDCJP1UqAW1//wDC/u3+3865t36gTdo7NQoEfQgLb2pCfmggFUNuYQZe/E6a8owBJ/UDrvxaubxbp3MDpv//AKH+NARbBE4CJgBYAAAABwFQAqwAAP//ABcAAAdjB4oCJgA6AAABBwFKAgUBaQAKszcQAnIAK84wMf//ABcAAgZGBiACJgBaAAABBwFKAXgAAAAKszcPBnIAK84wMf//AAAAAASaB4oCJgA8AAABBwFKAJYBaQAKsxUHAnIAK84wMf//AAL+EwQlBiACJgBcAAABBgFKWwAACrMkAAZyACvOMDH//wAAAAAEmgdIAiYAPAAAAQcAav/1AWkADLQeEgcCcgArzs4wMf//AEcAAARQB4oCJgA9AAABBwB2AX4BaQAKsxEFAnIAK84wMf//AEoAAAN+BiECJgBdAAABBwB2AQ4AAAAKsxEFBnIAK84wMf//AEcAAARQB1gCJgA9AAABBwFOAZEBaQAKsxAFAnIAK84wMf//AEoAAAN+Be8CJgBdAAABBwFOASIAAAAKsxAFBnIAK84wMf//AEcAAARQB4oCJgA9AAABBwFLAJoBaQAKswoFAnIAK84wMf//AEoAAAN+BiACJgBdAAABBgFLKwAACrMKBQZyACvOMDEAAQCrAAAC8wYfABAADrYACgFyBQpyACsrMjAxASIGFREjETQ2NjMyFhcHJiYCIlVYylukb0dqKTIgUwV6aHL7YASki6ZKGA+bCxIAAAEAwP4UBBYFywAlACNAECAhIQseDg4LCwAaEw9yBwAALzIrMhI5LzMRMxEzETMwMQEyFhcHJiYjIgYVFSEVIREUBgYjIiYnNRYWMzI2NREjNTc1NDY2AztGbSgwIk4tVE4BCf76TJdwKlAdHz4iT1DKylKdBcsbD5oLFF9yf5r8PnmfTg0IpAkKWHQDtmA/fYyiRQAE//8AAAUvB6wAEgAeACoANwAmQBMTGQENHwQREQcSCA8IMDA3NyUHAC8zMy8zLz8/EjkvFzkzMDEjASYmNTQ2MzIWFRQGBwEjAyEDEyEDLgInDgMHEzI2NTQmIyIGFRQWAzU+AjczFQ4DBwECDSsxgGRjhzErAg3Ynf2zmdcB2Z8KHh0KBxYVFAZKND9AMzJAPSseQj0W7BFBUVMjBOkaWj5odnVnPloa+xUBgP6AAjMBjBpOVCMaQEA3EQFsPDc2PDw2NT4BhhIgUlUlDxc+RD8XAAUAXP/sA+cHqQAdACgANABBAE0ANEAaBiUlEx4eAAsLcgUKQ01NSUdHKTUvPBcAB3IAKzLeMswyMi8zMxEzPysROS8zMhEzMDEBMhYVESMnIw4CIyImJjU0JCU3NTQmIyIGByc2NgEHBgYVFBYzMjY1AyIGFRQWMzI2NTQmJzIWFhUUBiMiJjU0NgEVDgIHIzU+AjcCUczKkCcILmSDXmScWQECAQa+c2dVnEhATscBPJq/m2pXhq3QMkA7NzE/QDBCaD2EY2WAgAGtF3CAL4wdQz4WBGG1w/0XoDxQKEiRcKiuCAg+gWoxIpIoNv22BwdxZVhSl5QEZD00NT4+NTQ9ajVhRGl2dWlmdQEnDBpMTRkPHEZIH/////8AAAaqB4oCJgCIAAABBwB2AxMBaQAKsxsGAnIAK84wMf//AFz/7AadBiECJgCoAAABBwB2ArgAAAAKs00sB3IAK84wMf//AHz/uwXHB4oCJgCaAAABBwB2Ak8BaQAKszgSA3IAK84wMf//AG3/uwRuBiECJgC6AAABBwB2AZgAAAAKszUQB3IAK84wMf//AGb+OwQHBcsCJgA2AAAABgHTHQD//wBl/jsDggRiAiYAVgAAAAYB0/UAAAEAUgTZAyQGIAASABdACwkEDgMSgAYPDAEMAC9dMxrNFzkwMQEeAhcVIyYmJwYGByM1PgI3AiUaW2QmizZ1NjZyNogmYVobBiAtcWsnFyJjNzdhJBcoa3AtAAEAUgTZAyQGIAASABtADAkADgQEDAaADwABAAAvXRrNMjIRMxE5MDEBLgInNTMWFhc2NjczFQ4CBwFOG1piJYg2dTM2dTaLJmRbGgTZLm5rJxkkYzg4ZCMZJ2pvLgABAFIE2wK9BXQAAwAMtAMPAgECAC9dMzAxARUhNQK9/ZUFdJmZAAEAUgTZAukF+AAQABK3EAiADA8EAQQAL10zGswyMDEBDgIjIiYnMx4CMzI2NjcC6QdTkmSapQh5BTVaPTZaOwcF+FWBSZyDODkTFTo1AAEAUgUAATsF7wALAAy0AA8GAQYAL10zMDETMhYVFAYjIiY1NDbHL0VFLzJDQwXvOD8/OTk/PzgAAgBSBNkCHgaTAAsAFwAOtBIGwAwAAC8yGswyMDEBIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBYBNmV/f2VihoVjMkBCMDBCOwTZdmhmdnVlaXdsPTU0PT00NT0AAQBS/jQBsAAfABQADrQDCsASEQAvMxrMMjAxFxQWMzI2NxUGBiMiJjU0NjY3FwYG7jAsIDQSHT4qa247WzFmRkvtLi8KBH0IC2tdOm1cIB9AcAAAAQBSBNsDTwXpABkAHUANFg0NBRGAGRkKDxEBEQAvXTMzLxoQzTIvMjAxEz4DMzIeAjMyNjczBgYjIi4CIyIGB1IGJT1RMC1TTEgiKzYObw17YSxRTEkkLDUOBNtBZEQjIy4jOT1/jiQtJDk9AAACAFIE2QNPBiEADAAZAB9ADgEODgwZgAgGBhUPEwETAC9dMzMRMxrNMjIRMzAxARUOAwcjNT4CNyMVDgMHIzU+AjcDTxFCU1QjcR5FQhWbEUJTVCNxHkRBFwYhFBxRWVEdGSdrby4UHFFZUR0ZJ2tvLgACAKv+FAS9Bh8AGAAwAClAFQgHKSkqKgAUD3ISHiEhDwtyGQABcgArMisyETM5KxI5LzMSOTkwMQEyFhYVFAYHFRYWFRQGBiMiJicRIxE0NjYXIgYGFREWFjMyNjU0JiYjIzUzMjY1NCYCnovWep2TtMB43ZtxpEPKgeKLUIVPQ5pdppxUl2ZkUZSLlQYfV62Ck68YCBXEuYzFZyYi/d8GNaPQY6Q6i3v8qSYumYtmgj6mkXl4eQD//wAXAAAHYweKAiYAOgAAAQcAQwJBAWkACrMwEAJyACvOMDH//wAXAAIGRgYhAiYAWgAAAQcAQwG1AAAACrMxHAZyACvOMDH//wAXAAAHYweKAiYAOgAAAQcAdgLnAWkACrMwEAJyACvOMDH//wAXAAIGRgYhAiYAWgAAAQcAdgJaAAAACrMxDwZyACvOMDH//wAXAAAHYwdIAiYAOgAAAQcAagFkAWkADLQ/MxACcgArzs4wMf//ABcAAgZGBd8CJgBaAAABBwBqANgAAAAMtEA0DwZyACvOzjAx//8AAAAABJoHigImADwAAAEHAEMA0gFpAAqzDwcCcgArzjAx//8AAv4TBCUGIQImAFwAAAEHAEMAmAAAAAqzJAAGcgArzjAxAAEAUgHSA64CewADAAixAQAALzIwMRM1IRVSA1wB0qmpAAABAFIB0geuAnsAAwAIsQEAAC8yMDETNSEVUgdcAdKpqQAAAQAbA8EBWwW2AAoADrUBAIAFAnIAKxrNOTAxEyc+AjczDgIHJwwSOEIhkxQpIQsDwRZJp6dITrKuRwAAAQAaA8EBWgW2AAsADrUBBYALAnIAKxrNOTAxARcOAgcjPgM3AUsPEjhDIZIPHhwXCAW2Fkmmpko6goZ9Nv//AEH++AGBAO0ABwFfACf7NwACABsDwQLjBbYACgAVABdAChEQEAYEgAoVAnIAKzIazDIyETMwMQEOAgcjJz4CNyMOAgcjJz4CNwLjFSgiCssPEjlDIvYVKCIKygwSN0IiBbZOs61HFkmmp0lOs61HFkmmp0kAAgAaA8EC4gW2AAoAFgAXQAoBDAwRBYAKFgJyACsyGswyMxEzMDEBFw4CByM+AjcjFw4CByM+AzcC0w8SOUIhlBQpIgq/DhE5QiGRDx4bFwcFthZKpqVKTbKvRxZKpqVKOoKGfTb//wBB/vgDCQDtAAcBYgAn+zcAAQCAAAADlQYUAAsAF0AJBAEBBwoKAwgDAC8vEjkvMzMRMzAxASUTIxMFNQUDMwMlA5X+pTHTMP64AUgw0zEBWwPYHfwLA/UduB0Bof5fHQABAJkB6AJpA+8ADwAIsQQMAC8zMDETNDY2MzIWFhUUBgYjIiYmmT1pQkJpPT1pQkJpPQLsXnIzM3NdW3M2NnL//wCO/+QF0wD9ACYAEQAAACcAEQIfAAAABwARBDsAAAABAFQDqAIiBbYAAwAKswIBAnIAK80wMQEzASMBXcX+toQFtv3yAAIAVAOoA50FtgADAAcADrUHAAIGAnIAKzLOMjAxAQEzASEBMwEBzgEKxf61/gIBCcX+tgOoAg798gIO/fIAAQBQAHMCPAPVAAYAELcEBgMAAgUBBQAvzBc5MDETARcBAQcBUAFckP7jAR2Q/qQCMAGlUf6g/qFSAaMAAQBOAHMCOgPVAAYAELcEAgUBBgUAAwAvzBc5MDETARUBJwEB3QFd/qOPARz+5APV/lwb/l1SAWABXwAAAf6BAAAChQW2AAMAC7QCEnIAAgA/KzAxAQEjAQKF/KKmA10FtvpKBbYAAQBPAAAEJAW2ABEAIEAPARAQBA0JDAwACAUEcgAMAD8rMhI5LzPOMjIRMzAxMxEjNTMRIRUhESEVIRUhFSER+aqqAyv9nQI9/cMBP/7BAQ6JBB+w/iKw4Yn+8gABAEkAAARPBcoAKQAsQBULJSUOIhIeHg8hIRkaFhYZDAcABXIAKzI/MxEzETkvMzMRM84yMhEzMDEBMhYXByYmIyIGFRUhFSEVIRUhFAYGByEVITU+AjUjNTM1IzUzNTQ2NgK2cbNHQ0SQT2h4AY/+cQGP/m8iPy4DBfv6Q1kuw8PDw1y7BcouIZwdJnKCoomhi05yTBizqBBLfFiLoYmFkMNmAAMApf/sBiIFtgAMABUALgAtQBYeJQtyLC0tFyoaGi4XDwkJCw4MAnILAC8rMhI5LzMvzTMRMxEzETMrMjAxASAWFRQOAiMjESMRBSMRMzI2NTQmBRUzFSMRFBYzMjY3FQYGIyImJjURIzU3NwHGARL4OIDVnT3EARhUObWyoQK07u48PiNPGh1fP1B0P5uiQgW24tBfqYJK/dAFtq391YWYiYXg25T+akxPDgmRDRY9gWYBqlVMzgABADj/7AR5BcgANgArQBUzMDAPJxgYKhUMDw8AHCMNcgcABXIAKzIrMhE5LzPOMjIRMxEzETMwMQEyFhcHJiYjIg4CByEVIRQGFRQWFyEVIR4CMzI2NxUGBiMiJiYnIzUzJiY1NDY3IzUzPgIDE2auUk08kE1Je19BEQHf/hMCAQEBtP5cFWSfbE+ZPz2WYKPtlB2fjwEBAQGPnRmV8AXILC6gHy8vXoxdiREmFRQpFYpum1EkHLAcI3zppIoVJBgVKw2Jp/aFAAIAXv/tA6oFywAjAC0AIkATEA0gERQrBggnGQVyAwMAAAgNcgArMhEzLysyEhc5MDElMjY3Mw4CIyImJjU1BgYHNTY2NxE0NjYzMhYVFAYGBxEUFhM0JiMiBhURNjYCeUhiCH8FSIxtXJVWLWExNF8sQoprgZdktXlMpTs8RzN4eYJicnKiVUqggtQPHA2GDh4PAdlgjU+hkYTWoDb+9GZ1BBFZW2FT/mk9zwACACAC5QWLBbYAFAAcACtAFRsXFwMPDAMYBw4OAAAVGAUCAhgCcgArMi8zEMwyETMRMxEXOTMRMzAxAREzExMzESMRNDY3IwMjAyMWFhURIREjNSEVIxEClLbFy7F8BAEH0mjICAID/enRAh7SAuUC0f3OAjL9LwGfFmEc/c4CMiJVEv5XAmhpaf2YAAEAYwKEBC4DIAADAAixAQAALzIwMRM1IRVjA8sChJycAAABAX4EzQKFBhQADAAOtAEHDIAFAC8azTk5MDEBFQ4CByM1PgM3AoULMDsgcQsUEw8EBhQSKG1wMBgdTFVQIQAAAQF0BNgChwYgAAsADrQBC4AHBgAvMxrNMjAxARUOAgcjNT4CNwKHDiIaBsMOMD8lBiAYI210LBQobHEvAAACABMDVALFBscACgATAB1ADQYLCwkJBAEBA3gPB3cAPzPkOS8zMxEzETMwMQEjFSM1ITUBMxEzITU0NjcGBgcHAsV/pv5zAZCjf/7bAwMLOhWlBBTAwHACQ/3MxCxqMRpgIPEAAQBEA0MCmwbBAB4AH0AOHRwcGRkDBgYTDHgCHncAPzPkMjkvMzMRMxEzMDEBFSEHNjYzMhYVFAYjIiYnNRYWMzI2NTQmIyIGBycTAm3+ihIZPCSItbGoRIsvNok3W2tnYC9KHkgiBsF+0AQIjoKPnRsakCEnUFVNUg4IJwGsAAABADoDVAKjBsEABgAQtgUBAQZ4A3cAP+QzETMwMRMBITUhFQGhAV7+OwJp/qcDVALphGz8/wADADIDRAKmBtEAGQAnADMAF0AMJxoUBi4FIQx4KAB3AD8y5DIXOTAxATIWFRQGBxYWFRQGIyImJjU0NjY3JiY1NDYTDgIVFBYzMjY1NCYnEyIGFRQWFzY2NTQmAW11plVAT2StjGSOSStJLT9GqlssPB9PT1FPVE0CPkVNOjpHRgbRbm5MYyEjbFRyjDxwTDlUPxcnXU1tdP4QFC88JjhJSDk3TBkBgzoxNUIYF0I2MToAAwBU/sEHqgYUAAMAIQAtABdACSElAhcPKysCAAAvLzkvOTkSOTMwMQkDBTU0Njc+AjU0JiMiBgYHFzY2MzIWFRQGBwYGFRUDFBYzMjY1NCYjIgYD/gOs/FT8VgPrKkM7Tie9ozl5cC5SRH83Pz41RExDG1E8OFNTODxRBhT8VvxXA6n7LzI+NC9UYkOJmBssG7IiLjovOkc1PXFQO/7tSD8/SEw9PQD///+L/hQCegYgAiYBqgAAAQcBS/9WAAAACrMRCwZyACvOMDH//wAaA8EBWgW2AgYBXwAA//8AxAAABoQHigImADAAAAEHAHYCzwFpAAqzHwkCcgArzjAx//8AqwAABuIGIQImAFAAAAEHAHYDAwAAAAqzLyEHcgArzjAx//8AAP3IBSsFvAImACQAAAAHAYQBRAAA//8AXP3IA+cEYQImAEQAAAEHAYQA1QAAABC1AwIvCwEBuP+WsFYAKzQ0AAIAbv3IAjv/ggALABcAELQMAMASBgB8LzMaGMwyMDEBIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBYBUmV/fmZhiIZjMkBDLzJAOv3IdmdndnZlaXZsPTQ2PDw2ND0AAgB8/+wGfwYUABwAKwAbQA0XFREaBSgOA3IhBQlyACsyKzISOTnOMjAxARQCBgYjIiYmAjU0EiQzMgQXPgI1MxcGBgcWFgUUEhYzMjYSNRACIyIGAgXFVKr8qa3/qFKUAS/nqQEAVDI2FtAOGHl+Kyr7jmLNoKLLX9vuoc5jAt2p/uvHbGzIARap4QFSu3BlEk9zSBWIyDFW0Xqy/v2NjQEDsgENATKL/v4AAAIAbf/sBUUE9gAaACkAG0ANFBIOGAQnCwdyHwQLcgArMisyEjk5zjIwMQEUAgYjIiYCNRAAMzIWFz4CNTMXDgIHFhYFFBYWMzI2NjU0JiYjIgYEbn3on5XmggEU7266Qjo+Fs8OEUBwWCAi/M1AiGtrhz8/h22fkgIptv8Ah4cBALYBEAEpSUQSUXZIFl+Yax5AnFuFtl1etoSDs1zMAAABALb/7AakBhQAHwAdQA4HBR8fAQwRFQJyGhEJcgArMisSOTkzL84yMDEBFT4CNTMXDgMHERQGBiMgADURMxEUFjMyNjY1EQUrPUQczg4NMFSFY3n6w/7o/tnOvLp+nkkFtsUNTXlQFUyFakkQ/Zma8owBJ/UDrvxTs7tapW4DrgAAAQCh/+wFyAT3ACIAKUAVAQAcHB4GDhMGcgkKChgYDgtyBwpyACsrMhEzETMrEjk5My/MMjAxARcOAwcRIycjDgIjIiYmNREzERQWMzI2NREzFT4CNQW6DgwwVIRhoRwLI2qFSoGyW8pzdqyJyjxCGgT3FkuIbUgM/LOXOUwmVLGMAs/9TYWEy74CM3kOTnpOAAAB/PoEu/5+BpYAFQAVQAkGAwwTwA8EAQQAL10azDI5OTAxARQGBwcjJzY2NTQmIyIGBzU2NjMyFv5+W0oKeRBNT0U0HzoWFkMpfoQF101YEmWmDTIuLCQHBnUHCWD//wAA/o0EmgW2AiYAPAAAAAcBsgS0AAD//wAC/hMEJQROAiYAXAAAAAcBsgWU/+r//wAAAAAEmgfoAiYAPAAAAQcBiQS0AVIACrMOBwJyACvOMDH//wAC/hMEJQaWAiYAXAAAAQcBiQR0AAAACrMjAAZyACvOMDH//wAAAAAEmgdTAiYAPAAAAQcBUQB4AWkACrMaBwJyACvOMDH//wAC/hMEJQXpAiYAXAAAAQYBUT0AAAqzLwAGcgArzjAx//8Abf7JBN8GFAImANMAAAEHAEIA8AAAAAqzLwALcgArzjAx//8AGP4UBF0FtgImADcAAAAHAHoBZAAA//8AJP4UAs4FSAImAFcAAAAHAHoA6gAA//8AfP40BccFzQImADIAAAAHAVACLAAA//8Abf40BG4EYgImAFIAAAAHAVABeAAA//8AfP40BccG3QImADIAAAAnAUwBmgFpAQcBUAJBAAAACrMjDgNyACvOMDH//wBt/jQEbgV0AiYAUgAAACcBTADlAAABBwFQAXgAAAAKsyMOB3IAK84wMQACAGb/7AQhBGIAFwAfABlADA0ZGQAdCAtyEQAHcgArMisyEjkvMzAxATIWFhUUAgYjIiYmNTUhJiYjIgYHNTY2ASEeAjMyNgIIofKGe96Wj89uAuwEr6BopFlTqQG4/eMBN3JYe5QEYoD7uLb+/ot74JhysL0mKKkmI/1YWopOnwAAAgApA0MCrgbTAAsAFwAOtQwAeBIGdwA/M+QyMDEBIiY1NDYzMhYVFAYnMjY1NCYjIgYVFBYBaqChmqeho5qqUkxMUk9LSgND7N3b7Ord2fCOm6CfmpqhnpsAAgAsA0QCsAbSAB4ALAAZQAsfDAsPDycWeAcAdwA/MuQyOS8zMzMwMQEyFhcVJiYjIgYGBzM2NjMyFhUUBgYjIiYmNTQ+AhMiBgYVFBYWMzI2NTQmAeseRxgXQiNvfzgGCB1sU3mTTI1fYJZWKGOuEzZRLCdOOUlbUAbSCAaFCQtQilcqPZCDXYpLV6+EZbqQVf5CKUAkMFs6W1hKVQACACUDRAKqBtUAHQArABtADBQVJCQYGBAJeB4AdwA/MuQyOS8zETMzMDEBMhYWFRQOAiMiJic1FhYzMjY2NyMGBiMiJjU0NhciBhUUFjMyNjY1NCYmAV1fl1coYa2FIUkXFj8rb304BAkcZ1GAlKqRRlxOUDZQLSZNBtVWrYZlu5NVCAaGCQxUjFQoQJKFhap/WFZKWShAIzdZNv//ACEAAAXzBh8AJgBJAAAABwBJAssAAP//ACEAAARRBh8AJgBJAAAABwBMAssAAP//ACEAAARABh8AJgBJAAAABwBPAssAAP//ACEAAAccBh8AJgBJAAAAJwBJAssAAAAHAEwFlgAA//8AIQAABwsGHwAmAEkAAAAnAEkCywAAAAcATwWWAAAAAQC3/+0FeQXLACsAJkATJwgcBQUdBAAaGgAUDQlyIQADcgArMisyETkvEjk5MxEzPzAxATIWFhcBHgIVFAYGIyImJzUWFjMyNjU0JiMjNQEuAiMiBgYVESMRNDY2AuaPzYIe/ut9wW5t47JsuU9PvleomKyvbwEoF09zTneaS8t/+gXLVptq/twIZbSBgspxIym2LDCWg36ElAE5NEYlWqZz/FkDsKDziAAB/+n+FQUoBcwAJgAeQBANFBQZCBwFBBoGAnIgAANyACsyKy8XOTMvMzAxEzIWFhcTATMBAR4CMzI2NxUGBiMiJiYnAwEjAQMmJiMiBgc1NjbVT2BCIcEBbtv+DgEWITI3JhI1HCBKK1dtUS3G/jfZAknsJTw3FDchIEYFzDVwVv4jAsL8af1cTFIfCAaeCw5HlHYB7vzDBBECQF9bCQueDBQAAAMAwP4UBL0FtgAUAB0AJwAgQA8ICRUVHh4AHxMSCB0AAnIAKzI/zTMSOS8zEjk5MDETISAEFRQGBgcVHgIVFAYGIyERIxMzMjY1NCYjIxERITI2NTQmJiPAAbIBHAEKQHdUX4hJhO2g/uHNzfyplKiq5wERqaBKmHgFtrO8VoVWDwkQUYxrjLxe/hQFOXRxdGv9mP3/ioJQbTgA//8AxP4UBAwFtgImAC8AAAEHAHoBpgAAAAu2ARcAAQAAVgArNAD//wDE/hQFYgW2AiYAMQAAAQcAegI9AAAAC7YBJQEBAABWACs0AP//AAD+NAUrBbwCJgAkAAAABwFQAZsAAP//AMT+NAP5BbYCJgAoAAAABwFQAWQAAP//AGT+NAHBBbYCJgAsAAABBgFQEgAAC7YBFQAAAB5WACs0AP//ALb+NAUrBbYCJgA4AAAABwFQAe0AAAABAKsAAAF0BE4AAwAMtQIGcgEKcgArKzAxISMRMwF0yckETgAB/4v+FAF0BE4AEAAOtgsGcgcAD3IAKzIrMDETIiYnNRYWMzI2NREzERQGBjIzVR8hQChDVMlDj/4UDwqhCgpKZATm+xJkllIA//8Aq/4UBL0GHwIGAVMAAP//AEn+FAHmBhQCJgBPAAABBgB6PQAAC7YBFQEBAABWACs0AP//AKv+FARbBGICJgBRAAABBwB6AboAAAAOtAEZDgAAuP4UsFYAKzQAAwBc/jQD5wRhABUAMwA+ADJAGQgHBx07OyE1NDQpKCgWIQtyGxItFgdyDwAALzIrMj8rEjkvMzMRMxEzETMzETMwMQEiJjU0NjY3Fw4CFRQWMzI2NxUGBgMyFhURIycjDgIjIiYmNTQkJTc1NCYjIgYHJzY2AQcGBhUUFjMyNjUCb2puR204ZjpSKzEqIjMRHD1JzMqQJwguZINeZJxZAQIBBr5zZ1WcSEBOxwE8mr+baleGrf40a11MjXgsHzxraDguLwkFfQgLBi21w/0XoDxQKEiRcKiuCAg+gWoxIpIoNv22BwdxZVhSl5QA//8Abf40BCcEYgImAEgAAAAHAVABYgAA//8APP40AZkF7wImAEwAAAAGAVDqAAACAKH+NARTBE4AFQAtACRAEy0GciMGcggHBxooKA8AHgtyGAoAPyvMMjMRMzMRMysrMDEBIiY1NDY2NxcOAhUUFjMyNjcVBgYBESMnIw4CIyImJjURMxEUFjMyNjY1EQKibW08YzmCPFYtMiogNREdPgGJoRwLImyGS3+xW8pzdnOHO/40a10+dWcqETNgWi8uLwkFfQgLBhr7spc5TCZUsYwC0f1LhYRbr38CNQAB/SL+jf4M/3wACwAIsQAGAC8zMDEBIiY1NDYzMhYVFAb9ljBERDAyRET+jTk+QDg4QD45AP//ACn/7wKuA38CBwGYAAD8rP//AFAAAAH7A20CBwB7AAD8rP//ADMAAAKGA4ACBwB0AAD8rP//ACv/8QKXA38CBwB1AAD8rP//ABMAAALFA3MCBwF1AAD8rP//AET/7wKbA20CBwF2AAD8rP//ACz/8AKwA34CBwGZAAD8rP//ADoAAAKjA20CBwF3AAD8rP//ADL/8AKmA30CBwF4AAD8rP//ACX/8AKqA4ECBwGaAAD8rAACAHL/7AREBc0AEQAfABC3HA4FchUFDXIAKzIrMjAxARQCBgYjIiYmAjU0EjYzMhYSBRASMzISETQCJiMiBgIERDZ2uoR+t3k6YNayqNhq/PiCnJuEOH5pan42At2y/ujCZWXCARez6wFQtbP+r+z+2/7dASIBJsABA4OD/v0AAAEALQAAAnIFtgANABVACgoJCQULBHINDHIAKysyMi8zMDEhETQ2NjcGBgcHJwEzEQGrAgMDGjolp2YBnqcD3TVZUSYbMR+HhAFC+koAAAEATQAABBsFywAdABdACwkRBXIaARsbAAxyACsyETMzKzIwMTM1AT4CNTQmIyIGByc+AjMyFhYVFAYGBwEVIRVNAYFukUqGbmWiVWw7iaVliMdrXal0/uIC0J4Bh2+nnV1yeElEhjJRMGCwdnXHxG/+5gmzAAABAFX/7AQgBcsALQAdQA0EAx0dGhoLJCsFEgsNAD8zPzMSOS8zEjk5MDEBFAYHFRYWFRQGBiMiJic1FhYzMjY2NTQmJiMjNTMyNjY1NCYjIgYHJzY2MzIWA/SriK6xePnCdshaXNRhf55JWrGEiYt7oE6HfHKpS2NS5pXh6gRllbIcBxaykn/GcCYqty4zQ31WVm00pkF2T2dxRjOLPljGAAACAC0AAARwBbwACgAVAB1ADQYDCwsJEAQBAQQEAAwAPz85LxI5MzMRMzMwMSERITUBMxEzFSMRAxE0NjY3IwYGBwEC3P1RAqvI0NDEAQQDCBU7Gf56AUqfA9P8O63+tgH3Ab5CaVQiJ10l/coAAAEAeP/sBB8FtgAhACFADxoZGRYWHwAACB4bBA8IDQA/Mz8zEjkvMzMRMxEzMDEBMhYWFRQGBiMiJic1FhYzMjY2NTQmIyIGBycTIRUhAzY2AjyS2XiC97BzxkVK0WFqnVaqtT6OLV84Auj9xiEkbwOIZcKLmNx2KCi5KzVChmeIlBULOQK9s/5uBxAAAgBy/+wEQQXKACIAMQAbQAwSKSkWFgYjHg0NBgUAPzM/MxI5LzMRMzAxEzQ+AzMyFhcVJiYjIgYCBzM+AjMyFhYVFAYGIyIuAgEyNjU0JicmBgYVFB4CciVZmuqlLmojJl0wuNJcBw0eXYVZgL5pdNOQbbiISwH1fJeGh1yITCRKcAJwg/rapV4ICqkMDJb+/aQxUC9pyI+Y3nhRofH+xKGlh5wBAU52PT9/a0EAAQATAAAD9AW2AAYAELYGDAUCAgMEAD8zETM/MDEzASE1IRUB0QJL/PcD4f23BQOzkPraAAMAdP/sBEUFywAfADAAPgAXQAwoKQgYMQU4EAUgAA0APzI/Mxc5MDEFIiYmNTQ2NjcuAjU0NjYzMhYWFRQGBgceAhUUBgYnMjY2NTQmJicnDgIVFBYWEz4CNTQmIyIGFRQWFgJgndxzU4pTR3VFdch8f8lyS31OWZRYedqWX4RFSoBVIlR5QEGDaENtQIhwa4lDchRdr3tllWsmKGaJWnCbUVCbc1iFYycqbJJkerNhnTxtSUVoUyINJFdvSUVsPQLOHUdjRWJnaGFGYUcAAgBk/+wEMwXKACIAMQAbQAwSKSkWFgYjHgUNBg0APzM/MxI5LzMRMzAxARQOAyMiJic1FhYzMjYSNyMOAiMiJiY1NDY2MzIeAgEiBhUUFhcyNjY1NC4CBDMlWZzspCtwIyViL7rSWwYMHV2GXH+8Z3TUkGy4iEv+C3yYhIdeikskSnEDR4P72qZdCQqqDQ6WAQOkMFAwaciOmt54UaHxATugpYebAUx1Pj5/a0H//wApAjkCrgXJAgcBmAAA/vb//wBQAkoB+wW3AgcAewAA/vb//wAzAkoChgXKAgcAdAAA/vb//wArAjsClwXJAgcAdQAA/vb//wATAkoCxQW9AgcBdQAA/vb//wBEAjkCmwW3AgcBdgAA/vb//wAsAjoCsAXIAgcBmQAA/vb//wA6AkoCowW3AgcBdwAA/vb//wAyAjoCpgXHAgcBeAAA/vb//wAlAjoCqgXLAgcBmgAA/vb//wATAAAC9AW2AgYAEgAAAAIArgAABeUFtgAPAB8AJUAREBAODhkBBHIICBISHx8ADHIAKzIRMxEzfC8rMjIRM30vMDEzESEyFhYVESMRNCYmIyEREzMRITI2NjURMxEUBgYjIa4B7ZzIXrVEgl/+4sa2ARhmika2YNGq/iEFtnbWjv2ZAmVtj0f64wRC/FdIkmwD1/wnidh8AAEBb/47AoD/gwALAA60AQcFgAsALxrNOTkwMQUVDgIHIzU+AjcCgAwxQCRwDiAcBX0SKG1xMBkjbXMsAAEAAAHUAJEAFgBfAAUAAgAQAC8AmgAAAr4PgwADAAEAAAAAAAAAAAAAACkARwCfAQUBZQHZAe0CFAI+Am8CjgKrArwC1wLsAywDUgOOA+EEGgRhBLkE1QU9BZYFwwXzBhEGKwZJBpYHIgdXB6IH3ggOCDMIUwiYCLwIzgjzCR8JNQluCZwJ3goRCmAKmwrwCwsLNwthC7UL4AwDDCYMQQxWDHAMjAyeDMANEQ1eDZUN4Q4hDlcO2g8SDzgPbw+lD7cQBhA3EHIQwxEQEUERjhHEEfgSIBJzEqAS3xMCE0oTWxOiE9sT2xQCFEMUjBUBFT8VWBXKFfgWaRa2Fu4XBRcNF38XkRfFF/AYJRhvGJEY0Bj6GQMZMRlXGYcZuxoZGnYa+BtEG1YbaBt6G4wbnxurG+cb8xwFHBccKRw8HE4cYBxyHIUcxxzZHOsc/R0PHSEdNB1nHdcd6R37Hg0eIB4yHmseyh7cHu4fAB8RHyMfNx+5H8Uf1x/pH/sgDSAeIC8gQSBUILcgySDbIO0g/yERISMhWiHCIdQh5iH4IgoiHCJtIn8ikSKjIrUixyLTIt8i8SMDIxUjJyM5I0sjXSNvI4EjlCOcI/MkBSQXJCkkOyRNJF8kayTRJOMk9SUHJRklKyU9JU8lYiVuJX8lkSWkJdwmISY0JkYmWSZqJn0mjyaaJqUmuCbEJtAm4ib0JwAnCyc/J1EnYyduJ3onjSefJ6sntyfgKAUoFygpKDUoQShTKGUocSi1KP0pDykhKTMpRSlYKWspxCo0KkYqWCpkKnAqgiqTKqUqtyrJKtoq5iryKwQrFSsgKysrPStJK3cruCvKK9wr7iwALBIsJCw4LEwsXyxyLMMszyzhLPMtBS0WLSktOy1NLV8tcS2DLZQtui4ELm4u+i8MLx4vMC9CL00vWC+FL7Qvxy/uMAowNzBhMJgw0TEtMT8xUTFjMXUxiDGbMa0xvzHQMeEx/zIeMicyWTKMMpUyvTLdMu0zADMfMz0zWzNwM54z8DRMNLA1BjVMNV01fTWcNc42DjYpNoI2gjaCNoI2gjbWNug28DcCNxQ3IDc1N2M3uTgJOEo4kzjCOM442jjsOP45EDkhOTM5PzlLOVc5Yzl5OY850Dn9Okw6mjqmOrI6vjrOOt47MzuFO9M75jv5PAU8ETwjPC88QTxmPG48gDyUPQs9Fz0iPXk9lD2dPaY9rz24PcE9yj3TPdw95T3uPi4+VT6QPuE/GD9eP7U/z0A2QI1AlkCfQKhAsUC6QMNAzEDVQN5A50DvQTRBUgAAAAEAAAADAELgdr4mXw889QALCAAAAAAA2czC9wAAAADddyZR+5z90wmcCGIAAAAGAAIAAAAAAAAEzQDBAAAAAAIUAAACFAAAAigAjgNWAIcFKwAyBJMAdQbDAFwF3wBoAdkAhwJzAFICcwA+BGUAUwSTAGMCIABOApMATQImAI4DBwATBJMAYASTAKkEkwBgBJMAWQSTACoEkwB8BJMAaQSTAFQEkwBfBJMAXgImAI4CJgBBBJMAYwSTAGwEkwBjA4sAGQcsAHIFLQAABTgAxAUOAHwF1gDEBHQAxAQyAMQF0AB8BfQAxAJXAMQCRv9fBQEAxARDAMQHSADEBiUAxAZCAHwE3gDEBkIAfAUGAMQEZABmBHcAGAXjALYE4QAAB3kAFwTNAAUEmgAABJgARwKgAKADBwATAqAAMwSTAEgDc//8AmMAUgSLAFwE8ACrA+cAbQTwAG0EjQBtAssAIQRjABkE/wCrAiAAnQIg/4sEZQCrAiAAqweFAKsE/wCrBNkAbQTwAKsE8ABsA1wAqwPbAGUDAgAkBP8AoQQjAAAGXQAXBEwAIAQlAAIDygBKAwoAMwRmAeMDCgBHBJMAYwIUAAACKACOBJMArwSTAEgEkwB3BJMAGQRmAeMEDgB2BLEBLgaoAGQC4gA/BDQAUASTAGMCkwBNBqgAZAQA//oDbQBsBJMAYwLYADMC2AArAmMAUgUIAKsFPQB4AiYAjgG+AAwC2ABQAwUAQQQ0AE4GGgA9BlsALAZcAC8DiwA2BS0AAAUtAAAFLQAABS0AAAUtAAAFLQAABx3//wUOAHwEdADEBHQAxAR0AMQEdADEAlf/4AJXALgCV//DAlcABAXWADcGJQDEBkIAfAZCAHwGQgB8BkIAfAZCAHwEkwCEBkIAfAXjALYF4wC2BeMAtgXjALYEmgAABN4AxAUoAKsEiwBcBIsAXASLAFwEiwBcBIsAXASLAFwHAgBcA+cAbQSNAG0EjQBtBI0AbQSNAG0CIP/nAiAAjAIg/6oCIP/mBNYAbAT/AKsE2QBtBNkAbQTZAG0E2QBtBNkAbQSTAGME2QBtBP8AoQT/AKEE/wChBP8AoQQlAAIE8ACrBCUAAgUtAAAEiwBcBS0AAASLAFwFLQAABIsAXAUOAHwD5wBtBQ4AfAPnAG0FDgB8A+cAbQUOAHwD5wBtBdYAxATwAG0F1gA3BPoAbQR0AMQEjQBtBHQAxASNAG0EdADEBI0AbQR0AMQEjQBtBHQAxASNAG0F0AB8BGMAGQXQAHwEYwAZBdAAfARjABkF0AB8BGMAGQX0AMQE//+tBfQAAAT/ABACV/+vAiD/jQJX//YCIP/bAlf/4AIg/8wCVwBkAiAAPAJXALkEnQDEBEAAnQJG/18CIP+LBQEAxARlAKsEZQCrBEMAowIgAIwEQwDEAiAAhgRDAMQCIACrBEMAxAJLAKsEQwAUAiD/7wYlAMQE/wCrBiUAxAT/AKsGJQDEBP8AqwWZAAMGJQDEBP8AqwZCAHwE2QBtBkIAfATZAG0GQgB8BNkAbQd/AHwHpQBrBQYAxANcAKsFBgDEA1wAgwUGAMQDXACGBGQAZgPbAGUEZABmA9sAZQRkAGYD2wBlBGQAZgPbAGUEdwAYAwIAJAR3ABgDAgAkBHcAGAMCACQF4wC2BP8AoQXjALYE/wChBeMAtgT/AKEF4wC2BP8AoQXjALYE/wCh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) format("truetype")}@font-face{font-family:OpenSans;font-style:normal;font-weight:600;src:url(data:font/ttf;base64,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A+UAYwMqACgFFQCfBEYAAAaGABYEaAAZBEgAAQPUAEQDFAAsBGcB2gMUAEsEkwBgAhQAAAI0AIYEkwCkBJMASwSTAHUEkwATBGcB2gQAAHIEvwEnBqgAZALyADoEcgBRBJMAYAKTAEgGqABkBAD/+gNtAGMEkwBgAugANQLoADACjwBSBR0AqAU9AHYCMQCGAbX//ALoAFQDDAA+BHIAUAZIADgGkgAtBn8APgOjADYFSgAABUoAAAVKAAAFSgAABUoAAAVKAAAHSP//BRIAegR3AMAEdwDABHcAwAR3AMACcf/MAnEAuwJx/7gCcQABBd0ANQZEAMAGTAB6BkwAegZMAHoGTAB6BkwAegSTAIMGTAB6BfEAtAXxALQF8QC0BfEAtAS8AAAE6wDABVYAqASkAFoEpABaBKQAWgSkAFoEpABaBKQAWgceAFoD+QBnBJwAZwScAGcEnABnBJwAZwI7/9UCOwCIAjv/nwI7/+UE4ABnBRUAqATiAGcE4gBnBOIAZwTiAGcE4gBnBJMAYATiAGcFFQCfBRUAnwUVAJ8FFQCfBEgAAQT7AKgESAABBUoAAASkAFoFSgAABKQAWgVKAAAEpABaBRIAegP5AGcFEgB6A/kAZwUSAHoD+QBnBRIAegP5AGcF3QDABPsAZwXdADUFDQBnBHcAwAScAGcEdwDABJwAZwR3AMAEnABnBHcAwAScAGcEdwDABJwAZwXOAHoEbwATBc4AegRvABMFzgB6BG8AEwXOAHoEbwATBgMAwAUV/6IGAwAABRUADAJx/7ICO/+SAnH/+gI7/98Ccf/ZAjv/xQJxAHACOwBHAnEAtgTXAMAEdgCaAmb/YgI7/4cFGwDABJUAqASVAKgEWQCgAjsAiARZAMACOwCIBFkAwAI7AKgEWQDAAn4AqARZAA4CO//tBkQAwAUVAKgGRADABRUAqAZEAMAFFQCoBckABAZEAMAFFQCoBkwAegTiAGcGTAB6BOIAZwZMAHoE4gBnB5gAege1AGYFHADAA3QAqAUcAMADdACIBRwAwAN0AHgEZgBkA+UAYwRmAGQD5QBjBGYAZAPlAGMEZgBkA+UAYwSFAB4DKgAoBIUAHgMqACgEhQAeAyoAKAXxALQFFQCfBfEAtAUVAJ8F8QC0BRUAnwXxALQFFQCfBfEAtAUVAJ8F8QC0BRUAnweQAA8GhgAW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SST/H0gj/x9HIqsfRiL/H0UiXh9EIZMfQyH/H0IfzR9BH/8fQB+rHz8g/x8+IGcfPR7/Hzwd/x87HHIfOhz/HzkcTx83QMI2Xh80M08fMTArHykoTx8oFRsZXCcbLR8mJUAfJQ4aGVwkGjEfIxkfHyIZ/x8hH2cfIB9AHx8cGBZcHhgcHx0X/x8cFv8fGzIZH1sYOBY3WxoyGR9bFzgWN1sVGT4W/1oTMRJVETEQVRJZEFkNMgxVBTIEVQxZBFkPBH8E7wQDD/8OVQsyClUHMgZVAV8AVQ5ZClkGWc8G7wYCAFlvAH8ArwDvAAQQAAEJMghVAzICVQhZAlkPAn8C7wIDEAADQEAFAbgBkLBUK0u4B/9SS7AJUFuwAYiwJVOwAYiwQFFasAaIsABVWltYsQEBjlmFjY0AHUJLsJBTWLIDAAAdQlmxAgJDUVixBAOOWUJzACsAKysrc3MAK3MAKwArACsrKysrcwArACsrKwArACsrKwErASsBKwErASsBKwArKwErKysBKysAKwArKysBKysBKwArKwErKysAKysrKysrKysrASsrKysAKysrKysrKysrKysrASsrKysAKysrKysrKysrKwErKysrKysrKwArKysrKysrKysrKysAKysYAAYUAAsFtgAWBbYAFgRNABQAAP/qAAD/7AAA/+r+Fv/+BbYAFQAA/+sAAACoAKoAlgCWAKYAggCCAKsAlgBxAJ8AjwCpAKYAyABtAIoAmgBrAI4AmwB6AKQAjQE6AIQAmgCiAIoA7gCFAHgBSACFAHoAmgCeAKoAswCWAHEAhQCQAJkAnwCkAKkAsACbAKYArADIAG0AegCCAIoAmgBrAIIAigCSAJsAoACmAHoAowCrAK8AgwCMAJgBOgBxAIAAhwCPAJsApQB9AIYAiwCVAJsApQCuAO4AeAB+AIgAkwFIAHkAgACGAIsAlACaAKcGwgN6BQoAFP84Ap4DpwAAABAAxgADAAEECQAAAKwAAAADAAEECQABACQArAADAAEECQACAA4A0AADAAEECQADADgA3gADAAEECQAEACQArAADAAEECQAFABoBFgADAAEECQAGACIBMAADAAEECQAOADQBUgADAAEECQAQABIBhgADAAEECQARABABmAADAAEECQEAAAwBqAADAAEECQEBAAoBtAADAAEECQEFABABmAAD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) format("truetype")}@font-face{font-family:OpenSans;font-style:normal;font-weight:700;src:url(data:font/ttf;base64,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BVYAAAT+AAAEogAxAqYAjwNOAAwCpgAzBJMALwNK//wC5QBSBNUAVgUQAKAEHQBcBRAAXAS6AFwDGQApBIUABgVCAKACcQCTAnH/fQT2AKACcQCgB9sAoAVCAKAE9ABcBRAAoAUQAFwDogCgA/oAXAN5AC8FQgCaBI0AAAbZABQEoAAKBI0AAAPnADcDJwAfBGgBxwMnAFIEkwBYAhQAAAJKAHUEkwCPBJMAUgSTAHEEkwAGBGgBxwPjAGoE2wEXBqgAZAMQAC8E7ABSBJMAWAKTAD0GqABkBAD/+gNtAFAEkwBYAwgALwMIADsC5QBSBUgAoAU9AHECSAB1AaT/2wMIAFwDGwA5BOwAUgakAC0G/gAtBsMAWgPRADcFhQAABYUAAAWFAAAFhQAABYUAAAWFAAAHngAABRkAdwR7ALgEewC4BHsAuAR7ALgCpv+kAqYAuAKm/6ICpv/8BewALwaBALgGXgB3Bl4AdwZeAHcGXgB3Bl4AdwSTAIEGXgB3BgwArgYMAK4GDACuBgwArgT+AAAFBgC4BbAAoATVAFYE1QBWBNUAVgTVAFYE1QBWBNUAVgdWAFYEHQBcBLoAXAS6AFwEugBcBLoAXAJx/7ICcQCBAnH/iQJx/+IE9ABcBUIAoAT0AFwE9ABcBPQAXAT0AFwE9ABcBJMAWAT0AFwFQgCaBUIAmgVCAJoFQgCaBI0AAAUQAKAEjQAABYUAAATVAFYFhQAABNUAVgWFAAAE1QBWBRkAdwQdAFwFGQB3BB0AXAUZAHcEHQBcBRkAdwQdAFwF7AC4BRAAXAXsAC8FMQBcBHsAuAS6AFwEewC4BLoAXAR7ALgEugBcBHsAuAS6AFwEewC4BLoAXAXLAHcEhQAGBcsAdwSFAAYFywB3BIUABgXLAHcEhQAGBh8AuAVC/40GHwAABUIABAKm/7YCcf+aAqYAAAJx/+gCpv/LAnH/tgKmAIcCcQBcAqYArgVMALgE4QCTAqb/aAJx/30FUAC4BPYAoAT2AKAEhQCYAnEAgQSFALgCcQCNBIUAuAJxAKAEhQC4AuUAoASFAAICcf/nBoEAuAVCAKAGgQC4BUIAoAaBALgFQgCgBikABQaBALgFQgCgBl4AdwT0AFwGXgB3BPQAXAZeAHcE9ABcB8kAdwfTAFwFSAC4A6IAoAVIALgDogCTBUgAuAOiAFoEaABe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) format("truetype")}@font-face{font-family:OpenSans;font-style:normal;font-weight:800;src:url(data:font/ttf;base64,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alZWamVaWgD//wAAAAAFzwdrAiYAJAAAAQcAQwDlAUoACrMZBQJyACvOMDH//wAAAAAFzwdrAiYAJAAAAQcAdgHJAUoACrMZBQJyACvOMDH//wAAAAAFzwdrAiYAJAAAAQcBSgDTAUoACrMfBQJyACvOMDH//wAAAAAFzwd3AiYAJAAAAQcBUQDuAUoACrMkBQJyACvOMDH//wAAAAAFzwdtAiYAJAAAAQcAagBtAUoADLQoHAUCcgArzs4wMf//AAAAAAXPBxECJgAkAAAABwFPAYcAQgAC//YAAAcvBbYADwATACtAFRMJCRADCg0DDQMNBQYCcg4BAQUIcgArMhEzKxE5OS8vETMRMzIRMzAxISERIQMhASERIRUhESERIQEhESMHL/ya/ktk/kYCdATF/icBtv5KAdn7XgE8bwES/u4Ftv7D5v7D/uwBGAIO//8AaP4UBPIFywImACYAAAAHAHoB1wAA//8AngAABAIHawImACgAAAEHAEMATgFKAAqzEgICcgArzjAx//8AngAABDcHawImACgAAAEHAHYBMQFKAAqzEgICcgArzjAx//8AjQAABBgHawImACgAAAEHAUoAOwFKAAqzEgICcgArzjAx//8AngAABAIHbQImACgAAAEHAGr/1QFKAAy0IRUCAnIAK87OMDH///+PAAACQwdrAiYALAAAAQcAQ/89AUoACrMKAQJyACvOMDH//wCZAAADTQdrAiYALAAAAQcAdgBHAUoACrMKAQJyACvOMDH///+gAAADKwdrAiYALAAAAQcBSv9OAUoACrMKAQJyACvOMDH////IAAADAAdtAiYALAAAAQcAav7pAUoADLQNGQECcgArzs4wMQACAB8AAAV3BbYADgAcAB9ADwwREQsUFAkQDgJyFQkIcgArMisyETkvMzMRMzAxATIEEhUUAgQjIREjETMRASMRMxEjFTMyNjU0JiYCmOwBSKu+/qfp/id/fwH+c9PTWLSoR44FtqL+yOL//q6pAjMBQAJD/sH+/P7A79HXha9X//8AngAABg4HdwImADEAAAEHAVEBXAFKAAqzFAoCcgArzjAx//8AaP/sBfYHawImADIAAAEHAEMBLwFKAAqzJw4DcgArzjAx//8AaP/sBfYHawImADIAAAEHAHYCEgFKAAqzKA4DcgArzjAx//8AaP/sBfYHawIm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BLAAXAJ5ADkCiwArAlAAVgOJAAoEsABIBLAAVASwAC0EsABGBLAAIwSwAF4EsABGBLAATgSwAEQEsAA/AlAAVgJgADkEsABcBLAAXASwAFwECgAABy0AUgXPAAAFZACeBTEAaAXfAJ4EZACeBFAAngXsAGgGIQCeAskAngLR/14FfwCeBKgAnge8AJ4GrACeBmAAaAUOAJ4GYABoBWoAngSeAFoEugAzBg4AlgWNAAAIUAAfBckABAVQAAAE4wA9ApgAdQOJAAYCmAAvBDP/8AQA//wDWABSBPwASgUlAIcEUABWBSUAVgTyAFYDTgAtBNkAFAVcAIcCmgB/Apj/mAVGAIcClgCHCAAAhwVcAIcFGQBWBSUAhwUlAFYDwQCHBCMAVgOuADUFXACFBOMAAAdIABkFCgAKBOH//gQOADEDdwA9BBIBgwN3AEIEsABcAhQAAAJSAFIEsACBBLAAZgSHAGAEsAAIBBIBgwQAAGoE0QDfBpgAXAMtADEFcwBKBLAAXAKLACsGmABcBAD/+gNgAD8EsABcAzEAPQMxAD8DWABSBWAAhwUlAGYCUABWAk4ALQMxADkDIwAxBXMATAcZ//QHaP/0B2AAVAQKACUFzwAABc8AAAXPAAAFzwAABc8AAAXPAAAHkf/2BTEAaARkAJ4EZACeBGQAjQRkAJ4Cyf+PAskAmQLJ/6ACyf/IBd8AHwasAJ4GYABoBmAAaAZgAGgGYABoBmAAaASwAI0GYABoBg4AlgYOAJYGDgCWBg4AlgVQAAAFBACeBgAAhwT8AEoE/ABKBPwASgT8AEoE/ABKBPwASgd7AEoEUABWBPIAVgTyAFYE8gBWBPIAVgKa/54CmgCBApr/iwKa/7IFIQBYBVwAhwUZAFYFGQBWBRkAVgUZAFYFGQBWBLAAXAVSAFYFXACFBVwAhQVcAIUFXACFBOH//gUlAIcE4f/+Bc8AAAT8AEoFzwAABPwASgXPAAAE/ABKBTEAaARQAFYFMQBoBFAAVgUxAGgEUABWBTEAaARQAFYF3wCeBSUAVgXfAB8FTgBWBGQAngTyAFYEZACeBPIAVgRkAJ4E8gBWBGQAngTyAFYEZACNBPIAVgXsAGgE2QAUBewAaATZABQF7ABoBNkAFAXsAGgE2QAUBiEAngVc/40GQgAABXEAAALJ/8ACmv+mAsn/+gKa/+oCyf/PApr/vwLJAIMCmgBmAskAlQWaAJ4FMQB/AtH/XgKY/4kFfwCeBUYAhwVGAIcEqACPApYAfwSoAJ4ClgCBBKgAngKWAIcEqACeA3cAhwTf/+EDVv/hBqwAngVcAIcGrACeBVwAhwasAJ4FXACHBqQAAAasAJ4FXACHBmAAaAUZAFYGYABoBRkAVgZgAGgFGQBWB6gAaAfXAFYFagCeA8EAhwVqAJ4DwQCHBWoAngPBAEAEngBaBCMAVgSeAFoEIwBABJ4AWgQjAFYEngBaBCMAQAS6ADMDrgA1BLoAMwOuADUEugAzA9cANQYOAJYFXACFBg4AlgVcAIUGDgCWBVwAhQYOAJYFXACFBg4AlgVcAIUGDgCWBVwAhQhQAB8HSAAZBVAAAATh//4FUAAABOMAPQQOADEE4wA9BA4AMQTjAD0EDgAxAzkAhwRxAIsFywAABPwASgeR//YHewBKBmAAaAVSAFYEngBaBCMAVgQvAFIELwBSA3sAUgPNAFICRABSArwAUgJmAFID7gBSBLYAUgV7AIcIUAAfB0gAGQhQAB8HSAAZCFAAHwdIABkFUAAABOH//gQAAEoIAABKAgAAFAIAACUCeQA8A/4AFAP+ACUEdwA8BBsAbwMjAEoG8ABWAocAQgSYAEIDMwBKAzMATAC8/k4EsAAfBLAAZge0AJ4EsAA3BLAANwYpACUEhwBIA8UBJQPFARADMQAdAzEAYAMxAD0DMQApBAAAAAFUAAAAAAAAAAAAAAgAAFYCmP+JAgAAJQe8AJ4IAACHBc8AAAT8AEoCngA/BsMAaAXHAFYHMwCWBnsAhQAA/GoFUAAABOH//gVQAAAE4f/+BVAAAATh//4FTgBWBLoAMwOuADUGYABoBRkAVgZgAGgFGQBWBPIAVgMxACkDMQAxAzEALwacAC0F5wAtBeMALQk1AC0JMQAtBmIAqAW4/8sFZACeBKgAngasAJ4FzwAABGQAngLJAIMGDgCWApoAiQKY/5gFewCHApYAYAVcAIcE/ABKBPIAVgKaAGYFXACFAAD8RgMxACkDMQA5AzEAPQMxAD8DMQAdAzEAYAMxADEDMQA9AzEAKQMxAC8E7gBmBFoAAASwAC0EsgBGBOEAMQSoAF4E3wBqBIkAOQTLAFAE7ABKAzEAKQMxADkDMQA9AzEAPwMxAB0DMQBgAzEAMQMxAD0DMQAp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AJkAnwCkAKkAsACbAKYArADIAG0AegCCAIoAmgBrAIIAigCSAJsAoACmAHoAowCrAK8AgwCMAJgBOgBxAIAAhwCPAJsApQB9AIYAiwCVAJsApQCuAO4AeAB+AIgAkwFIAHkAgACGAIsAlACaAKcGwgN6BQoAFP84Ap4DpwAAABAAxgADAAEECQAAAKwAAAADAAEECQABACYArAADAAEECQACAA4A0gADAAEECQADADoA4AADAAEECQAEACYArAADAAEECQAFABoBGgADAAEECQAGACQBNAADAAEECQAOADQBWAADAAEECQAQABIBjAADAAEECQARABIBngADAAEECQEAAAwBsAADAAEECQEBAAoBvAADAAEECQEHABIBngADAAEECQEaAAwBxgADAAEECQEcAAwB0gADAAEECQEdAAoB3gBDAG8AcAB5AHIAaQBnAGgAdAAgADIAMAAyADAAIABUAGgAZQAgAE8AcABlAG4AIABTAGEAbgBzACAAUAByAG8AagBlAGMAdAAgAEEAdQB0AGgAbwByAHMAIAAoAGgAdAB0AHAAcwA6AC8ALwBnAGkAdABoAHUAYgAuAGMAbwBtAC8AZwBvAG8AZwBsAGUAZgBvAG4AdABzAC8AbwBwAGUAbgBzAGEAbgBzACkATwBwAGUAbgAgAFMAYQBuAHMAIABFAHgAdAByAGEAQgBvAGwAZABSAGUAZwB1AGwAYQByADMALgAwADAAMAA7AEcATwBPAEcAOwBPAHAAZQBuAFMAYQBuAHMALQBFAHgAdAByAGEAQgBvAGwAZABWAGUAcgBzAGkAbwBuACAAMwAuADAAMAAwAE8AcABlAG4AUwBhAG4AcwAtAEUAeAB0AHIAYQBCAG8AbABkAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATABPAHAAZQBuACAAUwBhAG4AcwBFAHgAdAByAGEAQgBvAGwAZABXAGUAaQBnAGgAdABXAGkAZAB0AGgATgBvAHIAbQBhAGwASQB0AGEAbABpAGMAUgBvAG0AYQBuAAAAAwAAAAAAAP+cADIAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAMACAAKAA0AB///AA8AAQACAA4AAAAAAAAAugACABwAJAA9AAEARABdAAEAbABsAAEAfAB8AAEAggCNAAEAkgCYAAEAmgC4AAEAugDeAAEA4ADgAAEA4gDiAAEA5ADkAAEA5gDpAAEA6wDrAAEA7QDtAAEA7wDvAAEA8QDxAAEA9AFJAAEBVAFbAAEBfgF+AAEBgAGDAAEBhQGIAAEBigGPAAEBkQGXAAEBmwGfAAIBoAGgAAEBpQGmAAEBqAGqAAEBrgGxAAEAAQADAAAAEAAAABAAAAAQAAEAAAAAAAEAAAAOAAoADAAAAAAAAURGTFQACAAEAAAAAP//AAAAAQAAAAoATgAqAAVERkxUAIhjeXJsAIhncmVrAIhoZWJyAIhsYXRuAP4AEQBsAHQAdAB8AIQAjACUAKwAnACkAKwA1AC0ALQAvADEAMwAC2Rub20A3GZyYWMBGGxpZ2EA4mxvY2wA6GxvY2wA7mxvY2wA9GxvY2wA+mxvY2wBAG51bXIBBnBudW0BDHRudW0BEgEkAAAAAQAAAAEBcgABAAAAAQEqAAEAAAABATAABgAAAAEA/gAEAAAAAQDeAAQAAAABAN4AAQAAAAEAqgABAAAAAQCoAAEAAAABAKYAAQAAAAEApAABAAAAAQCiAAEAAAABAKAABAAAAAEArgAGAAAAAgDmAPgArgAFQ0FUIAEWTUFIIAEqTU9MIAE+TkFWIAFSUk9NIAFmAAAAAQAIAAAAAQAQAAAAAQAEAAAAAQADAAAAAQABAAAAAQAAAAAAAQACAAAAAQAHAAAAAQAOAAAAAQAPAAAAAwAJAAoACwABASgBoAABAQwBWQABARwBtAABASr/7AABARABqgABART+VgABAXgAAQD0AAEBfAABAPAAAQGcAAEBGgABAQoAAgDkAOgAAP//AAYAAAABAAIACAAJAAoAAgECAAQBSAFJASMBJAACAQAABAGjAawBpAGtAAMAAQD+AAEAyAAAAAEAAAAMAAMAAQDyAAEAtgAAAAEAAAANAAIA6gAIAaUBrgGmAa8BpwGwAagBsQAA//8ABwAAAAEAAgADAAgACQAKAAD//wAHAAAAAQACAAQACAAJAAoAAP//AAcAAAABAAIABQAIAAkACgAA//8ABwAAAAEAAgAGAAgACQAKAAD//wAHAAAAAQACAAcACAAJAAoAAQABABIAAQB+AAEAhgABALYAAQDCAAIAAQATABwAAAACAAEBvQHGAAAAAgABAccB0AAAAAEAAgAvAE8ABQByAHoAYABmAGwAAQAEAR8BIAGRAZIAAQAEAPwA/QEGAQcAAQABAWsAAgABAbMBvAAAAAEACADGAMcA2gDbAPAA8QEzATQBAQACAHkAAQABAE8BAAACAHkAAQABAC8BmwACAEkBnAACAEwBnQACAE8BngADAEkATAGfAAMASQBPAAEAAQBJAAAAAgB5AAEALwABAAAABgAAAAIAeQABAE8AAQAAAAUAAAABAAEACAADAAAAFAADAAAALAACd2R0aAEBAAB3Z2h0AQAAAWl0YWwBHAACAAYAEgAeAAEAAAACARoAZAAAAAEAAQAAAQcDIAAAAAMAAgACAR0AAAAAAAEAAAAA) format("truetype")}body,p{color:var(--dps-color-black);font-family:OpenSans,sans-serif,sans-serif;line-height:150%}.sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute!important;width:1px}.dps-button{display:inline-flex;align-items:center;justify-content:center;cursor:pointer;gap:8px;font-size:14px;font-family:OpenSans;font-weight:500;line-height:110%;color:var(--dps-color-white);background:var(--dps-color-primary);border:none;box-shadow:none;padding:6px 20px;border-radius:48px;transition:all .15s ease-out;min-height:40px;min-width:40px;text-decoration:none}.dps-button:active,.dps-button:focus-visible,.dps-button:hover{text-decoration:none}.dps-button:active,.dps-button:hover{background:#3968c2;color:var(--dps-color-white)}.dps-button:focus-visible{background:#3968c2;color:var(--dps-color-white);outline:1px solid var(--dps-color-primary);box-shadow:0 0 6px #3375d499}.dps-button .dps-icon{font-size:24px}.dps-button--secondary{color:var(--dps-color-primary);background:var(--dps-color-white);border:1px solid rgba(51,117,212,.5)}.dps-button--secondary:active,.dps-button--secondary:hover{color:var(--dps-color-white);background:var(--dps-color-primary)}.dps-button--secondary:focus-visible{background:var(--dps-color-white);border-color:var(--dps-color-primary);color:var(--dps-color-primary)}.dps-button--secondary.dps-button--disabled{background:var(--dps-color-white)!important;color:var(--dps-color-primary)!important;border:1px solid rgba(51,117,212,.5)!important}.dps-button--link,.dps-button--link-darker{background:transparent;color:var(--dps-color-primary);gap:4px;text-underline-offset:4px}.dps-button--link:focus-visible,.dps-button--link:hover,.dps-button--link-darker:focus-visible,.dps-button--link-darker:hover{background:transparent;box-shadow:none}.dps-button--link:focus-visible>span:not(.dps-icon),.dps-button--link:hover>span:not(.dps-icon),.dps-button--link-darker:focus-visible>span:not(.dps-icon),.dps-button--link-darker:hover>span:not(.dps-icon){text-decoration:underline}.dps-button--link:hover,.dps-button--link-darker:hover{color:var(--dps-color-primary)}.dps-button--link:focus-visible,.dps-button--link-darker:focus-visible{outline:none;color:var(--dps-color-primary);text-shadow:0 0 4px rgba(51,117,212,.6)}.dps-button--link.dps-button--size-sm,.dps-button--link-darker.dps-button--size-sm{padding-inline:16px}.dps-button--link.dps-button--disabled,.dps-button--link-darker.dps-button--disabled{color:var(--dps-color-medium-gray)!important;background:transparent!important;text-shadow:none!important}.dps-button--link.dps-button--disabled>span:not(.dps-icon),.dps-button--link-darker.dps-button--disabled>span:not(.dps-icon){text-decoration:none!important}.dps-button--link-darker,.dps-button--link-darker:focus-visible,.dps-button--link-darker:hover{color:var(--dps-color-primary-darker)}.dps-button--size-sm{gap:4px;min-height:32px;min-width:32px;padding:4px 20px;font-size:14px;line-height:100%}.dps-button--size-sm .dps-icon{font-size:20px}.dps-button--size-lg{min-height:48px;min-width:48px;padding:10px 24px;font-size:15px;font-weight:600}.dps-button--squared{border-radius:0}.dps-button--disabled{color:var(--dps-color-white)!important;opacity:.5!important;background:var(--dps-color-primary)!important;cursor:default!important;box-shadow:none!important;outline:none!important}.dps-button--no-padding{padding:0}.dps-button--no-padding.dps-button--link,.dps-button--no-padding.dps-button--link-darker{padding-inline:0}.dps-button-group{display:flex;flex-direction:row;gap:10px}.dps-button-group--center{justify-content:center}.dps-button-group--right{justify-content:end}.dps-checkbox{position:absolute;top:0;left:0;width:22px;height:22px;outline:none}.dps-checkbox+.dps-label{position:relative;margin:0;padding-left:34px;line-height:22px;font-weight:400;font-size:16px;cursor:pointer}.dps-checkbox+.dps-label:before{display:inline-block;content:"";position:absolute;top:0;left:0;width:22px;height:22px;background-color:var(--dps-color-white);border-radius:2px;border-style:solid;border-width:1px}.dps-checkbox+.dps-label:after{display:inline-block;content:none;position:absolute;top:9.35px;left:11px;width:12px;height:7.3846153846px;border-bottom:2px solid var(--dps-color-white);border-left:2px solid var(--dps-color-white);transform:translate(-50%,-50%) rotate(-50deg)}.dps-checkbox:focus+.dps-label:before{box-shadow:0 0 4px 1px #00000040;border-color:var(--dps-color-primary);outline:1px solid var(--dps-color-primary)}.dps-checkbox:checked+.dps-label:before{background-color:var(--dps-color-primary);border-color:var(--dps-color-primary)}.dps-checkbox:checked+.dps-label:after{content:""}.dps-checkbox:disabled+.dps-label{cursor:default;color:var(--dps-color-dark-gray)}.dps-checkbox:disabled+.dps-label:before{background-color:var(--dps-color-light-gray);border-color:var(--dps-color-light-gray)}.dps-checkbox[readonly]+.dps-label{cursor:default;color:var(--dps-color-black)}.dps-checkbox[readonly]+.dps-label:before{background-color:var(--dps-color-primary-light);border-color:var(--dps-color-primary-light)}.dps-checkbox[readonly]+.dps-label:after{border-color:var(--dps-color-dark-gray)}.dps-checkbox--error+.dps-label{color:var(--dps-color-error)}.dps-checkbox--error+.dps-label:before{background-color:var(--dps-color-white);border-color:var(--dps-color-error)}.dps-checkbox--error:checked+.dps-label:before{background-color:var(--dps-color-error);border-color:var(--dps-color-error)}.dps-checkbox--error:checked+.dps-label:after{display:none}.dps-checkbox--error:focus+.dps-label:before{box-shadow:0 0 4px 1px #dc354540;border-color:var(--dps-color-error);outline:1px solid var(--dps-color-error)}.dps-checkbox--size-sm{width:16px;height:16px}.dps-checkbox--size-sm+.dps-label{padding-left:27px;line-height:16px;font-size:14px}.dps-checkbox--size-sm+.dps-label:before{width:16px;height:16px}.dps-checkbox--size-sm+.dps-label:after{top:6.4px;left:8px;width:9px;height:5.5384615385px}.dps-heading{display:block;font-family:OpenSans,sans-serif,sans-serif;color:var(--dps-color-black)}.dps-heading--1{font-size:40px;font-weight:600;line-height:120%}.dps-heading--2{font-size:30px;font-weight:400;line-height:120%}.dps-heading--3{font-size:22px;font-weight:600;line-height:30px}.dps-heading--4{font-size:18px;font-weight:600;line-height:25px}.dps-heading--5{font-size:15px;font-weight:600;line-height:21px}.dps-heading--6{font-size:14px;font-weight:700;line-height:21px}@font-face{font-family:dpsIcons;font-style:normal;font-weight:400;src:url(data:font/ttf;base64,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) format("truetype")}[class^=dps-icon--],[class*=" dps-icon--"]{font-family:dpsIcons;speak:never;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.dps-icon--wechseln:before{content:""}.dps-icon--ladeanimation:before{content:""}.dps-icon--stuetzpunkte-anzeigen:before{content:""}.dps-icon--rueckgaengig:before{content:""}.dps-icon--durchschneiden:before{content:""}.dps-icon--flurstuecke-anzeigen:before{content:""}.dps-icon--kombinieren:before{content:""}.dps-icon--kreis-einzeichnen:before{content:""}.dps-icon--dok_validieren:before{content:""}.dps-icon--not-available:before{content:""}.dps-icon--search-filter:before{content:""}.dps-icon--cut-polygon:before{content:""}.dps-icon--api-sync:before{content:""}.dps-icon--polygon-menu:before{content:""}.dps-icon--merge-polygon:before{content:""}.dps-icon--dokumente:before{content:""}.dps-icon--veroeffentlichung-zueruckziehen:before{content:""}.dps-icon--plus-border:before{content:""}.dps-icon--polygon:before{content:""}.dps-icon--floppy-disk:before{content:""}.dps-icon--comment-add:before{content:""}.dps-icon--comment-edit:before{content:""}.dps-icon--bericht:before{content:""}.dps-icon--lock:before{content:""}.dps-icon--minus-small:before{content:""}.dps-icon--plus-small:before{content:""}.dps-icon--refresh:before{content:""}.dps-icon--meine-filter:before{content:""}.dps-icon--dok_ablehnen:before{content:""}.dps-icon--dok_annehmen:before{content:""}.dps-icon--telephone:before{content:""}.dps-icon--lock-error:before{content:""}.dps-icon--lock-open:before{content:""}.dps-icon--inhalt:before{content:""}.dps-icon--datei-aktualisieren:before{content:""}.dps-icon--datei-aktualisieren2:before{content:""}.dps-icon--profil:before{content:""}.dps-icon--group:before{content:""}.dps-icon--vector:before{content:""}.dps-icon--simple-language-outline:before{content:""}.dps-icon--sort-2:before{content:""}.dps-icon--minus:before{content:""}.dps-icon--institution-filled:before{content:""}.dps-icon--mark-filled:before{content:""}.dps-icon--layer-half:before{content:""}.dps-icon--layer:before{content:""}.dps-icon--layer-select:before{content:""}.dps-icon--vormerken-filled:before{content:""}.dps-icon--pin-information:before{content:""}.dps-icon--place-filled_24px:before{content:""}.dps-icon--point:before{content:""}.dps-icon--rmeasure-area:before{content:""}.dps-icon--rmeasure-radius:before{content:""}.dps-icon--trip-pin:before{content:""}.dps-icon--veroeffentlichen:before{content:""}.dps-icon--vormerkung_leserecht:before{content:""}.dps-icon--vormerkung_schreibrecht:before{content:""}.dps-icon--add-to-list:before{content:""}.dps-icon--auge-closed1:before{content:""}.dps-icon--auge-closed2:before{content:""}.dps-icon--calender-day:before{content:""}.dps-icon--calender-zeitraum:before{content:""}.dps-icon--cursor:before{content:""}.dps-icon--default_zoom:before{content:""}.dps-icon--halfscreen_24px:before{content:""}.dps-icon--institution:before{content:""}.dps-icon--legende:before{content:""}.dps-icon--list:before{content:""}.dps-icon--map:before{content:""}.dps-icon--map-lasso:before{content:""}.dps-icon--puzzle_24px:before{content:""}.dps-icon--ruler:before{content:""}.dps-icon--speakbubble_24px:before{content:""}.dps-icon--vormerken:before{content:""}.dps-icon--arrow-left:before{content:""}.dps-icon--calender-day-filled:before{content:""}.dps-icon--calender-filled:before{content:""}.dps-icon--calender-zeitraum-filled:before{content:""}.dps-icon--eraser:before{content:""}.dps-icon--freigeben:before{content:""}.dps-icon--freigegeben:before{content:""}.dps-icon--sign-language:before{content:""}.dps-icon--simple-language:before{content:""}.dps-icon--placeholder:before{content:""}.dps-icon--chevron-up:before{content:""}.dps-icon--chevron-down:before{content:""}.dps-icon--chevron-left:before{content:""}.dps-icon--chevron-right:before{content:""}.dps-icon--chevron-down-small:before{content:""}.dps-icon--chevron-up-small:before{content:""}.dps-icon--chevron-left-small:before{content:""}.dps-icon--chevron-right-small:before{content:""}.dps-icon--chevron-left-double-small:before{content:""}.dps-icon--chevron-right-double-small:before{content:""}.dps-icon--info-fill:before{content:""}.dps-icon--info:before{content:""}.dps-icon--help:before{content:""}.dps-icon--unsubscribe:before{content:""}.dps-icon--success:before{content:""}.dps-icon--warning:before{content:""}.dps-icon--check:before{content:""}.dps-icon--resize:before{content:""}.dps-icon--sort:before{content:""}.dps-icon--close:before{content:""}.dps-icon--plus:before{content:""}.dps-icon--copy:before{content:""}.dps-icon--external-link:before{content:""}.dps-icon--feedback-secure:before{content:""}.dps-icon--upload:before{content:""}.dps-icon--logout:before{content:""}.dps-icon--link:before{content:""}.dps-icon--create:before{content:""}.dps-icon--filter-list:before{content:""}.dps-icon--klammer:before{content:""}.dps-icon--delete:before{content:""}.dps-icon--calender:before{content:""}.dps-icon--gear-outline:before{content:""}.dps-icon--filter:before{content:""}.dps-icon--search:before{content:""}.dps-icon--menu:before{content:""}.dps-icon--place:before{content:""}.dps-icon--folder1:before{content:""}.dps-icon--release:before{content:""}.dps-icon--generate:before{content:""}.dps-icon--mark:before{content:""}.dps-icon--zeit:before{content:""}.dps-icon--folder:before{content:""}.dps-icon--fullscreen:before{content:""}.dps-icon--fullscreen-exit:before{content:""}.dps-icon--visibility-outline:before{content:""}.dps-icon--sheet:before{content:""}.dps-icon--mail:before{content:""}.dps-icon--leaf:before{content:""}.dps-icon--envelope-requirement:before{content:""}.dps-icon--him-workflow:before{content:""}.dps-icon--paragraph:before{content:""}.dps-icon--person-check:before{content:""}.dps-icon--bop:before{content:""}.dps-icon--information:before{content:""}.dps-icon--warning1:before{content:""}.dps-icon--error-outline:before{content:""}.dps-icon--more-horiz:before{content:""}.dps-icon--more-vert:before{content:""}.dps-icon--arrow-drop-left:before{content:""}.dps-icon--arrow-drop-right:before{content:""}.dps-icon--arrow-drop-up:before{content:""}.dps-icon--arrow-drop-down:before{content:""}.dps-icon--visibility:before{content:""}.dps-icon--check-circle-outline:before{content:""}.dps-icon--check-circle:before{content:""}.dps-icon--exclamation-mark:before{content:""}.dps-icon--close-circle:before{content:""}.dps-icon--arrow-drop-down-circle:before{content:""}.dps-icon--einstellungen:before{content:""}.dps-icon--import:before{content:""}.dps-icon--export:before{content:""}.dps-icon--download:before{content:""}.dps-icon--feedback-info:before{content:""}.dps-input{background-color:var(--dps-color-white);border-color:var(--dps-color-dark-gray);border-radius:2px;border-style:solid;border-width:1px;color:var(--dps-color-black);line-height:156%;padding:8px 16px;width:100%;height:48px;outline:none}.dps-input:focus{border-color:var(--dps-color-primary);outline:1px solid var(--dps-color-primary);box-shadow:0 0 4px 1px #00000040}.dps-input:disabled{border-color:var(--dps-color-background);background-color:var(--dps-color-background);color:var(--dps-color-dark-gray)}.dps-input[readonly]{border-color:var(--dps-color-background);background-color:var(--dps-color-light-blue)}.dps-input[readonly]:focus{border-color:var(--dps-color-primary);outline:1px solid var(--dps-color-primary)}.dps-input::placeholder{font-size:16px;color:var(--dps-color-dark-gray);opacity:1}.dps-input::-webkit-search-cancel-button{-webkit-appearance:none}.dps-input+.dps-icon{position:absolute;top:50%;right:12px;transform:translateY(-50%);font-size:24px}.dps-input--size-sm{height:40px;padding:4px 12px}.dps-input--icon{padding:4px 50px 4px 16px}.dps-input--icon.dps-input--size-sm{padding:4px 46px 4px 12px}.dps-input--success{border-color:var(--dps-color-success);color:var(--dps-color-black)}.dps-input--success+.dps-icon{color:var(--dps-color-success)}.dps-input--error{border-color:var(--dps-color-error);color:var(--dps-color-black)}.dps-input--error+.dps-icon{color:var(--dps-color-error)}.dps-input-wrapper{position:relative;height:fit-content}.dps-input-wrapper--disabled .dps-label{color:var(--dps-color-dark-gray)}label,.dps-label{color:var(--dps-color-black);display:block;font-size:15px;line-height:18.75px;margin-bottom:12px;font-weight:600}.dps-label--slim{font-weight:400}.dps-link{color:var(--dps-color-primary);font-size:16px;font-weight:500;line-height:110%;transition:none;letter-spacing:0;text-decoration:none;vertical-align:middle}.dps-link--darker{color:var(--dps-color-primary-darker)}.dps-link:hover,.dps-link:focus,.dps-link:active{color:var(--dps-color-primary-hover);text-decoration:underline}.dps-link.dps-link--icon{align-items:center;display:inline-flex;gap:2px}.dps-link.dps-link--icon:hover,.dps-link.dps-link--icon:focus,.dps-link.dps-link--icon:active{text-decoration:none}.dps-link.dps-link--icon:hover>span:not(.dps-icon),.dps-link.dps-link--icon:focus>span:not(.dps-icon),.dps-link.dps-link--icon:active>span:not(.dps-icon){text-decoration:underline}.dps-link .dps-icon{font-size:24px}.dps-list{list-style:none;padding:0;margin:0}.dps-list>li{padding:16px 0;position:relative}.dps-list--bordered{border-top:1px solid var(--dps-color-light-gray);border-bottom:1px solid var(--dps-color-light-gray)}.dps-list--bordered>li+li{border-top:1px solid var(--dps-color-light-gray)}.dps-radio{position:absolute;top:0;left:0;width:24px;height:24px;outline:none}.dps-radio+.dps-label{margin:0;padding-left:36px;position:relative;line-height:24px;font-weight:400;cursor:pointer}.dps-radio+.dps-label:before{display:inline-block;content:"";position:absolute;top:0;left:0;width:24px;height:24px;border-radius:100%;background-color:var(--dps-color-white);border-style:solid;border-width:1px}.dps-radio+.dps-label:after{content:none;position:absolute;top:12px;left:12px;transform:translate(-50%,-50%);width:12px;height:12px;background-color:var(--dps-color-primary);border-radius:100%}.dps-radio:focus+.dps-label:before{box-shadow:0 0 4px 1px #00000040;border-color:var(--dps-color-primary);outline:1px solid var(--dps-color-primary)}.dps-radio:checked+.dps-label:before{border-color:var(--dps-color-primary)}.dps-radio:checked+.dps-label:after{content:""}.dps-radio:disabled+.dps-label{cursor:default;color:var(--dps-color-dark-gray)}.dps-radio:disabled+.dps-label:before{background-color:var(--dps-color-light-gray);border-color:var(--dps-color-light-gray)}.dps-radio:disabled+.dps-label:after{background-color:var(--dps-color-white)}.dps-radio:disabled:checked:not([readonly])+.dps-label:before{background-color:var(--dps-color-white);border-color:var(--dps-color-light-gray)}.dps-radio:disabled:checked:not([readonly])+.dps-label:after{background-color:var(--dps-color-light-gray)}.dps-radio[readonly]+.dps-label{cursor:default;color:var(--dps-color-black)}.dps-radio[readonly]+.dps-label:before{background-color:var(--dps-color-white);border-color:var(--dps-color-primary-50)}.dps-radio[readonly]+.dps-label:after{background-color:var(--dps-color-primary-50)}.dps-radio--error+.dps-label{color:var(--dps-color-error)}.dps-radio--error+.dps-label:before{background-color:var(--dps-color-white);border-color:var(--dps-color-error)}.dps-radio--error:checked+.dps-label:before{background-color:var(--dps-color-white);border-color:var(--dps-color-error)}.dps-radio--error:checked+.dps-label:after{background-color:var(--dps-color-error)}.dps-radio--error:focus+.dps-label:before{box-shadow:0 0 4px 1px #dc354540;border-color:var(--dps-color-error);outline:1px solid var(--dps-color-error)}.dps-text,.dps-text>p,p,p>p,table,table>p{margin:20px 0 0;font-family:OpenSans,sans-serif,sans-serif;font-size:16px;letter-spacing:0;line-height:24.96px}.dps-heading+.dps-text,.dps-heading+.dps-text>p,.dps-heading+p,.dps-heading+p>p,.dps-heading+table,.dps-heading+table>p{margin-top:0}.dps-text b,.dps-text strong,.dps-text>p b,.dps-text>p strong,p b,p strong,p>p b,p>p strong,table b,table strong,table>p b,table>p strong{font-weight:700}.dps-text i,.dps-text em,.dps-text>p i,.dps-text>p em,p i,p em,p>p i,p>p em,table i,table em,table>p i,table>p em{font-style:italic}.dps-text table,.dps-text>p table,p table,p>p table,table table,table>p table{width:100%}.dps-text th,.dps-text td,.dps-text>p th,.dps-text>p td,p th,p td,p>p th,p>p td,table th,table td,table>p th,table>p td{font-size:14px;padding:5px 0}.dps-text:first-child,p:first-child,table:first-child{margin-top:0}.dps-text:last-child,p:last-child,table:last-child{margin-bottom:0}.dps-text--small,.dps-text--small>p{font-size:14px;line-height:19.6px}.dps-text--small .dps-link,.dps-text--small>p .dps-link{font-size:inherit;line-height:inherit}.dps-text--small p+p,.dps-text--small>p p+p{margin-top:20px;margin-bottom:20px}.dps-text--small p+p:last-child,.dps-text--small>p p+p:last-child{margin-bottom:0}.dps-text--bold,.dps-text--bold>p{font-weight:700}.dps-text--ellipse,.dps-text--ellipse>p{white-space:nowrap;text-overflow:ellipsis;overflow:hidden}.dps-textarea{background-color:var(--dps-color-white);border-color:var(--dps-color-dark-gray);border-radius:2px;border-style:solid;border-width:1px;color:var(--dps-color-black);font-size:16px;line-height:156%;padding:8px 16px;width:100%;outline:none;resize:none}.dps-textarea:focus{border-color:var(--dps-color-primary);outline:1px solid var(--dps-color-primary);box-shadow:0 0 4px 1px #00000040}.dps-textarea:disabled{border-color:var(--dps-color-background);background-color:var(--dps-color-background);color:var(--dps-color-dark-gray)}.dps-textarea[readonly]{border-color:var(--dps-color-background);background-color:var(--dps-color-light-blue)}.dps-textarea[readonly]:focus{border-color:var(--dps-color-primary);outline:1px solid var(--dps-color-primary)}.dps-textarea::placeholder{font-size:16px;color:var(--dps-color-dark-gray);opacity:1}.dps-textarea--success{border-color:var(--dps-color-success);color:var(--dps-color-black)}.dps-textarea--error{border-color:var(--dps-color-error);color:var(--dps-color-black)}.dps-action-menu{display:inline-flex;align-self:center;flex-shrink:0}.dps-action-menu__trigger-button{background:transparent;border:none;display:inline-flex;align-items:center;justify-content:center;min-width:24px;min-height:24px;padding:0}.dps-action-menu__trigger-button:focus-visible{outline:2px solid var(--dps-color-primary)}.dps-action-menu__trigger-button.show,.dps-action-menu__trigger-button.collapse{transition:none}.dps-action-menu__trigger-button--icon{font-size:24px;color:var(--dps-color-black);border-radius:100%}.dps-action-menu__trigger-button--icon:focus-visible,.dps-action-menu__trigger-button--icon:hover{color:var(--dps-color-primary)}.dps-action-menu__trigger-button--icon.show,.dps-action-menu__trigger-button--icon.collapse{color:var(--dps-color-white);background-color:var(--dps-color-primary)}.dps-action-menu__trigger-button--text{color:var(--dps-color-primary);font-size:15px;font-weight:400;line-height:156%;border-radius:2px;gap:4px}.dps-action-menu__trigger-button--text:focus-visible .dps-action-menu__trigger-button-label,.dps-action-menu__trigger-button--text:hover .dps-action-menu__trigger-button-label{text-decoration:underline}.dps-action-menu__trigger-button--text .dps-icon{font-size:16px}.dps-action-menu__trigger-button--text.show .dps-icon,.dps-action-menu__trigger-button--text.collapse .dps-icon{transform:rotate(180deg)}.dps-action-menu__trigger-button--disabled,.dps-action-menu__trigger-button--disabled .dps-action-menu__trigger-button-label{color:var(--dps-color-dark-gray)!important;text-decoration:none!important}.dps-action-menu__dropdown.dropdown-menu{border:none;border-radius:0;box-shadow:0 0 8px #00000014;padding:12px 16px 12px 12px}.dps-action-menu__dropdown.show,.dps-action-menu__dropdown.collapse{display:flex;flex-direction:column}.dps-action-menu__dropdown--with-header.dropdown-menu{padding-bottom:24px}.dps-action-menu__dropdown-header{display:flex;align-items:center;justify-content:flex-start;margin-bottom:16px;min-height:24px;gap:16px}.dps-action-menu__dropdown-close-button{margin-left:auto;flex-shrink:0}.dps-action-menu__dropdown-headline{flex-grow:1;font-weight:500;font-size:15px;line-height:130%;color:var(--dps-color-black)}.dps-action-menu__dropdown-list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:16px}.dps-action-menu__dropdown-list .dps-form-checkbox-group .dps-input-wrapper,.dps-action-menu__dropdown-list .dps-form-radio-group .dps-input-wrapper{gap:12px}.dps-action-menu-item{display:flex}.dps-action-menu-item__element{display:inline-flex;align-items:center;background:transparent;border:none;color:var(--dps-color-black);font-size:15px;line-height:150%;font-weight:400;white-space:nowrap;text-decoration:none;gap:10px;padding:0;cursor:pointer}.dps-action-menu-item__element:hover,.dps-action-menu-item__element:focus{color:var(--dps-color-primary);text-decoration:none}.dps-action-menu-item__element .dps-icon{font-size:24px}.dps-action-menu-item__element--danger:hover,.dps-action-menu-item__element--danger:focus{color:var(--dps-color-error)}.dps-action-menu-item__element--disabled{cursor:default!important;color:var(--dps-color-medium-gray)!important}.dps-form-input__search-cancel-button{background:none;border:none;padding:0}.dps-form-input__search-cancel-button:focus-visible{outline:2px solid var(--dps-color-primary);box-shadow:0 0 4px 1px #00000040;border-radius:100%}.dps-alert{border-left:4px solid;padding:16px;display:flex;gap:16px;font-size:14px;font-weight:400;color:var(--dps-color-black);border-color:var(--dps-color-medium-gray);background:#f1f3f6}.dps-alert__icon-wrapper{display:flex;align-self:start;font-size:24px;flex-shrink:0;color:var(--dps-color-dark-gray)}.dps-alert__content-wrapper{align-self:center;line-height:140%;flex-grow:1;display:flex;flex-direction:column;gap:8px}.dps-alert__content-wrapper p{margin:0;font-size:inherit;line-height:inherit;color:inherit}.dps-alert__content-header{font-size:15px;font-weight:600}.dps-alert--info{border-color:var(--dps-color-primary);background:var(--dps-color-light-blue)}.dps-alert--info .dps-alert__icon-wrapper{color:var(--dps-color-primary-darker)}.dps-alert--warning{border-color:var(--dps-color-warning);background:#fdfae0}.dps-alert--warning .dps-alert__icon-wrapper{color:var(--dps-color-black)}.dps-alert--success{border-color:var(--dps-color-success);background:#ebf8f0}.dps-alert--success .dps-alert__icon-wrapper{color:var(--dps-color-success)}.dps-alert--error{border-color:var(--dps-color-error);background:#ffefef}.dps-alert--error .dps-alert__icon-wrapper{color:var(--dps-color-error)}.dps-button--loading{cursor:default}.dps-button--loading .dps-icon:before{display:block;animation:.75s linear infinite dps-rotate}.dps-loading-spinner .dps-icon{display:inline-block;color:var(--dps-color-primary);font-size:24px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.nav-link:is(a),.nav-link a{color:var(--diplan-nav-link-color);text-decoration:none}.nav-link:is(a).active,.nav-link:is(a):active,.nav-link:is(a):hover,.nav-link.active a,.nav-link:active a,.nav-link:hover a{color:var(--diplan-link-hover-color);text-decoration:none}.dropdown-item>.dps-button--link{width:100%;justify-content:start}.dropdown-item>.dps-button--link:hover{border-color:transparent!important;box-shadow:unset!important}.dps-button--primary:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-primary);border-color:var(--diplan-primary)}.dps-button--primary:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#2763b9;border-color:#2763b9}.dps-button--secondary:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-secondary);border-color:var(--diplan-secondary)}.dps-button--secondary:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#adadad;border-color:#adadad}.dps-button--success:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-success);border-color:var(--diplan-success)}.dps-button--success:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#008d3b;border-color:#008d3b}.dps-button--info:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-info);border-color:var(--diplan-info)}.dps-button--info:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#a2c9ff;border-color:#a2c9ff}.dps-button--warning:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-warning);border-color:var(--diplan-warning)}.dps-button--warning:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#c9a900;border-color:#c9a900}.dps-button--danger:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-danger);border-color:var(--diplan-danger)}.dps-button--danger:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#c62232;border-color:#c62232}.dps-button--light:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-light);border-color:var(--diplan-light)}.dps-button--light:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#a2c9ff;border-color:#a2c9ff}.dps-button--dark:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary){background-color:var(--diplan-dark);border-color:var(--diplan-dark)}.dps-button--dark:not(.dps-button--primary):not(.dps-button--secondary):not(.dps-button--tertiary):hover{background-color:#25306d;border-color:#25306d}.icon.is-large>.dps-icon,.dps-icon.is-large{font-size:1.5rem}.icon.is-medium>.dps-icon,.dps-icon.is-medium{font-size:1.2rem}.icon.is-small>.dps-icon,.dps-icon.is-small{font-size:.75rem}label.formkit-icon{margin-bottom:0}.dps-select{display:inline-flex;color:#3375d4}.dps-select option,.dps-select select,.dps-select select[data-placeholder]{color:#ccc}.dps-select select.outlined{border-color:#3375d480;color:#3375d4}.dps-select select.outlined option{color:#3375d4}.dps-select .form-select[class*=form-select-]{border-radius:2px}.dps-select:not(:last-child):not(.is-fullwidth){margin-right:.5rem}.formkit-outer[data-type=tag] .dps-icon.dps-icon--chevron-down{transition:transform .2s}.formkit-outer[data-type=tag] .dropdown:focus .dps-icon.dps-icon--chevron-down,.formkit-outer[data-type=tag] .dropdown:focus-within .dps-icon.dps-icon--chevron-down{transform:rotate(180deg)}.dropdown{display:block}.dropdown-menu{background-clip:unset}.dps-icon--lock:before{content:url('data:image/svg+xml,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.97009 6.5704C7.97009 4.32238 9.7964 2.5 12.0493 2.5C14.3021 2.5 16.1284 4.32238 16.1284 6.5704V8.83808H17.2012C17.9729 8.83808 18.5985 9.46236 18.5985 10.2324V19.1056C18.5985 19.8757 17.9729 20.5 17.2012 20.5H6.89737C6.12562 20.5 5.5 19.8757 5.5 19.1056V10.2324C5.5 9.46236 6.12562 8.83808 6.89737 8.83808H7.97009V6.5704ZM9.07104 8.83808H15.0275V6.5704C15.0275 4.92911 13.6941 3.59859 12.0493 3.59859C10.4044 3.59859 9.07104 4.92912 9.07104 6.5704V8.83808ZM6.89737 9.93667C6.73366 9.93667 6.60095 10.0691 6.60095 10.2324V19.1056C6.60095 19.269 6.73366 19.4014 6.89737 19.4014H17.2012C17.3649 19.4014 17.4976 19.269 17.4976 19.1056V10.2324C17.4976 10.0691 17.3649 9.93667 17.2012 9.93667H6.89737Z" fill="black"/></svg>')}.dps-icon--lock-open:before{content:url('data:image/svg+xml,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.9496 8.33984H14.7C15.47 8.33984 16.1 8.95984 16.1 9.72984V18.5998C16.1 19.3698 15.47 19.9898 14.7 19.9898H4.4C3.63 19.9898 3 19.3698 3 18.5998V9.72984C3 8.95984 3.63 8.33984 4.4 8.33984H12.8496V6.07C12.8496 3.82 14.6796 2 16.9296 2C19.1796 2 21.0096 3.82 21.0096 6.07V8.34H19.9096V6.07C19.9096 4.43 18.5796 3.1 16.9296 3.1C15.2796 3.1 13.9496 4.43 13.9496 6.07V8.33984ZM4.1 9.73984C4.1 9.56984 4.24 9.43984 4.4 9.43984V9.42984H14.7C14.87 9.42984 15 9.56984 15 9.72984V18.6098C15 18.7798 14.86 18.9098 14.7 18.9098H4.4C4.23 18.9098 4.1 18.7698 4.1 18.6098V9.73984Z" fill="black"/></svg>')}.dps-icon--lasso:before{content:url('data:image/svg+xml,<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.58906 7.76458C2.58906 6.52903 3.46248 5.2866 5.14355 4.31675C6.80738 3.35685 9.14908 2.74238 11.7709 2.74238C14.3927 2.74238 16.7344 3.35685 18.3982 4.31675C20.0793 5.2866 20.9527 6.52903 20.9527 7.76458C20.9527 8.8811 20.2432 9.99988 18.8588 10.9263C17.5918 11.7742 15.8283 12.4064 13.7897 12.6622C13.4781 11.8506 12.6913 11.2744 11.77 11.2744C10.8488 11.2744 10.0621 11.8505 9.75044 12.662C7.67963 12.4019 5.89417 11.7537 4.62416 10.8866C3.2779 9.96737 2.58906 8.86515 2.58906 7.76458ZM6.82975 13.3534C5.71856 12.9996 4.72241 12.5278 3.89111 11.9602C2.34425 10.904 1.28906 9.45263 1.28906 7.76458C1.28906 5.86747 2.61657 4.2738 4.49391 3.19071C6.3885 2.09768 8.9627 1.44238 11.7709 1.44238C14.579 1.44238 17.1532 2.09768 19.0478 3.19071C20.9252 4.2738 22.2527 5.86747 22.2527 7.76458C22.2527 9.47743 21.1668 10.9461 19.5818 12.0067C18.0971 13.0002 16.1014 13.6933 13.8683 13.9623C13.6337 14.9028 12.7832 15.5996 11.77 15.5996C10.8022 15.5996 9.98283 14.9638 9.70684 14.0871H8.59737C7.63599 14.0871 6.85664 14.8665 6.85664 15.8278C6.85664 16.7892 7.63599 17.5686 8.59737 17.5686H13.5259C15.421 17.5686 16.9573 19.1049 16.9573 21C16.9573 21.359 16.6663 21.65 16.3073 21.65C15.9483 21.65 15.6573 21.359 15.6573 21C15.6573 19.8229 14.703 18.8686 13.5259 18.8686H8.59737C6.91802 18.8686 5.55664 17.5072 5.55664 15.8278C5.55664 14.8077 6.05897 13.905 6.82975 13.3534ZM11.77 12.5744C11.2936 12.5744 10.9074 12.9606 10.9074 13.437C10.9074 13.9134 11.2936 14.2996 11.77 14.2996C12.2464 14.2996 12.6326 13.9134 12.6326 13.437C12.6326 12.9606 12.2464 12.5744 11.77 12.5744Z" fill="black"/></svg>')}.dps-icon--layer-half:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M21.1511 9.61247C21.1511 9.85426 21.0169 10.0761 20.8027 10.1883L16.6396 12.369L20.789 14.5425C21.0032 14.6547 21.1374 14.8765 21.1374 15.1183C21.1374 15.3601 21.0032 15.5819 20.789 15.6941L12.0725 20.2601C11.8836 20.359 11.6581 20.359 11.4692 20.2601L2.75269 15.6941C2.53851 15.5819 2.4043 15.3601 2.4043 15.1183C2.4043 14.8765 2.53851 14.6547 2.75269 14.5425L6.91575 12.3618L2.76636 10.1883C2.55218 10.0761 2.41797 9.85426 2.41797 9.61247C2.41797 9.37068 2.55218 9.14888 2.76636 9.03668L11.4829 4.4707C11.6718 4.37175 11.8972 4.37175 12.0861 4.4707L20.8027 9.03668C21.0169 9.14888 21.1511 9.37068 21.1511 9.61247ZM8.21543 13.0426L8.25898 13.1257L4.45511 15.1183L11.7709 18.9505L19.0866 15.1183L15.2827 13.1257L15.3159 13.0624L12.0861 14.7542C11.8972 14.8532 11.6718 14.8532 11.4829 14.7542L8.21543 13.0426Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--flurstuecke-anzeigen:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M18.7 5.3H14.6004V13.9004H18.7V5.3ZM18.7 15.1004H8.9V10.1004H5.3V18.7H18.7V15.1004ZM5.3 8.90039H10.1V13.9004H13.4004V5.3H5.3V8.90039ZM20 4H14.6004H13.4004H4V20H20V4Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--stuetzpunkte-anzeigen:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M2.65039 4.59961C2.65039 5.47649 3.21471 6.22157 4 6.49148V17.4079C3.21471 17.6778 2.65039 18.4229 2.65039 19.2998C2.65039 20.4044 3.54582 21.2998 4.65039 21.2998C5.50862 21.2998 6.2406 20.7592 6.5244 20H17.4756C17.7594 20.7592 18.4914 21.2998 19.3496 21.2998C20.4542 21.2998 21.3496 20.4044 21.3496 19.2998C21.3496 18.4229 20.7853 17.6778 20 17.4079V6.49148C20.7853 6.22157 21.3496 5.47649 21.3496 4.59961C21.3496 3.49504 20.4542 2.59961 19.3496 2.59961C18.4539 2.59961 17.6958 3.18838 17.441 4H6.55895C6.30422 3.18838 5.54606 2.59961 4.65039 2.59961C3.54582 2.59961 2.65039 3.49504 2.65039 4.59961ZM18.7 17.4077V6.49175C18.135 6.29782 17.6843 5.85797 17.4757 5.3H6.52432C6.31569 5.85797 5.86498 6.29782 5.3 6.49175V17.4077C5.89852 17.6131 6.36879 18.0945 6.55889 18.7H17.4411C17.6312 18.0945 18.1015 17.6131 18.7 17.4077Z' fill='%2304071A'/%3E %3C/svg%3E")}.dps-icon--group:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M16.3326 1.3C15.4996 1.3 14.8244 1.97522 14.8244 2.80816C14.8244 3.64109 15.4996 4.31631 16.3326 4.31631C17.1655 4.31631 17.8407 3.64109 17.8407 2.80816C17.8407 1.97522 17.1655 1.3 16.3326 1.3ZM13.5244 2.80816C13.5244 1.25725 14.7817 0 16.3326 0C17.8835 0 19.1407 1.25725 19.1407 2.80816C19.1407 4.01933 18.374 5.05141 17.2994 5.44546L18.7603 17.1331C20.1853 17.2683 21.3 18.4683 21.3 19.9286C21.3 21.4795 20.0427 22.7368 18.4918 22.7368C17.0494 22.7368 15.8609 21.6492 15.7018 20.2492L5.24511 17.8727C4.76068 18.7164 3.85077 19.2846 2.80816 19.2846C1.25725 19.2846 0 18.0273 0 16.4764C0 15.0553 1.05563 13.8807 2.42553 13.6941L3.13148 8.75247C2.05974 8.35694 1.29556 7.3263 1.29556 6.11717C1.29556 4.56627 2.55282 3.30902 4.10372 3.30902C5.29599 3.30902 6.31473 4.05205 6.72211 5.10032L13.5389 3.09537C13.5293 3.00094 13.5244 2.90512 13.5244 2.80816ZM13.9684 4.32413L6.89742 6.40382C6.76448 7.71508 5.72939 8.75975 4.42254 8.90743L3.72076 13.8199C4.82367 14.1987 5.61631 15.245 5.61631 16.4764C5.61631 16.5256 5.61505 16.5745 5.61255 16.6231L15.8583 18.9517C16.1369 18.2009 16.7274 17.6016 17.4725 17.3112L16.0083 5.59779C15.1518 5.49931 14.4126 5.0155 13.9684 4.32413ZM4.10372 4.60902C3.27079 4.60902 2.59556 5.28424 2.59556 6.11717C2.59556 6.95011 3.27079 7.62533 4.10372 7.62533C4.93665 7.62533 5.61187 6.95011 5.61187 6.11717C5.61187 5.28424 4.93665 4.60902 4.10372 4.60902ZM2.80816 14.9683C1.97522 14.9683 1.3 15.6435 1.3 16.4764C1.3 17.3093 1.97522 17.9846 2.80816 17.9846C3.64109 17.9846 4.31631 17.3093 4.31631 16.4764C4.31631 15.6435 3.64109 14.9683 2.80816 14.9683ZM18.4918 18.4205C17.6589 18.4205 16.9837 19.0957 16.9837 19.9286C16.9837 20.7615 17.6589 21.4368 18.4918 21.4368C19.3248 21.4368 20 20.7615 20 19.9286C20 19.0957 19.3248 18.4205 18.4918 18.4205Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--kombinieren:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M4.34961 4.34961H14.6496V9.34961H19.6496V19.6496H9.34961V14.6496H4.34961V4.34961ZM5.64961 5.64961V13.3496H10.6496V18.3496H18.3496V10.6496H13.3496V5.64961H5.64961Z' fill='%2304071A'/%3E %3C/svg%3E")}.dps-icon--kreis-einzeichnen:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M12 18.7C15.7003 18.7 18.7 15.7003 18.7 12C18.7 8.29969 15.7003 5.3 12 5.3C8.29969 5.3 5.3 8.29969 5.3 12C5.3 15.7003 8.29969 18.7 12 18.7ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20Z' fill='%2304071A'/%3E %3C/svg%3E")}.dps-icon--durchschneiden:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M6.3 6.3H17.7V11.3496H16.4925V12.6496H17.7V17.7H6.3V12.6496H7.5075V11.3496H6.3V6.3ZM5 19V5H19V19H5ZM3.7675 11.3496H2V12.6496H3.7675V11.3496ZM11.2475 11.3496H9.0125V12.6496H11.2475V11.3496ZM14.9875 11.3496H12.7525V12.6496H14.9875V11.3496ZM22 11.3496H20.2325V12.6496H22V11.3496Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--create:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath d='M20.2996 6.27961C20.2096 6.03961 20.0696 5.82961 19.8896 5.64961L18.4296 4.16961C18.2596 3.98961 18.0496 3.83961 17.8196 3.74961C17.5796 3.64961 17.3196 3.59961 17.0596 3.59961C17.0596 3.59961 17.0496 3.59961 17.0396 3.59961C16.7796 3.59961 16.5296 3.64961 16.2996 3.74961C16.0596 3.84961 15.8496 3.98961 15.6696 4.16961L4.86961 14.9696C4.81961 14.9996 4.76961 15.0496 4.74961 15.1096C4.72961 15.1496 4.70961 15.1996 4.68961 15.2496L3.59961 19.7996V19.9096C3.59961 19.9796 3.60961 20.0496 3.63961 20.1196C3.65961 20.1796 3.69961 20.2396 3.74961 20.2896C3.79961 20.3396 3.85961 20.3796 3.92961 20.4096C3.99961 20.4396 4.07961 20.4596 4.15961 20.4596H4.20961C4.32961 20.4596 4.38961 20.4396 4.40961 20.4396L8.75961 19.3896C8.82961 19.3896 8.88961 19.3696 8.93961 19.3396C8.97961 19.3096 9.01961 19.2796 9.05961 19.2496L19.8896 8.40961C20.0696 8.23961 20.2196 8.02961 20.3096 7.79961C20.4096 7.54961 20.4496 7.28961 20.4496 7.02961C20.4496 6.76961 20.3996 6.51961 20.3096 6.27961H20.2996ZM7.80961 18.4696L4.88961 19.1596L5.56961 16.2296L7.80961 18.4696ZM17.2296 9.52961L8.80961 17.8696L6.17961 15.2296L14.5896 6.83961L17.2196 9.52961H17.2296ZM19.3396 7.01961C19.3396 7.12961 19.3196 7.23961 19.2796 7.33961C19.2396 7.43961 19.1796 7.52961 19.0996 7.60961L18.0196 8.68961L15.3796 6.03961L16.4596 4.95961C16.5296 4.88961 16.6196 4.81961 16.7096 4.77961C16.7996 4.73961 16.9096 4.71961 17.0096 4.71961C17.1296 4.71961 17.2496 4.73961 17.3496 4.78961C17.4496 4.83961 17.5396 4.89961 17.6196 4.96961L19.0896 6.45961C19.1696 6.52961 19.2296 6.61961 19.2696 6.70961C19.3096 6.80961 19.3296 6.91961 19.3296 7.02961L19.3396 7.01961Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--rueckgaengig:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M8.42514 4.4247L7.57661 3.57617L4.15234 7.00044L7.57661 10.4247L8.42514 9.57617L6.44935 7.60039H13.5C16.2062 7.60039 18.4 9.7942 18.4 12.5004C18.4 15.2066 16.2062 17.4004 13.5 17.4004H5V18.6004H13.5C16.8689 18.6004 19.6 15.8693 19.6 12.5004C19.6 9.13145 16.8689 6.40039 13.5 6.40039H6.44945L8.42514 4.4247Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--delete:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M19.66 5.22C19.84 5.22 20.01 5.29 20.13 5.41C20.25 5.53 20.32 5.7 20.32 5.87C20.32 6.04 20.25 6.21 20.13 6.33C20.01 6.45 19.84 6.52 19.67 6.52H18.62V20.65C18.62 20.82 18.55 20.99 18.43 21.11C18.31 21.23 18.15 21.3 17.98 21.3H6.34C6.17 21.3 6.01 21.23 5.89 21.11C5.77 20.99 5.7 20.82 5.7 20.65V6.52H4.65C4.48 6.52 4.31 6.45 4.19 6.33C4.07 6.21 4 6.04 4 5.87C4 5.7 4.07 5.53 4.19 5.41C4.31 5.29 4.48 5.22 4.65 5.22H8.6V3.65C8.6 3.47 8.67 3.31 8.79 3.19C8.91 3.07 9.07 3 9.24 3H15.06C15.23 3 15.39 3.07 15.51 3.19C15.63 3.32 15.7 3.48 15.7 3.65V5.22H19.66ZM14.42 5.22V4.3H9.89V5.22H14.42ZM17.33 20V6.52H6.98V20H17.33ZM9.70961 17.78C9.58961 17.9 9.41961 17.97 9.24961 17.97V17.98C9.07961 17.98 8.90961 17.91 8.78961 17.79C8.66961 17.67 8.59961 17.5 8.59961 17.33V8.46C8.59961 8.29 8.66961 8.12 8.78961 8C9.03961 7.75 9.45961 7.75 9.70961 8C9.82961 8.12 9.89961 8.29 9.89961 8.46V17.32C9.89961 17.49 9.82961 17.66 9.70961 17.78ZM15.5202 17.7801C15.4002 17.9001 15.2302 17.9701 15.0602 17.9701V17.9801C14.8902 17.9801 14.7202 17.9101 14.6002 17.7901C14.4802 17.6701 14.4102 17.5001 14.4102 17.3301V8.46007C14.4102 8.29007 14.4802 8.12007 14.6002 8.00007C14.8402 7.76007 15.2802 7.76007 15.5202 8.00007C15.6402 8.12007 15.7102 8.29007 15.7102 8.46007V17.3201C15.7102 17.4901 15.6402 17.6601 15.5202 17.7801ZM12.1598 17.97C12.3298 17.97 12.4998 17.9 12.6198 17.78C12.7398 17.66 12.8098 17.49 12.8098 17.32V8.46C12.8098 8.29 12.7398 8.12 12.6198 8C12.3698 7.75 11.9498 7.75 11.6998 8C11.5798 8.12 11.5098 8.29 11.5098 8.46V17.33C11.5098 17.5 11.5798 17.67 11.6998 17.79C11.8198 17.91 11.9898 17.98 12.1598 17.98V17.97Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--fullscreen:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M4 9.65H5.3V5.3H9.65V4H4V9.65ZM5.3 13.65H4V19.3H9.65V18H5.3V13.65ZM19.3004 19.3V13.65H18.0004V18H13.6504V19.3H19.3004ZM19.3004 4V9.65H18.0004V5.3H13.6504V4H19.3004Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--search:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M10.4 4.5C7.14421 4.5 4.5 7.14421 4.5 10.4C4.5 13.6558 7.14421 16.3 10.4 16.3C11.9865 16.3 13.4279 15.6721 14.4887 14.6515C14.5101 14.623 14.5337 14.5956 14.5597 14.5697C14.586 14.5433 14.6138 14.5194 14.6428 14.4978C15.6685 13.436 16.3 11.991 16.3 10.4C16.3 7.14421 13.6558 4.5 10.4 4.5ZM16.1307 15.08C17.1739 13.8045 17.8 12.1748 17.8 10.4C17.8 6.31579 14.4842 3 10.4 3C6.31579 3 3 6.31579 3 10.4C3 14.4842 6.31579 17.8 10.4 17.8C12.1697 17.8 13.7951 17.1775 15.069 16.1397L19.8997 20.9703C20.1926 21.2632 20.6674 21.2632 20.9603 20.9703C21.2532 20.6774 21.2532 20.2026 20.9603 19.9097L16.1307 15.08Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--close:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M5.53033 17.409C5.23744 17.7019 5.23744 18.1768 5.53033 18.4697C5.82322 18.7626 6.2981 18.7626 6.59099 18.4697L12.0303 13.0304L17.4696 18.4697C17.7625 18.7626 18.2373 18.7626 18.5302 18.4697C18.8231 18.1768 18.8231 17.7019 18.5302 17.409L13.0909 11.9697L18.5303 6.53033C18.8232 6.23744 18.8232 5.76256 18.5303 5.46967C18.2374 5.17678 17.7626 5.17678 17.4697 5.46967L12.0303 10.9091L6.59088 5.46967C6.29798 5.17678 5.82311 5.17678 5.53022 5.46967C5.23732 5.76256 5.23732 6.23744 5.53022 6.53033L10.9696 11.9697L5.53033 17.409Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--info:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M12 2.5C6.75329 2.5 2.5 6.75329 2.5 12C2.5 17.2467 6.75329 21.5 12 21.5C17.2467 21.5 21.5 17.2467 21.5 12C21.5 6.75329 17.2467 2.5 12 2.5ZM1.5 12C1.5 6.20101 6.20101 1.5 12 1.5C17.799 1.5 22.5 6.20101 22.5 12C22.5 17.799 17.799 22.5 12 22.5C6.20101 22.5 1.5 17.799 1.5 12Z' fill='black'/%3E %3Cpath d='M12.0791 8.09717C11.7692 8.09717 11.5119 8.00586 11.3071 7.82324C11.1024 7.64062 11 7.40267 11 7.10938C11 6.81055 11.1024 6.56982 11.3071 6.38721C11.5119 6.20459 11.7692 6.11328 12.0791 6.11328C12.3779 6.11328 12.6297 6.20459 12.8345 6.38721C13.0448 6.56982 13.1499 6.81055 13.1499 7.10938C13.1499 7.40267 13.0448 7.64062 12.8345 7.82324C12.6297 8.00586 12.3779 8.09717 12.0791 8.09717ZM11.2407 18V9.69922H12.8843V18H11.2407Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--minus:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M5.25 12C5.25 11.5858 5.58579 11.25 6 11.25H18C18.4142 11.25 18.75 11.5858 18.75 12C18.75 12.4142 18.4142 12.75 18 12.75H6C5.58579 12.75 5.25 12.4142 5.25 12Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--plus:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M12.75 6C12.75 5.58579 12.4142 5.25 12 5.25C11.5858 5.25 11.25 5.58579 11.25 6V11.25H6C5.58579 11.25 5.25 11.5858 5.25 12C5.25 12.4142 5.58579 12.75 6 12.75H11.25V18C11.25 18.4142 11.5858 18.75 12 18.75C12.4142 18.75 12.75 18.4142 12.75 18V12.75H18C18.4142 12.75 18.75 12.4142 18.75 12C18.75 11.5858 18.4142 11.25 18 11.25H12.75V6Z' fill='black'/%3E %3C/svg%3E")}.dps-icon--close-circle:before{content:url("data:image/svg+xml;charset=utf-8,%3Csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M12.0005 3.12129C7.06049 3.12129 3.05586 7.12592 3.05586 12.0659C3.05586 17.0058 7.06049 21.0105 12.0005 21.0105C16.9404 21.0105 20.9451 17.0058 20.9451 12.0659C20.9451 7.12592 16.9404 3.12129 12.0005 3.12129ZM1.75586 12.0659C1.75586 6.40795 6.34252 1.82129 12.0005 1.82129C17.6584 1.82129 22.2451 6.40795 22.2451 12.0659C22.2451 17.7238 17.6584 22.3105 12.0005 22.3105C6.34252 22.3105 1.75586 17.7238 1.75586 12.0659Z' fill='black'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M17.0858 7.45503C17.3592 7.72839 17.3592 8.17161 17.0858 8.44497L13.2564 12.2744L17.0858 16.1038C17.3592 16.3772 17.3592 16.8204 17.0858 17.0937C16.8124 17.3671 16.3692 17.3671 16.0959 17.0937L12.2665 13.2643L8.43716 17.0936C8.1638 17.367 7.72058 17.367 7.44721 17.0936C7.17385 16.8203 7.17385 16.377 7.44721 16.1037L11.2765 12.2744L7.44721 8.44509C7.17385 8.17172 7.17385 7.72851 7.44721 7.45514C7.72058 7.18177 8.1638 7.18177 8.43716 7.45514L12.2665 11.2844L16.0959 7.45503C16.3692 7.18166 16.8124 7.18166 17.0858 7.45503Z' fill='black'/%3E %3C/svg%3E")}@media screen{.formkit-input:disabled,textarea.form-control:disabled,input.form-control:disabled,input.form-check-input:disabled,select.form-control:disabled{background-color:#c8cacc;border:0;border-color:#c8cacc;opacity:1}.formkit-input[readonly],.formkit-input[data-readonly=true],.formkit-input[readonly]+.icon,textarea.form-control[readonly],textarea.form-control[data-readonly=true],textarea.form-control[readonly]+.icon,input.form-control[readonly],input.form-control[data-readonly=true],input.form-control[readonly]+.icon,input.form-check-input[readonly],input.form-check-input[data-readonly=true],input.form-check-input[readonly]+.icon,select.form-control[readonly],select.form-control[data-readonly=true],select.form-control[readonly]+.icon{background-color:var(--diplan-light)!important;border:1px solid var(--diplan-light)}}.formkit-inner.border:focus-within,.select.variant-primary input.formkit-inner:focus-within,.select.variant-primary textarea.formkit-inner:focus-within,.select.variant-primary select.formkit-inner:focus-within,.input.variant-primary input.formkit-inner:focus-within,.input.variant-primary textarea.formkit-inner:focus-within,.input.variant-primary select.formkit-inner:focus-within,.select.variant-secondary input.formkit-inner:focus-within,.select.variant-secondary textarea.formkit-inner:focus-within,.select.variant-secondary select.formkit-inner:focus-within,.input.variant-secondary input.formkit-inner:focus-within,.input.variant-secondary textarea.formkit-inner:focus-within,.input.variant-secondary select.formkit-inner:focus-within,.select.variant-success input.formkit-inner:focus-within,.select.variant-success textarea.formkit-inner:focus-within,.select.variant-success select.formkit-inner:focus-within,.input.variant-success input.formkit-inner:focus-within,.input.variant-success textarea.formkit-inner:focus-within,.input.variant-success select.formkit-inner:focus-within,.select.variant-info input.formkit-inner:focus-within,.select.variant-info textarea.formkit-inner:focus-within,.select.variant-info select.formkit-inner:focus-within,.input.variant-info input.formkit-inner:focus-within,.input.variant-info textarea.formkit-inner:focus-within,.input.variant-info select.formkit-inner:focus-within,.select.variant-warning input.formkit-inner:focus-within,.select.variant-warning textarea.formkit-inner:focus-within,.select.variant-warning select.formkit-inner:focus-within,.input.variant-warning input.formkit-inner:focus-within,.input.variant-warning textarea.formkit-inner:focus-within,.input.variant-warning select.formkit-inner:focus-within,.select.variant-danger input.formkit-inner:focus-within,.select.variant-danger textarea.formkit-inner:focus-within,.select.variant-danger select.formkit-inner:focus-within,.input.variant-danger input.formkit-inner:focus-within,.input.variant-danger textarea.formkit-inner:focus-within,.input.variant-danger select.formkit-inner:focus-within,.select.variant-light input.formkit-inner:focus-within,.select.variant-light textarea.formkit-inner:focus-within,.select.variant-light select.formkit-inner:focus-within,.input.variant-light input.formkit-inner:focus-within,.input.variant-light textarea.formkit-inner:focus-within,.input.variant-light select.formkit-inner:focus-within,.select.variant-dark input.formkit-inner:focus-within,.select.variant-dark textarea.formkit-inner:focus-within,.select.variant-dark select.formkit-inner:focus-within,.input.variant-dark input.formkit-inner:focus-within,.input.variant-dark textarea.formkit-inner:focus-within,.input.variant-dark select.formkit-inner:focus-within{box-shadow:0 0 0 .25rem #3375d440}.formkit-inner.border .form-control:focus,.select.variant-primary input.formkit-inner .form-control:focus,.select.variant-primary textarea.formkit-inner .form-control:focus,.select.variant-primary select.formkit-inner .form-control:focus,.input.variant-primary input.formkit-inner .form-control:focus,.input.variant-primary textarea.formkit-inner .form-control:focus,.input.variant-primary select.formkit-inner .form-control:focus,.select.variant-secondary input.formkit-inner .form-control:focus,.select.variant-secondary textarea.formkit-inner .form-control:focus,.select.variant-secondary select.formkit-inner .form-control:focus,.input.variant-secondary input.formkit-inner .form-control:focus,.input.variant-secondary textarea.formkit-inner .form-control:focus,.input.variant-secondary select.formkit-inner .form-control:focus,.select.variant-success input.formkit-inner .form-control:focus,.select.variant-success textarea.formkit-inner .form-control:focus,.select.variant-success select.formkit-inner .form-control:focus,.input.variant-success input.formkit-inner .form-control:focus,.input.variant-success textarea.formkit-inner .form-control:focus,.input.variant-success select.formkit-inner .form-control:focus,.select.variant-info input.formkit-inner .form-control:focus,.select.variant-info textarea.formkit-inner .form-control:focus,.select.variant-info select.formkit-inner .form-control:focus,.input.variant-info input.formkit-inner .form-control:focus,.input.variant-info textarea.formkit-inner .form-control:focus,.input.variant-info select.formkit-inner .form-control:focus,.select.variant-warning input.formkit-inner .form-control:focus,.select.variant-warning textarea.formkit-inner .form-control:focus,.select.variant-warning select.formkit-inner .form-control:focus,.input.variant-warning input.formkit-inner .form-control:focus,.input.variant-warning textarea.formkit-inner .form-control:focus,.input.variant-warning select.formkit-inner .form-control:focus,.select.variant-danger input.formkit-inner .form-control:focus,.select.variant-danger textarea.formkit-inner .form-control:focus,.select.variant-danger select.formkit-inner .form-control:focus,.input.variant-danger input.formkit-inner .form-control:focus,.input.variant-danger textarea.formkit-inner .form-control:focus,.input.variant-danger select.formkit-inner .form-control:focus,.select.variant-light input.formkit-inner .form-control:focus,.select.variant-light textarea.formkit-inner .form-control:focus,.select.variant-light select.formkit-inner .form-control:focus,.input.variant-light input.formkit-inner .form-control:focus,.input.variant-light textarea.formkit-inner .form-control:focus,.input.variant-light select.formkit-inner .form-control:focus,.select.variant-dark input.formkit-inner .form-control:focus,.select.variant-dark textarea.formkit-inner .form-control:focus,.select.variant-dark select.formkit-inner .form-control:focus,.input.variant-dark input.formkit-inner .form-control:focus,.input.variant-dark textarea.formkit-inner .form-control:focus,.input.variant-dark select.formkit-inner .form-control:focus{box-shadow:unset}.formkit-inner{min-height:2.75rem}:not(.dropdown)>.formkit-outer[data-type=checkbox]:not([data-multiple=true]){display:flex;flex-direction:row;align-items:center;height:100%;padding:1rem 0;margin:0rem}.form-check-input:checked[type=checkbox]:disabled{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%2304071a' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='m6 10 3 3 6-6'/%3e%3c/svg%3e")}.form-check-input:indeterminate[type=checkbox]:disabled{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3e%3cpath fill='none' stroke='%2304071a' stroke-linecap='round' stroke-linejoin='round' stroke-width='3' d='M6 10h8'/%3e%3c/svg%3e")}.form-check-input:checked[type=radio]:disabled{--diplan-form-check-bg-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 8 8'%3e%3ccircle r='2' fill='%2304071a'/%3e%3c/svg%3e")}.form-select:disabled{--diplan-form-select-bg-img: unset}html,body{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}#app-id-XXX{min-height:100vh;max-height:100vh;display:flex;flex-direction:column}#app-id-XXX>header{order:1}#app-id-XXX>main{order:2;flex-grow:1}#app-id-XXX>footer{order:3}body,body *{scroll-behavior:smooth}body::-webkit-scrollbar,body *::-webkit-scrollbar{width:16px}body ::-webkit-scrollbar-track,body * ::-webkit-scrollbar-track{background:transparent}body::-webkit-scrollbar-thumb,body *::-webkit-scrollbar-thumb{height:56px;border-radius:8px;border:2px solid transparent;background-clip:content-box;background-color:#ccc}a{line-height:inherit;text-decoration:none}.page{position:relative}.box{box-shadow:0 .125rem .25rem #04071a13;display:block;position:relative;border:1px solid #f7f8fa}.box:not(:last-child){margin-bottom:1.5rem}.sidebar .offcanvas{z-index:1057}.hover-danger:focus,.hover-danger:hover{color:#dc3545;text-shadow:none}.bg-white-hover:hover{background-color:#fff}.rotate{transform:rotate(180deg)}.text-nowrap{text-wrap:nowrap}.text-centered{text-align:center}.uppercase{text-transform:uppercase}.nav.nav-plain{--diplan-nav-link-padding-y: .5rem;--diplan-nav-link-padding-x: .75rem;border-bottom:unset;margin-bottom:unset}.nav.nav-plain .nav-link.active{border-radius:2px;background-color:#fff;border-bottom:unset}.error-truncat{overflow-y:hidden;display:-webkit-box;-webkit-line-clamp:5;-webkit-box-orient:vertical}@media print{*,*:before,*:after{text-shadow:none!important;box-shadow:none!important}a:not(.btn){text-decoration:underline}abbr[title]:after{content:" (" attr(title) ")"}pre{white-space:pre-wrap!important}pre,blockquote{border:1px solid #adb5bd;page-break-inside:avoid}tr,img{page-break-inside:avoid}p,h2,.h2,h3,.h3{orphans:3;widows:3}h2,.h2,h3,.h3{page-break-after:avoid}@page{size:a3}body,.container{min-width:992px!important}.badge{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered th,.table-bordered td{border:1px solid #dee2e6!important}.table-dark{color:inherit}.table-dark th,.table-dark td,.table-dark thead th,.table-dark tbody+tbody{border-color:#dee2e6}}@media print{.d-print-none{display:none!important}#app-id-XXX>header,#app-id-XXX>main,#app-id-XXX .area-header{position:relative!important;top:unset!important}article .row .col-12{width:50%}.badge{--diplan-badge-color: $gray}a:not(.btn){text-decoration:none;color:#04071a}.box{border:none}a:hover,:active,:focus{text-decoration:none}}`, i1e = UG(_M, {
    configureApp(t) {
      t.use(e1e);
    },
    styles: [t1e, _M.styles]
  });
  customElements.get("diplan-karte") || customElements.define("diplan-karte", i1e);
});
export default r1e();
//# sourceMappingURL=diplan-karten.js.map
