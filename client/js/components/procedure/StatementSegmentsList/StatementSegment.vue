<license>
  (c) 2010-present DEMOS E-Partizipation GmbH.

  This file is part of the package demosplan,
  for more information see the license file.

  All rights reserved
</license>

<template>
  <div
    class="border-radius segment-list-row"
    :class="{'segment-list-row--assigned': isAssignedToMe, 'fullscreen': isFullscreen}"
    @mouseenter="isHover = true"
    @mouseleave="isHover = false"
    :id="'segment_' + segment.id">
    <div class="flex flex-column flex-content-start flex-basis-20 u-pt-0_5 u-pl-0_5">
      <v-popover>
        <i
          class="fa fa-hashtag color--grey-light"
          :class="{'color--grey-dark': isAssignedToMe || isHover}"
          aria-hidden="true" />
        <span>{{ this.segment.attributes.externId }}</span>
        <template v-slot:popover>
          <div class="c-statement-meta-tooltip u-ph-0 u-pv-0">
            <dl>
              <div class="weight--bold u-pb-0_5 u-pr-0_5">
                {{ Translator.trans('segment') }} {{ segment.attributes.externId }}
              </div>
              <div v-if="segment.attributes.externId">
                <dt class="weight--bold">
                  {{ Translator.trans('id') }}:
                </dt>
                <dd>{{ segment.attributes.externId }}</dd>
              </div>
              <div>
                <dt class="weight--bold">
                  {{ Translator.trans('tags') }}:
                </dt>
                <dd>{{ tagsAsString }}</dd>
              </div>
              <div v-if="segment.relationships.place">
                <dt class="weight--bold">
                  {{ Translator.trans('workflow.place') }}:
                </dt>
                <dd>{{ segmentPlace.name }}</dd>
              </div>
              <div v-if="assignee.name !== ''">
                <dt class="weight--bold">
                  {{ Translator.trans('assigned.to') }}:
                </dt>
                <dd>{{ assignee.name }}</dd>
              </div>
            </dl>
          </div>
        </template>
      </v-popover>

      <dp-claim
        entity-type="segment"
        :assigned-id="assignee.id || ''"
        :assigned-name="assignee.name || ''"
        :assigned-organisation="assignee.orgaName || ''"
        :current-user-id="currentUserId"
        :current-user-name="currentUserName"
        :is-loading="claimLoading"
        @click="toggleClaimSegment" />
    </div>
    <div
      class="segment-list-col--l"
      v-cleanhtml="visibleSegmentText" />
    <div class="segment-list-col--s">
      <button
        v-if="!isFullscreen"
        class="segment-list-toggle-button btn--blank u-mh-auto"
        :class="{'reverse': !isCollapsed}"
        :aria-label="Translator.trans('aria.expand')"
        @click="isCollapsed = !isCollapsed">
        <i
          class="fa fa-arrow-up"
          aria-hidden="true" />
        <i
          class="fa fa-arrow-down"
          aria-hidden="true" />
      </button>
    </div>
    <div class="segment-list-col--l">
      <div
        v-if="isAssignedToMe === false"
        :class="{ 'color--grey': visibleRecommendation === '' }"
        :title="visibleRecommendation ? Translator.trans('explanation.segment.claim.to.edit.recommendation') : Translator.trans('explanation.segment.claim.to.add.recommendation')"
        v-cleanhtml="visibleRecommendation || Translator.trans('segment.recommendation.none')" />
      <div v-else-if="isAssignedToMe && isEditing === false">
        <div
          v-if="visibleRecommendation !== ''"
          v-cleanhtml="visibleRecommendation"
          class="u-mb-0_5" />
      </div>
      <div v-else>
        <dp-editor
          editor-id="recommendationText"
          :toolbar-items="{
            boilerPlate: 'consideration',
            fullscreenButton: false,
            linkButton: true,
            recommendationButton: segment.hasRelationship('tags')
          }"
          :procedure-id="procedureId"
          :value="segment.attributes.recommendation"
          @input="value => updateSegment('recommendation', value)"
          :segment-id="segment.id"
          class="u-mb-0_5" />
      </div>
      <div v-if="isAssignedToMe">
        <dp-checkbox
          :id="'showWorkflowActions_' + segment.id"
          v-model="showWorkflowActions"
          :label="{
            text: Translator.trans('workflow.change.assignee.place')
          }" />
        <div
          v-if="showWorkflowActions"
          class="u-mv-0_5">
          <dp-label
            :text="Translator.trans('assignee')"
            :bold="false"
            for="assignableUsersSegment" />
          <dp-multiselect
            id="assignableUsersSegment"
            :options="assignableUsers"
            class="u-1-of-1"
            v-model="selectedAssignee"
            label="name"
            track-by="id" />
          <dp-label
            :text="Translator.trans('workflow.place')"
            :bold="false"
            class="u-mt-0_5"
            for="segmentPlace" />
          <dp-multiselect
            id="segmentPlace"
            :options="places"
            class="u-1-of-1"
            v-model="selectedPlace"
            :allow-empty="false"
            label="name"
            track-by="id">
            <template v-slot:option="props">
              <div
                v-for="prop in props"
                v-tooltip="prop.description"
                :key="prop.id"
                v-text="prop.name" />
            </template>
          </dp-multiselect>
        </div>
      </div>
      <dp-button-row
        v-if="isAssignedToMe && (isEditing || showWorkflowActions)"
        align="left"
        class="u-mt-0_75"
        primary
        secondary
        @primary-action="save"
        @secondary-action="abort" />
    </div>
    <div class="segment-list-col--m text--right flex-shrink-2 u-ph-0_5">
      <div
        class="segment-list-toolbar"
        :class=" isAssignedToMe ? '' : 'segment-list-toolbar--dark'">
        <button
          class="segment-list-toolbar__button btn--blank"
          data-cy="editorFullscreen"
          :aria-label="Translator.trans('editor.fullscreen')"
          v-tooltip="Translator.trans('editor.fullscreen')"
          @click="isFullscreen = !isFullscreen">
          <dp-icon
            :icon="isFullscreen ? 'compress' : 'expand'"
            aria-hidden="true" />
        </button>

        <button
          v-if="isAssignedToMe"
          class="segment-list-toolbar__button btn btn--primary"
          data-cy="segmentEdit"
          :aria-label="Translator.trans('edit')"
          v-tooltip="Translator.trans('edit')"
          @click="startEditing">
          <i
            class="fa fa-pencil"
            aria-hidden="true" />
        </button>

        <button
          class="segment-list-toolbar__button btn--blank"
          :class="{ 'is-active' : slidebar.showTab === 'history' && slidebar.segmentId === segment.id }"
          type="button"
          :aria-label="Translator.trans('history')"
          v-tooltip="Translator.trans('history')"
          @click.prevent="showSegmentVersionHistory"
          data-cy="segmentVersionHistory">
          <dp-icon icon="history" />
        </button>

        <button
          v-if="hasPermission('feature_segment_comment_list_on_segment')"
          class="segment-list-toolbar__button btn--blank"
          :class="{ 'is-active' : slidebar.showTab === 'comments' && slidebar.segmentId === segment.id }"
          type="button"
          :aria-label="Translator.trans('comments')"
          v-tooltip="Translator.trans('comments')"
          data-cy="segmentComments"
          @click.prevent="showComments">
          <i
            class="fa fa-comment-o"
            aria-hidden="true" />
          <span
            v-if="commentCount > 0"
            class="segment-list-toolbar__badge o-badge--darker display--block position--absolute u-ml u-n-mt">
            {{ commentCount }}
          </span>
        </button>
        <button
          v-if="hasPermission('feature_segment_polygon_read')"
          class="segment-list-toolbar__button btn--blank"
          :class="{ 'is-active' : slidebar.showTab === 'map' && slidebar.segmentId === segment.id }"
          type="button"
          :aria-label="Translator.trans('public.participation.relation')"
          v-tooltip="Translator.trans('public.participation.relation')"
          data-cy="segmentMap"
          @click.prevent="showMap">
          <i
            class="fa fa-map-marker"
            aria-hidden="true" />
        </button>
      </div>
    </div>
  </div>
</template>

<script>
import { checkResponse, dpApi } from '@DpJs/plugins/DpApi'
import { CleanHtml, VPopover } from 'demosplan-ui/directives'
import { DpIcon, DpLabel } from 'demosplan-ui/components'
import { mapActions, mapGetters, mapMutations, mapState } from 'vuex'
import DpButtonRow from '@DpJs/components/core/DpButtonRow'
import DpCheckbox from '@DpJs/components/core/form/DpCheckbox'
import DpClaim from '@DpJs/components/statement/DpClaim'
import DpMultiselect from '@DpJs/components/core/form/DpMultiselect'

export default {
  name: 'StatementSegment',

  inject: ['procedureId'],

  components: {
    DpButtonRow,
    DpCheckbox,
    DpClaim,
    DpIcon,
    DpLabel,
    DpMultiselect,
    DpEditor: () => import('@DpJs/components/core/DpEditor/DpEditor'),
    VPopover
  },

  directives: {
    cleanhtml: CleanHtml
  },

  props: {
    currentUserFirstName: {
      required: false,
      type: String,
      default: ''
    },

    currentUserId: {
      required: true,
      type: String
    },

    currentUserLastName: {
      required: false,
      type: String,
      default: ''
    },

    currentUserOrga: {
      type: String,
      required: false,
      default: ''
    },

    segment: {
      required: true,
      type: Object
    },

    statementId: {
      required: true,
      type: String
    }
  },

  data () {
    return {
      showWorkflowActions: false,
      selectedAssignee: {},
      claimLoading: false,
      currentUserName: this.currentUserFirstName + ' ' + this.currentUserLastName,
      isCollapsed: !(this.segment.relationships?.assignee?.data && this.segment.relationships.assignee.data.id === this.currentUserId),
      isEditing: false,
      isFullscreen: false,
      isHover: false,
      selectedPlace: { id: '', type: 'Place' }
    }
  },

  computed: {
    ...mapState('segmentSlidebar', ['slidebar']),

    ...mapState('assignableUser', {
      assignableUserItems: 'items'
    }),

    assignableUsers () {
      const assigneeOptions = Object.values({ ...this.assignableUserItems })
        .map(assignableUser => {
          return {
            name: assignableUser.attributes.firstname + ' ' + assignableUser.attributes.lastname,
            id: assignableUser.id
          }
        })
      assigneeOptions.unshift({
        name: Translator.trans('not.assigned'),
        id: 'noAssigneeId'
      })
      return assigneeOptions
    },

    assignee () {
      if (this.segment?.relationships?.assignee?.data?.id && this.segment.relationships.assignee.data.id !== '') {
        const assignee = this.assignableUserItems[this.segment.relationships.assignee.data.id]
        const name = `${assignee.attributes.firstname} ${assignee.attributes.lastname}`
        const orga = assignee ? Object.values(assignee.rel('orga'))[0] : ''

        return { id: this.segment.relationships.assignee.data.id, name: name, orgaName: orga ? orga.attributes.name : '' }
      } else {
        return { id: '', name: '', orgaName: '' }
      }
    },

    commentCount () {
      return this.segment.relationships.comments?.data?.length || 0
    },

    isAssignedToMe () {
      return this.assignee.id === this.currentUserId
    },

    places () {
      return this.$store.state.place
        ? Object.values(this.$store.state.place.items)
          .map(pl => ({ ...pl.attributes, id: pl.id }))
        : []
    },

    segmentPlace () {
      return this.segment.relationships.place
        ? this.places.find(place => place.id === this.segment.relationships.place.data.id)
        : {}
    },

    tagsAsString () {
      if (this.segment.hasRelationship('tags')) {
        return Object.values(this.segment.rel('tags')).map(el => el.attributes.title).join(', ')
      }
      return '-'
    },

    visibleRecommendation () {
      const shortText = this.segment.attributes.recommendation.length > 40 ? this.segment.attributes.recommendation.slice(0, 40) + '...' : this.segment.attributes.recommendation
      return this.isCollapsed ? shortText : this.segment.attributes.recommendation
    },

    visibleSegmentText () {
      const shortText = this.segment.attributes.text.length > 40 ? this.segment.attributes.text.slice(0, 40) + '...' : this.segment.attributes.text
      return this.isCollapsed ? shortText : this.segment.attributes.text
    }
  },

  methods: {
    ...mapActions('assignableUser', {
      fetchAssignableUsers: 'list'
    }),

    ...mapActions('place', {
      fetchPlaces: 'list'
    }),

    ...mapActions('segmentSlidebar', [
      'toggleSlidebarContent'
    ]),

    ...mapMutations('segmentSlidebar', [
      'setProperty'
    ]),

    ...mapActions('statementSegment', {
      restoreSegmentAction: 'restoreFromInitial',
      saveSegmentAction: 'save'
    }),

    ...mapMutations('statementSegment', {
      updateSegment: 'update',
      setSegment: 'setItem'
    }),

    abort () {
      // Restore initial recommendation value, set it also in tiptap
      const initText = this.$store.state.statementSegment.initial[this.segment.id].attributes.recommendation
      this.updateSegment('recommendation', initText)
      // Update interface
      this.isFullscreen = false
      this.isEditing = false

      this.toggleAssignableUsersSelect()
    },

    claimSegment () {
      const dataToUpdate = {
        ...this.segment,
        ...{
          relationships: {
            ...this.segment.relationships,
            ...{
              assignee: {
                data: {
                  type: 'AssignableUser',
                  id: this.currentUserId
                }
              }
            }
          }
        }
      }
      this.setSegment({ ...dataToUpdate, id: this.segment.id, group: null })

      const payload = {
        data: {
          id: this.segment.id,
          type: 'StatementSegment',
          relationships: {
            assignee: {
              data: {
                type: 'AssignableUser',
                id: this.currentUserId
              }
            }
          }
        }
      }

      return dpApi.patch(Routing.generate('api_resource_update', { resourceType: 'StatementSegment', resourceId: this.segment.id }), {}, payload)
        .then(checkResponse)
        .then(() => {
          this.claimLoading = false
          this.isCollapsed = false
          this.selectedAssignee = {
            id: this.currentUserId,
            name: this.currentUserName
          }
        })
        .catch((err) => {
          console.error(err)
          // Restore segment in store if it didn't work
          this.restoreSegmentAction(this.segment.id)
          this.claimLoading = false
        })
    },

    /**
     * Remove non-updatable comments from segments relationships for update request
     * @param relations {Object}
     */
    removeComments (relations) {
      if (relations.comments) {
        this.setProperty({ prop: 'isLoading', val: true })
        delete relations.comments
      }
    },

    restoreComments (comments) {
      if (comments) {
        const segmentWithComments = {
          ...this.segment,
          relationships: {
            ...this.segment.relationships,
            comments: comments
          }
        }
        this.setSegment({ ...segmentWithComments, id: this.segment.id, group: null })
      }
    },

    save () {
      const comments = { ...this.segment.relationships.comments } || null

      this.updateRelationships()
      return this.saveSegmentAction(this.segment.id)
        .then(() => {
          /*
           * @improve - once the vuex-json-api resolves with a response,
           * we can handle success messages in checkResponse() again.
           */
          dplan.notify.notify('confirm', Translator.trans('confirm.saved'))
          this.isFullscreen = false
          this.isEditing = false

          this.restoreComments(comments)
          this.setProperty({ prop: 'isLoading', val: false })

          this.toggleAssignableUsersSelect()
        })
        .catch(() => {
          this.restoreComments(comments)
          this.setProperty({ prop: 'isLoading', val: false })
          this.isEditing = false
        })
    },

    showComments () {
      this.$parent.$parent.resetSlidebar()

      this.toggleSlidebarContent({
        prop: 'commentsList',
        val: {
          ...this.commentsList,
          currentCommentText: '',
          externId: this.segment.attributes.externId,
          segmentId: this.segment.id,
          show: true
        }
      })
      this.toggleSlidebarContent({ prop: 'slidebar', val: { segmentId: this.segment.id, showTab: 'comments' } })
      this.$root.$emit('show-slidebar')
    },

    showMap () {
      this.$parent.$parent.resetSlidebar()
      this.toggleSlidebarContent({ prop: 'slidebar', val: { segmentId: this.segment.id, showTab: 'map' } })
      this.$root.$emit('show-slidebar')
    },

    showSegmentVersionHistory () {
      this.$root.$emit('version:history', this.segment.id, 'segment', this.segment.attributes.externId)
      this.$root.$emit('show-slidebar')
      this.toggleSlidebarContent({ prop: 'slidebar', val: { segmentId: this.segment.id, showTab: 'history' } })
    },

    startEditing () {
      this.isEditing = true
      this.isCollapsed = false
    },

    toggleAssignableUsersSelect () {
      if (this.showWorkflowActions === true) {
        this.showWorkflowActions = false
      }
    },

    /**
     * Don't use vuex-json-api lib for claiming and un-claiming because there is a problem if data in relationship is
     * null (=un-claiming); using vuex-json-api lib only for claiming but not for un-claiming doesn't work because the
     * initial items in the lib store are not updated when un-claiming outside of lib
     */
    toggleClaimSegment () {
      this.claimLoading = true
      const userIdToSet = this.segment.hasRelationship('assignee') && this.segment.relationships.assignee.data.id === this.currentUserId ? null : this.currentUserId
      const isClaim = userIdToSet !== null

      if (isClaim) {
        this.claimSegment()
      } else {
        this.unclaimSegment()
      }
    },

    unclaimSegment () {
      const payload = {
        data: {
          type: 'StatementSegment',
          id: this.segment.id,
          relationships: {
            assignee: {
              data: null
            }
          }
        }
      }
      return dpApi.patch(Routing.generate('api_resource_update', { resourceType: 'StatementSegment', resourceId: this.segment.id }), {}, payload)
        .then(checkResponse)
        .then(() => {
          this.isFullscreen = false
          this.isEditing = false
          this.isCollapsed = true
          const dataToUpdate = JSON.parse(JSON.stringify(this.segment))
          delete dataToUpdate.relationships.assignee
          // Reset recommendation text in store (segment might have been in edit mode with some changes)
          dataToUpdate.attributes.recommendation = this.$store.state.statementSegment.initial[this.segment.id].attributes.recommendation
          // Set segment in store, without the assignee and with resetted recommendation
          this.setSegment({ ...dataToUpdate, id: this.segment.id, group: null })
          this.claimLoading = false
          this.selectedAssignee = { id: '', name: '' }
        })
        .catch((err) => {
          console.error(err)
          this.claimLoading = false
        })
    },

    updateRelationships () {
      let relations = { ...this.segment.relationships }

      /**
       *  Comments need to be removed as updating them is technically not supported
       *  After completing the request, they are added again to the store to be able to display them
       */
      this.removeComments(relations)

      if (this.showWorkflowActions) {
        let assignee = { assignee: { data: null } }

        if (this.selectedAssignee && this.selectedAssignee.id !== 'noAssigneeId') {
          assignee = {
            assignee: {
              data: {
                id: this.selectedAssignee.id,
                type: 'AssignableUser'
              }
            }
          }
        }

        const place = {
          place: {
            data: {
              id: this.selectedPlace.id,
              type: 'Place'
            }
          }
        }

        relations = {
          ...relations,
          ...place,
          ...assignee
        }
      }

      const updated = {
        ...this.segment,
        relationships: relations
      }

      this.setSegment({ ...updated, id: this.segment.id, group: null })
    },

    updateSegment (key, val) {
      const updated = { ...this.segment, ...{ attributes: { ...this.segment.attributes, ...{ [key]: val } } } }
      this.setSegment({ ...updated, id: this.segment.id, group: null })
    }
  },

  mounted () {
    this.fetchPlaces({
      fields: {
        Place: ['name', 'sortIndex', 'description'].join()
      },
      sort: 'sortIndex'
    })
      .then(() => {
        if (this.segment.relationships.place) {
          this.selectedPlace = this.places.find(place => place.id === this.segment.relationships.place.data.id) || this.places[0]
        }
      })
    this.fetchAssignableUsers({ include: 'department', sort: 'lastname' })
      .then(() => {
        if (this.segment.relationships?.assignee?.data?.id) {
          this.selectedAssignee = this.assignableUsers.find(user => user.id === this.segment.relationships.assignee.data.id)
        }
      })
  }
}
</script>
