<license>
  (c) 2010-present DEMOS E-Partizipation GmbH.

  This file is part of the package demosplan,
  for more information see the license file.

  All rights reserved
</license>

<template>
  <div>
    <!-- Header -->
    <dp-sticky-element
      border
      class="u-pv-0_5 space-stack-s">
      <div class="flex space-inline-xs">
        <search-modal
          :search-in-fields="searchFields"
          @search="(term, selectedFields) => applySearch(term, selectedFields)"
          ref="searchModal" />
        <dp-button
          class="flex-item-end"
          variant="outline"
          :href="Routing.generate('dplan_procedure_statement_list', { procedureId: procedureId })"
          :disabled="searchValue === ''"
          :text="Translator.trans('search.reset')" />
      </div>
      <dp-bulk-edit-header
        class="u-mt-0_5"
        v-if="selectedItemsCount > 0 && hasPermission('feature_statements_sync_to_procedure')"
        :selected-items-count="selectedItemsCount"
        :selection-text="Translator.trans('items.selected.multi.page', { count: selectedItemsCount })"
        @reset-selection="resetSelection">
        <dp-button
          variant="outline"
          @click.prevent="handleBulkShare"
          :text="Translator.trans('procedure.share_statements.bulk.share')" />
      </dp-bulk-edit-header>
      <div class="flex space-inline-xs">
        <dp-flyout :align="'left'">
          <template v-slot:trigger>
            {{ Translator.trans('export.verb') }}
            <i
              class="fa fa-angle-down"
              aria-hidden="true" />
          </template>
          <a
            :href="exportRoute('dplan_statement_segments_export')"
            rel="noopener">
            {{ Translator.trans('export.statements.docx') }}
          </a>
          <a
            :href="exportRoute('dplan_statement_segments_export_packaged')"
            rel="noopener">
            {{ Translator.trans('export.statements.zip') }}
          </a>
          <a
            v-if="hasPermission('feature_admin_assessmenttable_export_statement_generic_xlsx')"
            :href="exportRoute('dplan_statement_xls_export')"
            rel="noopener">
            {{ Translator.trans('export.statements.xlsx') }}
          </a>
        </dp-flyout>
        <div class="flex-item-end flex flex-items-center space-inline-xs">
          <label class="u-mb-0">
            {{ Translator.trans('sorting') }}
          </label>
          <dp-select
            :options="sortOptions"
            :selected="selectedSort"
            @select="applySort" />
        </div>
      </div>
    </dp-sticky-element>

    <dp-loading v-if="isLoading" />

    <!-- Statement list -->
    <template v-if="!isLoading && items.length > 0">
      <dp-data-table
        has-flyout
        :is-selectable="isSourceAndCoupledProcedure"
        :header-fields="headerFields"
        is-expandable
        :items="items"
        lock-checkbox-by="synchronized"
        :multi-page-all-selected="allSelectedVisually"
        :multi-page-selection-items-total="allItemsCount"
        :multi-page-selection-items-toggled="toggledItems.length"
        :should-be-selected-items="currentlySelectedItems"
        track-by="id"
        :translations="{ lockedForSelection: Translator.trans('item.lockedForSelection.sharedStatement') }"
        @select-all="handleSelectAll"
        @items-toggled="handleToggleItem">
        <template v-slot:externId="{ assignee, externId, id: statementId }">
          <span
            class="weight--bold"
            v-text="externId" />
          <dp-claim
            entity-type="statement"
            :assigned-id="assignee.id || ''"
            :assigned-name="assignee.name || ''"
            :assigned-organisation="assignee.orgaName || ''"
            :current-user-id="currentUserId"
            :is-loading="claimLoadingIds.indexOf(statementId) >= 0"
            @click="toggleClaimStatement(assignee.id, statementId)" />
        </template>
        <template
          v-slot:meta="{
            authorName,
            isSubmittedByCitizen,
            initialOrganisationName,
            submitDate,
            submitName
          }">
          <ul class="o-list max-width-350">
            <li
              v-if="authorName !== '' || submitName !== ''"
              class="o-list__item o-hellip--nowrap">
              {{ authorName ? authorName : (submitName ? submitName : Translator.trans('citizen')) }}
            </li>
            <li
              v-if="initialOrganisationName !== '' && !isSubmittedByCitizen"
              class="o-list__item o-hellip--nowrap">
              {{ initialOrganisationName }}
            </li>
            <li class="o-list__item o-hellip--nowrap">
              {{ date(submitDate) }}
            </li>
          </ul>
        </template>
        <template v-slot:internId="{ internId }">
          <div class="o-hellip__wrapper">
            <div
              v-tooltip="internId"
              class="o-hellip--nowrap text--right"
              dir="rtl"
              v-text="internId" />
          </div>
        </template>
        <template v-slot:text="{ text }">
          <div
            class="line-clamp-3 overflow-word-break"
            v-cleanhtml="text" />
        </template>
        <template v-slot:flyout="{ assignee, id, originalPdf, segmentsCount, synchronized }">
          <dp-flyout>
            <button
              v-if="hasPermission('area_statement_segmentation')"
              :class="`${(segmentsCount > 0 && segmentsCount !== '-') ? 'is-disabled' : '' } btn--blank o-link--default`"
              :disabled="segmentsCount > 0 && segmentsCount !== '-'"
              @click.prevent="handleStatementSegmentation(id, assignee, segmentsCount)"
              rel="noopener">
              {{ Translator.trans('split') }}
            </button>
            <a
              :href="Routing.generate('dplan_statement_segments_list', { statementId: id, procedureId: procedureId })"
              :class="{'is-disabled': synchronized }"
              rel="noopener">
              {{ Translator.trans('statement.details_and_recommendation') }}
            </a>
            <a
              v-if="hasPermission('feature_read_source_statement_via_api')"
              :class="{'is-disabled': originalPdf === null}"
              :href="Routing.generate('core_file', { hash: originalPdf })"
              rel="noreferrer noopener"
              target="_blank">
              {{ Translator.trans('original.pdf') }}
            </a>
            <button
              :class="`${ !synchronized || assignee.id === currentUserId ? 'text-decoration-underline--hover' : 'is-disabled' } btn--blank o-link--default`"
              :disabled="synchronized || assignee.id !== currentUserId"
              type="button"
              @click="triggerStatementDeletion(id)">
              {{ Translator.trans('delete') }}
            </button>
          </dp-flyout>
        </template>
        <template v-slot:expandedContent="{ text, fullText, id }">
          <!-- Statement meta data -->
          <statement-meta-data
            class="u-pt-0_5"
            :statement="statementsObject[id]"
            :submit-type-options="submitTypeOptions">
            <template
              v-slot:default="{
                authorName,
                formattedAuthoredDate,
                formattedSubmitDate,
                isSubmittedByCitizen,
                initialOrganisationDepartmentName,
                initialOrganisationName,
                internId,
                memo,
                submitName,
                submitType,
                location
              }">
              <div class="layout">
                <dl class="description-list-inline layout__item u-1-of-2">
                  <dt>{{ Translator.trans('submitter') }}:</dt>
                  <dd>{{ authorName ? authorName : submitName }}</dd>
                  <template
                    v-if="!isSubmittedByCitizen">
                    <dt>{{ Translator.trans('organisation') }}:</dt>
                    <dd>{{ initialOrganisationName }}</dd>
                    <dt>{{ Translator.trans('department') }}:</dt>
                    <dd>{{ initialOrganisationDepartmentName }}</dd>
                  </template>
                  <dt>{{ Translator.trans('address') }}:</dt>
                  <dd>{{ location }}</dd>
                  <template v-if="hasPermission('field_statement_memo')">
                    <dt>{{ Translator.trans('memo') }}:</dt>
                    <dd>{{ memo }}</dd>
                  </template>
                </dl><!--

             --><dl class="description-list-inline layout__item u-1-of-2">
                  <dt>{{ Translator.trans('internId') }}:</dt>
                  <dd>{{ internId }}</dd>
                  <dt>{{ Translator.trans('statement.date.authored') }}:</dt>
                  <dd>{{ formattedAuthoredDate }}</dd>
                  <dt>{{ Translator.trans('statement.date.submitted') }}:</dt>
                  <dd>{{ formattedSubmitDate }}</dd>
                  <dt class="whitespace--nowrap">
                    {{ Translator.trans('submit.type') }}:
                  </dt>
                  <dd>{{ submitType }}</dd>
                </dl>
              </div>
            </template>
          </statement-meta-data>

          <!-- Statement text -->
          <div class="u-pt-0_5 overflow-word-break">
            <strong>{{ Translator.trans('statement.text.short') }}:</strong>
            <template v-if="typeof fullText === 'undefined'">
              <div v-cleanhtml="text" />
              <a
                v-if="statementsObject[id].attributes.textIsTruncated"
                class="show-more cursor--pointer"
                @click.prevent.stop="() => getStatementsFullText(id)"
                rel="noopener">
                {{ Translator.trans('show.more') }}
              </a>
            </template>
            <template v-else>
              <div v-cleanhtml="statementsObject[id].attributes.isFulltextDisplayed ? fullText : text" />
              <a
                class="cursor--pointer"
                @click="() => toggleFulltext(id)"
                rel="noopener">
                {{ Translator.trans(statementsObject[id].attributes.isFulltextDisplayed ? 'show.less' : 'show.more') }}
              </a>
            </template>
          </div>
        </template>
      </dp-data-table>

      <dp-sliding-pagination
        v-if="totalPages > 1"
        :current="currentPage"
        :total="totalPages"
        :non-sliding-size="10"
        @page-change="getItemsByPage" />
    </template>

    <dp-inline-notification
      v-else-if="!isLoading && items.length === 0"
      :message="Translator.trans((this.searchValue === '' ? 'statements.none' : 'search.no.results'), {searchterm: this.searchValue})"
      type="info" />
  </div>
</template>

<script>
import { checkResponse, dpApi, dpRpc, formatDate, tableSelectAllItems } from '@demos-europe/demosplan-utils'
import {
  CleanHtml,
  DpBulkEditHeader,
  DpButton,
  DpDataTable,
  DpFlyout,
  DpInlineNotification,
  DpLoading,
  DpSelect,
  DpSlidingPagination,
  DpStickyElement
} from '@demos-europe/demosplan-ui'
import { mapActions, mapMutations, mapState } from 'vuex'
import DpClaim from '@DpJs/components/statement/DpClaim'
import SearchModal from '@DpJs/components/statement/assessmentTable/SearchModal/SearchModal'
import StatementMetaData from '@DpJs/components/statement/StatementMetaData'

export default {
  name: 'ListStatements',

  components: {
    DpBulkEditHeader,
    DpButton,
    DpClaim,
    DpDataTable,
    DpFlyout,
    DpInlineNotification,
    DpLoading,
    DpSelect,
    DpSlidingPagination,
    DpStickyElement,
    SearchModal,
    StatementMetaData
  },

  directives: {
    cleanhtml: CleanHtml
  },

  mixins: [tableSelectAllItems],

  props: {
    currentUserId: {
      type: String,
      required: true
    },

    /**
     * If inside a source procedure that is already coupled, HEARING_AUTHORITY_ADMIN users may copy statements to the
     * respective target procedure, while HEARING_AUTHORITY_WORKER users may see which statements are synchronized.
     */
    isSourceAndCoupledProcedure: {
      type: Boolean,
      required: false,
      default: false
    },

    procedureId: {
      required: true,
      type: String
    },

    submitTypeOptions: {
      type: Array,
      required: false,
      default: () => []
    }
  },

  data () {
    return {
      claimLoadingIds: [],
      headerFields: [
        { field: 'externId', label: Translator.trans('id') },
        { field: 'internId', label: Translator.trans('internId.shortened'), colClass: 'width-100' },
        { field: 'meta', label: Translator.trans('submitter.invitable_institution') },
        { field: 'text', label: Translator.trans('text') },
        { field: 'segmentsCount', label: Translator.trans('segments') }
      ],
      searchFields: [
        'authorName',
        'department',
        'internId',
        'memo',
        'municipalitiesNames',
        'orgaCity',
        'organisationName',
        'orgaPostalCode',
        'statementId',
        'statementText',
        'typeOfSubmission'
      ],
      searchFieldsSelected: null,
      searchValue: '',
      selectedSort: '-submitDate',
      sortOptions: [
        { value: '-submitDate', label: Translator.trans('sort.date.descending') },
        { value: 'submitDate', label: Translator.trans('sort.date.ascending') },
        { value: '-submitName', label: Translator.trans('sort.author.descending') },
        { value: 'submitName', label: Translator.trans('sort.author.ascending') },
        { value: '-internId', label: Translator.trans('sort.internId.descending') },
        { value: 'internId', label: Translator.trans('sort.internId.ascending') },
        { value: '-initialOrganisationName', label: Translator.trans('sort.organisation.descending') },
        { value: 'initialOrganisationName', label: Translator.trans('sort.organisation.ascending') }
      ]
    }
  },

  computed: {
    ...mapState('assignableUser', {
      assignableUsersObject: 'items'
    }),

    ...mapState('statement', {
      statementsObject: 'items',
      currentPage: 'currentPage',
      totalPages: 'totalPages',
      totalFiles: 'totalFiles',
      isLoading: 'loading'
    }),

    assignableUsers () {
      return Object.keys(this.assignableUsersObject).length
        ? Object.values(this.assignableUsersObject)
          .map(user => ({
            name: user.attributes.firstname + ' ' + user.attributes.lastname,
            id: user.id
          }))
        : []
    },

    exportRoute: function () {
      return (exportRoute) => Routing.generate(exportRoute, {
        filter: {
          procedureId: {
            condition: {
              path: 'procedure.id',
              value: this.procedureId
            }
          }
        },
        procedureId: this.procedureId,
        search: {
          value: this.searchValue,
          ...this.searchFieldsSelected !== null ? { fieldsToSearch: this.searchFieldsSelected } : {}
        },
        sort: this.selectedSort
      })
    },

    items () {
      return Object.values(this.statementsObject)
        .map(statement => {
          const segmentsCount = statement.relationships.segments.data.length
          const originalPdf = this.getOriginalPdfAttachmentHash(statement)
          return {
            ...statement.attributes,
            assignee: this.getAssignee(statement),
            id: statement.id,
            segmentsCount: segmentsCount || '-',
            originalPdf: originalPdf
          }
        })
    }
  },

  methods: {
    ...mapActions('assignableUser', {
      fetchAssignableUsers: 'list'
    }),

    ...mapActions('statement', {
      deleteStatement: 'delete',
      fetchStatements: 'list',
      restoreStatementAction: 'restoreFromInitial'
    }),

    ...mapMutations('statement', {
      setStatement: 'setItem'
    }),

    assigneeId (statement) {
      if (statement.hasRelationship('assignee') && statement.relationships.assignee.data.id !== '') {
        return statement.relationships.assignee.data.id
      } else {
        return null
      }
    },

    getAssignee (statement) {
      if (this.assigneeId(statement)) {
        const assignee = this.assignableUsersObject[this.assigneeId(statement)]
        const assigneeOrga = assignee ? Object.values(assignee.rel('orga'))[0] : null
        if (typeof assignee === 'undefined') {
          return {
            id: statement.relationships.assignee.data.id,
            name: 'Benutzer',
            orgaName: 'unbekannt'
          }
        }
        return {
          id: statement.relationships.assignee.data.id,
          name: `${assignee.attributes.firstname} ${assignee.attributes.lastname}`,
          orgaName: assigneeOrga ? assigneeOrga.attributes.name : ''
        }
      }
      return {
        id: '',
        name: '',
        orgaName: ''
      }
    },

    /**
     * If statement already has segments, do nothing
     * If statement is not claimed, silently assign it to the current user and go to split statement view
     * If statement is claimed by current user, go to split statement view
     * If statement is claimed by another user, ask the current user to claim it and, after they confirm, assign it to
     * the current user, then go to split statement view. If the user doesn't confirm, do nothing.
     * @param statementId {string}
     * @param assignee {object} { data: { id: string, type: string }}
     * @param segmentsCount {number || string} can be a number or '-'
     */
    handleStatementSegmentation (statementId, assignee, segmentsCount) {
      const isStatementSegmented = segmentsCount > 0 && segmentsCount !== '-'
      const isStatementClaimedByCurrentUser = assignee.id === this.currentUserId
      const isStatementClaimed = assignee.id !== ''
      const isStatementClaimedByOtherUser = isStatementClaimed && !isStatementClaimedByCurrentUser

      if (isStatementSegmented) {
        return
      }

      if (isStatementClaimedByCurrentUser) {
        window.location.href = Routing.generate('dplan_drafts_list_edit', { statementId: statementId, procedureId: this.procedureId })
      }

      if (!isStatementClaimed) {
        // claim silently
        this.claimStatement(statementId)
          .then(() => {
            window.location.href = Routing.generate('dplan_drafts_list_edit', { statementId: statementId, procedureId: this.procedureId })
          })
          .catch(err => {
            console.error(err)
          })
      }

      if (isStatementClaimedByOtherUser && dpconfirm(Translator.trans('warning.statement.needLock.generic'))) {
        this.claimStatement(statementId)
          .then(() => {
            window.location.href = Routing.generate('dplan_drafts_list_edit', { statementId: statementId, procedureId: this.procedureId })
          })
          .catch(err => {
            console.error(err)
          })
      }

      // window.location.href = Routing.generate('dplan_drafts_list_edit', { statementId: statementId, procedureId: this.procedureId })
    },

    applySearch (term, selectedFields) {
      this.searchValue = term
      this.searchFieldsSelected = selectedFields
      this.getItemsByPage(1)
    },

    applySort (sortValue) {
      this.selectedSort = sortValue
      this.getItemsByPage(1)
    },

    /**
     * Returns an error if claiming fails
     * @return {Promise<*>}
     */
    claimStatement (statementId) {
      const statement = this.statementsObject[statementId]
      if (typeof statement !== 'undefined') {
        const dataToUpdate = { ...statement, ...{ relationships: { ...statement.relationships, ...{ assignee: { data: { type: 'User', id: this.currentUserId } } } } } }
        this.setStatement({ ...dataToUpdate, id: statementId, group: null })

        const payload = {
          data: {
            id: statementId,
            type: 'Statement',
            relationships: {
              assignee: {
                data: {
                  type: 'User',
                  id: this.currentUserId
                }
              }
            }
          }
        }
        return dpApi.patch(Routing.generate('api_resource_update', { resourceType: 'Statement', resourceId: statementId }), {}, payload)
          .then(response => {
            checkResponse(response)
            return response
          })
          .then(response => {
            dplan.notify.notify('confirm', Translator.trans('confirm.statement.assignment.assigned'))

            return response
          })
          .catch((err) => {
            console.error(err)
            // Restore statement in store in case request failed
            this.restoreStatementAction(statementId)
            return err
          })
          .finally(() => {
            this.claimLoadingIds.splice(this.claimLoadingIds.indexOf(statementId), 1)
          })
      }
    },

    toggleClaimStatement (assigneeId, statementId) {
      this.claimLoadingIds.push(statementId)

      if (assigneeId !== this.currentUserId) {
        this.claimStatement(statementId)
      } else {
        console.log('unclaim')
        this.unclaimStatement(statementId)
      }
    },

    unclaimStatement (statementId) {
      const statement = this.statementsObject[statementId]
      const dataToUpdate = { ...statement, ...{ relationships: { ...statement.relationships, ...{ assignee: { data: { type: 'User', id: null } } } } } }
      this.setStatement({ ...dataToUpdate, id: statementId, group: null })

      const payload = {
        data: {
          type: 'Statement',
          id: statementId,
          relationships: {
            assignee: {
              data: null
            }
          }
        }
      }
      return dpApi.patch(Routing.generate('api_resource_update', { resourceType: 'Statement', resourceId: statementId }), {}, payload)
        .then(checkResponse)
        .catch((err) => {
          this.restoreStatementAction(statementId)
          console.error(err)
        })
        .finally(() => {
          this.claimLoadingIds.splice(this.claimLoadingIds.indexOf(statementId), 1)
        })
    },

    date (d) {
      return formatDate(d)
    },

    getItemsByPage (page) {
      this.fetchStatements({
        page: {
          number: page
        },
        search: {
          value: this.searchValue,
          ...this.searchFieldsSelected !== null ? { fieldsToSearch: this.searchFieldsSelected } : {}
        },
        filter: {
          procedureId: {
            condition: {
              path: 'procedure.id',
              value: this.procedureId
            }
          }
        },
        sort: this.selectedSort,
        include: [
          'segments',
          'assignee',
          'attachments',
          'attachments.file'
        ].join(),
        fields: {
          Statement: [
            // Attributes:
            'authoredDate',
            'authorName',
            'externId',
            'isSubmittedByCitizen',
            'initialOrganisationCity',
            'initialOrganisationDepartmentName',
            'initialOrganisationHouseNumber',
            'initialOrganisationName',
            'initialOrganisationPostalCode',
            'initialOrganisationStreet',
            'internId',
            'isCitizen',
            'memo',
            'submitDate',
            'submitName',
            'submitType',
            'submitterEmailAddress',
            'synchronized',
            'text',
            'textIsTruncated',
            // Relationships:
            'assignee',
            'attachments',
            'segments'
          ].join(),
          File: [
            'hash'
          ].join(),
          // Segments are only counted, no data needed here.
          StatementSegment: [
            'id'
          ].join()
        }
      }).then((data) => {
        this.setNumSelectableItems(data)
      })
    },

    /**
     * Returns the hash of the original statement attachment
     */
    getOriginalPdfAttachmentHash (el) {
      if (el.hasRelationship('attachments')) {
        const originalAttachment = Object.values(el.relationships.attachments.list())
          .filter(attachment => attachment.attributes.type === 'source_statement')
        if (originalAttachment.length === 1) {
          return originalAttachment[0].relationships.file.get().attributes.hash
        }
      }

      return null
    },

    /**
     * Returns the params needed for the RPC to synchronize statements in coupled procedures.
     * We need to send a filter and a search with the call.
     * There are three different cases for the filter.
     * 1. All items
     * 2. All items minus deselected items
     * 3. Only selected items
     * We can group filters, so multiple conditions are applied.
     * You can find more on how to use filters in the documentation here
     * {@link https://dplan-documentation.demos-europe.eu/development/application-architecture/web-api/jsonapi/filter.html#background}.
     *
     * @param {boolean} [isDry=false] If set to true, the call will be executed as dry run - no actions will be applied.
     *
     * @returns {Object}
     */
    getParamsForBulkShare (isDry = false) {
      const params = {
        dry: isDry,
        search: {
          value: this.searchValue,
          ...this.searchFieldsSelected !== null ? { fieldsToSearch: this.searchFieldsSelected } : {}
        }
      }

      /*
       * When tracking deselected items, we want the action to apply to all but the deselected items.
       * That's why `AND` is used as conjunction, and `<>` (not equal) as operator, in that case.
       */
      const filterForToggledItems = {}
      if (this.toggledItems.length > 0) {
        filterForToggledItems.statementFilterGroup = {
          group: {
            conjunction: this.trackDeselected ? 'AND' : 'OR'
          }
        }
        this.toggledItems.forEach((item, idx) => {
          filterForToggledItems['statement_' + idx] = {
            condition: {
              path: 'id',
              value: item.id,
              memberOf: 'statementFilterGroup',
              operator: this.trackDeselected ? '<>' : '='
            }
          }
        })
      }

      // If we send a dry call, we always need to get all statements
      if (this.allSelectedVisually || isDry) {
        // All
        params.filter = {
          procedureId: {
            condition: {
              path: 'procedure.id',
              value: this.procedureId
            }
          }
        }
      } else if (this.trackDeselected) {
        // All but deselected
        params.filter = {
          procedureId: {
            condition: {
              path: 'procedure.id',
              value: this.procedureId
            }
          },
          ...filterForToggledItems
        }
      } else {
        // Only selected
        params.filter = filterForToggledItems
      }

      return params
    },

    getStatementsFullText (statementId) {
      return dpApi.get(Routing.generate('api_resource_get', { resourceType: 'Statement', resourceId: statementId }), { fields: { Statement: ['fullText'].join() } }, { serialize: true })
        .then((response) => {
          const oldStatement = Object.values(this.statementsObject).find(el => el.id === statementId)
          const fullText = response.data.data.attributes.fullText
          const updatedStatement = { ...oldStatement, attributes: { ...oldStatement.attributes, fullText, isFulltextDisplayed: true } }
          this.setStatement({ ...updatedStatement, id: statementId })
        })
    },

    handleBulkShare () {
      if (window.dpconfirm(Translator.trans('procedure.share_statements.bulk.confirm'))) {
        const params = this.getParamsForBulkShare()

        dplan.notify.notify('warning', Translator.trans('procedure.share_statements.info.duration'))
        dpRpc('statement.procedure.sync', params)
          .then(checkResponse)
          .then((response) => {
            /*
             * Error messages are displayed with "checkResponse", but we need to check for error here to, because
             * we also get 200 status with an error
             */
            if (!response[0].error) {
              this.getItemsByPage(this.currentPage)
              this.resetSelection()
            }
          })
          .catch(e => {
            console.error(e)
          })
      }
    },

    resetSearch () {
      this.searchValue = ''
      this.getItemsByPage(1)
    },

    /**
     * If the procedure is coupled get the num of total items, that are not synchronized yet and
     * therefor are selectable, and set the num of total items to it.
     * Otherwise, set it to the total number of items available.
     */
    setNumSelectableItems (data) {
      if (this.isSourceAndCoupledProcedure) {
        // Call without actually changing anything in the backend.
        dpRpc('statement.procedure.sync', this.getParamsForBulkShare(true), 'rpc_generic_post')
          .then((response) => {
            // ActuallySynchronizedStatementCount is the num of items that are not synchronized yet, but can be
            this.allItemsCount = response.data[0].result.actuallySynchronizedStatementCount
          })
          .catch(e => {
            console.error(e)
          })
      } else {
        this.allItemsCount = data.meta.pagination.total
      }
    },

    triggerStatementDeletion (id) {
      if (window.confirm(Translator.trans('check.statement.delete'))) {
        this.deleteStatement(id)
          .then(response => checkResponse(response, {
            200: { type: 'confirm', text: 'confirm.statement.deleted' },
            204: { type: 'confirm', text: 'confirm.statement.deleted' }
          }))
      }
    },

    toggleFulltext (statementId) {
      const statement = this.statementsObject[statementId]
      const isFulltext = statement.attributes.isFulltextDisplayed
      this.setStatement({ ...{ ...statement, attributes: { ...statement.attributes, isFulltextDisplayed: !isFulltext }, id: statementId } })
    }
  },

  mounted () {
    this.fetchAssignableUsers({
      include: 'orga',
      fields: {
        Orga: 'name'
      }
    })
    this.getItemsByPage(1)
  }
}
</script>
